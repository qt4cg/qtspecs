<item>
   <title>Issue #2287 created</title>
   <pubDate>2025-11-13T16:33:50Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/2287</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-2287</guid>
   <description>&lt;div&gt;&lt;p&gt;Ordered maps break JSON interoperability&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;Something about the proposed change from unordered to ordered maps in QT4 has been bothering me for a long time. I hadn't been able to put my finger on it until whilst listening to John and Juri talk about QT4 at Declarative Amsterdam 2025, I think I now understand what at least one of the alarms going off in my head was trying to tell me.&lt;/p&gt;
&lt;p&gt;I'd just like to say that if the below is not a problem and I have misunderstood the explanation of QT4, many apologies! I would love to hear how this isn't a problem, but otherwise...&lt;/p&gt;
&lt;p&gt;I fear that the switch now from Unordered Maps in XDM 3.1 to Ordered Maps in XDM 4.0 breaks JSON interoperability.&lt;/p&gt;
&lt;p&gt;I recall that when we were working on XQuery 3.1 the major use-case was interoperability with JSON. It says as much in the XQuery 3.1 spec &lt;a href="https://www.w3.org/TR/xquery-31/"&gt;here&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;XQuery 3.1 extends XQuery to support JSON as well as XML, adding maps and arrays to the data model&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;In XQuery 3.1, maps are unordered. In JSON, these things are not called "maps", they are called "objects". If we look at the various JSON specifications, we can see that Objects (or Maps as they are known in XDM) are unordered:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;From &lt;a href="https://www.json.org/json-en.html"&gt;json.org&lt;/a&gt;:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;An object is an unordered set of name/value pairs.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="2"&gt;
&lt;li&gt;
&lt;p&gt;From &lt;a href="https://datatracker.ietf.org/doc/html/rfc7159"&gt;IETF - RFC 7159 - The JavaScript Object Notation (JSON) Data Interchange Format&lt;/a&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Section 1:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;An object is an unordered collection of zero or more name/value pairs&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol start="2"&gt;
&lt;li&gt;Section 4:&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;JSON parsing libraries have been observed to differ as to whether or not they make the ordering of object members visible to calling software. Implementations whose behavior does not depend on member ordering will be interoperable in the sense that they will not be affected by these differences.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, I think we can all agree that:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Object members are unordered in JSON.&lt;/li&gt;
&lt;li&gt;Their equivalent in XDM, Maps, were unordered in version 3.1, but they are scheduled to become ordered in version 4.0.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So, what's the problem that I foresee with making Maps ordered?&lt;/p&gt;
&lt;p&gt;The problem is not Maps in isolation, if you took XQuery 3.1 and simply changed Maps from Unordered to Ordered, I can't foresee any breakage or interoperability problems with JSON.&lt;/p&gt;
&lt;p&gt;The problem that I foresee right now in QT4, that I think I can show breaks JSON interoperability, is the use of Ordered Maps to provide sibling access to members of a map. There may be other areas of the spec that have similar problems too, but I haven't given them any consideration yet.&lt;/p&gt;
&lt;hr/&gt;
&lt;h2&gt;Example 1&lt;/h2&gt;
&lt;p&gt;Given the following JSON document (&lt;code&gt;doc1.json&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;[
	{
		"name": "Adam",
		"age": 44,
		"location": "Bardonecchia"
	},
	{
		"name": "Bob",
		"years": 33,
		"location": "London"
	}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The following QT4 XQuery:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;fn:json-doc("doc1.json")//name/following-sibling::*[1]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I can't find a working implementation to test this against, but if I have understood the QT4 spec, then running the above QT4 XQuery would yield something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(44, 33)
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;Example 2&lt;/h2&gt;
&lt;p&gt;The same QT4 XQuery from above, but instead executed against this JSON document (&lt;code&gt;doc2.json&lt;/code&gt;):&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-json"&gt;[
	{
		"name": "Adam",
		"age": 44,
		"location": "Bardonecchia"
	},
	{
		"name": "Bob",
		"location": "London",
		"years": 33
	}
]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;I think would yield something like:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(44, "London")
&lt;/code&gt;&lt;/pre&gt;
&lt;hr/&gt;
&lt;p&gt;The problem as I see it is that both of those two JSON documents (&lt;code&gt;doc1.json&lt;/code&gt;) and (&lt;code&gt;doc2.json&lt;/code&gt;) are from a JSON perspective canonically identical, yet our XQuery which hasn't changed, produces different results against each JSON document.&lt;/p&gt;
&lt;p&gt;As systems (e.g. Web APIs) that produce JSON are not required to enforce an ordering of object members. Calling the same application or API that produces a JSON document more than once (standard when talking to Web APIs), may validly produce canonically identical JSON documents even if their object members are in a different order.&lt;/p&gt;
&lt;p&gt;IMHO we simply cannot rely on an ordering of Map members within XDM for sibling lookups. If we allow users to program against JSON documents in QT4 using the Sibling Axis (over Ordered Maps), they will get bitten and bitten hard when their XQuery starts returning different or no results because the ordering in their JSON changed (but canonically is the same).&lt;/p&gt;
&lt;p&gt;I understand that there is a general desire to enable XPath Axis to operate over JSON documents, and I think that's a wonderful thing in general. However, if I have understood what it means for Maps and Sibling Axis, I think some changes have to be made before we create a big sibling shaped hole for users to fall into.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
