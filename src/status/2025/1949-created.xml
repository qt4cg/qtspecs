<item>
   <title>Issue #1949 created</title>
   <pubDate>2025-04-23T15:26:51Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1949</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-1949</guid>
   <description>&lt;div&gt;&lt;p&gt;fn:element-to-map: Updated Feedback&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;My feedback is based on the latest version PR (#1906):&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Boolean types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I think we should be careful about changing data to a representation that differs from the input data. If the input contains &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;, it seems too invasive to me to return a boolean. Many users will not be aware that those numbers are valid candidates for Boolean conversions in XPath. That’s why I would still pledge for adapting the type rule detections, and placing &lt;code&gt;numeric&lt;/code&gt; before &lt;code&gt;boolean&lt;/code&gt; (related: 5).&lt;/p&gt;
&lt;p&gt;Things are even more awkward (if I got the rules right) when working without a conversion plan:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;(: Query :)
element-to-map(&amp;lt;x&amp;gt;&amp;lt;a&amp;gt;1&amp;lt;/a&amp;gt;&amp;lt;a&amp;gt;2&amp;lt;/a&amp;gt;&amp;lt;/x&amp;gt;)

(: Result :)
{ "x": [ true(), 2 ] }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;2. Explicit types&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I still feel uneasy that we ignore the specified type if it does not match – even more because XML is known for its rigor that documents must be well-formed to be accepted. I agree we should allow users to be lax about their generated output – by deliberately omitting types – but if type hints are supplied, I think we should take them serious.&lt;/p&gt;
&lt;p&gt;An example:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;element-to-map(
  &amp;lt;a&amp;gt;2&amp;lt;/a&amp;gt;,
  { 'plan': { 'a': { 'layout': 'simple', 'type': 'boolean' } } }
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;3. Numeric casts&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If the prescribed type is &lt;code&gt;numeric&lt;/code&gt; and the value is castable as &lt;code&gt;xs:numeric&lt;/code&gt;, then it is output as an instance of &lt;code&gt;xs:integer&lt;/code&gt;, &lt;code&gt;xs:decimal&lt;/code&gt;, or &lt;code&gt;xs:double&lt;/code&gt; depending on the lexical form of the value, following the same rules as for XPath numeric literals.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Unless we use the same rule somewhere else in the spec, I would definitely vote for making things easier and choose consistency. &lt;code&gt;xs:numeric(&amp;lt;a&amp;gt;1&amp;lt;/a&amp;gt;)&lt;/code&gt; returns a double value, so I think we should do exactly the same here. If the result will be serialized as JSON, everything will be a number anyway.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. Normalized space&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol start="2"&gt;
&lt;li&gt;If &lt;code&gt;empty($EE/(* | text())&lt;/code&gt; …the layout is &lt;code&gt;empty&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;I still believe &lt;code&gt;empty($EE/(* | text()[normalize-space()])&lt;/code&gt; would be a better choice. The error sections for both &lt;code&gt;empty&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt; state that “whitespace-only text nodes are discarded.”, so it is not clear to me why the rules for whitespace text nodes differ for these layouts.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 18.5.2 Creating a conversion plan&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The current rules do not mention yet that &lt;code&gt;child&lt;/code&gt; keys need to be added for &lt;code&gt;list&lt;/code&gt; and &lt;code&gt;list-plus&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;In general, I would appreciate if redundancy could be removed. I’m still struggling finding all relevant information without resorting to the tests. For example, I think that due to the new XQuery code, a lot of informal and possibly lossy rules can be dropped.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;6. Function signatures: &lt;code&gt;document-node()&lt;/code&gt;, &lt;code&gt;element()&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Both functions should accept only elements, or accept both document nodes and elements. Maybe it’s better to only accept elements; it would resemble the name of the function.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;7. &lt;code&gt;deep-skip&lt;/code&gt; option&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;I wouldn’t be able to tell how a &lt;code&gt;shallow-skip&lt;/code&gt; option could work, so maybe &lt;code&gt;skip&lt;/code&gt; is sufficient?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;8. Streamability&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;The conversion is not streamable.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;It is not clear (to me) what this means. Is this XSLT-related? Maybe a reference would be helpful, or we should drop the phrase if it’s not relevant anymore?&lt;/p&gt;
&lt;p&gt;My observation was that &lt;code&gt;fn:element-to-map&lt;/code&gt; can be implemented without keeping the full document in main-memory, so maybe we should let the processors decide what to do?&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;9. JSON&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Example output: …shown as serialized JSON. The result is always shown as a singleton map…&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;This sounds contradictory, as there are no maps in the JSON terminology (but objects). Maybe there is no need to mention the JSON serialization, as the presented results are maps &amp;amp; arrays that can be run as XPath expressions out of the box.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;10. Layout rules: errors&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;The error rules for &lt;code&gt;empty&lt;/code&gt; and &lt;code&gt;empty-plus&lt;/code&gt; say: “If any other child nodes are present, this layout fails.”. For the &lt;code&gt;simple&lt;/code&gt; and &lt;code&gt;simple-plus&lt;/code&gt; layouts, it is “If any child elements are present, this layout fails.”.&lt;/p&gt;
&lt;p&gt;Am I right to assume that in both cases it’s only child element that result in a failure?&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
