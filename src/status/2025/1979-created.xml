<item>
   <title>Issue #1979 created</title>
   <pubDate>2025-05-04T09:36:58Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1979</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-1979</guid>
   <description>&lt;div&gt;&lt;p&gt;Records: Type Safety&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;One cognitive challenge with records is to internalize that records are not independent types, but only map constraints. As a consequence, no type safety guarantees exist when records are accessed and updated:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;A lookup of a non-existing key raises no error.&lt;/li&gt;
&lt;li&gt;A record update may result in a map that does not match the original record definition.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;This makes it hard and often impossible/illegal for processors to output helpful error messages.&lt;/p&gt;
&lt;p&gt;There are reasons why we donâ€™t want to make records too strict: an extensible record may include keys that are not defined in the record type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;(: must not raise an error :)
declare record local:r(a, *);
let $r as local:r := { 'a': 1, 'b': 2 }
return $r?b
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;However, for &lt;strong&gt;non-extensible&lt;/strong&gt; records, I think we should &lt;strong&gt;allow&lt;/strong&gt; processors to perform stricter checks when unknown keys are looked up, or when the result of an update would conflict with the original record type:&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xquery"&gt;declare record local:r(a as xs:integer);
(: unknown key :)
local:r(1)?b,
(: invalid value type :)
map:put(local:r(1), 'a', 'string')
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;As records are no independent types, it will be difficult to &lt;strong&gt;enforce&lt;/strong&gt; errors in all cases: It would require implementations to always know that a currently processed map has once been validated against a specific record type. But in many cases, implementations may be able to preserve record types for maps that have been coerced to a record, or created with a record declaration, and propagate them to updated maps. For example, we already do so when we can statically infer that the resulting map of a &lt;code&gt;map:put&lt;/code&gt; call will match the original record type.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
