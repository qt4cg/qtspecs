<item>
   <title>Issue #2051 created</title>
   <pubDate>2025-06-14T01:37:09Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/2051</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-2051</guid>
   <description>&lt;div&gt;&lt;p&gt;XSLT group by cluster&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;I propose an enhancement of &lt;code&gt;xsl:for-each-group&lt;/code&gt; to support clustering.&lt;/p&gt;
&lt;p&gt;To start off with a simple use case, suppose one has the following population, &lt;code&gt;&amp;lt;xsl:variable name="ages" as="xs:integer*" select="5, 24, 9, 5, 6, 8, 36, 38, 28"/&amp;gt;&lt;/code&gt; and one wishes to cluster the figures like so, in four groups: &lt;code&gt;(5, 5, 6, 8, 9)&lt;/code&gt;, &lt;code&gt;(24)&lt;/code&gt;, &lt;code&gt;(28)&lt;/code&gt;, &lt;code&gt;(36, 38)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;One is tempted to create an &lt;code&gt;&amp;lt;xsl:for-each-group&amp;gt;&lt;/code&gt; with &lt;code&gt;group-by="((. - 1) to (. + 1))"&lt;/code&gt;. But this does not work. If &lt;code&gt;@composite&lt;/code&gt; is absent or is &lt;code&gt;no&lt;/code&gt;, eighteen groups are created. If &lt;code&gt;@composite&lt;/code&gt; is &lt;code&gt;yes&lt;/code&gt;, eight groups are created. In both cases, the results are not significantly close to the desired output.&lt;/p&gt;
&lt;p&gt;I propose a new &lt;code&gt;@group-by-cluster&lt;/code&gt;. The following code&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;xsl:for-each-group select="$ages" group-by-cluster="((. - 1) to (. + 1))"&amp;gt;
    &amp;lt;xsl:sort select="current-grouping-key()"/&amp;gt;
    &amp;lt;group key="{current-grouping-key()}" count="{count(current-group())}"&amp;gt;
        &amp;lt;xsl:copy-of select="current-group()"/&amp;gt;
    &amp;lt;/group&amp;gt;
&amp;lt;/xsl:for-each-group&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;would produce this&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;   &amp;lt;group key="4 5 6 7 8 9 10" count="2"&amp;gt;5 5 6 8 9&amp;lt;/group&amp;gt;
   &amp;lt;group key="23 24 25" count="1"&amp;gt;24&amp;lt;/group&amp;gt;
   &amp;lt;group key="27 28 29" count="1"&amp;gt;28&amp;lt;/group&amp;gt;
   &amp;lt;group key="35 36 37 38 39" count="1"&amp;gt;36 38&amp;lt;/group&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;There are numerous use cases for the proposed new feature. Here are a few:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Clustering map or spatial coordinates&lt;/li&gt;
&lt;li&gt;Grouping disparate rectangles from OCR output&lt;/li&gt;
&lt;li&gt;Reconciling triples in linked open data (RDF) that use different IRIs synonymously&lt;/li&gt;
&lt;li&gt;Detecting typologies within in large corpora of documents that have periodically repetitive formulaic paragraphs.&lt;/li&gt;
&lt;li&gt;Discovering networks of connected things, e.g., networks of email correspondence or publication citations
Â 
Currently, the clustering I describe above is feasible in XSLT, but it requires creative strategies, usually a combination of preprocessing and the creation of specialized helper functions to recursively iterate over multiple grouping keys to create group numbers. These are challenging to write and debug, and one loses identity in a preprocessed copy of the original.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;By putting clustering into a &lt;code&gt;@group-by-cluster&lt;/code&gt; construct, users benefit not only from convenience but also from performance, as a processor might bring novel strategies for clustering.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;current-grouping-key()&lt;/code&gt; for a group would consist of a sequence of all members' grouping keys, duplicates removed. No two groups would have any overlap in their grouping key sequences. (That's the definition of a cluster.)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;@group-by-cluster&lt;/code&gt; would have effect only if its value actually produced a sequence of length greater than one, and if &lt;code&gt;@composite&lt;/code&gt; is no. (Should a user should be warned if &lt;code&gt;@composite&lt;/code&gt; is yes?)&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
