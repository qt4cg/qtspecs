<item>
   <title>Issue #2297 created</title>
   <pubDate>2025-11-15T15:24:12Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/2297</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-2297</guid>
   <description>&lt;div&gt;&lt;p&gt;XSLT pattern ambiguities with typed matches&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;(&lt;em&gt;Note&lt;/em&gt;: Edited to show that the parses though &lt;code&gt;XNodePattern&lt;/code&gt; are subtly different in the two cases - I originally hadn't spotted the difference.)&lt;/p&gt;
&lt;p&gt;I think there is a (minor?) ambiguity in the current XSLT pattern grammar, involving the the 'shortened' type match patterns such as &lt;code&gt;map(*)&lt;/code&gt;, &lt;code&gt;item()&lt;/code&gt;, &lt;code&gt;record(...)&lt;/code&gt; and &lt;code&gt;enum("red")&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If the type is enclosed in the &lt;code&gt;type(...)&lt;/code&gt; qualifier, e.g. &lt;code&gt;type(map(*))&lt;/code&gt; then the grammar appears to be unambiguous, yielding a parse down through pattern productions to &lt;code&gt;SimpleNodeTest&lt;/code&gt; to a &lt;code&gt;TypeTest&lt;/code&gt;/&lt;code&gt;SequenceType&lt;/code&gt;:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Pattern&amp;gt;
 &amp;lt;UnionPattern&amp;gt;
  &amp;lt;IntersectExceptPattern&amp;gt;
   &amp;lt;PrimaryPattern&amp;gt;
    &amp;lt;XNodePattern&amp;gt;
     &amp;lt;PathExprP&amp;gt;
      &amp;lt;RelativePathExprP&amp;gt;
       &amp;lt;StepExprP&amp;gt;
        &amp;lt;AxisStepP&amp;gt;
         &amp;lt;ForwardStepP&amp;gt;
          &amp;lt;AbbrevForwardStepP&amp;gt;
           &amp;lt;SimpleNodeTest&amp;gt;
            &amp;lt;TypeTest&amp;gt;
             &amp;lt;SequenceType&amp;gt;
              &amp;lt;ItemType&amp;gt;
               &amp;lt;RegularItemType&amp;gt;
                &amp;lt;MapType&amp;gt;
                 &amp;lt;AnyMapType/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;but if the 'short form' of the pattern is used, &lt;em&gt;viz&lt;/em&gt; &lt;code&gt;map(*)&lt;/code&gt;, then there are two parse routes.
The first is close to that given above, but not exactly the same:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Pattern&amp;gt;
 &amp;lt;UnionPattern&amp;gt;
  &amp;lt;IntersectExceptPattern&amp;gt;
   &amp;lt;PrimaryPattern&amp;gt;
    &amp;lt;XNodePattern&amp;gt;
     &amp;lt;PathExprP&amp;gt;
      &amp;lt;RelativePathExprP&amp;gt;
       &amp;lt;StepExprP&amp;gt;
        &amp;lt;AxisStepP&amp;gt;
         &amp;lt;ForwardStepP&amp;gt;
          &amp;lt;AbbrevForwardStepP&amp;gt;
           &amp;lt;SimpleNodeTest&amp;gt;
            &amp;lt;TypeTest&amp;gt;
             &amp;lt;RegularItemType&amp;gt;
              &amp;lt;MapType&amp;gt;
               &amp;lt;AnyMapType/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where an alternative of &lt;code&gt;TypeTest&lt;/code&gt;/&lt;code&gt;RegularItemType&lt;/code&gt; (without the &lt;code&gt;type(..)&lt;/code&gt; surround) has been chosen.&lt;/p&gt;
&lt;p&gt;The second is:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;Pattern&amp;gt;
 &amp;lt;UnionPattern&amp;gt;
  &amp;lt;IntersectExceptPattern&amp;gt;
   &amp;lt;PrimaryPattern&amp;gt;
    &amp;lt;TypePattern&amp;gt;
     &amp;lt;MapType&amp;gt;
      &amp;lt;AnyMapType/&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;where &lt;code&gt;PrimaryPattern&lt;/code&gt; parses through &lt;code&gt;TypePattern&lt;/code&gt;, and perhaps might be the intended outcome. The same logic applies to any of the 'shortened' type match instances.&lt;/p&gt;
&lt;p&gt;Whether this is significant or not, I'm not sure. A cursory inspection of the spec. doesn't show any suggestion of preference for the latter form.&lt;/p&gt;
&lt;p&gt;As &lt;code&gt;TypeTest&lt;/code&gt; is defined in XPath and can of course be used in predicates and selectors, it may be difficult to avoid this ambiguity from the XSLT pattern productions. Will need to think about alternatives.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
