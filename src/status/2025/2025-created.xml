<item>
   <title>Issue #2025 created</title>
   <pubDate>2025-05-25T07:36:49Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/2025</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-2025</guid>
   <description>&lt;div&gt;&lt;p&gt;Combine the concepts of pins/labels and modified lookups&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;We have two rather separate mechanisms, both designed to solve aspects of what is essentially the same problem: lookup expressions lose too much information.&lt;/p&gt;
&lt;p&gt;Pinning tries to solve the problem by saying that if the origin of the lookup is pinned, then the results of the lookup carry a label containing information about the key and the parent.&lt;/p&gt;
&lt;p&gt;Modifiers like pair::* try to solve the problem by returning a map containing the key and the value as separate fields.&lt;/p&gt;
&lt;p&gt;But pinning only solves part of the problem, in particular it doesn't prevent X?* flattening the result, and the &lt;code&gt;pairs&lt;/code&gt; modifier only solves part of the problem, in particular it doesn't retain parentage.&lt;/p&gt;
&lt;p&gt;I would like to try combining them and trying to create a mechanism that is better than either. I don't yet know exactly how this might work, but I'm thinking along the lines:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Replace the concept of labelled items with labelled values (that is, a label can be attached to any value, not just an item)&lt;/li&gt;
&lt;li&gt;Scrap pin() as an explicit function&lt;/li&gt;
&lt;li&gt;A lookup expression like $X ? child::Y returns a sequence of labelled values (no flattening)&lt;/li&gt;
&lt;li&gt;The properties of a labelled value include:
** target - the actual value
** key - the associated key (or array index)
** parent - the containing map or array&lt;/li&gt;
&lt;li&gt;These properties might be made available through syntax such as &lt;code&gt;$LV ? target::*&lt;/code&gt; , &lt;code&gt;$LV ? key::*&lt;/code&gt;, &lt;code&gt;$LV ? parent::*&lt;/code&gt; (or otherwise)&lt;/li&gt;
&lt;li&gt;ancestor and ancestor-or-self can be made available as derived properties&lt;/li&gt;
&lt;li&gt;Many operations when given a labelled value should automatically operate on its target, and ignore the label (rather like atomisation). Exactly which operations do this is an interesting question to which I don't yet know the answer. It's tricky because child::* returns a sequence of labelled values, and we want to be able to manipulate this in unflattened form. Perhaps child::* should instead return an array of labelled values? But then you end up with another lookup operation to extract the members of this array.&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
