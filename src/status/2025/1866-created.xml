<item>
   <title>Issue #1866 created</title>
   <pubDate>2025-03-12T08:15:55Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1866</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-1866</guid>
   <description>&lt;div&gt;&lt;p&gt;Ambiguities introduced by #1864&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;The grammar check done by &lt;a href="https://github.com/GuntherRademacher/rex-parser-generator/tree/main/docs/sample-grammars/XQuery-40"&gt;RExification of XQuery and XPath 4.0 Grammars&lt;/a&gt; has detected a bunch of LALR(2) conflicts caused by the recent addition of &lt;a href="https://qt4cg.org/specifications/xquery-40/xquery-40.html#doc-xquery40-UnaryLookup-TypeSpecifier"&gt;&lt;code&gt;TypeSpecifier&lt;/code&gt;&lt;/a&gt; to the &lt;a href="https://qt4cg.org/specifications/xquery-40/xquery-40.html#doc-xquery40-UnaryLookup-KeySpecifier"&gt;&lt;code&gt;KeySpecifier&lt;/code&gt;&lt;/a&gt; production.&lt;/p&gt;
&lt;p&gt;In fact these are ambiguities between following being used as a &lt;code&gt;QName&lt;/code&gt; (via &lt;code&gt;EQName&lt;/code&gt;, &lt;code&gt;TypeName&lt;/code&gt;), or as a keyword:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;array&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;attribute&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;comment&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;document-node&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;element&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;empty-sequence&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;fn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;function&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;item&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;namespace-node&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;node&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;processing-instruction&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;record&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schema-attribute&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;schema-element&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;text&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;E.g. &lt;code&gt;element&lt;/code&gt; in&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$A?~element()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;can be parsed as an element test, &lt;code&gt;element()&lt;/code&gt;, or as a type name &lt;code&gt;element&lt;/code&gt; followed by a &lt;code&gt;PositionalArgumentList&lt;/code&gt;. This is similar to what the "reserved-function-names" constraint covers, but that does not apply here because there is no function name involved.&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;SequenceType&lt;/code&gt; in &lt;code&gt;TypeSpecifier&lt;/code&gt;, enclosed in extra parenthese, does not present a problem, so my proposal is to drop &lt;code&gt;ItemType&lt;/code&gt; from &lt;code&gt;TypeSpecifier&lt;/code&gt; and rewrite the production to&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;TypeSpecifier
         ::= '~' '(' SequenceType ')' 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
