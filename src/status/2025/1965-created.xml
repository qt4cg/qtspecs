<item>
   <title>Issue #1965 created</title>
   <pubDate>2025-04-30T01:13:19Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1965</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-1965</guid>
   <description>&lt;div&gt;&lt;p&gt;The Generator record - ready for a PR&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;This is a continuation of the original issue &lt;strong&gt;https://github.com/qt4cg/qtspecs/issues/716&lt;/strong&gt;, created almost 2 years ago, and having accumulated a lot of very useful discussion.&lt;/p&gt;
&lt;p&gt;Now, when we have methods that are fields of records, it became practical to produce the record type entirely in code, and &lt;strong&gt;this is the base for the planned PR.&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;1. What it contains&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The standard record fields as originally published:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;     initialized as xs:boolean,
     endReached as xs:boolean,
     getCurrent as %method fn() as item()*,
     moveNext as %method fn(*)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;The following 34 methods - this will form the signatures and formal definitions of the methods inside the documentation:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;toArray := %method fn()
take := %method fn($n as xs:integer)
takeWhile := %method fn($pred as function(item()*) as xs:boolean)
skip := %method fn($n as xs:nonNegativeInteger)
skipWhile := %method fn($pred as function(item()*) as xs:boolean)
some := %method fn()
someWhere := %method fn($pred)
subrange := %method fn($m as xs:positiveInteger, $n as xs:integer)
chunk := %method fn($size as xs:positiveInteger)
head := %method fn()
tail := %method fn()
at := %method fn($ind as xs:nonNegativeInteger)
for-each := %method fn($fun as function(*))
for-each-pair := %method fn($gen2 as f:generator, $fun as function(*))
zip := %method fn($gen2 as f:generator)
concat := %method fn($gen2 as f:generator)
append := %method fn($value as item()*)
prepend := %method fn($value as item()*)
insertAt := %method fn($pos as xs:positiveInteger, $value as item()*)
removeAt := %method fn($pos as xs:nonNegativeInteger)
replace := %method fn($funIsMatching as function(item()*) as xs:boolean, $replacement as item()*)
reverse := %method fn()
filter := %method fn($pred as function(item()*) as xs:boolean)
fold-left := %method fn($init as item()*, $action as fn(*))
fold-right := %method fn($init as item()*, $action as fn(*))
fold-lazy := %method fn($init as item()*, $action as fn(*), $shortCircuitProvider as function(*))
scan-left := %method fn($init as item()*, $action as fn(*))
scan-right := %method fn($init as item()*, $action as fn(*))
makeGenerator := %method fn($provider as function(*))
makeGeneratorFromArray := %method fn($input as array(*))
makeGeneratorFromSequence := %method fn($input as item()*)
toSequence := %method fn()
emptyGenerator := %method fn()
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;90 tests/examples - with calls to all the methods  - in normal and edge cases&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;2. Where to get the executable (with BaseX) code?&lt;/h2&gt;
&lt;p&gt;For everyone's convenience, you will find the complete executable code at the end of this issue/initial-comment.
Alternatively, the code is available here: https://github.com/dnovatchev/Articles/blob/main/Generators/Code/generator.xpath&lt;/p&gt;
&lt;p&gt;The latter will always contain the latest, up-to-date code.
And, of course, please execute the code with BaseX, as I have done many times:&lt;/p&gt;
&lt;p&gt;&lt;img src="https://github.com/user-attachments/assets/e8d671d1-fda8-418e-a5c8-bb75e81d7a5a" alt="Image"/&gt;&lt;/p&gt;
&lt;h2&gt;3. What this gives us:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;Working with huge collections, that would otherwise be restricted by the available memory.&lt;/li&gt;
&lt;li&gt;Deferred execution.&lt;/li&gt;
&lt;li&gt;Handling collections containing unknown or infinite number of members&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;A (next) member is produced only on request. &lt;strong&gt;No time is spent on producing all members of the collection&lt;/strong&gt;.&lt;/li&gt;
&lt;li&gt;A (next) member is produced only on request. &lt;strong&gt;No memory is consumed to store all members of the collection&lt;/strong&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="4"&gt;
&lt;li&gt;Lazy evaluation - due to the above and also using the &lt;strong&gt;&lt;em&gt;fold-lazy&lt;/em&gt;&lt;/strong&gt; method (also described in &lt;strong&gt;&lt;em&gt;&lt;a href="https://medium.com/@dimitrenovatchev/laziness-in-xpath-the-trouble-with-fn-fold-right-cbb1cc654d1c?sk=872244cf80bfcb52d67bcb8b359478ff"&gt;this article&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;)&lt;/li&gt;
&lt;li&gt;Implementation of the original idea about Kollection - https://github.com/qt4cg/qtspecs/issues/910 .&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;4. What assistance is needed&lt;/h2&gt;
&lt;p&gt;I will greatly appreciate any recommendations on how to proceed with the actual PR:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Can this be a single PR ?&lt;/li&gt;
&lt;li&gt;If this is too-big for a single PR, then how to proceed, like splitting it to pieces?&lt;/li&gt;
&lt;li&gt;Any observations and comments on the code itself.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;5. References:&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;The original issue: &lt;strong&gt;&lt;em&gt;Generators in XPath&lt;/em&gt;&lt;/strong&gt;: https://github.com/qt4cg/qtspecs/issues/716&lt;/li&gt;
&lt;li&gt;This article: &lt;strong&gt;&lt;em&gt;&lt;a href="https://medium.com/@dimitrenovatchev/generators-in-xpath-987a609cfbd5?sk=6334d48f9565f78eba90b212e461243b"&gt;Generators in XPath&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;The article defining fold-lazy : &lt;strong&gt;&lt;em&gt;&lt;a href="https://medium.com/@dimitrenovatchev/laziness-in-xpath-the-trouble-with-fn-fold-right-cbb1cc654d1c?sk=872244cf80bfcb52d67bcb8b359478ff"&gt;"Laziness in XPath. The trouble with fn:fold-right"&lt;/a&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;6. Complete, executable definition of the &lt;strong&gt;&lt;em&gt;generator&lt;/em&gt;&lt;/strong&gt; record&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-xq"&gt;declare namespace f = "http://www.w3.org/2005/xpath-functions-2025";
declare record f:generator 
   ( initialized as xs:boolean,
     endReached as xs:boolean,
     getCurrent as %method fn() as item()*,
     moveNext as %method fn(*) (: as f:generator, :),
     toArray := %method fn()
     {
       while-do( [., []],
                function( $inArr) 
                { $inArr(1)?initialized and not($inArr(1)?endReached) },                 
                function($inArr) 
                { array{$inArr(1)?moveNext(), 
                        array:append($inArr(2), $inArr(1)?getCurrent())
                       } 
                 }         
       ) (2)
     },
     
     take := %method fn($n as xs:integer) 
     {
      let $gen := if(not(?initialized)) then ?moveNext()
                    else .
       return
         if($gen?endReached or $n le 0) then $gen?emptyGenerator()
          else
            let $current := $gen?getCurrent(),
                $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                $nextGen := $gen?moveNext()
             return
               if($nextGen?endReached) then $newResultGen
                 else
                   let
                       $newResultGen2 :=  map:put($newResultGen, "moveNext", %method fn() {$nextGen?take($n -1)}) 
                     return
                       $newResultGen2
      },
      
      takeWhile := %method fn($pred as function(item()*) as xs:boolean)
      {
        let $gen := if(not(?initialized)) then ?moveNext()
                      else .
         return
           if($gen?endReached) then $gen?emptyGenerator()
            else      
              let $current := $gen?getCurrent()
                return
                  if(not($pred($current))) then $gen?emptyGenerator()
                  else
                    let $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                        $nextGen := ?moveNext()
                     return
                        if($nextGen?endReached) then $newResultGen
                        else
                          let $newResultGen2 :=  map:put($newResultGen, "moveNext", %method fn() {$nextGen?takeWhile($pred)}) 
                           return $newResultGen2  
      },
     
     skipStrict := %method fn($n as xs:nonNegativeInteger, $issueErrorOnEmpty as xs:boolean) 
     {
            if($n eq 0) then .
              else if(?endReached) 
                     then if($issueErrorOnEmpty)
                           then error((), "Input Generator too-short") 
                           else ?emptyGenerator()
              else 
                let $gen := if(not(?initialized)) then ?moveNext()
                             else .
                  return
                    if(not($gen?endReached)) then $gen?moveNext()?skipStrict($n -1, $issueErrorOnEmpty)
                      else $gen?emptyGenerator()                 

     },
     skip := %method fn($n as xs:nonNegativeInteger) 
     {
       ?skipStrict($n, false())
     },
     
     skipWhile := %method fn($pred as function(item()*) as xs:boolean)
     {
        let $gen := if(not(?initialized)) then ?moveNext()
                      else .
         return
           if($gen?endReached) then $gen?emptyGenerator()
            else
              let $current := $gen?getCurrent()
               return
                 if(not($pred($current))) then $gen
                  else $gen?moveNext()?skipWhile($pred)                    
     },
     
     some := %method fn()
     {
       ?initialized and not(?endReached)
     },
     
     someWhere := %method fn($pred)
     {
       ?filter($pred)?some()
     },
     
     subrange := %method fn($m as xs:positiveInteger, $n as xs:integer)
     {
       ?skip($m - 1)?take($n - $m + 1)
     },
     
     chunk := %method fn($size as xs:positiveInteger)
     {
        let $gen := if(not(?initialized)) then ?moveNext()
                      else .
         return
           if($gen?endReached) then $gen?emptyGenerator()
           else
             let $thisChunk := $gen?take($size)?toArray(),
                 $cutGen := $gen?skip($size),
                 $resultGen := $gen =&amp;gt; map:put("getCurrent", %method fn(){$thisChunk})
                                    =&amp;gt; map:put("moveNext", %method fn(){$cutGen?chunk($size)})
              return $resultGen
     },
     
     head := %method fn() {?take(1)?getCurrent()},
     tail := %method fn() {?skip(1)},
     
     at := %method fn($ind as xs:nonNegativeInteger) {?subrange($ind, $ind)?getCurrent()},
           
     for-each := %method fn($fun as function(*))
     {
      let $gen := if(not(?initialized)) then ?moveNext()
                    else .        
       return
         if(?endReached) then ?emptyGenerator()
          else
           let $current := $fun(?getCurrent()),
                $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                $nextGen := ?moveNext()
            return
              if($nextGen?endReached) then $newResultGen
                else
                  let $newResultGen2 :=  map:put($newResultGen, "moveNext", %method fn() {$nextGen?for-each($fun)}) 
                     return
                       $newResultGen2                    
      },
      
      for-each-pair := %method fn($gen2 as f:generator, $fun as function(*))
      {
        let $gen := if(not(?initialized)) then ?moveNext()
                    else .,
            $gen2 := if(not($gen2?initialized)) then $gen2?moveNext()
                    else $gen2
         return
            if(?endReached or $gen2?endReached) then ?emptyGenerator() 
             else  
               let $current := $fun(?getCurrent(), $gen2?getCurrent()),
                   $newResultGen := map:put(., "getCurrent", %method fn(){$current}),
                   $nextGen1 := ?moveNext(),
                   $nextGen2 := $gen2?moveNext()
                return
                   if($nextGen1?endReached or $nextGen2?endReached) then $newResultGen
                     else
                       let $newResultGen2 := map:put($newResultGen, "moveNext", %method fn(){$nextGen1?for-each-pair($nextGen2, $fun)})
                         return
                           $newResultGen2                        
      },
      
      zip := %method fn($gen2 as f:generator)
      {
        ?for-each-pair($gen2, fn($x1, $x2){[$x1, $x2]})
      },

      concat := %method fn($gen2 as f:generator)
      {
        let $gen := if(not(?initialized)) then ?moveNext()
                    else .,
            $gen2 := if(not($gen2?initialized)) then $gen2?moveNext()
                    else $gen2,
            $resultGen := if($gen?endReached) then $gen2
                            else if($gen2?endReached) then $gen
                            else
                              $gen  =&amp;gt; map:put(  "moveNext", 
                                                %method fn()
                                                 {
                                                 let $nextGen := $gen?moveNext()
                                                   return 
                                                     $nextGen?concat($gen2)
                                                 }
                                              )                                   
        return 
           $resultGen            
      },

      append := %method fn($value as item()*)
      {
        let $gen := if(not(?initialized)) then ?moveNext()
                    else .,
            $genSingle := $gen =&amp;gt; map:put("getCurrent", %method fn(){$value})
                               =&amp;gt; map:put("moveNext", %method fn(){?emptyGenerator()})
                               =&amp;gt; map:put("endReached", false())
         return
           $gen?concat($genSingle)                    
      },
      
      prepend := %method fn($value as item()*)
      {
                let $gen := if(not(?initialized)) then ?moveNext()
                    else .,
                    $genSingle := $gen =&amp;gt; map:put("getCurrent", %method fn(){$value})
                                       =&amp;gt; map:put("moveNext", %method fn(){?emptyGenerator()})
         return
           $genSingle?concat($gen)  
      },
      
      insertAt := %method fn($pos as xs:positiveInteger, $value as item()*)
      {
        let $genTail := ?skipStrict($pos - 1, true())
         return
            if($pos gt 1)
              then ?take($pos - 1)?append($value)?concat($genTail)
              else $genTail?prepend($value)               
      },
      
      removeAt := %method fn($pos as xs:nonNegativeInteger)
      {
        let $genTail := ?skipStrict($pos, true())
          return
            if($pos gt 1)
              then ?take($pos - 1)?concat($genTail)
              else $genTail
      },
    
      replace := %method fn($funIsMatching as function(item()*) as xs:boolean, $replacement as item()*)
      {
        if(?endReached) then .
          else
            let $current := ?getCurrent()
              return
                if($funIsMatching($current))
                  then let $nextGen := ?moveNext()
                     return
                       . =&amp;gt; map:put("getCurrent", %method fn() {$replacement})
                         =&amp;gt; map:put("moveNext", %method fn() { $nextGen } 
                                  )
                  else (: $current is not the match for replacement :)
                    let $nextGen := ?moveNext()
                      return . =&amp;gt; map:put("moveNext", 
                                           %method fn()
                                           {
                                             let $intendedReplace := function($z) {$z?replace($funIsMatching, $replacement)}
                                              return
                                                if($nextGen?endReached) then $nextGen
                                                else $intendedReplace($nextGen)
                                           }
                                        )
      },
      
      reverse := %method fn()
      {
        if(?endReached) then ?emptyGenerator()
          else
           let $current := ?getCurrent()
             return
               ?tail()?reverse()?append($current)
      },

      filter := %method fn($pred as function(item()*) as xs:boolean)
      {
             if(?initialized and ?endReached) then ?emptyGenerator()
              else
                let $getNextGoodGen := function($gen as map(*), 
                                             $pred as function(item()*) as xs:boolean)
                   {
                      if($gen?endReached) then $gen?emptyGenerator()
                      else
                        let $mapResult := 
                              while-do(
                                       $gen,
                                       function($x) { not($x?endReached) and not($pred($x?getCurrent()))},
                                       function($x) { $x?moveNext() }
                                       )   
                        return 
                          if($mapResult?endReached) then $gen?emptyGenerator()
                           else $mapResult                  
                   },
                   
                   $gen := if(?initialized) then . 
                             else ?moveNext(),
                   $nextGoodGen := $getNextGoodGen($gen, $pred)
                return
                  if($nextGoodGen?endReached) then $gen?emptyGenerator()
                  else
                    $nextGoodGen =&amp;gt; map:put("moveNext", 
                                            %method fn() 
                                              {
                                                let $nextGoodGen := $getNextGoodGen(?inputGen?moveNext(), $pred)
                                                  return
                                                    if($nextGoodGen?endReached) then $nextGoodGen?emptyGenerator()
                                                    else
                                                      map:put(map:put($nextGoodGen, "moveNext", %method fn() {$nextGoodGen?moveNext()?filter($pred)}),
                                                                      "inputGen", $nextGoodGen
                                                              )
                                               }
                                           )
                                   =&amp;gt;
                                     map:put("inputGen", $nextGoodGen)
        },     
        fold-left := %method fn($init as item()*, $action as fn(*))
        {
          if(?endReached) then $init
            else ?tail()?fold-left($action($init, ?getCurrent()), $action)
        },
        
        fold-right := %method fn($init as item()*, $action as fn(*))
        {
          if(?endReached) then $init
            else $action(?head(), ?tail()?fold-right($init, $action))
        },
        
        fold-lazy := %method fn($init as item()*, $action as fn(*), $shortCircuitProvider as function(*))
        {
          if(?endReached) then $init
          else
           let $current := ?getCurrent()
             return
               if(function-arity($shortCircuitProvider($current, $init)) eq 0)
                 then $shortCircuitProvider($current, $init)()
                 else $action($current, ?moveNext()?fold-lazy($init, $action, $shortCircuitProvider))
        },
        
        scan-left := %method fn($init as item()*, $action as fn(*))
        {
          let $resultGen := ?emptyGenerator() 
                                =&amp;gt; map:put("endReached", false())
                                =&amp;gt; map:put("getCurrent", %method fn(){$init})
           return
             if(?endReached) 
               then $resultGen =&amp;gt; map:put("moveNext", %method fn(){?emptyGenerator()})
               else
                 let $resultGen := $resultGen =&amp;gt; map:put("getCurrent", %method fn(){$init}),
                     $partialFoldResult := $action($init, ?getCurrent())
                   return
                     let $nextGen := ?moveNext()
                      return
                        $resultGen =&amp;gt; map:put("moveNext", %method fn()
                                              { 
                                                  $nextGen?scan-left($partialFoldResult, $action)
                                               }
                                              )            
        },
      
        scan-right := %method fn($init as item()*, $action as fn(*))
        {
          ?reverse()?scan-left($init, $action)?reverse()                         
        },
        
        makeGenerator := %method fn($provider as function(*))
        {
         let $gen := if(not(?initialized)) then ?moveNext()
                    else .,
              $nextDataItemGetter := $provider(0),
              $nextGen := if(not($nextDataItemGetter instance of function(*))) then $gen?emptyGenerator()  
                           else $gen?emptyGenerator()
                            =&amp;gt; map:put("numDataItems", 1)
                            =&amp;gt; map:put("current", $nextDataItemGetter())
                            =&amp;gt; map:put("endReached", false())
                            =&amp;gt; map:put("getCurrent", %method fn() {?current})
                            =&amp;gt; map:put("moveNext",  
                                       %method fn() 
                                        {
                                          let $nextDataItemGetter := $provider(?numDataItems)
                                            return
                                              if(not($nextDataItemGetter instance of function(*))) then ?emptyGenerator()
                                              else
                                                . =&amp;gt; map:put("current", $nextDataItemGetter())
                                                  =&amp;gt; map:put("numDataItems", ?numDataItems + 1)
                                        }
                                       )
           return $nextGen                                                  
        },
        
        makeGeneratorFromArray := %method fn($input as array(*))
        {
          let $size := array:size($input),
              $arrayProvider := fn($ind as xs:integer)
                                {
                                  if($ind +1 gt $size) then -1
                                   else fn(){$input($ind + 1)}
                                }
           return ?makeGenerator($arrayProvider)
        },
        
        makeGeneratorFromSequence := %method fn($input as item()*)
        {
          let $size := count($input),
              $seqProvider := fn($ind as xs:integer)
                                {
                                  if($ind +1 gt $size) then -1
                                   else fn(){$input[$ind + 1]}
                                }
           return ?makeGenerator($seqProvider)
        },
        
        toSequence := %method fn() {?toArray() =&amp;gt; array:items()},     
        
        emptyGenerator := %method fn() 
        {
          . =&amp;gt; map:put("initialized", true()) =&amp;gt; map:put("endReached", true())
            =&amp;gt; map:put("getCurrent", %method fn() {error((),"getCurrent() called on an emptyGenerator")})
            =&amp;gt; map:put("moveNext", %method fn() {error((),"moveNext() called on an emptyGenerator")})
        },      
     *
   );

let $gen2ToInf := f:generator(initialized := true(), endReached := false(), 
                              getCurrent := %method fn(){?last +1},
                              moveNext := %method fn()
                              {
                                if(not(?initialized))
                                  then map:put(., "inittialized", true())
                                  else map:put(., "last", ?last + 1)
                              },
                              options := {"last" : 1}
                             ),
    $double := fn($n) {2*$n},
    $sum2 := fn($m, $n) {$m + $n},
    $product := fn($m, $n) {$m * $n}
  return    
  (
    "$gen2ToInf?take(3)?toArray()",
    $gen2ToInf?take(3)?toArray(),
    "================",    
    "$gen2ToInf?take(3)?skip(2)?getCurrent()",
    $gen2ToInf?take(3)?skip(2)?getCurrent(),
    (: $gen2ToInf?take(3)?moveNext()?moveNext()?moveNext()?getCurrent(), :)
    "================",
    "$gen2ToInf?getCurrent()",
    $gen2ToInf?getCurrent(),
    "$gen2ToInf?moveNext()?getCurrent()",
    $gen2ToInf?moveNext()?getCurrent(),
    "================",
    "$gen2ToInf?take(5) instance of f:generator",
    $gen2ToInf?take(5) instance of f:generator,
    "==&amp;gt;  $gen2ToInf?skip(7) instance of f:generator",
    $gen2ToInf?skip(7) instance of f:generator,  
    "================",
    "$gen2ToInf?subrange(4, 6)?getCurrent()",
    $gen2ToInf?subrange(4, 6)?getCurrent(), 
    "$gen2ToInf?subrange(4, 6)?moveNext()?getCurrent()",
    $gen2ToInf?subrange(4, 6)?moveNext()?getCurrent(),
    "$gen2ToInf?subrange(4, 6)?moveNext()?moveNext()?getCurrent()",
    $gen2ToInf?subrange(4, 6)?moveNext()?moveNext()?getCurrent(),
    (: $gen2ToInf?subrange(4, 6)?moveNext()?moveNext()?moveNext()?getCurrent() :) (: Must raise error:)    
    "================",    
    "$gen2ToInf?subrange(4, 6)?head()",
    $gen2ToInf?subrange(4, 6)?head(),  
    "$gen2ToInf?subrange(4, 6)?tail()?head()",
    $gen2ToInf?subrange(4, 6)?tail()?head(),
    "$gen2ToInf?subrange(4, 6)?toArray()",
    $gen2ToInf?subrange(4, 6)?toArray(),
    "$gen2ToInf?head()",
    $gen2ToInf?head(),
    "==&amp;gt;  $gen2ToInf?tail()?head()",
    $gen2ToInf?tail()?head(),
    "================", 
    "$gen2ToInf?subrange(4, 6)?tail()?toArray()",
    $gen2ToInf?subrange(4, 6)?tail()?toArray(),
    "================",
    "$gen2ToInf?at(5)",
    $gen2ToInf?at(5), 
    "================",
    "$gen2ToInf?subrange(1, 5)?toArray()",
    $gen2ToInf?subrange(1, 5)?toArray(),
    "$gen2ToInf?subrange(1, 5)?for-each($double)?toArray()",
    $gen2ToInf?subrange(1, 5)?for-each($double)?toArray(),
    "$gen2ToInf?take(5)?for-each($double)?toArray()",
    $gen2ToInf?take(5)?for-each($double)?toArray(),
    "==&amp;gt;  $gen2ToInf?for-each($double)?take(5)?toArray()",
    $gen2ToInf?for-each($double)?take(5)?toArray(),
    "================",
    "$gen2ToInf?subrange(1, 5)?toArray()",
    $gen2ToInf?subrange(1, 5)?toArray(),
    "$gen2ToInf?subrange(6, 10)?toArray()",
    $gen2ToInf?subrange(6, 10)?toArray(),
    "$gen2ToInf?subrange(1, 5)?for-each-pair($gen2ToInf?subrange(6, 10), $sum2)?toArray()",
    $gen2ToInf?subrange(1, 5)?for-each-pair($gen2ToInf?subrange(6, 10), $sum2)?toArray(), 
    "==&amp;gt;  $gen2ToInf?for-each-pair($gen2ToInf, $sum2)?take(5)?toArray()",
    $gen2ToInf?for-each-pair($gen2ToInf, $sum2)?take(5)?toArray(),
    "================",
    "==&amp;gt;  $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?getCurrent()",
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?getCurrent(),
    "$gen2ToInf?filter(fn($n){$n mod 2 eq 1})?moveNext()?getCurrent()",
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?moveNext()?getCurrent(),
    "================", 
    "$gen2ToInf?filter(fn($n){$n mod 2 eq 1})?take(10)?toArray()",
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?take(10)?toArray(),  
    "================", 
    "$gen2ToInf?filter(fn($n){$n mod 2 eq 1})?take(10)?toSequence()",
    $gen2ToInf?filter(fn($n){$n mod 2 eq 1})?take(10)?toSequence(),
    "================", 
    "$gen2ToInf?takeWhile(fn($n){$n &amp;lt; 11})?toArray()",
    $gen2ToInf?takeWhile(fn($n){$n &amp;lt; 11})?toArray(), 
    "$gen2ToInf?takeWhile(fn($n){$n &amp;lt; 2})?toArray()",
    $gen2ToInf?takeWhile(fn($n){$n &amp;lt; 2})?toArray(), 
    "================", 
    "$gen2ToInf?skipWhile(fn($n){$n &amp;lt; 11})?take(5)?toArray()",
    $gen2ToInf?skipWhile(fn($n){$n &amp;lt; 11})?take(5)?toArray(),
    "==&amp;gt; $gen2ToInf?skipWhile(fn($n){$n &amp;lt; 2})",
    $gen2ToInf?skipWhile(fn($n){$n &amp;lt; 2}),
    "
     ==&amp;gt; $gen2ToInf?skipWhile(fn($n){$n &amp;lt; 2})?skip(1)",
    $gen2ToInf?skipWhile(fn($n){$n &amp;lt; 2})?skip(1),
(:    $gen2ToInf?skipWhile(fn($x) {$x ge 2}) :) (: ?skip(1) :)
    "================", 
    "$gen2ToInf?some()",
     $gen2ToInf?some(),
     "let $empty := $gen2ToInf?emptyGenerator()
      return $empty?some()",
     let $empty := $gen2ToInf?emptyGenerator()
      return $empty?some(),
    "================",
    "$gen2ToInf?take(5)?filter(fn($n){$n ge 7})?some()",
     $gen2ToInf?take(5)?filter(fn($n){$n ge 7})?some(),  
     "$gen2ToInf?take(5)?someWhere(fn($n){$n ge 7})",
     $gen2ToInf?take(5)?someWhere(fn($n){$n ge 7}), 
     "$gen2ToInf?take(5)?someWhere(fn($n){$n ge 6})",
     $gen2ToInf?take(5)?someWhere(fn($n){$n ge 6}),
     "$gen2ToInf?someWhere(fn($n){$n ge 100})",
     $gen2ToInf?someWhere(fn($n){$n ge 100}),
     "================",
     "$gen2ToInf?take(10)?take(11)?toArray()",
     $gen2ToInf?take(10)?take(11)?toArray(),
     "$gen2ToInf?take(10)?skip(10)?toArray()",
     $gen2ToInf?take(10)?skip(10)?toArray(),
     "$gen2ToInf?take(10)?skip(9)?toArray()",     
     $gen2ToInf?take(10)?skip(9)?toArray(),
     "$gen2ToInf?take(10)?subrange(3, 12)?toArray()",
     $gen2ToInf?take(10)?subrange(3, 12)?toArray(),
     "$gen2ToInf?take(10)?subrange(5, 3)?toArray()",
     $gen2ToInf?take(10)?subrange(5, 3)?toArray(),
     "================",
     "$gen2ToInf?take(100)?chunk(20)?getCurrent()",
      $gen2ToInf?take(100)?chunk(20)?getCurrent(),
      "==&amp;gt;  $gen2ToInf?chunk(20)?take(5)?toArray()",
      $gen2ToInf?chunk(20)?take(5)?toArray(),
     "================",
     "$gen2ToInf?take(100)?chunk(20)?moveNext()?getCurrent()",
      $gen2ToInf?take(100)?chunk(20)?moveNext()?getCurrent(),
     "$gen2ToInf?take(100)?chunk(20)?moveNext()?moveNext()?getCurrent()", 
      $gen2ToInf?take(100)?chunk(20)?moveNext()?moveNext()?getCurrent(),
     "$gen2ToInf?take(100)?chunk(20)?skip(1)?getCurrent()",      
      $gen2ToInf?take(100)?chunk(20)?skip(1)?getCurrent(),
     "================",      
     "$gen2ToInf?take(100)?chunk(20)?for-each(fn($genX){$genX})?toArray()",      
      $gen2ToInf?take(100)?chunk(20)?for-each(fn($genX){$genX})?toArray(),
     "================",  
     "$gen2ToInf?take(10)?chunk(4)?toArray()",
      $gen2ToInf?take(10)?chunk(4)?toArray(),
      "$gen2ToInf?take(10)?chunk(4)?for-each(fn($arr){array:size($arr)})?toArray()",
      $gen2ToInf?take(10)?chunk(4)?for-each(fn($arr){array:size($arr)})?toArray(),
     "================", 
     "$gen2ToInf?subrange(10, 15)?concat($gen2ToInf?subrange(1, 9))?toArray()",
     $gen2ToInf?subrange(10, 15)?concat($gen2ToInf?subrange(1, 9))?toArray(),
     "================", 
     "$gen2ToInf?subrange(1, 5)?append(101)?toArray()",
     $gen2ToInf?subrange(1, 5)?append(101)?toArray(),
     "$gen2ToInf?subrange(1, 5)?prepend(101)?toArray()",
     $gen2ToInf?subrange(1, 5)?prepend(101)?toArray(),
     "==&amp;gt;  $gen2ToInf?append(101)",
     $gen2ToInf?append(101),
     "$gen2ToInf?prepend(101)?take(5)?toArray()",
     $gen2ToInf?prepend(101)?take(5)?toArray(),
     "================", 
     "$gen2ToInf?subrange(1, 5)?zip($gen2ToInf?subrange(6, 10))?toArray()",
     $gen2ToInf?subrange(1, 5)?zip($gen2ToInf?subrange(6, 10))?toArray(),
     "$gen2ToInf?subrange(1, 5)?zip($gen2ToInf?subrange(10, 20))?toArray()",
     $gen2ToInf?subrange(1, 5)?zip($gen2ToInf?subrange(10, 20))?toArray(),
     "==&amp;gt;  $gen2ToInf?zip($gen2ToInf?skip(5))?take(10)?toArray()",
     $gen2ToInf?zip($gen2ToInf?skip(5))?take(10)?toArray(),
     "================", 
     "$gen2ToInf?makeGenerator(fn($numGenerated as xs:integer)
                                 {if($numGenerated le 9) then fn() {$numGenerated + 1} else -1} 
                             )?toArray()",
     $gen2ToInf?makeGenerator(fn($numGenerated as xs:integer)
                                 {if($numGenerated le 9) then fn() {$numGenerated + 1} else -1} 
                             )?toArray(),
     "================", 
     "$gen2ToInf?makeGeneratorFromArray([1, 4, 9, 16, 25])?toArray()",
      $gen2ToInf?makeGeneratorFromArray([1, 4, 9, 16, 25])?toArray(),
      "$gen2ToInf?makeGeneratorFromSequence((1, 8, 27, 64, 125))?toArray()",
      $gen2ToInf?makeGeneratorFromSequence((1, 8, 27, 64, 125))?toArray(), 
     "================", 
     "$gen2ToInf?take(10)?insertAt(3, ""XYZ"")?toArray()",
      $gen2ToInf?take(10)?insertAt(3, "XYZ")?toArray(),
      "$gen2ToInf?take(10)?insertAt(1, ""ABC"")?toArray()",
      $gen2ToInf?take(10)?insertAt(1, "ABC")?toArray(),
      "$gen2ToInf?take(10)?insertAt(11, ""PQR"")?toArray()",
      $gen2ToInf?take(10)?insertAt(11, "PQR")?toArray(),
      "==&amp;gt;  $gen2ToInf?insertAt(3, ""XYZ"")?take(10)?toArray()", 
      $gen2ToInf?insertAt(3, "XYZ")?take(10)?toArray(),
     (: , $gen2ToInf?take(10)?insertAt(12, "GHI")?toArray() :)  (:  Must raise error "Input Generator too-short." :) 
     "================", 
     "$gen2ToInf?take(10)?removeAt(3)?toArray()",
      $gen2ToInf?take(10)?removeAt(3)?toArray(),
      "$gen2ToInf?take(10)?removeAt(1)?toArray()",
      $gen2ToInf?take(10)?removeAt(1)?toArray(),
      "$gen2ToInf?take(10)?removeAt(10)?toArray()",
      $gen2ToInf?take(10)?removeAt(10)?toArray(),
      "==&amp;gt;  $gen2ToInf?removeAt(3)?take(10)?toArray()",
      $gen2ToInf?removeAt(3)?take(10)?toArray(),
      (: , $gen2ToInf?take(10)?removeAt(11)?toArray() :)        (:  Must raise error "Input Generator too-short." :) 
     "================",
     "$gen2ToInf?take(10)?replace(fn($x){$x gt 4}, ""Replacement"")?toArray()",
      $gen2ToInf?take(10)?replace(fn($x){$x gt 4}, "Replacement")?toArray(),
      "$gen2ToInf?take(10)?replace(fn($x){$x lt 3}, ""Replacement"")?toArray()",
      $gen2ToInf?take(10)?replace(fn($x){$x lt 3}, "Replacement")?toArray(),
      "$gen2ToInf?take(10)?replace(fn($x){$x gt 10}, ""Replacement"")?toArray()",
      $gen2ToInf?take(10)?replace(fn($x){$x gt 10}, "Replacement")?toArray(),
      "$gen2ToInf?take(10)?replace(fn($x){$x gt 11}, ""Replacement"")?toArray()",
      $gen2ToInf?take(10)?replace(fn($x){$x gt 11}, "Replacement")?toArray(),
      "$gen2ToInf?take(10)?replace(fn($x){$x lt 2}, ""Replacement"")?toArray()",
      $gen2ToInf?take(10)?replace(fn($x){$x lt 2}, "Replacement")?toArray(),
      "==&amp;gt; $gen2ToInf?replace(fn($x){$x gt 4}, ""Replacement"")?take(10)?toArray()",
      $gen2ToInf?replace(fn($x){$x gt 4}, "Replacement")?take(10)?toArray(),
      "$gen2ToInf?replace(fn($x){$x lt 3}, ""Replacement"")?take(10)?toArray()",
      $gen2ToInf?replace(fn($x){$x lt 3}, "Replacement")?take(10)?toArray(),
    (:  
      Will result in endless loop:
      
      , "==&amp;gt;  ==&amp;gt;  ==&amp;gt;  $gen2ToInf?replace(fn($x){$x lt 2}, ""Replacement"")?take(10)?toArray() &amp;lt;==  &amp;lt;==  &amp;lt;==",
      $gen2ToInf?replace2(fn($x){$x lt 2}, "Replacement")?take(10)?toArray() 
    :)
    "================",
    "$gen2ToInf?emptyGenerator()?reverse()?toArray()",
    $gen2ToInf?emptyGenerator()?reverse()?toArray(),
    "$gen2ToInf?emptyGenerator()?append(2)?reverse()?toArray()",
    $gen2ToInf?emptyGenerator()?append(2)?reverse()?toArray(),
    "$gen2ToInf?take(10)?reverse()?toArray()",
    $gen2ToInf?take(10)?reverse()?toArray(),
    "================",
    "$gen2ToInf?take(5)?fold-left(0, fn($x, $y){$x + $y})",
    $gen2ToInf?take(5)?fold-left(0, fn($x, $y){$x + $y}),
    "================",
    "$gen2ToInf?take(5)?fold-right(0, fn($x, $y){$x + $y})",
    $gen2ToInf?take(5)?fold-right(0, fn($x, $y){$x + $y}),
    "================",
    "$gen2ToInf?emptyGenerator()?scan-left(0, fn($x, $y){$x + $y})?toArray()",
    $gen2ToInf?emptyGenerator()?scan-left(0, fn($x, $y){$x + $y})?toArray(),
    "$gen2ToInf?take(5)?scan-left(0, fn($x, $y){$x + $y})?toArray()",
    $gen2ToInf?take(5)?scan-left(0, fn($x, $y){$x + $y})?toArray(),
    "================",
    "$gen2ToInf?makeGeneratorFromSequence((1 to 10))?scan-right(0, fn($x, $y){$x + $y})?toArray()",
    $gen2ToInf?makeGeneratorFromSequence((1 to 10))?scan-right(0, fn($x, $y){$x + $y})?toArray(),
    "================",
    let $multShortCircuitProvider := fn($x, $y)
        {
          if($x eq 0) then fn(){0}
            else fn($z) {$x * $z}
        },
        $gen-5ToInf := $gen2ToInf?for-each(fn($n){$n -7})
     return
     (
       "let $multShortCircuitProvider := fn($x, $y)
        {
          if($x eq 0) then fn(){0}
            else fn($z) {$x * $z}
        },
            $gen-5ToInf := $gen2ToInf?for-each(fn($n){$n -7})
          return
            $gen2ToInf?take(5)?fold-lazy(1, $product, $multShortCircuitProvider),
            $gen-5ToInf?fold-lazy(1, $product, $multShortCircuitProvider)",
       $gen2ToInf?take(5)?fold-lazy(1, $product, $multShortCircuitProvider),
       $gen-5ToInf?fold-lazy(1, $product, $multShortCircuitProvider)
     )
   )
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
