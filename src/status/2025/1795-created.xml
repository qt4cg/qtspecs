<item>
   <title>Issue #1795 created</title>
   <pubDate>2025-02-12T12:51:15Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/1795</link>
   <guid>https://qt4cg.org/@qt4cg/2025/#created-1795</guid>
   <description>&lt;div&gt;&lt;p&gt;XSLT templates: Matching values in a map by key&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;The simplest coding pattern for template rule processing for JSON structures would be to take a structure like this:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[
   {"name": "John", "address": { .... }, job-history: [ { .... }, {....} ]},
   {"name": "Jane", "address": { .... }, job-history: [ { .... }, {....} ]}
]

and to process it using template rules of the form:

&amp;lt;xsl:template match="record(name, address, job-history)"&amp;gt;
    &amp;lt;xsl:apply-templates select="?*"/&amp;gt;
&amp;lt;/xsl:template&amp;gt;

&amp;lt;xsl:template match="(pattern matching key 'name')"&amp;gt;...&amp;lt;/xsl:template&amp;gt;

&amp;lt;xsl:template match="(pattern matching key 'address')"&amp;gt;...&amp;lt;/xsl:template&amp;gt;

&amp;lt;xsl:template match="(pattern matching key 'job-history')"&amp;gt;...&amp;lt;/xsl:template&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;We have nearly all the ingredients in place for this. In particular, we can ensure that the &lt;code&gt;select="?*"&lt;/code&gt; selects values that are labelled with the relevant key, making it technically possible to match values according to that key: &lt;code&gt;select="?*"&lt;/code&gt; might select an xs:string value "John", but the string is labelled with the property key="name", so it can in principle match a template rule designed to process the "name" value.&lt;/p&gt;
&lt;p&gt;The only piece that's missing is how to write the match patterns. We can write &lt;code&gt;match=".[label()?key = 'name']"&lt;/code&gt;, but that's hopelessly long-winded.&lt;/p&gt;
&lt;p&gt;I propose that we use the syntax &lt;code&gt;match="?name"&lt;/code&gt; to match a value that is labelled with the key "name". This feels intuitive and natural, and 99% of users won't trouble with the complex underlying semantics.&lt;/p&gt;
&lt;p&gt;We can extend this by borrowing other parts of the Lookup expression syntax, for example &lt;code&gt;match="?('X', 'Y', 'Z')"&lt;/code&gt; to match several keys.&lt;/p&gt;
&lt;p&gt;I would also suggest promoting the operators "union", "intersect" and "except" so they can be used to combine any patterns (not just node patterns) so this could be written &lt;code&gt;match="?X | ?X | ?Z"&lt;/code&gt;, or we could write &lt;code&gt;match="?* except ?X"&lt;/code&gt;. But note that this would create an expectation that users can also write &lt;code&gt;select="?* except ?X"&lt;/code&gt; in an XPath expression; and that's quite hard to achieve: see also #1794.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
