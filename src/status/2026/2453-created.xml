<item>
   <title>Issue #2453 created</title>
   <pubDate>2026-02-09T00:20:18Z</pubDate>
   <link>https://github.com/qt4cg/qtspecs/issues/2453</link>
   <guid>https://qt4cg.org/@qt4cg/2026/#created-2453</guid>
   <description>&lt;div&gt;&lt;p&gt;XSLT Patterns: the "child-or-top" adjustment&lt;/p&gt;&lt;div class="markup"&gt;&lt;p&gt;This issue identifies a bug in XSLT 3.0 (retained in XSLT 4.0).&lt;/p&gt;
&lt;p&gt;There is a special rule in XSLT 3.0 designed to ensure that the pattern &lt;code&gt;match="a"&lt;/code&gt; will match an &lt;code&gt;a&lt;/code&gt; element even if it is parentless. Without the special rule, it would not do so, because "a" expands to &lt;code&gt;child::a&lt;/code&gt; which would otherwise only match an element that is a child of something.&lt;/p&gt;
&lt;p&gt;The rule is written (in ยง5.5.3):&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;If any PathExprP in the Pattern is a RelativePathExprP, then the first StepExprP PS of this RelativePathExprP is adjusted to allow it to match a parentless element... If PS uses the child axis (explicitly or implicitly), and if the NodeTest in PS is not document-node() (optionally with arguments), then the axis in step PS is replaced by child-or-top, which is defined as follows. If the context node is a parentless element, comment, processing-instruction, or text node then the child-or-top axis selects the context node; otherwise it selects the children of the context node. It is a forwards axis whose principal node kind is element.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Now consider the pattern &lt;code&gt;match="*/(b union c)"&lt;/code&gt;. Clearly &lt;code&gt;b&lt;/code&gt; is a PathExprP and a RelativePathExprP, so the adjustment applies to its first StepExprP, namely to &lt;code&gt;b&lt;/code&gt;. So the pattern should expand to &lt;code&gt;match="*/(child-or-top::b union child-or-top::c)"&lt;/code&gt;, and a literal reading of the semantics of patterns, in conjunction with the semantics of path expressions, means that this should match a parentless &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; element, whereas the clear intention (and the Saxon implementation) is that it matches a &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; element only if it has an element node parent.&lt;/p&gt;
&lt;p&gt;Similarly, consider the pattern &lt;code&gt;match="b[b or c]"&lt;/code&gt;. Again, the rules suggest that this should be adjusted to &lt;code&gt;match="child-or-top::b[child-or-top::b or child-or-top::c]"&lt;/code&gt; which would technically match a parentless &lt;code&gt;b&lt;/code&gt; element having no &lt;code&gt;b&lt;/code&gt; or &lt;code&gt;c&lt;/code&gt; child. This is clearly not intended&lt;/p&gt;
&lt;p&gt;Saxon in fact is not applying any syntactic adjustment to the pattern at all. Rather, it is evaluating the pattern steps from right to left, and if a sub pattern has no preceding "/" or "//" operator then it is assuming there are no constraints on the element's ancestry.&lt;/p&gt;
&lt;p&gt;I can think of a couple of ways the bug might be fixed.&lt;/p&gt;
&lt;p&gt;Firstly, we could try to define more precisely the StepExprP subexpressions that are subjected to this adjustment. It's basically any StepExprP that is not the right-hand operand of "/" or "//", and that is not an operand of a union, intersect, or except expression that is the right hand operand of "/" or "//", and is not contained within a predicate.&lt;/p&gt;
&lt;p&gt;Alternatively, we could try to amend the "equivalent expression" rule. We say that a pattern P matches a node N if N has an ancestor-or-self node $A such that the path expression $A//(P) selects N. We could amend this rule to say that if N is parentless, then this rule is evaluated "as if" N had an imaginary parent.&lt;/p&gt;
&lt;p&gt;Neither solution is very elegant.&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;</description>
</item>
