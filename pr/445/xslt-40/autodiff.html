<!DOCTYPE HTML>
<html xmlns="http://www.w3.org/1999/xhtml" lang="EN"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><!--Generated by the DeltaXML.com xhtml-outfilter.xsl--><!--Using XSL Processor: Saxonica--><title>XSL Transformations (XSLT) Version 4.0</title><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><link rel="stylesheet" type="text/css" href="https://www.w3.org/StyleSheets/TR/2016/W3C-REC.css"><link rel="stylesheet" href="css/qtspecs.css"><link rel="stylesheet" href="css/xslt-40.css"><style type="text/css">
          body { margin-top: 50px }
          a.button { background: #DDD; border: 2px outset black; padding: 2px; margin: 2px; font-family: sans-serif; font-size: small;}
          a.button:hover { cursor:pointer; }
          a.button:active { border-style: inset; }
        </style><link rel="stylesheet" href="/css/autodiff.css"></head><body><div style="position:fixed; clear:both; top:0px" id="_autodiff_buttons"><p><a class="button" onclick="view('old')">
              View Old
            </a><a class="button" onclick="view('new')">
              View New
            </a><a class="button" onclick="view('both')">
              View Both
            </a><a class="button" onclick="view('only')">
              View Only
            </a><a class="button" onclick="scroll_to('prev')">
              Previous
            </a><a class="button" onclick="scroll_to('next')">
              Next
            </a><span id="__autodiff__"></span></p></div><div class="head"><p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p><h1><a id="title"></a>XSL Transformations (XSLT) Version 4.0</h1><h2><a id="w3c-doctype"></a>W3C Editor's Draft 18 April 2023</h2><dl><dt>This version:</dt><dd><a href="https://qt4cg.org/pr/445/xslt-40//">https://qt4cg.org/<span class="deltaxml-old" style="background:#FF5555">specifications/</span><span class="deltaxml-new" style="background:#90EE90">pr/445/</span>xslt-40/</a></dd><dt>Latest version:</dt><dd><a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a></dd><dt>Most recent Recommendation of XSL Transformations (XSLT):</dt><dd><a href="https://www.w3.org/TR/xslt-30/">https://www.w3.org/TR/xslt-30/</a></dd><dt>Editor:</dt><dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd></dl><p>The following associated resources are available:</p><ul><li><a href="Overview.html">Normative specification in HTML format</a></li><li><a href="Overview-diff.html">HTML with revision markings (non-normative)</a></li><li><a href="schema-for-xslt40.xsd">XSD 1.1 Schema for XSLT 4.0 Stylesheets (non-normative)</a></li><li><a href="schema-for-xslt40.rnc">Relax-NG Schema for XSLT 4.0 Stylesheets (non-normative)</a></li><li><a href="schema-for-json.xsd">XSD 1.0 Schema for the XML representation of JSON used by fn:json-to-xml (non-normative)</a></li><li><a href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion (non-normative)</a></li></ul><p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2023&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p><hr></div><div><h2><a id="abstract"></a>Abstract</h2><p>This specification defines the syntax and semantics of XSLT 4.0, a language designed primarily for transforming XML documents into other XML documents.</p><p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <a href="#xslt-30">[XSLT 3.0]</a> published on 8 June 2017.</p><p>The changes in this version of the language are relatively minor usability enhancements. There are no changes to the data model or processing model. Instead, the specification attempts to fill a number of gaps in functionality resulting from feedback from XSLT 3.0 users. The main areas covered are:</p><ul><li><p>Enhancements to the type system to allow more expressive constraints, especially for maps and atomic values.</p></li><li><p>Additional functionality for processing arrays.</p></li><li><p>Exploitation of the power afforded by first-class function items.</p></li></ul><p>XSLT 4.0 is designed to be used in conjunction with XPath 4.0, which is defined in <a href="#xpath-40">[XPath 4.0]</a>. XSLT shares the same data model as XPath 4.0, which is defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>, and it uses the library of functions and operators defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. XPath 4.0 and the underlying function library introduce a number of enhancements, for example the availability of union and record types. </p><p>XSLT 4.0 also includes optional facilities to serialize the results of a transformation, by means of an interface to the serialization component described in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization 3.1]</a>. </p><p><span style="display: none;" class="delete_version"><em>This document contains hyperlinks to specific sections or definitions within other documents in this family of specifications. These links are indicated visually by a superscript identifying the target specification: for example XP40 for XPath 4.0, DM30 for the XDM data model version 3.0, FO40 for Functions and Operators version 4.0.</em></span><span style="display: none;" class="add_version"><em>This document contains hyperlinks to specific sections or definitions within other documents in this family of specifications. These links are indicated visually by a superscript identifying the target specification: for example XP40 for XPath 4.0, DM40 for the XDM data model version 4.0, FO40 for Functions and Operators version 4.0.</em></span><span class="modify_version"><em>This document contains hyperlinks to specific sections or definitions within other documents in this family of specifications. These links are indicated visually by a superscript identifying the target specification: for example XP40 for XPath 4.0, <span class="deltaxml-old" style="background:#FF5555">DM30</span><span class="deltaxml-new" style="background:#90EE90">DM40</span> for the XDM data model version <span class="deltaxml-old" style="background:#FF5555">3.0</span><span class="deltaxml-new" style="background:#90EE90">4.0</span>, FO40 for Functions and Operators version 4.0.</em></span></p></div><div><h2><a id="status"></a>Status of this Document</h2><p><em>This section describes the status of this document at the time of its publication. Other documents may supersede this document. A list of current W3C publications and the latest revision of this technical report can be found in the <a href="https://www.w3.org/TR/">W3C technical reports index at https://www.w3.org/TR/.</a></em></p><p>This document has no official standing. It is produced by the editor as a proposal for community review. Insofar as it copies large amounts of text from the W3C XSLT 3.0 Recommendation, W3C copyright and similar provisions apply.</p></div><nav id="toc"><h2><a id="contents"></a>Table of Contents</h2><ol class="toc"><li><a href="#introduction"><span class="secno">1 </span><span class="content">Introduction</span></a><ol class="toc"><li><a href="#what-is-xslt"><span class="secno">1.1 </span><span class="content">What is XSLT?</span></a></li><li><a href="#whats-new-in-xslt4"><span class="secno">1.2 </span><span class="content">What’s New in XSLT 4.0?</span></a></li></ol></li><li><a href="#concepts"><span class="secno">2 </span><span class="content">Concepts</span></a><ol class="toc"><li><a href="#terminology"><span class="secno">2.1 </span><span class="content">Terminology</span></a></li><li><a href="#notation"><span class="secno">2.2 </span><span class="content">Notation</span></a></li><li><a href="#initiating"><span class="secno">2.3 </span><span class="content">Initiating a Transformation</span></a><ol class="toc"><li><a href="#info-for-static-analysis"><span class="secno">2.3.1 </span><span class="content">Information needed for Static Analysis</span></a></li><li><a href="#priming-stylesheet"><span class="secno">2.3.2 </span><span class="content">Priming a Stylesheet</span></a></li><li><a href="#invoking-initial-mode"><span class="secno">2.3.3 </span><span class="content">Apply-Templates Invocation</span></a></li><li><a href="#invoking-initial-template"><span class="secno">2.3.4 </span><span class="content">Call-Template Invocation</span></a></li><li><a href="#invoking-initial-function"><span class="secno">2.3.5 </span><span class="content">Function Call Invocation</span></a></li><li><a href="#post-processing"><span class="secno">2.3.6 </span><span class="content">Post-processing the Raw Result</span></a><a href="#result-tree-construction"><span class="secno">2.3.6.1 </span><span class="content">Result Tree Construction</span></a><a href="#result-serialization"><span class="secno">2.3.6.2 </span><span class="content">Serializing the Result</span></a></li></ol></li><li><a href="#executing-a-transformation"><span class="secno">2.4 </span><span class="content">Instructions</span></a></li><li><a href="#rule-based-processing"><span class="secno">2.5 </span><span class="content">Rule-Based Processing</span></a></li><li><a href="#context"><span class="secno">2.6 </span><span class="content">The Evaluation Context</span></a></li><li><a href="#parsing-and-serialization"><span class="secno">2.7 </span><span class="content">Parsing and Serialization</span></a></li><li><a href="#packages-and-modules"><span class="secno">2.8 </span><span class="content">Packages and Modules</span></a></li><li><a href="#extensibility"><span class="secno">2.9 </span><span class="content">Extensibility</span></a></li><li><a href="#stylesheets-and-schemas"><span class="secno">2.10 </span><span class="content">Stylesheets and XML Schemas</span></a></li><li><a href="#streaming-concepts"><span class="secno">2.11 </span><span class="content">Streaming</span></a></li><li><a href="#streamed-validation"><span class="secno">2.12 </span><span class="content">Streamed Validation</span></a></li><li><a href="#streaming-non-xml"><span class="secno">2.13 </span><span class="content">Streaming of non-XML data</span></a></li><li><a href="#errors"><span class="secno">2.14 </span><span class="content">Error Handling</span></a></li></ol></li><li><a href="#stylesheet-structure"><span class="secno">3 </span><span class="content">Stylesheet Structure</span></a><ol class="toc"><li><a href="#xslt-namespace"><span class="secno">3.1 </span><span class="content">XSLT Namespace</span></a></li><li><a href="#extension-attributes"><span class="secno">3.2 </span><span class="content">Extension Attributes</span></a></li><li><a href="#xslt-media-type"><span class="secno">3.3 </span><span class="content">XSLT Media Type</span></a></li><li><a href="#standard-attributes"><span class="secno">3.4 </span><span class="content">Standard Attributes</span></a></li><li><a href="#packages"><span class="secno">3.5 </span><span class="content">Packages</span></a><ol class="toc"><li><a href="#package-versions"><span class="secno">3.5.1 </span><span class="content">Versions of a Package</span></a></li><li><a href="#package-dependencies"><span class="secno">3.5.2 </span><span class="content">Dependencies between Packages</span></a></li><li><a href="#named-components"><span class="secno">3.5.3 </span><span class="content">Named Components in Packages</span></a><a href="#visibility"><span class="secno">3.5.3.1 </span><span class="content">Visibility of Components</span></a><a href="#accepting-components"><span class="secno">3.5.3.2 </span><span class="content">Accepting Components</span></a><a href="#package-overriding-components"><span class="secno">3.5.3.3 </span><span class="content">Overriding Components from a Used Package</span></a><a href="#refer-to-overridden"><span class="secno">3.5.3.4 </span><span class="content">Referring to Overridden Components</span></a><a href="#component-references"><span class="secno">3.5.3.5 </span><span class="content">Binding References to Components</span></a><a href="#dynamic-component-references"><span class="secno">3.5.3.6 </span><span class="content">Dynamic References to Components</span></a></li><li><a href="#modes-and-packages"><span class="secno">3.5.4 </span><span class="content">Overriding Template Rules from a Used Package</span></a><a href="#requiring-explicit-modes"><span class="secno">3.5.4.1 </span><span class="content">Requiring Explicit Mode Declarations</span></a></li><li><a href="#package-local-declarations"><span class="secno">3.5.5 </span><span class="content">Declarations Local to a Package</span></a></li><li><a href="#declaring-global-context-item"><span class="secno">3.5.6 </span><span class="content">Declaring the Global Context Item</span></a></li><li><a href="#packages-csv-library-example"><span class="secno">3.5.7 </span><span class="content">Worked Example of a Library Package</span></a><a href="#csv-example-default-functionality"><span class="secno">3.5.7.1 </span><span class="content">Default Functionality of the CSV Package</span></a><a href="#csv-example-package-structure"><span class="secno">3.5.7.2 </span><span class="content">Package Structure</span></a><a href="#csv-example-customizing-parse"><span class="secno">3.5.7.3 </span><span class="content">The csv:parse Function and its User-customization Hooks</span></a><a href="#csv-example-line-breaking"><span class="secno">3.5.7.4 </span><span class="content">Breaking the Input into Lines</span></a><a href="#csv-example-preprocessing-lines"><span class="secno">3.5.7.5 </span><span class="content">Pre-processing the Lines</span></a><a href="#example-csv-mode-parse-line"><span class="secno">3.5.7.6 </span><span class="content">The Mode csv:parse-line</span></a><a href="#csv-example-mode"><span class="secno">3.5.7.7 </span><span class="content">Mode csv:parse-field</span></a><a href="#csv-example-variable"><span class="secno">3.5.7.8 </span><span class="content">The csv:quote Variable</span></a><a href="#csv-example-preprocess-field"><span class="secno">3.5.7.9 </span><span class="content">The csv:preprocess-field Function</span></a><a href="#csv-example-postprocess"><span class="secno">3.5.7.10 </span><span class="content">The Mode csv:post-process</span></a><a href="#csv-example-overriding"><span class="secno">3.5.7.11 </span><span class="content">Overriding the Default Behavior</span></a></li></ol></li><li><a href="#stylesheet-modules"><span class="secno">3.6 </span><span class="content">Stylesheet Modules</span></a></li><li><a href="#stylesheet-element"><span class="secno">3.7 </span><span class="content">Stylesheet Element</span></a><ol class="toc"><li><a href="#default-collation-attribute"><span class="secno">3.7.1 </span><span class="content">The default-collation Attribute</span></a></li><li><a href="#default-mode"><span class="secno">3.7.2 </span><span class="content">The default-mode Attribute</span></a></li><li><a href="#user-defined-top-level"><span class="secno">3.7.3 </span><span class="content">User-defined Data Elements</span></a></li></ol></li><li><a href="#simplified-stylesheet"><span class="secno">3.8 </span><span class="content">Simplified Stylesheet Modules</span></a></li><li><a href="#backwards"><span class="secno">3.9 </span><span class="content">Backwards Compatible Processing</span></a><ol class="toc"><li><a href="#backwards-1.0"><span class="secno">3.9.1 </span><span class="content">XSLT 1.0 Compatibility Mode</span></a></li><li><a href="#backwards-2.0"><span class="secno">3.9.2 </span><span class="content">XSLT 2.0 Compatibility Mode</span></a></li><li><a href="#backwards-3.0"><span class="secno">3.9.3 </span><span class="content">XSLT 3.0 Compatibility Mode</span></a></li></ol></li><li><a href="#forwards"><span class="secno">3.10 </span><span class="content">Forwards Compatible Processing</span></a></li><li><a href="#combining-modules"><span class="secno">3.11 </span><span class="content">Combining Stylesheet Modules</span></a><ol class="toc"><li><a href="#locating-modules"><span class="secno">3.11.1 </span><span class="content">Locating Stylesheet Modules</span></a></li><li><a href="#include"><span class="secno">3.11.2 </span><span class="content">Stylesheet Inclusion</span></a></li><li><a href="#import"><span class="secno">3.11.3 </span><span class="content">Stylesheet Import</span></a></li></ol></li><li><a href="#embedded"><span class="secno">3.12 </span><span class="content">Embedded Stylesheet Modules</span></a></li><li><a href="#preprocessing"><span class="secno">3.13 </span><span class="content">Stylesheet Preprocessing</span></a><ol class="toc"><li><a href="#stylesheet-stripping"><span class="secno">3.13.1 </span><span class="content">Stripping Whitespace and Commentary from the Stylesheet</span></a></li><li><a href="#xsl-note-elements"><span class="secno">3.13.2 </span><span class="content">The xsl:note element</span></a></li><li><a href="#conditional-inclusion"><span class="secno">3.13.3 </span><span class="content">Conditional Element Inclusion</span></a></li><li><a href="#shadow-attributes"><span class="secno">3.13.4 </span><span class="content">Shadow Attributes</span></a></li></ol></li><li><a href="#built-in-types"><span class="secno">3.14 </span><span class="content">Built-in Types</span></a></li><li><a href="#import-schema"><span class="secno">3.15 </span><span class="content">Importing Schema Components</span></a></li></ol></li><li><a href="#data-model"><span class="secno">4 </span><span class="content">Data Model</span></a><ol class="toc"><li><a href="#xml-versions"><span class="secno">4.1 </span><span class="content">XML Versions</span></a></li><li><a href="#xdm-versions"><span class="secno">4.2 </span><span class="content">XDM versions</span></a></li><li><a href="#preprocessing-source-docs"><span class="secno">4.3 </span><span class="content">Preprocessing Source Documents</span></a><ol class="toc"><li><a href="#stripping-annotations"><span class="secno">4.3.1 </span><span class="content">Stripping Type Annotations from a Source Tree</span></a></li><li><a href="#strip"><span class="secno">4.3.2 </span><span class="content">Stripping Whitespace from a Source Tree</span></a></li></ol></li><li><a href="#id-in-data-model"><span class="secno">4.4 </span><span class="content">Attribute Types and DTD Validation</span></a></li><li><a href="#model-for-streaming"><span class="secno">4.5 </span><span class="content">Data Model for Streaming</span></a><ol class="toc"><li><a href="#streamed-documents"><span class="secno">4.5.1 </span><span class="content">Streamed Documents</span></a></li><li><a href="#streaming-other-types"><span class="secno">4.5.2 </span><span class="content">Other Data Structures</span></a></li></ol></li><li><a href="#limits"><span class="secno">4.6 </span><span class="content">Limits</span></a></li><li><a href="#d-o-e-in-data-model"><span class="secno">4.7 </span><span class="content">Disable Output Escaping</span></a></li></ol></li><li><a href="#constructs"><span class="secno">5 </span><span class="content">Features of the XSLT Language</span></a><ol class="toc"><li><a href="#names"><span class="secno">5.1 </span><span class="content">Names</span></a><ol class="toc"><li><a href="#qname"><span class="secno">5.1.1 </span><span class="content">Qualified Names</span></a></li><li><a href="#unprefixed-qnames"><span class="secno">5.1.2 </span><span class="content">Unprefixed Lexical QNames in Expressions and Patterns</span></a><a href="#unprefixed-element-names"><span class="secno">5.1.2.1 </span><span class="content">Unprefixed Element Names</span></a><a href="#unprefixed-type-names"><span class="secno">5.1.2.2 </span><span class="content">Unprefixed Type Names</span></a><a href="#unprefixed-function-names"><span class="secno">5.1.2.3 </span><span class="content">Unprefixed Function Names</span></a><a href="#other-unprefixed-names"><span class="secno">5.1.2.4 </span><span class="content">Other Unprefixed Names</span></a></li><li><a href="#reserved-namespaces"><span class="secno">5.1.3 </span><span class="content">Reserved Namespaces</span></a></li></ol></li><li><a href="#expressions"><span class="secno">5.2 </span><span class="content">Expressions</span></a></li><li><a href="#static-and-dynamic-context"><span class="secno">5.3 </span><span class="content">The Static and Dynamic Context</span></a><ol class="toc"><li><a href="#static-context"><span class="secno">5.3.1 </span><span class="content">Initializing the Static Context</span></a></li><li><a href="#resolving-function-names"><span class="secno">5.3.2 </span><span class="content">Resolving Function Names</span></a><a href="#resolving-function-names-without-function-library"><span class="secno">5.3.2.1 </span><span class="content">When no xsl:function-library is Declared</span></a><a href="#resolving-function-names-with-function-library"><span class="secno">5.3.2.2 </span><span class="content">When an xsl:function-library is Declared</span></a></li><li><a href="#additional-static-context"><span class="secno">5.3.3 </span><span class="content">Additional Static Context Components used by XSLT</span></a></li><li><a href="#xpath-dynamic-context"><span class="secno">5.3.4 </span><span class="content">Initializing the Dynamic Context</span></a><a href="#focus"><span class="secno">5.3.4.1 </span><span class="content">Maintaining Position: the Focus</span></a><a href="#evaluation-context"><span class="secno">5.3.4.2 </span><span class="content">Other Components of the XPath Dynamic Context</span></a></li><li><a href="#additional-dynamic-context"><span class="secno">5.3.5 </span><span class="content">Additional Dynamic Context Components used by XSLT</span></a></li></ol></li><li><a href="#patterns"><span class="secno">5.4 </span><span class="content">Patterns</span></a><ol class="toc"><li><a href="#pattern-examples"><span class="secno">5.4.1 </span><span class="content">Examples of Patterns</span></a></li><li><a href="#pattern-syntax"><span class="secno">5.4.2 </span><span class="content">Syntax of Patterns</span></a><a href="#predicate-patterns"><span class="secno">5.4.2.1 </span><span class="content">Predicate Patterns</span></a><a href="#type-patterns"><span class="secno">5.4.2.2 </span><span class="content">Type Patterns</span></a><a href="#node-patterns"><span class="secno">5.4.2.3 </span><span class="content">Node Patterns</span></a><a href="#pattern-semantics"><span class="secno">5.4.2.4 </span><span class="content">The Meaning of a Node Pattern</span></a></li><li><a href="#pattern-errors"><span class="secno">5.4.3 </span><span class="content">Errors in Patterns</span></a></li></ol></li><li><a href="#named-item-types"><span class="secno">5.5 </span><span class="content">Defining Named Item Types</span></a></li><li><a href="#defining-decimal-format"><span class="secno">5.6 </span><span class="content">Defining a Decimal Format</span></a></li><li><a href="#value-templates"><span class="secno">5.7 </span><span class="content">Value Templates</span></a><ol class="toc"><li><a href="#attribute-value-templates"><span class="secno">5.7.1 </span><span class="content">Attribute Value Templates</span></a></li><li><a href="#text-value-templates"><span class="secno">5.7.2 </span><span class="content">Text Value Templates</span></a></li></ol></li><li><a href="#sequence-constructors"><span class="secno">5.8 </span><span class="content">Sequence Constructors</span></a><ol class="toc"><li><a href="#constructing-complex-content"><span class="secno">5.8.1 </span><span class="content">Constructing Complex Content</span></a></li><li><a href="#constructing-simple-content"><span class="secno">5.8.2 </span><span class="content">Constructing Simple Content</span></a></li><li><a href="#namespace-fixup"><span class="secno">5.8.3 </span><span class="content">Namespace Fixup</span></a></li></ol></li><li><a href="#uri-references"><span class="secno">5.9 </span><span class="content">URI References</span></a></li></ol></li><li><a href="#rules"><span class="secno">6 </span><span class="content">Template Rules</span></a><ol class="toc"><li><a href="#defining-templates"><span class="secno">6.1 </span><span class="content">Defining Templates</span></a></li><li><a href="#defining-template-rules"><span class="secno">6.2 </span><span class="content">Defining Template Rules</span></a></li><li><a href="#applying-templates"><span class="secno">6.3 </span><span class="content">Applying Template Rules</span></a></li><li><a href="#apply-templates-separator"><span class="secno">6.4 </span><span class="content">The separator attribute</span></a></li><li><a href="#conflict"><span class="secno">6.5 </span><span class="content">Conflict Resolution for Template Rules</span></a></li><li><a href="#default-priority"><span class="secno">6.6 </span><span class="content">Default Priority for Template Rules</span></a></li><li><a href="#modes"><span class="secno">6.7 </span><span class="content">Modes</span></a><ol class="toc"><li><a href="#declaring-modes"><span class="secno">6.7.1 </span><span class="content">Declaring Modes</span></a></li><li><a href="#using-modes"><span class="secno">6.7.2 </span><span class="content">Using Modes</span></a></li><li><a href="#xsl-mode-typed"><span class="secno">6.7.3 </span><span class="content">Declaring the Type of Nodes Processed by a Mode</span></a></li><li><a href="#mode-result-type"><span class="secno">6.7.4 </span><span class="content">Declaring the result type of a mode</span></a></li><li><a href="#enclosing-modes"><span class="secno">6.7.5 </span><span class="content">Enclosing Modes</span></a></li><li><a href="#streamable-templates"><span class="secno">6.7.6 </span><span class="content">Streamable Templates</span></a></li></ol></li><li><a href="#built-in-rule"><span class="secno">6.8 </span><span class="content">Built-in Template Rules</span></a><ol class="toc"><li><a href="#built-in-templates-text-only-copy"><span class="secno">6.8.1 </span><span class="content">Built-in Templates: Text-only Copy</span></a></li><li><a href="#built-in-templates-deep-copy"><span class="secno">6.8.2 </span><span class="content">Built-in Templates: Deep Copy</span></a></li><li><a href="#built-in-templates-shallow-copy"><span class="secno">6.8.3 </span><span class="content">Built-in Templates: Shallow Copy</span></a></li><li><a href="#built-in-templates-deep-skip"><span class="secno">6.8.4 </span><span class="content">Built-in Templates: Deep Skip</span></a></li><li><a href="#built-in-templates-shallow-skip"><span class="secno">6.8.5 </span><span class="content">Built-in Templates: Shallow Skip</span></a></li><li><a href="#built-in-templates-fail"><span class="secno">6.8.6 </span><span class="content">Built-in Templates: Fail</span></a></li></ol></li><li><a href="#apply-imports"><span class="secno">6.9 </span><span class="content">Overriding Template Rules</span></a></li><li><a href="#parameters-to-template-rules"><span class="secno">6.10 </span><span class="content">Passing Parameters to Template Rules</span></a></li></ol></li><li><a href="#repetition"><span class="secno">7 </span><span class="content">Repetition</span></a><ol class="toc"><li><a href="#for-each"><span class="secno">7.1 </span><span class="content">The xsl:for-each instruction</span></a><ol class="toc"><li><a href="#for-each-separator"><span class="secno">7.1.1 </span><span class="content">The separator attribute</span></a></li></ol></li><li><a href="#iterate"><span class="secno">7.2 </span><span class="content">The xsl:iterate Instruction</span></a></li></ol></li><li><a href="#conditionals"><span class="secno">8 </span><span class="content">Conditional Processing</span></a><ol class="toc"><li><a href="#xsl-if"><span class="secno">8.1 </span><span class="content">Conditional Processing with xsl:if </span></a></li><li><a href="#xsl-choose"><span class="secno">8.2 </span><span class="content">Conditional Processing with xsl:choose </span></a></li><li><a href="#xsl-switch"><span class="secno">8.3 </span><span class="content">Conditional Processing with xsl:switch </span></a></li><li><a href="#try-catch"><span class="secno">8.4 </span><span class="content">Try/Catch</span></a><ol class="toc"><li><a href="#recovery"><span class="secno">8.4.1 </span><span class="content">Recovery of Result Trees</span></a></li><li><a href="#try-catch-examples"><span class="secno">8.4.2 </span><span class="content">Try/Catch Examples</span></a></li></ol></li><li><a href="#conditional-content-construction"><span class="secno">8.5 </span><span class="content">Conditional Content Construction</span></a><ol class="toc"><li><a href="#where-populated"><span class="secno">8.5.1 </span><span class="content">The xsl:where-populated instruction</span></a></li><li><a href="#on-empty"><span class="secno">8.5.2 </span><span class="content">The xsl:on-empty instruction</span></a></li><li><a href="#on-non-empty"><span class="secno">8.5.3 </span><span class="content">The xsl:on-non-empty instruction</span></a></li><li><a href="#evaluating-on-empty"><span class="secno">8.5.4 </span><span class="content">Evaluating xsl:on-empty and xsl:on-non-empty Instructions</span></a></li><li><a href="#where-populated-example"><span class="secno">8.5.5 </span><span class="content">A More Complex Example</span></a></li></ol></li></ol></li><li><a href="#variables-and-parameters"><span class="secno">9 </span><span class="content">Variables and Parameters</span></a><ol class="toc"><li><a href="#variables"><span class="secno">9.1 </span><span class="content">Variables</span></a></li><li><a href="#parameters"><span class="secno">9.2 </span><span class="content">Parameters</span></a><ol class="toc"><li><a href="#parameter-type"><span class="secno">9.2.1 </span><span class="content">The Required Type of a Parameter</span></a></li><li><a href="#default-values-of-parameters"><span class="secno">9.2.2 </span><span class="content">Default Values of Parameters</span></a></li></ol></li><li><a href="#variable-values"><span class="secno">9.3 </span><span class="content">Values of Variables and Parameters</span></a></li><li><a href="#temporary-trees"><span class="secno">9.4 </span><span class="content">Creating Implicit Document Nodes</span></a></li><li><a href="#global-variables"><span class="secno">9.5 </span><span class="content">Global Variables and Parameters</span></a></li><li><a href="#static-params"><span class="secno">9.6 </span><span class="content">Static Variables and Parameters</span></a></li><li><a href="#static-expression"><span class="secno">9.7 </span><span class="content">Static Expressions</span></a></li><li><a href="#local-variables"><span class="secno">9.8 </span><span class="content">Local Variables and Parameters</span></a></li><li><a href="#scope-of-variables"><span class="secno">9.9 </span><span class="content">Scope of Variables</span></a></li><li><a href="#with-param"><span class="secno">9.10 </span><span class="content">Setting Parameter Values</span></a></li><li><a href="#circularity"><span class="secno">9.11 </span><span class="content">Circular Definitions</span></a></li></ol></li><li><a href="#callable-components"><span class="secno">10 </span><span class="content">Callable Components</span></a><ol class="toc"><li><a href="#named-templates"><span class="secno">10.1 </span><span class="content">Named Templates</span></a><ol class="toc"><li><a href="#declaring-named-templates"><span class="secno">10.1.1 </span><span class="content">Declaring Named Templates</span></a></li><li><a href="#invoking-named-templates"><span class="secno">10.1.2 </span><span class="content">Invoking Named Templates</span></a></li><li><a href="#invoking-templates-with-extension-instructions"><span class="secno">10.1.3 </span><span class="content">Invoking Named Templates using Extension Instructions</span></a></li><li><a href="#declaring-context-item"><span class="secno">10.1.4 </span><span class="content">Declaring the Context Item for a Template</span></a></li><li><a href="#call-template-params"><span class="secno">10.1.5 </span><span class="content">Passing Parameters to Named Templates</span></a></li><li><a href="#tunnel-params"><span class="secno">10.1.6 </span><span class="content">Tunnel Parameters</span></a></li></ol></li><li><a href="#attribute-sets"><span class="secno">10.2 </span><span class="content">Named Attribute Sets</span></a><ol class="toc"><li><a href="#using-attribute-sets"><span class="secno">10.2.1 </span><span class="content">Using Attribute Sets</span></a></li><li><a href="#visibility-of-attribute-sets"><span class="secno">10.2.2 </span><span class="content">Visibility of Attribute Sets</span></a></li><li><a href="#streamability-of-attribute-sets"><span class="secno">10.2.3 </span><span class="content">Streamability of Attribute Sets</span></a></li><li><a href="#evaluating-attribute-sets"><span class="secno">10.2.4 </span><span class="content">Evaluating Attribute Sets</span></a></li><li><a href="#attribute-sets-examples"><span class="secno">10.2.5 </span><span class="content">Attribute Sets: Examples</span></a></li></ol></li><li><a href="#stylesheet-functions"><span class="secno">10.3 </span><span class="content">Stylesheet Functions</span></a><ol class="toc"><li><a href="#xsl-function-name"><span class="secno">10.3.1 </span><span class="content">Function Name and Arity</span></a></li><li><a href="#function-arguments"><span class="secno">10.3.2 </span><span class="content">Arguments</span></a></li><li><a href="#function-result"><span class="secno">10.3.3 </span><span class="content">Function Result</span></a></li><li><a href="#function-visibility-and-overriding"><span class="secno">10.3.4 </span><span class="content">Visibility and Overriding of Functions</span></a><a href="#function-overriding-within-package"><span class="secno">10.3.4.1 </span><span class="content">Overriding Functions within a Package</span></a><a href="#overriding-extension-functions"><span class="secno">10.3.4.2 </span><span class="content">Overriding Extension Functions</span></a><a href="#overriding-functions-in-used-packages"><span class="secno">10.3.4.3 </span><span class="content">Overriding Functions in a Used Package</span></a></li><li><a href="#streamability-of-stylesheet-functions"><span class="secno">10.3.5 </span><span class="content">Streamability of Stylesheet Functions</span></a></li><li><a href="#function-lookup"><span class="secno">10.3.6 </span><span class="content">Dynamic Access to Functions</span></a></li><li><a href="#function-determinism"><span class="secno">10.3.7 </span><span class="content">Determinism of Functions</span></a></li><li><a href="#memoization"><span class="secno">10.3.8 </span><span class="content">Memoization</span></a></li><li><a href="#function-examples"><span class="secno">10.3.9 </span><span class="content">Examples of Stylesheet Functions</span></a></li></ol></li><li><a href="#dynamic-xpath"><span class="secno">10.4 </span><span class="content">Dynamic XPath Evaluation</span></a><ol class="toc"><li><a href="#evaluate-static-context"><span class="secno">10.4.1 </span><span class="content">Static context for the target expression</span></a></li><li><a href="#evaluate-dynamic-context"><span class="secno">10.4.2 </span><span class="content">Dynamic context for the target expression</span></a></li><li><a href="#evaluate-effect"><span class="secno">10.4.3 </span><span class="content">The effect of the xsl:evaluate instruction</span></a></li><li><a href="#evaluation-as-optional-feature"><span class="secno">10.4.4 </span><span class="content">xsl:evaluate as an optional feature</span></a></li><li><a href="#evaluate-examples"><span class="secno">10.4.5 </span><span class="content">Examples of xsl:evaluate</span></a></li></ol></li></ol></li><li><a href="#creating-new-nodes"><span class="secno">11 </span><span class="content">Creating Nodes and Sequences</span></a><ol class="toc"><li><a href="#literal-result-element"><span class="secno">11.1 </span><span class="content">Literal Result Elements</span></a><ol class="toc"><li><a href="#setting-annotation-for-lre"><span class="secno">11.1.1 </span><span class="content">Setting the Type Annotation for Literal Result Elements</span></a></li><li><a href="#attributes-for-lres"><span class="secno">11.1.2 </span><span class="content">Attribute Nodes for Literal Result Elements</span></a></li><li><a href="#lre-namespaces"><span class="secno">11.1.3 </span><span class="content">Namespace Nodes for Literal Result Elements</span></a></li><li><a href="#namespace-aliasing"><span class="secno">11.1.4 </span><span class="content">Namespace Aliasing</span></a></li></ol></li><li><a href="#xsl-element"><span class="secno">11.2 </span><span class="content">Creating Element Nodes Using xsl:element </span></a><ol class="toc"><li><a href="#xsl-element-content"><span class="secno">11.2.1 </span><span class="content">The Content of the Constructed Element Node</span></a></li><li><a href="#xsl-element-name"><span class="secno">11.2.2 </span><span class="content">The Name of the Constructed Element Node</span></a></li><li><a href="#xsl-element-properties"><span class="secno">11.2.3 </span><span class="content">Other Properties of the Constructed Element Node</span></a></li><li><a href="#annotation-for-constructed-element"><span class="secno">11.2.4 </span><span class="content">The Type Annotation of the Constructed Element Node</span></a></li></ol></li><li><a href="#creating-attributes"><span class="secno">11.3 </span><span class="content">Creating Attribute Nodes Using xsl:attribute </span></a><ol class="toc"><li><a href="#annotation-for-constructed-attribute"><span class="secno">11.3.1 </span><span class="content">Setting the Type Annotation for a Constructed Attribute Node</span></a></li></ol></li><li><a href="#creating-text-nodes"><span class="secno">11.4 </span><span class="content">Creating Text Nodes</span></a><ol class="toc"><li><a href="#literal-text-nodes"><span class="secno">11.4.1 </span><span class="content">Literal Text Nodes</span></a></li><li><a href="#xsl-text"><span class="secno">11.4.2 </span><span class="content">Creating Text Nodes Using xsl:text </span></a></li><li><a href="#value-of"><span class="secno">11.4.3 </span><span class="content">Generating Text with xsl:value-of </span></a></li></ol></li><li><a href="#creating-document-nodes"><span class="secno">11.5 </span><span class="content">Creating Document Nodes</span></a></li><li><a href="#creating-processing-instructions"><span class="secno">11.6 </span><span class="content">Creating Processing Instructions</span></a></li><li><a href="#creating-namespace-nodes"><span class="secno">11.7 </span><span class="content">Creating Namespace Nodes</span></a></li><li><a href="#creating-comments"><span class="secno">11.8 </span><span class="content">Creating Comments</span></a></li><li><a href="#copying"><span class="secno">11.9 </span><span class="content">Copying Nodes</span></a><ol class="toc"><li><a href="#shallow-copy"><span class="secno">11.9.1 </span><span class="content">Shallow Copy</span></a></li><li><a href="#copy-of"><span class="secno">11.9.2 </span><span class="content">Deep Copy</span></a></li></ol></li><li><a href="#constructing-sequences"><span class="secno">11.10 </span><span class="content">Constructing Sequences</span></a></li></ol></li><li><a href="#number"><span class="secno">12 </span><span class="content">Numbering</span></a><ol class="toc"><li><a href="#start-at"><span class="secno">12.1 </span><span class="content">The start-at Attribute</span></a></li><li><a href="#formatting-supplied-number"><span class="secno">12.2 </span><span class="content">Formatting a Supplied Number</span></a></li><li><a href="#numbering-based-on-position"><span class="secno">12.3 </span><span class="content">Numbering based on Position in a Document </span></a></li><li><a href="#convert"><span class="secno">12.4 </span><span class="content">Number to String Conversion Attributes</span></a></li></ol></li><li><a href="#sorting"><span class="secno">13 </span><span class="content">Sorting</span></a><ol class="toc"><li><a href="#xsl-sort"><span class="secno">13.1 </span><span class="content">The xsl:sort Element</span></a><ol class="toc"><li><a href="#sorting-process"><span class="secno">13.1.1 </span><span class="content">The Sorting Process</span></a></li><li><a href="#comparing-sort-keys"><span class="secno">13.1.2 </span><span class="content">Comparing Sort Key Values</span></a></li><li><a href="#collating-sequences"><span class="secno">13.1.3 </span><span class="content">Sorting Using Collations</span></a></li></ol></li><li><a href="#creating-sorted-sequence"><span class="secno">13.2 </span><span class="content">Creating a Sorted Sequence</span></a></li><li><a href="#sorted-iteration"><span class="secno">13.3 </span><span class="content">Processing a Sequence in Sorted Order</span></a></li></ol></li><li><a href="#grouping"><span class="secno">14 </span><span class="content">Grouping</span></a><ol class="toc"><li><a href="#xsl-for-each-group"><span class="secno">14.1 </span><span class="content">The xsl:for-each-group Element</span></a></li><li><a href="#information-about-group"><span class="secno">14.2 </span><span class="content">Accessing Information about the Current Group Value</span></a><ol class="toc"><li><a href="#func-current-group"><span class="secno">14.2.1 </span><span class="content">fn:current-group</span></a></li><li><a href="#func-current-grouping-key"><span class="secno">14.2.2 </span><span class="content">fn:current-grouping-key</span></a></li></ol></li><li><a href="#order-of-groups"><span class="secno">14.3 </span><span class="content">Ordering among Groups</span></a></li><li><a href="#grouping-examples"><span class="secno">14.4 </span><span class="content">Examples of Grouping</span></a></li></ol></li><li><a href="#merging"><span class="secno">15 </span><span class="content">Merging</span></a><ol class="toc"><li><a href="#merge-terminology"><span class="secno">15.1 </span><span class="content">Terminology for Merging</span></a></li><li><a href="#merge-instruction"><span class="secno">15.2 </span><span class="content">The xsl:merge Instruction</span></a></li><li><a href="#merge-input-sequences"><span class="secno">15.3 </span><span class="content">Selecting the Sequences to be Merged</span></a></li><li><a href="#streamable-merging"><span class="secno">15.4 </span><span class="content">Streamable Merging</span></a></li><li><a href="#merge-keys"><span class="secno">15.5 </span><span class="content">Defining the Merge Keys</span></a></li><li><a href="#current-merge-group-and-key"><span class="secno">15.6 </span><span class="content">The Current Merge Group and Key</span></a><ol class="toc"><li><a href="#func-current-merge-group"><span class="secno">15.6.1 </span><span class="content">fn:current-merge-group</span></a></li><li><a href="#func-current-merge-key"><span class="secno">15.6.2 </span><span class="content">fn:current-merge-key</span></a></li></ol></li><li><a href="#merge-action"><span class="secno">15.7 </span><span class="content">The xsl:merge-action Element</span></a></li><li><a href="#merge-examples"><span class="secno">15.8 </span><span class="content">Examples of xsl:merge</span></a></li></ol></li><li><a href="#splitting"><span class="secno">16 </span><span class="content">Splitting</span></a><ol class="toc"><li><a href="#fork-instruction"><span class="secno">16.1 </span><span class="content">The xsl:fork Instruction</span></a></li><li><a href="#splitting-examples"><span class="secno">16.2 </span><span class="content">Examples of Splitting with Streamed Data</span></a></li></ol></li><li><a href="#regular-expressions"><span class="secno">17 </span><span class="content">Regular Expressions</span></a><ol class="toc"><li><a href="#analyze-string"><span class="secno">17.1 </span><span class="content">The xsl:analyze-string Instruction</span></a></li><li><a href="#func-regex-group"><span class="secno">17.2 </span><span class="content">fn:regex-group</span></a></li><li><a href="#regex-examples"><span class="secno">17.3 </span><span class="content">Examples of Regular Expression Matching</span></a></li></ol></li><li><a href="#streaming"><span class="secno">18 </span><span class="content">Streaming</span></a><ol class="toc"><li><a href="#source-document-instruction"><span class="secno">18.1 </span><span class="content">The xsl:source-document Instruction</span></a><ol class="toc"><li><a href="#source-document-validation"><span class="secno">18.1.1 </span><span class="content">Validation of Source Documents</span></a></li><li><a href="#stream-examples"><span class="secno">18.1.2 </span><span class="content">Examples of xsl:source-document</span></a></li><li><a href="#func-stream-available"><span class="secno">18.1.3 </span><span class="content">fn:stream-available</span></a></li></ol></li><li><a href="#accumulators"><span class="secno">18.2 </span><span class="content">Accumulators</span></a><ol class="toc"><li><a href="#accumulator-declaration"><span class="secno">18.2.1 </span><span class="content">Declaring an Accumulator</span></a></li><li><a href="#applicability-of-accumulators"><span class="secno">18.2.2 </span><span class="content">Applicability of Accumulators</span></a></li><li><a href="#accumulator-informal-rules"><span class="secno">18.2.3 </span><span class="content">Informal Model for Accumulators</span></a></li><li><a href="#accumulator-formal-rules"><span class="secno">18.2.4 </span><span class="content">Formal Model for Accumulators</span></a></li><li><a href="#errors-in-accumulators"><span class="secno">18.2.5 </span><span class="content">Dynamic Errors in Accumulators</span></a></li><li><a href="#func-accumulator-before"><span class="secno">18.2.6 </span><span class="content">fn:accumulator-before</span></a></li><li><a href="#func-accumulator-after"><span class="secno">18.2.7 </span><span class="content">fn:accumulator-after</span></a></li><li><a href="#accumulators-visibility-and-overriding"><span class="secno">18.2.8 </span><span class="content">Importing of Accumulators</span></a></li><li><a href="#streamability-of-accumulators"><span class="secno">18.2.9 </span><span class="content">Streamability of Accumulators</span></a></li><li><a href="#copying-accumulators"><span class="secno">18.2.10 </span><span class="content">Copying Accumulator Values</span></a></li><li><a href="#accumulator-examples"><span class="secno">18.2.11 </span><span class="content">Examples of Accumulators</span></a></li></ol></li><li><a href="#func-copy-of"><span class="secno">18.3 </span><span class="content">fn:copy-of</span></a></li><li><a href="#func-snapshot"><span class="secno">18.4 </span><span class="content">fn:snapshot</span></a></li></ol></li><li><a href="#streamability"><span class="secno">19 </span><span class="content">Streamability</span></a><ol class="toc"><li><a href="#determining-static-type"><span class="secno">19.1 </span><span class="content">Determining the Static Type of a Construct</span></a><ol class="toc"><li><a href="#static-type-of-steps"><span class="secno">19.1.1 </span><span class="content">Static Type of an Axis Step</span></a></li><li><a href="#static-type-of-current-function"><span class="secno">19.1.2 </span><span class="content">Static Type of a Call to current</span></a></li><li><a href="#notes-on-schema-aware-analysis"><span class="secno">19.1.3 </span><span class="content">Schema-Aware Streamability Analysis</span></a></li></ol></li><li><a href="#determining-context-item-type"><span class="secno">19.2 </span><span class="content">Determining the Context Item Type</span></a></li><li><a href="#operand-roles"><span class="secno">19.3 </span><span class="content">Operand Roles</span></a><ol class="toc"><li><a href="#operand-usage-examples"><span class="secno">19.3.1 </span><span class="content">Examples showing the Effect of Operand Usage</span></a></li></ol></li><li><a href="#posture"><span class="secno">19.4 </span><span class="content">Determining the Posture of a Construct</span></a></li><li><a href="#determining-context-posture"><span class="secno">19.5 </span><span class="content">Determining the Context Posture</span></a></li><li><a href="#sweep"><span class="secno">19.6 </span><span class="content">The Sweep of a Construct</span></a></li><li><a href="#grounded-consuming-constructs"><span class="secno">19.7 </span><span class="content">Grounded Consuming Constructs</span></a></li><li><a href="#classifying-constructs"><span class="secno">19.8 </span><span class="content">Classifying Constructs</span></a><ol class="toc"><li><a href="#general-streamability-rules"><span class="secno">19.8.1 </span><span class="content">General Rules for Streamability</span></a></li><li><a href="#general-streamability-examples"><span class="secno">19.8.2 </span><span class="content">Examples of the General Streamability Rules</span></a></li><li><a href="#classifying-sequence-constructors"><span class="secno">19.8.3 </span><span class="content">Classifying Sequence Constructors</span></a></li><li><a href="#classifying-instructions"><span class="secno">19.8.4 </span><span class="content">Classifying Instructions</span></a><a href="#streamability-literal-result-elements"><span class="secno">19.8.4.1 </span><span class="content">Streamability of Literal Result Elements</span></a><a href="#streamability-extension-instructions"><span class="secno">19.8.4.2 </span><span class="content">Streamability of extension instructions</span></a><a href="#streamability-xsl-analyze-string"><span class="secno">19.8.4.3 </span><span class="content">Streamability of xsl:analyze-string</span></a><a href="#streamability-xsl-apply-imports"><span class="secno">19.8.4.4 </span><span class="content">Streamability of xsl:apply-imports</span></a><a href="#streamability-xsl-apply-templates"><span class="secno">19.8.4.5 </span><span class="content">Streamability of xsl:apply-templates</span></a><a href="#streamability-xsl-assert"><span class="secno">19.8.4.6 </span><span class="content">Streamability of xsl:assert</span></a><a href="#streamability-xsl-attribute"><span class="secno">19.8.4.7 </span><span class="content">Streamability of xsl:attribute</span></a><a href="#streamability-xsl-break"><span class="secno">19.8.4.8 </span><span class="content">Streamability of xsl:break</span></a><a href="#streamability-xsl-call-template"><span class="secno">19.8.4.9 </span><span class="content">Streamability of xsl:call-template</span></a><a href="#streamability-xsl-choose"><span class="secno">19.8.4.10 </span><span class="content">Streamability of xsl:choose</span></a><a href="#streamability-xsl-comment"><span class="secno">19.8.4.11 </span><span class="content">Streamability of xsl:comment</span></a><a href="#streamability-xsl-copy"><span class="secno">19.8.4.12 </span><span class="content">Streamability of xsl:copy</span></a><a href="#streamability-xsl-copy-of"><span class="secno">19.8.4.13 </span><span class="content">Streamability of xsl:copy-of</span></a><a href="#streamability-xsl-document"><span class="secno">19.8.4.14 </span><span class="content">Streamability of xsl:document</span></a><a href="#streamability-xsl-element"><span class="secno">19.8.4.15 </span><span class="content">Streamability of xsl:element</span></a><a href="#streamability-xsl-evaluate"><span class="secno">19.8.4.16 </span><span class="content">Streamability of xsl:evaluate</span></a><a href="#streamability-xsl-fallback"><span class="secno">19.8.4.17 </span><span class="content">Streamability of xsl:fallback</span></a><a href="#streamability-xsl-for-each"><span class="secno">19.8.4.18 </span><span class="content">Streamability of xsl:for-each</span></a><a href="#streamability-xsl-for-each-group"><span class="secno">19.8.4.19 </span><span class="content">Streamability of xsl:for-each-group</span></a><a href="#streamability-xsl-fork"><span class="secno">19.8.4.20 </span><span class="content">Streamability of xsl:fork</span></a><a href="#streamability-xsl-if"><span class="secno">19.8.4.21 </span><span class="content">Streamability of xsl:if</span></a><a href="#streamability-xsl-iterate"><span class="secno">19.8.4.22 </span><span class="content">Streamability of xsl:iterate</span></a><a href="#streamability-xsl-map"><span class="secno">19.8.4.23 </span><span class="content">Streamability of xsl:map</span></a><a href="#streamability-xsl-map-entry"><span class="secno">19.8.4.24 </span><span class="content">Streamability of xsl:map-entry</span></a><a href="#streamability-xsl-merge"><span class="secno">19.8.4.25 </span><span class="content">Streamability of xsl:merge</span></a><a href="#streamability-xsl-message"><span class="secno">19.8.4.26 </span><span class="content">Streamability of xsl:message</span></a><a href="#streamability-xsl-namespace"><span class="secno">19.8.4.27 </span><span class="content">Streamability of xsl:namespace</span></a><a href="#streamability-xsl-next-iteration"><span class="secno">19.8.4.28 </span><span class="content">Streamability of xsl:next-iteration</span></a><a href="#streamability-xsl-next-match"><span class="secno">19.8.4.29 </span><span class="content">Streamability of xsl:next-match</span></a><a href="#streamability-xsl-number"><span class="secno">19.8.4.30 </span><span class="content">Streamability of xsl:number</span></a><a href="#streamability-xsl-on-empty"><span class="secno">19.8.4.31 </span><span class="content">Streamability of xsl:on-empty</span></a><a href="#streamability-xsl-on-non-empty"><span class="secno">19.8.4.32 </span><span class="content">Streamability of xsl:on-non-empty</span></a><a href="#streamability-xsl-perform-sort"><span class="secno">19.8.4.33 </span><span class="content">Streamability of xsl:perform-sort</span></a><a href="#streamability-xsl-processing-instruction"><span class="secno">19.8.4.34 </span><span class="content">Streamability of xsl:processing-instruction</span></a><a href="#streamability-xsl-result-document"><span class="secno">19.8.4.35 </span><span class="content">Streamability of xsl:result-document</span></a><a href="#streamability-xsl-sequence"><span class="secno">19.8.4.36 </span><span class="content">Streamability of xsl:sequence</span></a><a href="#streamability-xsl-stream"><span class="secno">19.8.4.37 </span><span class="content">Streamability of xsl:source-document</span></a><a href="#streamability-xsl-switch"><span class="secno">19.8.4.38 </span><span class="content">Streamability of xsl:switch</span></a><a href="#streamability-xsl-text"><span class="secno">19.8.4.39 </span><span class="content">Streamability of xsl:text</span></a><a href="#streamability-xsl-try"><span class="secno">19.8.4.40 </span><span class="content">Streamability of xsl:try</span></a><a href="#streamability-xsl-value-of"><span class="secno">19.8.4.41 </span><span class="content">Streamability of xsl:value-of</span></a><a href="#streamability-xsl-variable"><span class="secno">19.8.4.42 </span><span class="content">Streamability of xsl:variable</span></a><a href="#streamability-xsl-where-populated"><span class="secno">19.8.4.43 </span><span class="content">Streamability of xsl:where-populated</span></a></li><li><a href="#streamable-stylesheet-functions"><span class="secno">19.8.5 </span><span class="content">Classifying Stylesheet Functions</span></a><a href="#category-unclassified"><span class="secno">19.8.5.1 </span><span class="content">Streamability Category: unclassified</span></a><a href="#category-absorbing"><span class="secno">19.8.5.2 </span><span class="content">Streamability Category: absorbing</span></a><a href="#category-inspection"><span class="secno">19.8.5.3 </span><span class="content">Streamability Category: inspection</span></a><a href="#category-filter"><span class="secno">19.8.5.4 </span><span class="content">Streamability Category: filter</span></a><a href="#category-shallow-descent"><span class="secno">19.8.5.5 </span><span class="content">Streamability Category: shallow-descent</span></a><a href="#category-deep-descent"><span class="secno">19.8.5.6 </span><span class="content">Streamability Category: deep-descent</span></a><a href="#category-ascent"><span class="secno">19.8.5.7 </span><span class="content">Streamability Category: ascent</span></a></li><li><a href="#classifying-attribute-sets"><span class="secno">19.8.6 </span><span class="content">Classifying Attribute Sets</span></a></li><li><a href="#classifying-vts"><span class="secno">19.8.7 </span><span class="content">Classifying Value Templates</span></a></li><li><a href="#classifying-expressions"><span class="secno">19.8.8 </span><span class="content">Classifying Expressions</span></a><a href="#streamability-of-for-expressions"><span class="secno">19.8.8.1 </span><span class="content">Streamability of for Expressions</span></a><a href="#streamability-of-quantified-expressions"><span class="secno">19.8.8.2 </span><span class="content">Streamability of Quantified Expressions</span></a><a href="#streamability-of-if-expressions"><span class="secno">19.8.8.3 </span><span class="content">Streamability of if expressions</span></a><a href="#streamability-of-union-expressions"><span class="secno">19.8.8.4 </span><span class="content">Streamability of union, intersect, and except Expressions</span></a><a href="#streamability-of-instance-of-expressions"><span class="secno">19.8.8.5 </span><span class="content">Streamability of instance of Expressions</span></a><a href="#streamability-of-treat-as-expressions"><span class="secno">19.8.8.6 </span><span class="content">Streamability of treat as Expressions</span></a><a href="#streamability-of-simple-mapping-expressions"><span class="secno">19.8.8.7 </span><span class="content">Streamability of Simple Mapping Expressions</span></a><a href="#streamability-of-path-expressions"><span class="secno">19.8.8.8 </span><span class="content">Streamability of Path Expressions</span></a><a href="#streamability-of-axis-steps"><span class="secno">19.8.8.9 </span><span class="content">Streamability of Axis Steps</span></a><a href="#streamability-of-filter-expressions"><span class="secno">19.8.8.10 </span><span class="content">Streamability of Filter Expressions</span></a><a href="#streamability-of-dynamic-function-calls"><span class="secno">19.8.8.11 </span><span class="content">Streamability of Dynamic Function Calls</span></a><a href="#streamability-of-variable-references"><span class="secno">19.8.8.12 </span><span class="content">Streamability of Variable References</span></a><a href="#streamability-of-context-item-expression"><span class="secno">19.8.8.13 </span><span class="content">Streamability of the Context Item Expression</span></a><a href="#streamability-of-function-calls"><span class="secno">19.8.8.14 </span><span class="content">Streamability of Static Function Calls</span></a><a href="#streamability-of-named-function-ref"><span class="secno">19.8.8.15 </span><span class="content">Streamability of Named Function References</span></a><a href="#streamability-of-inline-functions"><span class="secno">19.8.8.16 </span><span class="content">Streamability of Inline Function Declarations</span></a><a href="#streamability-of-map-constructors"><span class="secno">19.8.8.17 </span><span class="content">Streamability of Map Constructors</span></a><a href="#streamability-of-lookup-expressions"><span class="secno">19.8.8.18 </span><span class="content">Streamability of Lookup Expressions</span></a></li><li><a href="#classifying-built-in-functions"><span class="secno">19.8.9 </span><span class="content">Classifying Calls to Built-In Functions</span></a><a href="#streamability-fn-accumulator-after"><span class="secno">19.8.9.1 </span><span class="content">Streamability of the accumulator-after Function</span></a><a href="#streamability-fn-accumulator-before"><span class="secno">19.8.9.2 </span><span class="content">Streamability of the accumulator-before Function</span></a><a href="#streamability-fn-current"><span class="secno">19.8.9.3 </span><span class="content">Streamability of the current Function</span></a><a href="#streamability-fn-current-group"><span class="secno">19.8.9.4 </span><span class="content">Streamability of the current-group Function</span></a><a href="#streamability-fn-current-grouping-key"><span class="secno">19.8.9.5 </span><span class="content">Streamability of the current-grouping-key Function</span></a><a href="#streamability-fn-current-merge-group"><span class="secno">19.8.9.6 </span><span class="content">Streamability of the current-merge-group Function</span></a><a href="#streamability-fn-current-merge-key"><span class="secno">19.8.9.7 </span><span class="content">Streamability of the current-merge-key Function</span></a><a href="#streamability-fn-fold-left"><span class="secno">19.8.9.8 </span><span class="content">Streamability of the fold-left Function</span></a><a href="#streamability-fn-fold-right"><span class="secno">19.8.9.9 </span><span class="content">Streamability of the fold-right Function</span></a><a href="#streamability-fn-for-each"><span class="secno">19.8.9.10 </span><span class="content">Streamability of the for-each Function</span></a><a href="#streamability-fn-for-each-pair"><span class="secno">19.8.9.11 </span><span class="content">Streamability of the for-each-pair Function</span></a><a href="#streamability-fn-function-lookup"><span class="secno">19.8.9.12 </span><span class="content">Streamability of the function-lookup Function</span></a><a href="#streamability-fn-innermost"><span class="secno">19.8.9.13 </span><span class="content">Streamability of the innermost Function</span></a><a href="#streamability-fn-last"><span class="secno">19.8.9.14 </span><span class="content">Streamability of the last Function</span></a><a href="#streamability-fn-outermost"><span class="secno">19.8.9.15 </span><span class="content">Streamability of the outermost Function</span></a><a href="#streamability-fn-position"><span class="secno">19.8.9.16 </span><span class="content">Streamability of the position Function</span></a><a href="#streamability-fn-reverse"><span class="secno">19.8.9.17 </span><span class="content">Streamability of the reverse Function</span></a><a href="#streamability-fn-root"><span class="secno">19.8.9.18 </span><span class="content">Streamability of the root Function</span></a></li><li><a href="#classifying-patterns"><span class="secno">19.8.10 </span><span class="content">Classifying Patterns</span></a></li></ol></li><li><a href="#streamability-analysis-examples"><span class="secno">19.9 </span><span class="content">Examples of Streamability Analysis</span></a></li><li><a href="#streamability-guarantees"><span class="secno">19.10 </span><span class="content">Streamability Guarantees</span></a></li></ol></li><li><a href="#add-func"><span class="secno">20 </span><span class="content">Additional Functions</span></a><ol class="toc"><li><a href="#func-document"><span class="secno">20.1 </span><span class="content">fn:document</span></a></li><li><a href="#key"><span class="secno">20.2 </span><span class="content">Keys</span></a><ol class="toc"><li><a href="#xsl-key"><span class="secno">20.2.1 </span><span class="content">The xsl:key Declaration</span></a></li><li><a href="#func-key"><span class="secno">20.2.2 </span><span class="content">fn:key</span></a></li></ol></li><li><a href="#keys-and-streaming"><span class="secno">20.3 </span><span class="content">Keys and Streaming</span></a></li><li><a href="#misc-func"><span class="secno">20.4 </span><span class="content">Miscellaneous Additional Functions</span></a><ol class="toc"><li><a href="#func-current"><span class="secno">20.4.1 </span><span class="content">fn:current</span></a></li><li><a href="#func-unparsed-entity-uri"><span class="secno">20.4.2 </span><span class="content">fn:unparsed-entity-uri</span></a></li><li><a href="#func-unparsed-entity-public-id"><span class="secno">20.4.3 </span><span class="content">fn:unparsed-entity-public-id</span></a></li><li><a href="#func-system-property"><span class="secno">20.4.4 </span><span class="content">fn:system-property</span></a></li><li><a href="#func-available-system-properties"><span class="secno">20.4.5 </span><span class="content">fn:available-system-properties</span></a></li></ol></li></ol></li><li><a href="#map"><span class="secno">21 </span><span class="content">Maps</span></a><ol class="toc"><li><a href="#map-instructions"><span class="secno">21.2 </span><span class="content">Map Instructions</span></a><ol class="toc"><li><a href="#duplicate-keys"><span class="secno">21.2.1 </span><span class="content">Handling of duplicate keys</span></a></li></ol></li><li><a href="#maps-streaming"><span class="secno">21.4 </span><span class="content">Maps and Streaming</span></a></li><li><a href="#map-examples"><span class="secno">21.5 </span><span class="content">Examples using Maps</span></a></li></ol></li><li><a href="#arrays"><span class="secno">22 </span><span class="content">Arrays</span></a><ol class="toc"><li><a href="#array-construction"><span class="secno">22.1 </span><span class="content">Array Construction</span></a></li></ol></li><li><a href="#json"><span class="secno">23 </span><span class="content">Processing JSON Data</span></a><ol class="toc"><li><a href="#xml-to-json-transformation"><span class="secno">23.3 </span><span class="content">Transforming XML to JSON</span></a></li></ol></li><li><a href="#diagnostics"><span class="secno">24 </span><span class="content">Diagnostics</span></a><ol class="toc"><li><a href="#message"><span class="secno">24.1 </span><span class="content">Messages</span></a></li><li><a href="#assertions"><span class="secno">24.2 </span><span class="content">Assertions</span></a></li></ol></li><li><a href="#extension"><span class="secno">25 </span><span class="content">Extensibility and Fallback</span></a><ol class="toc"><li><a href="#extension-functions"><span class="secno">25.1 </span><span class="content">Extension Functions</span></a><ol class="toc"><li><a href="#func-function-available"><span class="secno">25.1.1 </span><span class="content">fn:function-available</span></a></li><li><a href="#calling-extension-functions"><span class="secno">25.1.2 </span><span class="content">Calling Extension Functions</span></a></li><li><a href="#external-objects"><span class="secno">25.1.3 </span><span class="content">External Objects</span></a></li><li><a href="#func-type-available"><span class="secno">25.1.4 </span><span class="content">fn:type-available</span></a></li></ol></li><li><a href="#extension-instruction"><span class="secno">25.2 </span><span class="content">Extension Instructions</span></a><ol class="toc"><li><a href="#designating-extension-namespace"><span class="secno">25.2.1 </span><span class="content">Designating an Extension Namespace</span></a></li><li><a href="#func-element-available"><span class="secno">25.2.2 </span><span class="content">fn:element-available</span></a></li><li><a href="#fallback"><span class="secno">25.2.3 </span><span class="content">Fallback</span></a></li></ol></li></ol></li><li><a href="#result-trees"><span class="secno">26 </span><span class="content">Transformation Results</span></a><ol class="toc"><li><a href="#creating-result-trees"><span class="secno">26.1 </span><span class="content">Creating Secondary Results</span></a></li><li><a href="#result-document-restrictions"><span class="secno">26.2 </span><span class="content">Restrictions on the use of xsl:result-document</span></a></li><li><a href="#current-output-uri"><span class="secno">26.3 </span><span class="content">The Current Output URI</span></a><ol class="toc"><li><a href="#func-current-output-uri"><span class="secno">26.3.1 </span><span class="content">fn:current-output-uri</span></a></li></ol></li><li><a href="#validation"><span class="secno">26.4 </span><span class="content">Validation</span></a><ol class="toc"><li><a href="#validating-constructed-nodes"><span class="secno">26.4.1 </span><span class="content">Validating Constructed Elements and Attributes</span></a><a href="#validating-using-validation-attribute"><span class="secno">26.4.1.1 </span><span class="content">Validation using the [xsl:]validation Attribute</span></a><a href="#validation-xsl-type"><span class="secno">26.4.1.2 </span><span class="content">Validation using the [xsl:]type Attribute</span></a><a href="#validation-process"><span class="secno">26.4.1.3 </span><span class="content">The Validation Process</span></a></li><li><a href="#validating-document-nodes"><span class="secno">26.4.2 </span><span class="content">Validating Document Nodes</span></a></li><li><a href="#validating-xml-id"><span class="secno">26.4.3 </span><span class="content">Validating xml:id attributes</span></a></li></ol></li></ol></li><li><a href="#serialization"><span class="secno">27 </span><span class="content">Serialization</span></a><ol class="toc"><li><a href="#character-maps"><span class="secno">27.1 </span><span class="content">Character Maps</span></a></li><li><a href="#disable-output-escaping"><span class="secno">27.2 </span><span class="content">Disabling Output Escaping</span></a></li></ol></li><li><a href="#conformance"><span class="secno">28 </span><span class="content">Conformance</span></a><ol class="toc"><li><a href="#basic-conformance"><span class="secno">28.1 </span><span class="content">Basic XSLT Processor</span></a></li><li><a href="#schema-aware-conformance"><span class="secno">28.2 </span><span class="content">Schema-Awareness Conformance Feature</span></a></li><li><a href="#serialization-feature"><span class="secno">28.3 </span><span class="content">Serialization Feature</span></a></li><li><a href="#backwards-compatibility-feature"><span class="secno">28.4 </span><span class="content">Compatibility Features</span></a></li><li><a href="#streaming-feature"><span class="secno">28.5 </span><span class="content">Streaming Feature</span></a></li><li><a href="#dynamic-evaluation-feature"><span class="secno">28.6 </span><span class="content">Dynamic Evaluation Feature</span></a></li></ol></li><li><a href="#references"><span class="secno">A </span><span class="content">References</span></a><ol class="toc"><li><a href="#normative-references"><span class="secno">A.1 </span><span class="content">Normative References</span></a></li><li><a href="#other-references"><span class="secno">A.2 </span><span class="content">Other References</span></a></li></ol></li><li><a href="#json-in-xml"><span class="secno">B </span><span class="content">XML Representation of JSON</span></a><ol class="toc"><li><a href="#schema-for-json"><span class="secno">B.1 </span><span class="content">Schema for the XML Representation of JSON</span></a></li><li><a href="#xml-to-json-stylesheet"><span class="secno">B.2 </span><span class="content">Stylesheet for converting XML to JSON</span></a></li></ol></li><li><a href="#glossary"><span class="secno">C </span><span class="content">Glossary</span></a> (Non-Normative) <ol class="toc"></ol></li><li><a href="#element-syntax-summary"><span class="secno">D </span><span class="content">Element Syntax Summary</span></a> (Non-Normative) <ol class="toc"></ol></li><li><a href="#error-summary"><span class="secno">E </span><span class="content">Summary of Error Conditions</span></a> (Non-Normative) <ol class="toc"></ol></li><li><a href="#implementation-defined-features"><span class="secno">F </span><span class="content">Checklist of Implementation-Defined Features</span></a> (Non-Normative) <ol class="toc"><li><a href="#imp-def-api"><span class="secno">F.1 </span><span class="content">Application Programming Interfaces</span></a></li><li><a href="#imp-def-ext"><span class="secno">F.2 </span><span class="content">Vendor and User Extensions</span></a></li><li><a href="#imp-def-feature"><span class="secno">F.3 </span><span class="content">Localization</span></a></li><li><a href="#imp-def-optional-feature"><span class="secno">F.4 </span><span class="content">Optional Features</span></a></li><li><a href="#imp-def-dependencies"><span class="secno">F.5 </span><span class="content">Dependencies</span></a></li><li><a href="#imp-def-defaults-and-limits"><span class="secno">F.6 </span><span class="content">Defaults and Limits</span></a></li><li><a href="#imp-def-errors"><span class="secno">F.7 </span><span class="content">Detection and Reporting of Errors</span></a></li></ol></li><li><a href="#summary-list-of-functions"><span class="secno">G </span><span class="content">Summary of Available Functions</span></a> (Non-Normative) <ol class="toc"><li><a href="#function-categories"><span class="secno">G.1 </span><span class="content">Function Classification</span></a></li><li><a href="#XSLT-defined-functions"><span class="secno">G.2 </span><span class="content">List of XSLT-defined functions</span></a></li></ol></li><li><a href="#schema-for-xslt"><span class="secno">H </span><span class="content">Schemas for XSLT 4.0 Stylesheets</span></a> (Non-Normative) <ol class="toc"><li><a href="#xsd11-schema-for-xslt"><span class="secno">H.1 </span><span class="content">XSD 1.1 Schema for XSLT Stylesheets</span></a></li><li><a href="#relax-ng-schema-for-xslt"><span class="secno">H.2 </span><span class="content">Relax-NG Schema for XSLT Stylesheets</span></a></li></ol></li><li class="delete_version" style="display: none;"><a href="#acknowledgements"><span class="secno">I </span><span class="content">Acknowledgements</span></a> (Non-Normative) <ol class="toc"></ol></li><li class="modify_version"><a href="#acknowledgements"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">I </span></span><span class="content"><span class="deltaxml-old" style="background:#FF5555">Acknowledgements</span></span></a><span class="deltaxml-old" style="background:#FF5555"> (Non-Normative) </span><ol class="toc"></ol></li><li><a href="#changes-since-3.0"><span style="display: none;" class="delete_version"><span class="secno">J </span><span class="content">Changes since XSLT 3.0</span></span><span style="display: none;" class="add_version"><span class="secno">I </span><span class="content">Changes since XSLT 3.0</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span> </span><span class="content">Changes since XSLT 3.0</span></span></a> (Non-Normative) <ol class="toc"><li><a href="#xslt-changes-since-3.0"><span style="display: none;" class="delete_version"><span class="secno">J.1 </span><span class="content">Changes in successive Drafts</span></span><span style="display: none;" class="add_version"><span class="secno">I.1 </span><span class="content">Changes in successive Drafts</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.1 </span><span class="content">Changes in successive Drafts</span></span></a><ol class="toc"><li><a href="#changes-in-draft-A"><span style="display: none;" class="delete_version"><span class="secno">J.1.1 </span><span class="content">Changes in this Specification: draft A (12 April 2021)</span></span><span style="display: none;" class="add_version"><span class="secno">I.1.1 </span><span class="content">Changes in this Specification: draft A (12 April 2021)</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.1.1 </span><span class="content">Changes in this Specification: draft A (12 April 2021)</span></span></a></li><li><a href="#changes-in-draft-B"><span style="display: none;" class="delete_version"><span class="secno">J.1.2 </span><span class="content">Changes in this Specification: draft B (date TBA)</span></span><span style="display: none;" class="add_version"><span class="secno">I.1.2 </span><span class="content">Changes in this Specification: draft B (date TBA)</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.1.2 </span><span class="content">Changes in this Specification: draft B (date TBA)</span></span></a></li></ol></li><li><a href="#xpath-changes-since-3.1"><span style="display: none;" class="delete_version"><span class="secno">J.2 </span><span class="content">Changes in Other Related Specifications</span></span><span style="display: none;" class="add_version"><span class="secno">I.2 </span><span class="content">Changes in Other Related Specifications</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.2 </span><span class="content">Changes in Other Related Specifications</span></span></a></li></ol></li><li><a href="#todo-list"><span style="display: none;" class="delete_version"><span class="secno">K </span><span class="content">Changes Pending</span></span><span style="display: none;" class="add_version"><span class="secno">J </span><span class="content">Changes Pending</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">K</span><span class="deltaxml-new" style="background:#90EE90">J</span> </span><span class="content">Changes Pending</span></span></a> (Non-Normative) <ol class="toc"></ol></li><li><a href="#incompatibilities"><span style="display: none;" class="delete_version"><span class="secno">L </span><span class="content">Incompatibilities with XSLT 3.0</span></span><span style="display: none;" class="add_version"><span class="secno">K </span><span class="content">Incompatibilities with XSLT 3.0</span></span><span class="modify_version"><span class="secno"><span class="deltaxml-old" style="background:#FF5555">L</span><span class="deltaxml-new" style="background:#90EE90">K</span> </span><span class="content">Incompatibilities with XSLT 3.0</span></span></a> (Non-Normative) <ol class="toc"></ol></li></ol></nav><hr><div class="body"><div class="div1"><h2><a id="introduction"></a>1 <a href="#introduction" style="text-decoration: none">Introduction</a></h2><div class="div2"><h3><a id="what-is-xslt"></a>1.1 <a href="#what-is-xslt" style="text-decoration: none">What is XSLT?</a></h3><p>This specification defines the syntax and semantics of the XSLT 4.0 language.</p><p>A transformation in the XSLT language is expressed in the form of a <b>stylesheet</b>. A stylesheet is made up of one or more well-formed XML <a href="#REC-xml">[XML 1.0]</a> documents conforming to the Namespaces in XML Recommendation <a href="#xml-names">[Namespaces in XML]</a>. </p><p>A stylesheet generally includes elements that are defined by XSLT as well as elements that are not defined by XSLT. XSLT-defined elements are distinguished by use of the namespace <code>http://www.w3.org/1999/XSL/Transform</code> (see <a href="#xslt-namespace"><i>3.1 XSLT Namespace</i></a>), which is referred to in this specification as the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. Thus this specification is a definition of the syntax and semantics of the XSLT namespace.</p><p>The term <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> reflects the fact that one of the important roles of XSLT is to add styling information to an XML source document, by transforming it into a document consisting of XSL formatting objects (see <a href="#xsl11">[XSL-FO]</a>), or into another presentation-oriented format such as HTML, XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks, not exclusively for formatting and presentation applications.</p><p>A transformation expressed in XSLT describes rules for transforming input data into output data. The inputs and outputs will all be instances of the XDM data model, described in <a href="#xpath-datamodel-30">[XDM 3.0]</a>. In the simplest and most common case, the input is an XML document referred to as the source tree, and the output is an XML document referred to as the result tree. It is also possible to process multiple source documents, to generate multiple result documents, and to handle formats other than XML. The transformation is achieved by a set of <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>. A template rule associates a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, which typically matches nodes in the source document, with a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. In many cases, evaluating the sequence constructor will cause new nodes to be constructed, which can be used to produce part of a result tree. The structure of the result trees can be completely different from the structure of the source trees. In constructing a result tree, nodes from the source trees can be filtered and reordered, and arbitrary structure can be added. This mechanism allows a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to be applicable to a wide class of documents that have similar source tree structures.</p><p>Stylesheets have a modular structure; they may contain several packages developed independently of each other, and each package may consist of several stylesheet modules. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet" title="stylesheet"></a>A <b>stylesheet</b> consists of one or more packages: specifically, one <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> and zero or more <a title="library package" class="termref" href="#dt-library-package">library packages</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-top-level-package" title="top-level package"></a>For a given transformation, one <a title="package" class="termref" href="#dt-package">package</a> functions as the <b>top-level package</b>. The complete <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is assembled by finding the packages referenced directly or indirectly from the top-level package using <a href="#element-use-package"><code>xsl:use-package</code></a> declarations: see <a href="#package-dependencies"><i>3.5.2 Dependencies between Packages</i></a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-library-package" title="library package"></a>Every <a title="package" class="termref" href="#dt-package">package</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, other than the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, is referred to as a <b>library package</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-principal-stylesheet-module" title="principal stylesheet module"></a>Within a <a title="package" class="termref" href="#dt-package">package</a>, one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> functions as the <b>principal stylesheet module</b>. The complete package is assembled by finding the stylesheet modules referenced directly or indirectly from the principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><i>3.11.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.11.3 Stylesheet Import</i></a>.<span class="definition">]</span></p></div><div class="div2"><h3><a id="whats-new-in-xslt4"></a>1.2 <a href="#whats-new-in-xslt4" style="text-decoration: none">What’s New in XSLT 4.0?</a></h3><p>A full list of changes is at <a href="#changes-since-3.0"><span style="display: none;" class="delete_version"><i>J Changes since XSLT 3.0</i></span><span style="display: none;" class="add_version"><i>I Changes since XSLT 3.0</i></span><span class="modify_version"><i><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span> Changes since XSLT 3.0</i></span></a>.</p></div></div><div class="div1"><h2><a id="concepts"></a>2 <a href="#concepts" style="text-decoration: none">Concepts</a></h2><div class="div2"><h3><a id="terminology"></a>2.1 <a href="#terminology" style="text-decoration: none">Terminology</a></h3><p>For a full glossary of terms, see <a href="#glossary"><i>C Glossary</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-processor" title="processor"></a>The software responsible for transforming source trees into result trees using an XSLT stylesheet is referred to as the <b>processor</b>. This is sometimes expanded to <em>XSLT processor</em> to avoid any confusion with other processors, for example an XML processor.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-implementation" title="implementation"></a>A specific product that performs the functions of an <a title="processor" class="termref" href="#dt-processor">XSLT processor</a> is referred to as an <b>implementation</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-tree" title="tree"></a>The term <b>tree</b> is used (as in <a href="#xpath-datamodel-30">[XDM 3.0]</a>) to refer to the aggregate consisting of a parentless node together with all its descendant nodes, plus all their attributes and namespaces.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The use of the term <b>tree</b> in this document does not imply the use of a data structure in memory that holds the entire contents of the document at one time. It implies rather a logical view of the XML input and output in which elements have a hierarchic relationship to each other. When a source document is being processed in a streaming manner, access to the nodes in this tree is constrained, but it is still viewed and described as a tree.</p></div><p>The output of a transformation consists of the following:</p><ol class="enumar"><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-principal-result" title="principal result"></a>A <b>principal result</b>: this can be any sequence of items (as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>).<span class="definition">]</span> The principal result is the value returned by the function or template in the stylesheet that is nominated as the entry point, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-secondary-result" title="secondary result"></a>Zero or more <b>secondary results</b>: each secondary result can be any sequence of items (as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>).<span class="definition">]</span> A secondary result is the value returned by evaluating the body of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction.</p></li><li><p>Zero or more messages. Messages are generated by the <a href="#element-message"><code>xsl:message</code></a> and <a href="#element-assert"><code>xsl:assert</code></a> instructions, and are described in <a href="#message"><i>24.1 Messages</i></a> and <a href="#assertions"><i>24.2 Assertions</i></a>.</p></li><li><p>Static or dynamic errors: see <a href="#errors"><i>2.14 Error Handling</i></a>. </p></li></ol><p>The <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> and the <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a> may be post-processed as described in <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-result-tree" title="result tree"></a>The term <b>result tree</b> is used to refer to any <a title="tree" class="termref" href="#dt-tree">tree</a> constructed by <a title="instruction" class="termref" href="#dt-instruction">instructions</a> in the stylesheet. A result tree is either a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> or a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-final-result-tree" title="final result tree"></a>A <b>final result tree</b> is a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that forms part of the output of a transformation: specifically, a tree built by post-processing the items in the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or in a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. Once created, the contents of a final result tree are not accessible within the stylesheet itself.<span class="definition">]</span> Any final result tree <span class="verb">may</span> be serialized as described in <a href="#serialization"><i>27 Serialization</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-source-tree" title="source tree"></a>The term <b>source tree</b> means any tree provided as input to the transformation. This includes the document containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if any, documents containing nodes present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, documents containing nodes supplied as the values of <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, documents obtained from the results of functions such as <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>, documents read using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, and documents returned by extension functions or extension instructions. In the context of a particular XSLT instruction, the term <b>source tree</b> means any tree provided as input to that instruction; this may be a source tree of the transformation as a whole, or it may be a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> produced during the course of the transformation.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-temporary-tree" title="temporary tree"></a>The term <b>temporary tree</b> means any tree that is neither a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> nor a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.<span class="definition">]</span> Temporary trees are used to hold intermediate results during the execution of the transformation.</p><p>The use of the term “tree” in phrases such as <b>source tree</b>, <b>result tree</b>, and <b>temporary tree</b> is not confined to documents that the processor materializes in memory in their entirety. The processor <span class="verb">may</span>, and in some cases <span class="verb">must</span>, use streaming techniques to limit the amount of memory used to hold source and result documents. When streaming is used, the nodes of the tree may never all be in memory at the same time, but at an abstract level the information is still modeled as a tree of nodes, and the document is therefore still described as a tree. Unless otherwise stated, the term “tree” refers to a tree rooted at a parentless node: that is, the term does not include subtrees of larger trees. Every node therefore belongs to exactly one tree.</p><p>In this specification the phrases <span class="verb">must</span>, <span class="verb">must not</span>, <span class="verb">should</span>, <span class="verb">should not</span>, <span class="verb">may</span>, <span class="verb">required</span>, and <span class="verb">recommended</span>, when used in normative text and rendered in capitals, are to be interpreted as described in <a href="#rfc2119">[RFC2119]</a>.</p><p>Where the phrase <span class="verb">must</span>, <span class="verb">must not</span>, or <span class="verb">required</span> relates to the behavior of the XSLT processor, then an implementation is not conformant unless it behaves as specified, subject to the more detailed rules in <a href="#conformance"><i>28 Conformance</i></a>. </p><p>Where the phrase <span class="verb">must</span>, <span class="verb">must not</span>, or <span class="verb">required</span> relates to a stylesheet then the processor <span class="verb">must</span> enforce this constraint on stylesheets by reporting an error if the constraint is not satisfied.</p><p>Where the phrase <span class="verb">should</span>, <span class="verb">should not</span>, or <span class="verb">recommended</span> relates to a stylesheet then a processor <span class="verb">may</span> produce warning messages if the constraint is not satisfied, but <span class="verb">must not</span> treat this as an error.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-implementation-defined" title="implementation-defined"></a>In this specification, the term <b>implementation-defined</b> refers to a feature where the implementation is allowed some flexibility, and where the choices made by the implementation <span class="verb">must</span> be described in documentation that accompanies any conformance claim.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-implementation-dependent" title="implementation-dependent"></a>The term <b>implementation-dependent</b> refers to a feature where the behavior <span class="verb">may</span> vary from one implementation to another, and where the vendor is not expected to provide a full specification of the behavior.<span class="definition">]</span> (This might apply, for example, to limits on the size of source documents that can be transformed.)</p><p>In all cases where this specification leaves the behavior implementation-defined or implementation-dependent, the implementation has the option of providing mechanisms that allow the user to influence the behavior.</p><p>A paragraph labeled as a <b>Note</b> or described as an <b>example</b> is non-normative.</p><p>Many terms used in this document are defined in the XPath specification <a href="#xpath-30">[XPath 3.0]</a> or the XDM specification <a href="#xpath-datamodel-30">[XDM 3.0]</a>. Particular attention is drawn to the following:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-atomization" title="atomize"></a>The term <b>atomization</b> is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-atomization">Section 2.5.2 Atomization</a><sup><small>XP40</small></sup>. It is a process that takes as input a sequence of items, and returns a sequence of atomic values, in which the nodes are replaced by their typed values as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>. Arrays (see <a href="#arrays"><i>22 Arrays</i></a>) are atomized by atomizing their members, recursively.<span class="definition">]</span> For some items (for example, elements with element-only content, function items, and maps, atomization generates a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-typed-value" title="typed value"></a>The term <b>typed value</b> is defined in <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-typed-value">Section 5.15 typed-value Accessor </a><sup><small>DM30</small></sup>. Every node, other than an element whose type annotation identifies it as having element-only content, has a <a title="string value" class="termref" href="#dt-string-value">typed value</a>. For example, the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of an attribute of type <code>xs:IDREFS</code> is a sequence of zero or more <code>xs:IDREF</code> values.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-string-value" title="string value"></a>The term <b>string value</b> is defined in <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-string-value">Section 5.13 string-value Accessor </a><sup><small>DM30</small></sup>. Every node has a <a title="string value" class="termref" href="#dt-string-value">string value</a>. For example, the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an element is the concatenation of the <a title="string value" class="termref" href="#dt-string-value">string values</a> of all its descendant text nodes.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xpath-compat-mode" title="XPath 1.0 compatibility mode"></a>The term <b>XPath 1.0 compatibility mode</b> is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#static_context">Section 2.2.1 Static Context</a><sup><small>XP40</small></sup>. This is a setting in the static context of an XPath expression; it has two values, <code>true</code> and <code>false</code>. When the value is set to true, the semantics of function calls and certain other operations are adjusted to give a greater degree of backwards compatibility between XPath <span>4.0</span> and XPath 1.0.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-function-definition" title="function definition"></a>The term <b>function definition</b> is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#static_context">Section 2.2.1 Static Context</a><sup><small>XP40</small></sup>. It is the definition of a function that can be called statically from within an XPath expression: in the case of XSLT it typically means either a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, or a built-in function such as those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a><span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-arity-range" title="arity range"></a>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b> which defines the minimum and maximum number of arguments that must be supplied in a call to the function. The static context can contain multiple <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> with the same name, provided that their <b>arity ranges</b> do not overlap.<span class="definition">]</span></p></li></ul></div><div class="div2"><h3><a id="notation"></a>2.2 <a href="#notation" style="text-decoration: none">Notation</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-element" title="XSLT element"></a>An <b>XSLT element</b> is an element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose syntax and semantics are defined in this specification.<span class="definition">]</span> For a non-normative list of XSLT elements, see <a href="#element-syntax-summary"><i>D Element Syntax Summary</i></a>.</p><p>In this document the specification of each <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> is preceded by a summary of its syntax in the form of a model for elements of that element type. A full list of all these specifications can be found in <a href="#element-syntax-summary"><i>D Element Syntax Summary</i></a>. The meaning of the syntax summary notation is as follows:</p><ul><li><p>An attribute that is <span class="verb">required</span> is shown with its name in bold. An attribute that may be omitted is shown with a question mark following its name.</p></li><li><p>An attribute that is <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a> is shown in a grayed font within square brackets.</p></li><li><p>The string that occurs in the place of an attribute value specifies the allowed values of the attribute. If this is surrounded by curly brackets (<code>{...}</code>), then the attribute value is treated as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, and the string occurring within curly brackets specifies the allowed values of the result of evaluating the attribute value template. Alternative allowed values are separated by <code>|</code>. A quoted string indicates a value equal to that specific string. An unquoted, italicized name specifies a particular type of value.</p><p>The types used, and their meanings, are as follows:</p><dl><dt class="label"><code>boolean</code></dt><dd><p>One of the strings <code>"yes"</code>, <code>"true"</code>, or <code>"1"</code> to indicate the value <code>true</code>, or one of the strings <code>"no"</code>, <code>"false"</code>, or <code>"0"</code> to indicate the value <code>false</code>. Note: the values are synonyms; where this specification uses a phrase such as “If <code>required='yes'</code> is specified ...” this is to be interpreted as meaning “If the attribute named <code>required</code> is present, and has the value <code>yes</code>, <code>true</code>, or <code>1</code> (after stripping leading and trailing whitespace) ...”. </p></dd><dt class="label"><code>string</code></dt><dd><p>Any string</p></dd><dt class="label"><code>expression</code></dt><dd><p>An XPath <a title="expression" class="termref" href="#dt-expression">expression</a></p></dd><dt class="label"><code>pattern</code></dt><dd><p>A <a title="pattern" class="termref" href="#dt-pattern">pattern</a> as described in <a href="#patterns"><i>5.4 Patterns</i></a>.</p></dd><dt class="label"><code>item-type</code></dt><dd><p>An <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP40</small></sup> as defined in the XPath <span>4.0</span> specification.</p></dd><dt class="label"><code>sequence-type</code></dt><dd><p>A <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP40</small></sup> as defined in the XPath <span>4.0</span> specification.</p></dd><dt class="label"><code>uri; uris</code></dt><dd><p>A URI, for example a namespace URI or a collation URI; a whitespace-separated list of URIs</p></dd><dt class="label"><code>qname</code></dt><dd><p>A <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> as defined in <a href="#qname"><i>5.1.1 Qualified Names</i></a></p></dd><dt class="label"><code>eqname; eqnames</code></dt><dd><p>An <a title="EQName" class="termref" href="#dt-eqname">EQName</a> as defined in <a href="#qname"><i>5.1.1 Qualified Names</i></a>; a whitespace-separated list of EQNames</p></dd><dt class="label"><code>token; tokens</code></dt><dd><p>A string containing no significant whitespace; a whitespace-separated list of such strings</p></dd><dt class="label"><code>nmtoken; nmtokens</code></dt><dd><p>A string conforming to the XML schema rules for the type <code>xs:NMTOKEN</code>; a whitespace-separated list of such strings.</p></dd><dt class="label"><code>char</code></dt><dd><p>A string comprising a single Unicode character</p></dd><dt class="label"><code><span class="deltaxml-new" style="background:#90EE90">language</span></code></dt><dd><p><span class="deltaxml-new" style="background:#90EE90">A string in the value space of </span><code><span class="deltaxml-new" style="background:#90EE90">xs:language</span></code><span class="deltaxml-new" style="background:#90EE90">, or a zero-length string.</span></p></dd><dt class="label"><code>integer</code></dt><dd><p>An integer, that is a string <span>that is castable to</span> the schema type <code>xs:integer</code></p></dd><dt class="label"><code>decimal</code></dt><dd><p>A decimal value, that is a string <span>that is castable to</span> the schema type <code>xs:decimal</code></p></dd><dt class="label"><code>ncname;</code><span><code>ncnames</code></span></dt><dd><p>An unprefixed name: a string <span>that is castable to</span> the schema type <code>xs:NCName</code>; <span>a whitespace-separated list of such strings</span></p></dd><dt class="label"><span style="display: none;" class="delete_version"><code>prefix</code></span><span style="display: none;" class="add_version"><code>prefix</code><span>; <code>prefixes</code></span></span><span class="modify_version"><code>prefix</code><span><span class="deltaxml-new" style="background:#90EE90">; </span><code><span class="deltaxml-new" style="background:#90EE90">prefixes</span></code></span></span></dt><dd><p><span style="display: none;" class="delete_version">An <code>xs:NCName</code> representing a namespace prefix, which must be in scope for the element on which it appears</span><span style="display: none;" class="add_version">An <code>xs:NCName</code> representing a namespace prefix, which must be in scope for the element on which it appears; <span>a whitespace-separated list of such strings</span>.</span><span class="modify_version">An <code>xs:NCName</code> representing a namespace prefix, which must be in scope for the element on which it appears<span class="deltaxml-new" style="background:#90EE90">; </span><span><span class="deltaxml-new" style="background:#90EE90">a whitespace-separated list of such strings</span></span><span class="deltaxml-new" style="background:#90EE90">.</span></span></p></dd><dt class="label"><code>id</code></dt><dd><p>An <code>xs:NCName</code> used as a unique identifier for an element in the containing XML document</p></dd></dl><p>Except where the set of allowed values of an attribute is specified using the italicized name <em>string</em> or <em>char</em>, leading and trailing whitespace in the attribute value is ignored. In the case of an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, this applies to the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> obtained when the attribute value template is expanded.</p><p>XPath comments (delimited by <code>(: ... :)</code>) are permitted anywhere that inter-token whitespace is permitted in attributes whose type is given as <em>expression</em>, <em>pattern</em>, <em>item-type</em>, or <em>sequence-type</em>, and are not permitted in attributes of other types (other than within expressions enclosed by curly braces within an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>).</p></li><li><p>Unless the element is <span class="verb">required</span> to be empty, the model element contains a comment specifying the allowed content. The allowed content is specified in a similar way to an element type declaration in XML; <em>sequence constructor</em> means that any mixture of text nodes, <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, and <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a> from the <a title="instruction" class="termref" href="#dt-instruction">instruction</a> category is allowed; <em>other-declarations</em> means that any mixture of XSLT elements from the <a title="declaration" class="termref" href="#dt-declaration">declaration</a> category is allowed, together with <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>.</p></li><li><p>The element is prefaced by comments indicating if it belongs to the <code>instruction</code> category or <code>declaration</code> category or both. The category of an element only affects whether it is allowed in the content of elements that allow a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> or <em>other-declarations</em>.</p></li></ul><div class="example"><div class="exampleHeader"><a id="d8e882"></a><a id="d8e896"></a>Example: Syntax Notation</div><p>This example illustrates the notation used to describe <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>.</p><p class="element-syntax"><a id="element-example-element"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:example-element<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;debug? = <var>boolean</var><br>&nbsp;&nbsp;validation? = { "strict" | "lax" }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a>)*, <a href="#element-sequence">xsl:sequence</a>) --&gt;<br>&lt;/xsl:example-element&gt;</code></p><p>This example defines a (non-existent) element <code>xsl:example-element</code>. The element is classified as an instruction. It takes the following attributes:</p><ol class="enumar"><li><p>A mandatory <code>select</code> attribute, whose value is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a></p></li><li><p>An optional <code>debug</code> attribute, whose value <span class="verb">must</span> be <code>yes</code>, <code>true</code>, or <code>1</code> to indicate <code>true</code>, or <code>no</code>, <code>false</code>, or <code>0</code> to indicate <code>false</code>.</p></li><li><p>An optional <code>validation</code> attribute, whose value must be <code>strict</code> or <code>lax</code>; the curly brackets indicate that the value can be defined as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, allowing a value such as <code>validation="{$val}"</code>, where the <a title="variable" class="termref" href="#dt-variable">variable</a><code>val</code> is evaluated to yield <code>"strict"</code> or <code>"lax"</code> at run-time.</p></li></ol><p>The content of an <code>xsl:example-element</code> instruction is defined to be a sequence of zero or more <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> elements, followed by an <a href="#element-sequence"><code>xsl:sequence</code></a> element.</p></div><p><a id="err-XTSE0010"><span class="error">[ERR XTSE0010] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an XSLT-defined element is used in a context where it is not permitted, if a <span class="verb">required</span> attribute is omitted, or if the content of the element does not correspond to the content that is allowed for the element. </p><p>The rules in the element syntax summary (both for the element structure and for its attributes) apply to the stylesheet content after preprocessing as described in <a href="#preprocessing"><i>3.13 Stylesheet Preprocessing</i></a>.</p><p><span class="definition"><span class="deltaxml-new" style="background:#90EE90">[Definition:&nbsp;</span></span><a id="dt-effective-value" title="effective value"></a><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">effective value</span></b><span class="deltaxml-new" style="background:#90EE90"> of an attribute or text node in the stylesheet is the value after any required expansion or normalization.</span><span class="definition"><span class="deltaxml-new" style="background:#90EE90">]</span></span></p><p><span class="deltaxml-new" style="background:#90EE90">More specifically, the effective value is the value after:</span></p><ul><li><p><span class="deltaxml-new" style="background:#90EE90">Expanding shadow attributes as described in </span><a href="#shadow-attributes"><i><span class="deltaxml-new" style="background:#90EE90">3.13.4 Shadow Attributes</span></i></a><span class="deltaxml-new" style="background:#90EE90">;</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Expanding defaults (for example, if an </span><a href="#element-message"><code><span class="deltaxml-new" style="background:#90EE90">xsl:message</span></code></a><span class="deltaxml-new" style="background:#90EE90"> instruction has no </span><code><span class="deltaxml-new" style="background:#90EE90">terminate</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute, then the effective value of the </span><code><span class="deltaxml-new" style="background:#90EE90">terminate</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is </span><code><span class="deltaxml-new" style="background:#90EE90">no</span></code><span class="deltaxml-new" style="background:#90EE90">);</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Stripping ignored whitespace (for example, the effective value of a boolean attribute written as </span><code><span class="deltaxml-new" style="background:#90EE90">terminate=" no "</span></code><span class="deltaxml-new" style="background:#90EE90"> is </span><code><span class="deltaxml-new" style="background:#90EE90">no</span></code><span class="deltaxml-new" style="background:#90EE90">);</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Replacing synonyms (for example in boolean attributes, </span><code><span class="deltaxml-new" style="background:#90EE90">1</span></code><span class="deltaxml-new" style="background:#90EE90"> and </span><code><span class="deltaxml-new" style="background:#90EE90">true</span></code><span class="deltaxml-new" style="background:#90EE90"> are synonyms of </span><code><span class="deltaxml-new" style="background:#90EE90">yes</span></code><span class="deltaxml-new" style="background:#90EE90">);</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Expanding </span><a title="attribute value template" class="termref" href="#dt-attribute-value-template"><span class="deltaxml-new" style="background:#90EE90">attribute value templates</span></a><span class="deltaxml-new" style="background:#90EE90"> and </span><a title="text value template" class="termref" href="#dt-text-value-template"><span class="deltaxml-new" style="background:#90EE90">text value templates</span></a><span class="deltaxml-new" style="background:#90EE90">.</span></p></li><li><p><span class="deltaxml-new" style="background:#90EE90">Applying rules from the static context: for example, the effective value of a </span><code><span class="deltaxml-new" style="background:#90EE90">collation</span></code><span class="deltaxml-new" style="background:#90EE90"> attribute is the value after expanding a relative URI against the static base URI.</span></p></li></ul><p>Attributes are validated as follows. These rules apply to the value of the attribute after removing leading and trailing whitespace.</p><ul><li><p><a id="err-XTSE0020"><span class="error">[ERR XTSE0020] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an attribute (other than an attribute written using curly brackets in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted) contains a value that is not one of the permitted values for that attribute. </p></li><li><p><a id="err-XTDE0030"><span class="error">[ERR XTDE0030] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute written using curly brackets, in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted, is a value that is not one of the permitted values for that attribute. If the processor is able to detect the error statically (for example, when any XPath expressions within the curly brackets can be evaluated statically), then the processor may optionally signal this as a static error. </p></li></ul><p>Special rules apply if the construct appears in part of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that is processed with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>: see <a href="#forwards"><i>3.10 Forwards Compatible Processing</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-deprecated" title="deprecated"></a>Some constructs defined in this specification are described as being <b>deprecated</b>. The use of this term implies that stylesheet authors <span class="verb">should not</span> use the construct, and that the construct may be removed in a later version of this specification.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification includes a non-normative XML Schema for XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> (see <a href="#schema-for-xslt"><i>H Schemas for XSLT 4.0 Stylesheets</i></a>). The syntax summaries described in this section are normative.</p></div><p>XSLT defines a set of standard functions which are additional to those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. A list of these functions appears in <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>. The signatures of these functions are described using the same notation as used in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. The names of many of these functions are in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>.</p></div><div class="div2"><h3><a id="initiating"></a>2.3 <a href="#initiating" style="text-decoration: none">Initiating a Transformation</a></h3><p>This document does not specify any application programming interfaces or other interfaces for initiating a transformation. This section, however, describes the information that is supplied when a transformation is initiated. Except where otherwise indicated, the information is <span class="verb">required</span>.</p><p>The execution of a stylesheet necessarily involves two activities: static analysis and dynamic evaluation. Static analysis consists of those tasks that can be performed by inspection of the stylesheet alone, including the binding of <a title="static variable" class="termref" href="#dt-static-variable">static variables</a>, the evaluation of <code>[xsl:]use-when</code> expressions (see <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>), and shadow attributes (see <a href="#shadow-attributes"><i>3.13.4 Shadow Attributes</i></a>) and detection of <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Dynamic evaluation consists of tasks which in general cannot be carried out until a source document is available.</p><p>Dynamic evaluation is further divided into two activities: <b>priming</b> the stylesheet, and <b>invoking</b> a selected component. </p><ul><li><p>Priming the stylesheet provides the dynamic context for evaluation, and supplies all the information needed to establish the values of global variables.</p></li><li><p>Invoking a component (such as a template or function) causes evaluation of that template or function to produce a result, which is an arbitrary XDM value.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-raw-result" title="raw result"></a>The result of invoking the selected component, after any required conversion to the declared result type of the component, is referred to as the <b>raw result</b>.<span class="definition">]</span></p><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the target template or function, modified by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> to the type declared in the <code>as</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-function"><code>xsl:function</code></a> declaration, if present.</p><p>This raw result may optionally be post-processed to construct a result tree, to serialize the result, or both, as described in <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>.</p></li></ul><p>Implementations <span class="verb">may</span> allow static analysis and dynamic evaluation to be initiated independently, so that the cost of static analysis can be amortized over multiple transformations using the same stylesheet. Implementations <span class="verb">may</span> also allow priming of a stylesheet and invocation of components to be initiated independently, in which case a single act of priming the stylesheet may be followed by a series of independent component invocations. Although this specification does not require such a separation, this section distinguishes information that is needed before static analysis can proceed, information that is needed to prime the stylesheet, and information that is needed when invoking components.</p><p>The language is designed to allow the static analysis of each <a title="package" class="termref" href="#dt-package">package</a> to be performed independently of other packages, with only basic knowledge of the properties of components made available by used packages. Beyond this, the specification leaves it to implementations to decide how to organize this process. When packages are not used explicitly, the entire stylesheet is treated as a single package.</p><div class="div3"><h4><a id="info-for-static-analysis"></a>2.3.1 <a href="#info-for-static-analysis" style="text-decoration: none">Information needed for Static Analysis</a></h4><p>The following information is needed prior to static analysis of a package:</p><ul><li><p>The location of the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>, or in the absence of a package manifest, the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is to act as the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the <a title="package" class="termref" href="#dt-package">package</a>. The complete <a title="package" class="termref" href="#dt-package">package</a> is assembled by recursively expanding the <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a> declarations in the principal stylesheet module, as described in <a href="#include"><i>3.11.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.11.3 Stylesheet Import</i></a>. </p></li><li><p>Information about the packages referenced from this package using <a href="#element-use-package"><code>xsl:use-package</code></a> declarations. The information needed will include the names and signatures of public components exported by the referenced package.</p></li><li><p>A set (possibly empty) of values for <a title="static parameter" class="termref" href="#dt-static-parameter">static parameters</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>). These values are available for use within <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a> (notably in <code>[xsl:]use-when</code> expressions and shadow attributes) as well as non-static expressions in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. As a minimum, values <span class="verb">must</span> be supplied for any static parameters declared with the attribute <code>required="yes"</code>.</p></li></ul><p>Conceptually, the output of the static analysis of a package is an object which might be referred to (without constraining the implementation) as a compiled package. Prior to dynamic evaluation, all the compiled packages needed for execution must be checked for consistency, and component references must be resolved. This process may be referred to, again without constraining the implementation, as linking.</p></div><div class="div3"><h4><a id="priming-stylesheet"></a>2.3.2 <a href="#priming-stylesheet" style="text-decoration: none">Priming a Stylesheet</a></h4><p>The information needed when priming a stylesheet is as follows:</p><ul><li><p>A set (possibly empty) of values for non-static <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>). These values are available for use within <a title="expression" class="termref" href="#dt-expression">expressions</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. As a minimum, values <span class="verb">must</span> be supplied for any parameters declared with the attribute <code>required="yes"</code>.</p><p>A supplied value is converted if necessary to the declared type of the stylesheet parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Non-static stylesheet parameters are implicitly <code>public</code>, which ensures that all the parameters in the stylesheet for which values can be supplied externally have distinct names. Static parameters, by contrast, are local to a package.</p></div></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-global-context-item" title="global context item"></a>An item that acts as the <b>global context item</b> for the transformation. This item acts as the <a title="context item" class="termref" href="#dt-context-item">context item</a> when evaluating the <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><span>whose declaration is</span> within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, as described in <a href="#focus"><i>5.3.4.1 Maintaining Position: the Focus</i></a>. The global context item may also be available in a <a title="named template" class="termref" href="#dt-named-template">named template</a> when the stylesheet is invoked as described in <a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a><span class="definition">]</span>. <span>[XSLT 3.0 Erratum E7, bug 30179].</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In previous releases of this specification, a single node was typically supplied to represent the source document for the transformation. This node was used as the target node for the implicit call on <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> used to start the transformation process (now called the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>), and the root node of the containing tree was used as the context item for evaluation of global variables (now called the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>). This relationship between the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> and the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is likely to be found for compatibility reasons in a transformation API designed to work with earlier versions of this specification, but it is no longer a necessary relationship; the two values can in principle be completely independent of each other.</p><p>Stylesheet authors wanting to write code that can be invoked using legacy APIs should not rely on the caller being able to supply different values for the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> and the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p></div><p>The value given to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> (and the values given to <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>) cannot be nodes in a streamed document. This rule ensures that all global variables can freely navigate within the relevant tree, with no constraints imposed by the streamability rules.</p><p>The <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is potentially used when initializing global variables and parameters. If the initialization of any <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> or <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">parameter</a> depends on the context item, a dynamic error can occur if the context item is absent. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether this error occurs during priming of the stylesheet or subsequently when the variable is referenced; and it is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether the error occurs at all if the variable or parameter is never referenced. The error can be suppressed by use of <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a> within the sequence constructor used to initialize the variable or parameter. It cannot be suppressed by use of <a href="#element-try"><code>xsl:try</code></a> around a reference to the global variable. </p><p>In a <a title="library package" class="termref" href="#dt-library-package">library package</a>, the <a title="context item" class="termref" href="#dt-context-item">context item</a>, <a title="context position" class="termref" href="#dt-context-position">context position</a>, and <a title="context size" class="termref" href="#dt-context-size">context size</a> used for evaluation of global variables will be <a title="absent" class="termref" href="#dt-absent">absent</a>, and the evaluation of any expression that references these values will result in a dynamic error. This will also be the case in the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> if no <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is supplied.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If a context item is available within a global variable declaration, then the <a title="context position" class="termref" href="#dt-context-position">context position</a> and <a title="context size" class="termref" href="#dt-context-size">context size</a> will always be 1 (one).</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>For maximum reusability of code, it is best to avoid use of the context item when initializing global variables and parameters. Instead, all external information should be supplied using named <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>. Especially when these use namespaces to avoid conflicts, there is then no risk of confusion between the information supplied externally to different packages.</p><p>When a stylesheet parameter is defined in a library package, it is possible for a using package to supply a value for the parameter by overriding the parameter declaration within an <a href="#element-override"><code>xsl:override</code></a> element. If the using package is the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> then the overriding declaration can refer to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p></div></li><li><p>A mechanism for obtaining a document node and a media type, given an absolute URI. The total set of available documents (modeled as a mapping from URIs to document nodes) forms part of the context for evaluating XPath expressions, specifically the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function. The XSLT <a href="#func-document"><code>document</code></a> function additionally requires the media type of the resource representation, for use in interpreting any fragment identifier present within a URI Reference.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The set of documents that are available to the stylesheet is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, as is the processing that is carried out to construct a tree representing the resource retrieved using a given URI. Some possible ways of constructing a document (specifically, rules for constructing a document from an Infoset or from a PSVI) are described in <a href="#xpath-datamodel-30">[XDM 3.0]</a>.</p></div></li></ul><p>Once a stylesheet is primed, the values of global variables remain stable through all component invocations. In addition, priming a stylesheet creates an <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO40</small></sup> during which the dynamic context and all calls on <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO40</small></sup> functions remain stable; for example two calls on the <a href="https://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>current-dateTime</code></a><sup><small>FO30</small></sup> function within an execution scope are defined to return the same result.</p><p>Parameters passed to the transformation by the client application when a stylesheet is primed are matched against <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>), not against the <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a> of any template executed during the course of the transformation. </p><p><a id="err-XTDE0050"><span class="error">[ERR XTDE0050] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a stylesheet declares a visible <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> that is <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly</a> mandatory, and no value for this parameter is supplied when the stylesheet is primed. A stylesheet parameter is visible if it is not masked by another global variable or parameter with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. If the parameter is a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a> then the value <span class="verb">must</span> be supplied prior to the static analysis phase. </p></div><div class="div3"><h4><a id="invoking-initial-mode"></a>2.3.3 <a href="#invoking-initial-mode" style="text-decoration: none">Apply-Templates Invocation</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-match-selection" title="initial match selection"></a>A stylesheet may be evaluated by supplying a value to be processed, together with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. The value (which can be any sequence of items) is referred to as the <b>initial match selection</b>. The processing then corresponds to the effect of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.<span class="definition">]</span></p><p>The <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> will often be a single document node, traditionally called the source document of the transformation; but in general, it can be any sequence. If the initial match selection is an empty sequence, the result of the transformation will be empty, since no template rules are evaluated.</p><p>Processing proceeds by finding the <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> that match the items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, and evaluating these template rules with a <a title="focus" class="termref" href="#dt-focus">focus</a> based on the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. The template rules are evaluated in <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>.</p><p>The following information is needed when dynamic evaluation is to start with a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>:</p><ul><li><p>The <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. An API that chooses to maintain compatibility with previous versions of this specification <span class="verb">should</span> allow a method of invocation in which a singleton node is provided, which is then used in two ways: the node itself acts as the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, and the root node of the containing tree acts as the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>. </p></li><li><p>Optionally, an initial <a title="mode" class="termref" href="#dt-mode">mode</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-mode" title="initial mode"></a>The <b>initial mode</b> is the <a title="mode" class="termref" href="#dt-mode">mode</a> used to select <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> for processing items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> when apply-templates invocation is used to initiate a transformation.<span class="definition">]</span></p><p>In searching for the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that best matches the items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, the processor considers only those rules that apply to the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>.</p><p>If no <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> is supplied explicitly, then the initial mode is that named in the <code>default-mode</code> attribute of the (explicit or implicit) <a href="#element-package"><code>xsl:package</code></a> element of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> or in the absence of such an attribute, the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p><p><a id="err-XTDE0044"><span class="error">[ERR XTDE0044] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> when no <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> is supplied (either explicitly, or defaulted to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>). </p><p>A (named or unnamed) <a title="mode" class="termref" href="#dt-mode">mode</a><var>M</var> is <b>eligible as an initial mode</b> if one of the following conditions applies, where <var>P</var> is the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> of the stylesheet:</p><ol class="enumar"><li><p><var>M</var> is explicitly declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration within <var>P</var>, and has <code>public</code> or <code>final</code><a title="visibility" class="termref" href="#dt-visibility">visibility</a> (either by virtue of its <code>visibility</code> attribute, or by virtue of an <a href="#element-expose"><code>xsl:expose</code></a> declaration).</p></li><li><p><var>M</var> is the unnamed mode.</p></li><li><p><var>M</var> is named in the <code>default-mode</code> attribute of the (explicit or implicit) <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var>.</p></li><li><p><var>M</var> is declared in a package used by <var>P</var>, and is given <code>public</code> or <code>final</code><a title="visibility" class="termref" href="#dt-visibility">visibility</a> in <var>P</var> by means of an <a href="#element-accept"><code>xsl:accept</code></a> declaration.</p></li><li><p><span style="display: none;" class="delete_version">The effective value of the <code>declared-modes</code> attribute of the explicit or implicit <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var> is <code>no</code>, and <var>M</var> appears as a mode-name in the <code>mode</code> attribute of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within <var>P</var>.</span><span style="display: none;" class="add_version">The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of the explicit or implicit <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var> is <code>no</code>, and <var>M</var> appears as a mode-name in the <code>mode</code> attribute of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within <var>P</var>.</span><span class="modify_version">The <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>declared-modes</code> attribute of the explicit or implicit <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var> is <code>no</code>, and <var>M</var> appears as a mode-name in the <code>mode</code> attribute of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within <var>P</var>.</span></p></li></ol><p><a id="err-XTDE0045"><span class="error">[ERR XTDE0045] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> and the specified mode is not eligible as an initial mode (as defined above). </p></li><li><p>Parameters, which will be passed to the template rules used to process items in the input sequence. The parameters consist of two sets of (QName, value) pairs, one set for <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel parameters, in which the QName identifies the name of a parameter and the value provides the value of the parameter. Either or both sets of parameters may be empty. The effect is the same as when a template is invoked using <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with an <a href="#element-with-param"><code>xsl:with-param</code></a> child specifying <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If a parameter is supplied that is not declared or used, the value is simply ignored. These parameters are <em>not</em> used to set <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>.</p><p>A supplied value is converted if necessary to the declared type of the template parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p></li><li><p>Details of how the result of the initial template is to be returned. For details, see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a></p></li></ul><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the result of processing the supplied input sequence as if by a call on <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> in the specified mode: specifically, each item in the input sequence is processed by selecting and evaluating the best matching template rule, and converting the result (if necessary) to the type declared in the <code>as</code> attribute of that template using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>; and the results of processing each item are then concatenated into a single sequence, respecting the order of items in the input sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If the initial mode is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>, then a streaming processor <span class="verb">should</span> allow some or all of the items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> to be nodes supplied in streamable form, and any nodes that are supplied in this form <span class="verb">must</span> then be processed using streaming.</p><p>Since the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> cannot be a streamed node, in cases where the transformation is to proceed by applying streamable templates to a streamed input document, the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> must either be absent, or must be something that differs from the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The design of the API for invoking a transformation should provide some means for users to designate the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> as the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> in cases where it is not the default mode.</p></div><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> selected for processing any item in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> defines a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> that specifies <code>required="yes"</code> and no value is supplied for that parameter.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can process further source documents in addition to those supplied when the transformation is invoked. These additional documents can be loaded using the functions <a href="#func-document"><code>document</code></a> (see <a href="#func-document"><i>20.1 fn:document</i></a>) or <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>), or using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction; alternatively, they can be supplied as <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>), or returned as the result of an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> (see <a href="#extension-functions"><i>25.1 Extension Functions</i></a>).</p></div></div><div class="div3"><h4><a id="invoking-initial-template"></a>2.3.4 <a href="#invoking-initial-template" style="text-decoration: none">Call-Template Invocation</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-named-template" title="initial named template"></a>A stylesheet may be evaluated by selecting a named template to be evaluated; this is referred to as the <b>initial named template</b>.<span class="definition">]</span> The effect is analogous to the effect of executing an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. The following information is needed in this case:</p><ul><li><p>Optionally, the name of the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a> which is to be executed as the entry point to the transformation. If no template name is supplied, the default template name is <code>xsl:initial-template</code>. The selected template <span class="verb">must</span> exist within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. </p></li><li><p>Optionally, a context item for evaluation of this named template, defaulting to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if it exists. This is constrained by any <a href="#element-context-item"><code>xsl:context-item</code></a> element appearing within the selected <a href="#element-template"><code>xsl:template</code></a> element. The initial named template is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on this context item if it exists, or with an <a title="absent" class="termref" href="#dt-absent">absent</a> focus otherwise.</p></li><li><p>Parameters, which will be passed to the selected template rule. The parameters consist of two sets of (QName, value) pairs, one set for <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel parameters, in which the QName identifies the name of a parameter and the value provides the value of the parameter. Either or both sets of parameters may be empty. The effect is the same as when a template is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a> with an <a href="#element-with-param"><code>xsl:with-param</code></a> child specifying <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If a parameter is supplied that is not declared or used, the value is simply ignored. These parameters are <em>not</em> used to set <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>.</p><p>A supplied value is converted if necessary to the declared type of the template parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p></li><li><p>Details of how the result of the initial named template is to be returned. For details, see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a></p></li></ul><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the result of evaluating the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a>, after conversion of the result to the type declared in the <code>as</code> attribute of that template using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, if such conversion is necessary.</p><p>The <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a> is evaluated in <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>.</p><p><a id="err-XTDE0040"><span class="error">[ERR XTDE0040] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a template name that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of a named template defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is <code>public</code> or <code>final</code>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>When the top-level package is rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element, named templates having no explicit <code>visibility</code> attribute are automatically exposed as public components. (This is a consequence of the transformation applied to a package written using "simplified syntax", described in <a href="#packages"><i>3.5 Packages</i></a>.) [XSLT 3.0 Erratum E8, bug 30181].</p></div><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a><span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a>, or any of the template rules invoked to process items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, defines a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> that specifies <code>required="yes"</code> and no value is supplied for that parameter. </p></div><div class="div3"><h4><a id="invoking-initial-function"></a>2.3.5 <a href="#invoking-initial-function" style="text-decoration: none">Function Call Invocation</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-function" title="initial function"></a>A stylesheet may be evaluated by calling a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, referred to as the <b>initial function</b>.<span class="definition">]</span> The following additional information is needed in this case:</p><ul><li><p>The name and arity of a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> which is to be executed as the entry point to the transformation.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the design of a concrete API, the arity may be inferred from the length of the parameter list.</p></div></li><li><p>A list of values to act as parameters to the <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>. The number of values in the list must be the same as the arity of the function.</p><p>A supplied value is converted if necessary to the declared type of the function parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p></li><li><p>Details of how the result of the initial function is to be returned. For details, see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a></p></li></ul><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the result of evaluating the <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>, after conversion of the result to the type declared in the <code>as</code> attribute of that function using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, if such conversion is necessary.</p><div class="note"><p class="prefix"><b>Note:</b></p><p> The <a title="initial function" class="termref" href="#dt-initial-function">initial function</a> (like all stylesheet functions) is evaluated with an <a title="absent" class="termref" href="#dt-absent">absent</a><a title="focus" class="termref" href="#dt-focus">focus</a>.</p></div><p>If the <a title="initial function" class="termref" href="#dt-initial-function">initial function</a> is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>, a streaming processor <span class="verb">should</span> allow the value of the first argument to be supplied in streamable form, and if it is supplied in this form, then it <span class="verb">must</span> be processed using streaming.</p><p><a id="err-XTDE0041"><span class="error">[ERR XTDE0041] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a function name and arity that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and arity of a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is <code>public</code> or <code>final</code>. </p><p>When a transformation is invoked by calling an <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>, the entire transformation executes in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>, which means that calls on <a href="#element-result-document"><code>xsl:result-document</code></a> are not permitted.</p><p>[TODO: Generalize the above description to allow for the possibility of keyword-based and optional arguments.]</p></div><div class="div3"><h4><a id="post-processing"></a>2.3.6 <a href="#post-processing" style="text-decoration: none">Post-processing the Raw Result</a></h4><p>There are three ways the result of a transformation may be delivered. (This applies both to the principal result, described here, and also to secondary results, generated using <a href="#element-result-document"><code>xsl:result-document</code></a>.)</p><ol class="enumar"><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> (a sequence of values) may be returned directly to the calling application.</p></li><li><p><span style="display: none;" class="delete_version">A result tree may be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>. By default, a result tree is constructed if the <code>build-tree</code> attribute of the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> has the effective value <code>yes</code>. An API for invoking transformations <span class="verb">may</span> allow this setting to be overridden by the calling application. If result tree construction is requested, it is performed as described in <a href="#result-tree-construction"><i>2.3.6.1 Result Tree Construction</i></a>. </span><span style="display: none;" class="add_version">A result tree may be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>. By default, a result tree is constructed if the <code>build-tree</code> attribute of the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>yes</code>. An API for invoking transformations <span class="verb">may</span> allow this setting to be overridden by the calling application. If result tree construction is requested, it is performed as described in <a href="#result-tree-construction"><i>2.3.6.1 Result Tree Construction</i></a>. </span><span class="modify_version">A result tree may be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>. By default, a result tree is constructed if the <code>build-tree</code> attribute of the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>yes</code>. An API for invoking transformations <span class="verb">may</span> allow this setting to be overridden by the calling application. If result tree construction is requested, it is performed as described in <a href="#result-tree-construction"><i>2.3.6.1 Result Tree Construction</i></a>. </span></p></li><li><p>Alternatively, the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be serialized as described in <a href="#result-serialization"><i>2.3.6.2 Serializing the Result</i></a>. The decision whether or not to serialize the result is determined by the rules of transformation API provided by the <a title="processor" class="termref" href="#dt-processor">processor</a>, and is not influenced by anything in the stylesheet.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification does not constrain the design of application programming interfaces or the choice of defaults. In previous versions of this specification, result tree construction was a mandatory process, while serialization was optional. When invoking stylesheet functions directly, however, result tree construction and serialization may be inappropriate as defaults. These considerations may affect the design of APIs.</p><p>In previous versions of XSLT, results were delivered either in serialized form (as a character or byte stream), or as a tree. In the latter case processors typically would use either their own tree representation, or a standardized tree representation such as the W3C Document Object Model (DOM) (see <a href="#DOM-Level-2-Core">[DOM Level 2]</a>), adapted to the data structures offered by the programming language in which the API is defined. To deliver a raw result, processors need to define a representation not only of XDM nodes but also of sequences, atomic values, maps and even functions. As with the return of a simple tree, this may involve a trade-off between strict fidelity to the XDM data model and usability in the particular programming language environment. It is <em>not</em> a requirement that an API should return results in a way that exposes every property of the XDM data model; for example there may be APIs that do not expose the precise type annotation of a returned node or atomic value, or that fail to expose the base URI or document URI of a node, or that provide no way of determining whether two nodes in the result sequence are the same node in the sense of the XPath <code>is</code> operator. The way in which maps, arrays, and functions are returned requires careful design choices. It is <span class="verb">recommended</span> that an API should be capable of returning any XDM value without error, and that there should be minimal loss of information if the raw results output by one transformation are subsequently used as input to another transformation.</p></div><div class="div4"><h5><a id="result-tree-construction"></a>2.3.6.1 <a href="#result-tree-construction" style="text-decoration: none">Result Tree Construction</a></h5><p>If a result tree is to be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>, then this is done by applying the rules for the process of <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#sequence-normalization">sequence normalization</a><sup><small>SER30</small></sup> as defined in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>. This process takes as input the serialization parameters defined in the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>; though the only parameter that is actually used by this process is <code>item-separator</code>. <span>[XSLT 3.0 Erratum E14, bug 30208].</span></p><p>The sequence normalization process either returns a document node, or raises a serialization error. The content of the document node is not necessarily well-formed (the document node may have any number of element or text nodes among its children).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>More specifically, the process raises a serialization error if any item in the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is an attribute node, a namespace node, or a function (including a map, but not an array: arrays are flattened).</p></div><p>The tree that is constructed is referred to as a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p><p>If the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is an empty sequence, the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> will consist of a document node with no children.</p><p>The base URI of the document node is set to the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>item-separator</code> property has no effect if the raw result of the transformation is a sequence of length zero or one, which in practice will often be the case, especially in a traditional scenario such as transformation of an XML document to HTML.</p><p>If there is no <code>item-separator</code>, then a single space is inserted between adjacent atomic values; for example if the raw result is the sequence <code>1 to 5</code>, then sequence normalization produces a tree comprising a document node with a single child, the child being a text node with the string value <code>1 2 3 4 5</code>.</p><p>If there is an <code>item-separator</code>, then it is used not only between adjacent atomic values, but between any pair of items in the raw result. For example if the raw result is a sequence of two element nodes <code>A</code> and <code>B</code>, and the <code>item-separator</code> is a comma, then the result of sequence normalization will be a document node with three children: a copy of <code>A</code>, a text node whose string value is a single comma, and a copy of <code>B</code>.</p></div></div><div class="div4"><h5><a id="result-serialization"></a>2.3.6.2 <a href="#result-serialization" style="text-decoration: none">Serializing the Result</a></h5><p>See <a href="#parsing-and-serialization"><i>2.7 Parsing and Serialization</i></a>.</p><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may optionally be serialized as described in <a href="#serialization"><i>27 Serialization</i></a>. The serialization is controlled by the serialization parameters defined in the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The first phase of serialization, called <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#sequence-normalization">sequence normalization</a><sup><small>SER30</small></sup>, takes place for some output methods but not others. For example, if the <code>json</code> output method (defined in <a href="#xslt-xquery-serialization-31">[XSLT and XQuery Serialization 3.1]</a>) is selected, then the process of constructing a tree is bypassed.</p></div><p>The effect of serialization is to generate a sequence of octets, representing the serialized result in some character encoding. The processor’s API may define mechanisms enabling this sequence of octets to be written to persistent storage at some location. The default location is the location identified by the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p><p>In previous versions of this specification it was stated that when the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the initial template or function is an empty sequence, a result tree should be produced if and only if the transformation generates no secondary results (that is, if it does not invoke <a href="#element-result-document"><code>xsl:result-document</code></a>). This provision is most likely to have a noticeable effect if the transformation produces serialized results, and these results are written to persistent storage: the effect is then that a transformation producing an empty principal result will overwrite any existing content at the base output URI location if and only if the transformation produces no other output. Processor APIs offering backwards compatibility with earlier versions of XSLT must respect this behavior, but there is no requirement for new processor APIs to do so.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-base-output-uri" title="base output URI"></a> The <b>base output URI</b> is a URI to be used as the base URI when resolving a relative URI reference allocated to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. If the transformation generates more than one final result tree, then typically each one will be allocated a URI relative to this base URI.<span class="definition">]</span> The way in which a base output URI is established is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Each invocation of the stylesheet may supply a different base output URI. It is acceptable for the base output URI to be <a title="absent" class="termref" href="#dt-absent">absent</a>, provided no constructs (such as <a href="#element-result-document"><code>xsl:result-document</code></a>) are evaluated that depend on the value of the base output URI.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It will often be convenient for the base output URI to be the same as the location to which the principal result document is serialized, but this relationship is not a necessary one.</p></div></div></div></div><div class="div2"><h3><a id="executing-a-transformation"></a>2.4 <a href="#executing-a-transformation" style="text-decoration: none">Instructions</a></h3><p>The main executable components of a stylesheet are templates and functions. The body of a template or function is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, which is a sequence of elements and text nodes that can be evaluated to produce a result.</p><p>A <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is a sequence of sibling nodes in the stylesheet, each of which is either an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a>, a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, a text node, or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-instruction" title="instruction"></a>An <b>instruction</b> is either an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-instruction" title="XSLT instruction"></a>An <b>XSLT instruction</b> is an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> whose syntax summary in this specification contains the annotation <code>&lt;!-- category: instruction --&gt;</code>.<span class="definition">]</span></p><p><a title="extension instruction" class="termref" href="#dt-extension-instruction">Extension instructions</a> are described in <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a>.</p><p>The main categories of <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a> are as follows:</p><ul><li><p>instructions that create new nodes: <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, <a href="#element-comment"><code>xsl:comment</code></a>, <a href="#element-value-of"><code>xsl:value-of</code></a>, <a href="#element-text"><code>xsl:text</code></a>, <a href="#element-namespace"><code>xsl:namespace</code></a>;</p></li><li><p>instructions that copy nodes: <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>;</p></li><li><p>an instruction that returns an arbitrary sequence by evaluating an XPath expression: <a href="#element-sequence"><code>xsl:sequence</code></a>;</p></li><li><p>instructions that cause conditional or repeated evaluation of nested instructions: <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-choose"><code>xsl:choose</code></a>, <a href="#element-try"><code>xsl:try</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-fork"><code>xsl:fork</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a> and its subordinate instructions <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> and <a href="#element-break"><code>xsl:break</code></a>;</p></li><li><p>instructions that generate output conditionally if elements are or are not empty: <a href="#element-on-empty"><code>xsl:on-empty</code></a>, <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>, <a href="#element-where-populated"><code>xsl:where-populated</code></a>;</p></li><li><p>instructions that invoke templates: <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-next-match"><code>xsl:next-match</code></a>;</p></li><li><p>Instructions that declare variables: <a href="#element-variable"><code>xsl:variable</code></a>;</p></li><li><p>Instructions to assist debugging: <a href="#element-message"><code>xsl:message</code></a>, <a href="#element-assert"><code>xsl:assert</code></a>;</p></li><li><p>other specialized instructions: <a href="#element-number"><code>xsl:number</code></a>, <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, <a href="#element-fork"><code>xsl:fork</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, <a href="#element-merge"><code>xsl:merge</code></a>.</p></li></ul></div><div class="div2"><h3><a id="rule-based-processing"></a>2.5 <a href="#rule-based-processing" style="text-decoration: none">Rule-Based Processing</a></h3><p>The classic method of executing an XSLT transformation is to apply template rules to the root node of an input document (see <a href="#invoking-initial-mode"><i>2.3.3 Apply-Templates Invocation</i></a>). The operation of applying templates to a node searches the stylesheet for the best matching template rule for that node. This template rule is then evaluated. A common coding pattern, especially when XSLT is used to convert XML documents into display formats such as HTML, is to have one template rule for each kind of element in the source document, and for that template rule to generate some appropriate markup elements, and to apply templates recursively to its own children. The effect is to perform a recursive traversal of the source tree, in which each node is processed using the best-fit template rule for that node. The final result of the transformation is then the tree produced by this recursive process. This result can then be optionally serialized (see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>). </p><div class="example"><div class="exampleHeader"><a id="rule-based-processing-example"></a>Example: Example of Rule-Based Processing</div><p>This example uses rule-based processing to convert a simple XML input document into an HTML output document.</p><p>The input document takes the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">PERSONAE</span><span class="z"></span><span class="atn">PLAY</span><span class="atneq">=</span><span class="z">"</span><span class="av">OTHELLO</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">TITLE</span><span class="scx">&gt;</span><span class="txt">Dramatis Personae</span><span class="ez">&lt;/</span><span class="cl">TITLE</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">DUKE OF VENICE</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">BRABANTIO, a senator.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">Other Senators.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">GRATIANO, brother to Brabantio.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">LODOVICO, kinsman to Brabantio.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">OTHELLO, a noble Moor in the service of the Venetian state.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">CASSIO, his lieutenant.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">IAGO, his ancient.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">RODERIGO, a Venetian gentleman.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">MONTANO, Othello's predecessor in the government of Cyprus.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">Clown, servant to Othello. </span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">DESDEMONA, daughter to Brabantio and wife to Othello.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">EMILIA, wife to Iago.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">BIANCA, mistress to Cassio.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">PERSONA</span><span class="scx">&gt;</span><span class="txt">Sailor, Messenger, Herald, Officers, Gentlemen, Musicians, and Attendants.</span><span class="ez">&lt;/</span><span class="cl">PERSONA</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">PERSONAE</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The stylesheet to render this as HTML can be written as a set of template rules:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:strip-space</span><span class="z"></span><span class="atn">elements</span><span class="atneq">=</span><span class="z">"</span><span class="av">PERSONAE</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">PERSONAE</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">html</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The Cast of </span><span class="op">{</span><span class="axis">@</span><span class="qname">PLAY</span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">html</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">TITLE</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h1</span><span class="scx">&gt;</span><span class="op">{</span><span class="context">.</span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">h1</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">PERSONA</span><span class="filter">[</span><span class="function">count</span><span class="parenthesis">(</span><span class="function">tokenize</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">,</span><span class="op">'</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="numeric">2</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">b</span><span class="scx">&gt;</span><span class="op">{</span><span class="function">substring-before</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">,</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">b</span><span class="ec">&gt;</span><span class="txt">: </span><span class="op">{</span><span class="function">substring-after</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">,</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">PERSONA</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">b</span><span class="scx">&gt;</span><span class="op">{</span><span class="context">.</span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">b</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>There are four template rules here:</p><ul><li><p>The first rule matches the outermost element, named <code>PERSONAE</code> (it could equally have used <code>match="/"</code> to match the document node). The effect of this rule is to create the skeleton of the output HTML page. Technically, the body of the template is a sequence constructor comprising a single <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> (the <code>html</code> element); this in turn contains a sequence constructor comprising two literal result elements (the <code>head</code> and <code>body</code> elements). The <code>head</code> element is populated with a literal <code>title</code> element whose content is computed as a mixture of fixed and variable text using a <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a>. The <code>body</code> element is populated by evaluating an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>The effect of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is to process the children of the <code>PERSONAE</code> element in the source tree: that is, the <code>TITLE</code> and <code>PERSONA</code> elements. (It would also process any whitespace text node children, but these have been stripped by virtue of the <a href="#element-strip-space"><code>xsl:strip-space</code></a> declaration.) Each of these child elements is processed by the best matching template rule for that element, which will be one of the other three rules in the stylesheet.</p></li><li><p>The template rule for the <code>TITLE</code> element outputs an <code>h1</code> element to the HTML result document, and populates this with the value of ".", the context item. That is, it copies the text content of the <code>TITLE</code> element to the output <code>h1</code> element.</p></li><li><p>The last two rules match <code>PERSONA</code> element. The first rule matches <code>PERSONA</code> elements whose text content contains exactly one comma; the second rule matches all <code>PERSONA</code> elements, but it has lower priority than the first rule, so in practice it only applies to <code>PERSONA</code> elements that contain no comma or multiple commas.</p><p>For both rules the body of the rule is a sequence constructor containing a single literal result element, the <code>p</code> element. These literal result elements contain further sequence constructors comprising literal result elements and text nodes. In each of these examples the text nodes are in the form of a <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a>: in general this is a combination of fixed text together with XPath expressions enclosed in curly braces, which are evaluated to form the content of the containing literal result element. </p></li></ul></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-template-rule" title="template rule"></a>A stylesheet contains a set of <b>template rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A template rule has three parts: a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that is matched against selected items (often but not necessarily nodes), a (possibly empty) set of <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>, and a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is evaluated to produce a sequence of items.<span class="definition">]</span> In many cases these items are newly constructed nodes, which are then written to a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p></div><div class="div2"><h3><a id="context"></a>2.6 <a href="#context" style="text-decoration: none">The Evaluation Context</a></h3><p>The results of some expressions and instructions in a stylesheet may depend on information provided contextually. This context information is divided into two categories: the static context, which is known during static analysis of the stylesheet, and the dynamic context, which is not known until the stylesheet is evaluated. Although information in the static context is known at analysis time, it is sometimes used during stylesheet evaluation.</p><p>Some context information can be set by means of declarations within the stylesheet itself. For example, the namespace bindings used for any XPath expression are determined by the namespace declarations present in containing elements in the stylesheet. Other information may be supplied externally or implicitly: an example is the current date and time.</p><p>The context information used in processing an XSLT stylesheet includes as a subset all the context information required when evaluating XPath expressions. The XPath 4.0 specification defines a static and dynamic context that the host language (in this case, XSLT) may initialize, which affects the results of XPath expressions used in that context. XSLT augments the context with additional information: this additional information is used firstly by XSLT constructs outside the scope of XPath (for example, the <a href="#element-sort"><code>xsl:sort</code></a> element), and secondly, by functions that are defined in the XSLT specification (such as <a href="#func-key"><code>key</code></a> and <a href="#func-current-group"><code>current-group</code></a>) that are available for use in XPath expressions appearing within a stylesheet.</p><p>The static context for an expression or other construct in a stylesheet is determined by the place in which it appears lexically. The details vary for different components of the static context, but in general, elements within a stylesheet module affect the static context for their descendant elements within the same stylesheet module.</p><p>The dynamic context is maintained as a stack. When an instruction or expression is evaluated, it may add dynamic context information to the stack; when evaluation is complete, the dynamic context reverts to its previous state. An expression that accesses information from the dynamic context always uses the value at the top of the stack.</p><p>The most commonly used component of the dynamic context is the <a title="context item" class="termref" href="#dt-context-item">context item</a>. This is an implicit variable whose value is the item currently being processed (it may be a node, an atomic value, or a function item). The value of the context item can be referenced within an XPath expression using the expression <code>.</code> (dot).</p><p>Full details of the static and dynamic context are provided in <a href="#static-and-dynamic-context"><i>5.3 The Static and Dynamic Context</i></a>.</p></div><div class="div2"><h3><a id="parsing-and-serialization"></a>2.7 <a href="#parsing-and-serialization" style="text-decoration: none">Parsing and Serialization</a></h3><p>An XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> describes a process that constructs a set of results from a set of inputs. The inputs are the data provided at stylesheet invocation, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. The results include the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> (an arbitrary sequence), which is the result of the initial component invocation, together with any <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a> produced using <a href="#element-result-document"><code>xsl:result-document</code></a> instructions. </p><p>The <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> does not describe how a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> is constructed. Some possible ways of constructing source trees are described in <a href="#xpath-datamodel-30">[XDM 3.0]</a>. Frequently an <a title="implementation" class="termref" href="#dt-implementation">implementation</a> will operate in conjunction with an XML parser (or more strictly, in the terminology of <a href="#REC-xml">[XML 1.0]</a>, an <em>XML processor</em>), to build a source tree from an input XML document. An implementation <span class="verb">may</span> also provide an application programming interface allowing the tree to be constructed directly, or allowing it to be supplied in the form of a DOM Document object (see <a href="#DOM-Level-2-Core">[DOM Level 2]</a>). This is outside the scope of this specification. Users should be aware, however, that since the input to the transformation is a tree conforming to the XDM data model as described in <a href="#xpath-datamodel-30">[XDM 3.0]</a>, constructs that might exist in the original XML document, or in the DOM, but which are not within the scope of the data model, cannot be processed by the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> and cannot be guaranteed to remain unchanged in the transformation output. Such constructs include CDATA section boundaries, the use of entity references, and the DOCTYPE declaration and internal DTD subset.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-serialization" title="serialization"></a>A frequent requirement is to output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as an XML document (or in other formats such as HTML). This process is referred to as <b>serialization</b>.<span class="definition">]</span></p><p>Like parsing, serialization is not part of the transformation process, and it is not <span class="verb">required</span> that an XSLT processor <span class="verb">must</span> be able to perform serialization. However, for pragmatic reasons, this specification describes declarations (the <a href="#element-output"><code>xsl:output</code></a> element and the <a href="#element-character-map"><code>xsl:character-map</code></a> declarations, see <a href="#serialization"><i>27 Serialization</i></a>), and attributes on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, that allow a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to specify the desired properties of a serialized output file. When serialization is not being performed, either because the implementation does not support the serialization option, or because the user is executing the transformation in a way that does not invoke serialization, then the content of the <a href="#element-output"><code>xsl:output</code></a> and <a href="#element-character-map"><code>xsl:character-map</code></a> declarations has no effect. Under these circumstances the processor <span class="verb">may</span> report any errors in an <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-character-map"><code>xsl:character-map</code></a> declaration, or in the serialization attributes of <a href="#element-result-document"><code>xsl:result-document</code></a>, but is not <span class="verb">required</span> to do so.</p></div><div class="div2"><h3><a id="packages-and-modules"></a>2.8 <a href="#packages-and-modules" style="text-decoration: none">Packages and Modules</a></h3><p>In XSLT 1.0 and 2.0 it was possible to structure a stylesheet as a collection of modules, using the <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> declarations to express the dependency of one module on others.</p><p>In XSLT 3.0 an additional layer of modularization of stylesheet code was enabled through the introduction of <a title="package" class="termref" href="#dt-package">packages</a>. A package is a collection of stylesheet modules with a controlled interface to the packages that use it: for example, it defines which functions and templates defined in the package are visible to callers, which are purely internal, and which are not only public but capable of being overridden by other functions and templates supplied by the using package.</p><p>Packages are introduced with several motivations, which broadly divide into two categories:</p><ol class="enumar"><li><p>Software engineering benefits: greater re-use of code, greater robustness through ease of testing, controlled evolution of code in response to new requirements, ability to deliver code that users cannot see or modify.</p></li><li><p>Efficiency benefits: the ability to avoid compiling libraries repeatedly when they are used in multiple stylesheets, and to avoid holding multiple copies of the same library in memory simultaneously.</p></li></ol><p>Packages are designed to allow separate compilation: that is, a package can be compiled independently of the packages that use it. This specification does not define a process model for compilation, or expand on what it means to compile different packages independently. Nor does it mandate that implementations offer any feature along these lines. It merely defines language features that are designed to make separate compilation of packages possible.</p><p>To achieve this, packages (unlike modules):</p><ul><li><p>Must not contain unresolved references to functions, templates, or variables declared in other packages;</p></li><li><p>Have strict rules governing the ability to override declarations in a <a title="library package" class="termref" href="#dt-library-package">library package</a> with declarations in a package that uses the library;</p></li><li><p>Constrain the visibility of component names and of context declarations such as the declarations of keys and decimal formats;</p></li><li><p>Can declare a mode (a collection of template rules) as final, which disallows the addition of new overriding template rules in a using package;</p></li><li><p>Require explicit disambiguation where naming conflicts arise, for example when a package uses two other packages that both export like-named components;</p></li><li><p>Allow multiple specializations of library components to coexist in the same application.</p></li></ul><p>A package is defined in XSLT by means of an XML document whose outermost element is an <a href="#element-package"><code>xsl:package</code></a> element. This is referred to as the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>. The <a href="#element-package"><code>xsl:package</code></a> element has optional child elements <a href="#element-use-package"><code>xsl:use-package</code></a> and <a href="#element-expose"><code>xsl:expose</code></a> describing properties of the package. The package manifest may refer to an external top-level stylesheet module using an <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> declaration, or it may contain the body of a stylesheet module inline (the two approaches can also be mixed).</p><p>Although this specification defines packages as constructs written using a defined XSLT syntax, implementations <span class="verb">may</span> provide mechanisms that allow packages to be written using other languages (for example, XQuery).</p><p>When no packages are explicitly defined, the entire stylesheet is treated as a single package; the effect is as if the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element of the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> were replaced by an <a href="#element-package"><code>xsl:package</code></a> element with no other information in the package manifest.</p></div><div class="div2"><h3><a id="extensibility"></a>2.9 <a href="#extensibility" style="text-decoration: none">Extensibility</a></h3><p>XSLT defines a number of features that allow the language to be extended by implementers, or, if implementers choose to provide the capability, by users. These features have been designed, so far as possible, so that they can be used without sacrificing interoperability. Extensions other than those explicitly defined in this specification are not permitted.</p><p>These features are all based on XML namespaces; namespaces are used to ensure that the extensions provided by one implementer do not clash with those of a different implementer.</p><p>The most common way of extending the language is by providing additional functions, which can be invoked from XPath expressions. These are known as <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>, and are described in <a href="#extension-functions"><i>25.1 Extension Functions</i></a>.</p><p>It is also permissible to extend the language by providing new <a title="instruction" class="termref" href="#dt-instruction">instructions</a>. These are referred to as <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, and are described in <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a>. A stylesheet that uses extension instructions in a particular namespace must declare that it is doing so by using the <code>[xsl:]extension-element-prefixes</code> attribute.</p><p>Extension instructions and extension functions defined according to these rules <span class="verb">may</span> be provided by the implementer of the XSLT processor, and the implementer <span class="verb">may</span> also provide facilities to allow users to create further extension instructions and extension functions.</p><p>This specification defines how extension instructions and extension functions are invoked, but the facilities for creating new extension instructions and extension functions are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. For further details, see <a href="#extension"><i>25 Extensibility and Fallback</i></a>.</p><p>The XSLT language can also be extended by the use of <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a> (see <a href="#extension-attributes"><i>3.2 Extension Attributes</i></a>), and by means of <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.7.3 User-defined Data Elements</i></a>).</p></div><div class="div2"><h3><a id="stylesheets-and-schemas"></a>2.10 <a href="#stylesheets-and-schemas" style="text-decoration: none">Stylesheets and XML Schemas</a></h3><p>An XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can make use of information from a schema. An XSLT transformation can take place in the absence of a schema (and, indeed, in the absence of a DTD), but where the source document has undergone schema validity assessment, the XSLT processor has access to the type information associated with individual nodes, not merely to the untyped text.</p><p>Information from a schema can be used both statically (when the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is compiled), and dynamically (during evaluation of the stylesheet to transform a source document).</p><p>There are places within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and within XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> and <a title="pattern" class="termref" href="#dt-pattern">patterns</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, where it is possible to refer to named type definitions in a schema, or to element and attribute declarations. For example, it is possible to declare the types expected for the parameters of a function. This is done using a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-type" title="SequenceType"></a>A <b>SequenceType</b> constrains the type and number of items in a sequence. The term is used both to denote the concept, and to refer to the syntactic form in which sequence types are expressed in the XPath grammar: specifically <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP40</small></sup> in <a href="#xpath-30">[XPath 3.0]</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-component" title="schema component"></a>Type definitions and element and attribute declarations are referred to collectively as <b>schema components</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-in-scope-schema-component" title="in-scope schema component"></a>The <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> that may be referenced by name in a <a title="package" class="termref" href="#dt-package">package</a> are referred to as the <b>in-scope schema components</b>.<span class="definition">]</span></p><p>The set of in-scope schema components may vary between one package and another, but as explained in <a href="#import-schema"><i>3.15 Importing Schema Components</i></a>, the schema components used in different packages must be consistent with each other.</p><p>The conformance rules for XSLT 4.0, defined in <a href="#conformance"><i>28 Conformance</i></a>, distinguish between a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a> and a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>. As the names suggest, a basic XSLT processor does not support the features of XSLT that require access to schema information, either statically or dynamically. A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that works with a basic XSLT processor will produce the same results with a schema-aware XSLT processor provided that the source documents are untyped (that is, they are not validated against a schema). However, if source documents are validated against a schema then the results may be different from the case where they are not validated. Some constructs that work on untyped data may fail with typed data (for example, an attribute of type <code>xs:date</code> cannot be used as an argument of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-substring"><code>substring</code></a><sup><small>FO30</small></sup> function) and other constructs may produce different results depending on the datatype (for example, given the element <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression <code>@price gt @discount</code> will return true if the attributes have type <code>xs:decimal</code>, but will return false if they are untyped).</p><p>There is a standard set of type definitions that are always available as <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> in every stylesheet. These are defined in <a href="#built-in-types"><i>3.14 Built-in Types</i></a>. </p><p>The remainder of this section describes facilities that are available only with a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>.</p><p>Additional <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> (type definitions, element declarations, and attribute declarations) may be added to the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> by means of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration in a stylesheet.</p><p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration may reference an external schema document by means of a URI, or it may contain an inline <code>xs:schema</code> element.</p><p>It is only necessary to import a schema explicitly if one or more of its <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> are referenced explicitly by name in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>; it is not necessary to import a schema merely because the stylesheet is used to process a source document that has been assessed against that schema. It is possible to make use of the information resulting from schema assessment (for example, the fact that a particular attribute holds a date) even if no schema has been imported by the stylesheet.</p><p>Importing a schema does not of itself say anything about the type of the source document that the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is expected to process. The imported type definitions can be used for temporary nodes or for nodes on a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> just as much as for nodes in source documents. It is possible to make assertions about the type of an input document by means of tests within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example:</p><div class="example"><div class="exampleHeader"><a id="d8e2782"></a><a id="d8e2854"></a>Example: Asserting the Required Type of the Source Document</div><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">typed</span><span class="atneq">=</span><span class="z">"</span><span class="av">lax</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:global-context-item</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="qname">required</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">document-node(schema-element(my:invoice))</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>This example will cause the transformation to fail with an error message, unless the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is valid against the top-level element declaration <code>my:invoice</code>, and has been annotated as such.</p><p>The setting <code>typed="lax"</code> further ensures that in any match pattern for a template rule in this mode, an element name that corresponds to the name of an element declaration in the schema is taken as referring to elements validated against that declaration: for example, <code>match="employee"</code> will only match a validated <code>employee</code> element. Selecting this option enables the XSLT processor to do more compile-time type-checking against the schema, for example it allows the processor to produce warning or error messages when path expressions contain misspelt element names, or confuse an element with an attribute.</p></div><p>It is also true that importing a schema does not of itself say anything about the structure of the result tree. It is possible to request validation of a result tree against the schema by using the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, for example:</p><div class="example"><div class="exampleHeader"><a id="d8e2804"></a><a id="d8e2876"></a>Example: Requesting Validation of the Result Document</div><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strict</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xhtml:html</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">xhtml:html</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This example will cause the transformation to fail with an error message unless the document element of the result document is valid against the top-level element declaration <code>xhtml:html</code>.</p></div><p>It is possible that a source document may contain nodes whose <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> is not one of the types imported by the stylesheet. This creates a potential problem because in the case of an expression such as <code>data(.) instance of xs:integer</code> the system needs to know whether the type named in the type annotation of the context node is derived by restriction from the type <code>xs:integer</code>. This information is not explicitly available in an XDM tree, as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>. The implementation may choose one of several strategies for dealing with this situation:</p><ol class="enumar"><li><p>The processor may signal a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a source document is found to contain a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that is not known to the processor.</p></li><li><p>The processor may maintain additional metadata, beyond that described in <a href="#xpath-datamodel-30">[XDM 3.0]</a>, that allows the source document to be processed as if all the necessary schema information had been imported using <a href="#element-import-schema"><code>xsl:import-schema</code></a>. Such metadata might be held in the data structure representing the source document itself, or it might be held in a system catalog or repository.</p></li><li><p>The processor may be configured to use a fixed set of schemas, which are automatically used to validate all source documents before they can be supplied as input to a transformation. In this case it is impossible for a source document to have a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the processor is not aware of.</p></li><li><p>The processor may be configured to treat the source document as if no schema processing had been performed, that is, effectively to strip all type annotations from elements and attributes on input, marking them instead as having type <code>xs:untyped</code> and <code>xs:untypedAtomic</code> respectively.</p></li></ol><p>Where a stylesheet author chooses to make assertions about the types of nodes or of <a title="variable" class="termref" href="#dt-variable">variables</a> and <a title="parameter" class="termref" href="#dt-parameter">parameters</a>, it is possible for an XSLT processor to perform static analysis of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (that is, analysis in the absence of any source document). Such analysis <span class="verb">may</span> reveal errors that would otherwise not be discovered until the transformation is actually executed. An XSLT processor is not <span class="verb">required</span> to perform such static type-checking. Under some circumstances (see <a href="#errors"><i>2.14 Error Handling</i></a>) type errors that are detected early <span class="verb">may</span> be reported as static errors. In addition an implementation <span class="verb">may</span> report any condition found during static analysis as a warning, provided that this does not prevent the stylesheet being evaluated as described by this specification.</p><p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can also control the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> of nodes that it constructs in a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. This can be done in a number of ways.</p><ul><li><p>It is possible to request explicit validation of a complete document, that is, a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> rooted at a document node. Validation is either strict or lax, as described in <a href="#xmlschema-1">[XML Schema Part 1]</a>. If validation of a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> fails (strictly speaking, if the outcome of the validity assessment is <code>invalid</code>), then the transformation fails, but in all other cases, the element and attribute nodes of the tree will be annotated with the names of the types to which these nodes conform. These <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> will be discarded if the result tree is serialized as an XML document, but they remain available when the result tree is passed to an application (perhaps another <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>) for further processing.</p></li><li><p>It is also possible to validate individual element and attribute nodes as they are constructed. This is done using the <code>type</code> and <code>validation</code> attributes of the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, and <a href="#element-copy-of"><code>xsl:copy-of</code></a> instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes of a literal result element.</p></li><li><p>When elements, attributes, or document nodes are copied, either explicitly using the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instructions, or implicitly when nodes in a sequence are attached to a new parent node, the options <code>validation="strip"</code> and <code>validation="preserve"</code> are available, to control whether existing <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> are to be retained or not.</p></li></ul><p>When nodes in a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> are validated, type information is available for use by operations carried out on the temporary tree, in the same way as for a source document that has undergone schema assessment.</p><p>For details of how validation of element and attribute nodes works, see <a href="#validation"><i>26.4 Validation</i></a>.</p></div><div class="div2"><h3><a id="streaming-concepts"></a>2.11 <a href="#streaming-concepts" style="text-decoration: none">Streaming</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streaming" title="streaming"></a>The term <b>streaming</b> refers to a manner of processing in which XML documents (such as source and result documents) are not represented by a complete tree of nodes occupying memory proportional to document size, but instead are processed “on the fly” as a sequence of events, similar in concept to the stream of events notified by an XML parser to represent markup in lexical XML.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streamed-document" title="streamed document"></a>A <b>streamed document</b> is a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> that is processed using streaming, that is, without constructing a complete tree of nodes in memory.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streamed-node" title="streamed node"></a>A <b>streamed node</b> is a node in a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a>.<span class="definition">]</span></p><p>Many processors implementing earlier versions of this specification adopted an architecture that allowed streaming of the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> directly to a serializer, without first materializing the complete result tree in memory. Streaming of the <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>, however, has proved to be more difficult without subsetting the language. This has created a situation where documents exceeding the capacity of virtual memory could not be transformed. XSLT 3.0 therefore introduced facilities allowing stylesheets to be written in a way that makes streaming of source documents possible, without excessive reliance on processor-specific optimization techniques.</p><p>Streaming achieves two important objectives: it allows large documents to be transformed without requiring correspondingly large amounts of memory; and it allows the processor to start producing output before it has finished receiving its input, thus reducing latency.</p><p>This specification does not attempt to legislate precisely which implementation techniques fall under the definition of streaming, and which do not. A number of techniques are available that reduce memory requirements, while still requiring a degree of buffering, or allocation of memory to partial results. A stylesheet that requests streaming of a source document is indicating that the processor should avoid assuming that the entire source document will fit in memory; in return, the stylesheet must be written in a way that makes streaming possible. This specification does not attempt to describe the algorithms that the processor should actually use, or to impose quantitative constraints on the resources that these algorithms should consume.</p><p>Nothing in this specification, nor in its predecessors <a href="#xslt">[XSLT 1.0]</a> and <a href="#xslt20">[XSLT 2.0]</a>, prevents a processor using streaming whenever it sees an opportunity to do so. However, experience has shown that in order to achieve streaming, it is often necessary to write stylesheet code in such a way as to make this possible. Therefore, XSLT provides explicit constructs allowing the stylesheet author to request streaming, and defines explicit static constraints on the structure of the code which are designed to make streaming possible.</p><p>A processor that claims conformance with the streaming option offers a guarantee that when streaming is requested for a source document, and when the stylesheet conforms to the rules that make the processing <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, then an algorithm will be adopted in which memory consumption is either completely independent of document size, or increases only very slowly as document size increases, allowing documents to be processed that are orders-of-magnitude larger than the physical memory available. A processor that does not claim conformance with the streaming option must still process a stylesheet and deliver the correct results, but is not required to use streaming algorithms, and may therefore fail with out-of-memory errors when presented with large source documents.</p><p>Apart from the fact that there are constructs to request streaming, and rules that must be followed to guarantee that streaming is possible, the language has been designed so there are as few differences as possible between streaming and non-streaming evaluation. The semantics of the language continue to be expressed in terms of the XDM data model, which is substantively unchanged; but readers must take care to observe that when terms like “node” and “axis” are used, the concepts are completely abstract and may have no direct representation in the run-time execution environment.</p><p>Streamed processing of a document can be initiated in one of three ways:</p><ul><li><p>The <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> can be declared as a <a title="streamable mode" class="termref" href="#dt-streamable-mode">streamable mode</a>. In this case the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> will generally be a document node (or sequence of document nodes), supplied by the calling application in a form that allows streaming (that is, in some form other than a tree in memory; for example, as a reference to a push or pull XML parser primed to deliver a stream of events). The type of these nodes can be constrained by using the attribute <code>on-no-match="fail"</code> on the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>, and using this mode only for processing the top-level nodes. </p></li><li><p>Streamed processing of any document can be initiated using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction. This has an attribute <code>href</code> whose value is the URI of a document to be processed, and an attribute <code>streamable</code> that indicates whether it is to be processed using streaming; the actual processing to be applied is defined by the instructions written as children of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction. </p></li><li><p>Streamed merging of a set of input documents can be initiated using the <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p></li></ul><p>The rules for streamability, which are defined in detail in <a href="#streamability"><i>19 Streamability</i></a>, impose two main constraints:</p><ul><li><p>The only nodes reachable from the node that is currently being processed are its attributes and namespaces, its ancestors and their attributes and namespaces, and its descendants and their attributes and namespaces. The siblings of the node, and the siblings of its ancestors, are not reachable in the tree, and any attempt to use their values is a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></li><li><p>When processing a given node in the tree, each descendant node can only be visited once. Essentially this allows two styles of processing: either visit each of the children once, and then process that child with the same restrictions applied; or process all the descendants in a single pass, in which case it is not possible while processing a descendant to make any further downward selection.</p></li></ul><p>The second restriction, that only one visit to the children is allowed, means that XSLT code that was not designed with streaming in mind will often need to be rewritten to make it streamable. In many cases it is possible to do this using a technique sometimes called <em>windowing</em> or <em>burst-mode streaming</em> (note this is not quite the same meaning as <em>windowing</em> in XQuery 3.0). Many XML documents consist of a large number of elements, each of manageable size, representing transactions or business objects where each such element can be processed independently: in such cases, an effective design pattern is to write a streaming transformation that takes a snapshot of each element in turn, processing the snapshot using the full power of the XSLT language. Each snapshot is a tree built in memory and is therefore fully navigable. For details see the <a href="#func-snapshot"><code>snapshot</code></a> and <a href="#func-copy-of"><code>copy-of</code></a> functions.</p><p>The new facility of <em>accumulators</em> allows applications complete control over how much information is retained (and by implication, how much memory is required) in the course of a pass over a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a>. An accumulator computes a value for every node in a streamed document: or more accurately, two values, one for the first visit to a node (before visiting its descendants), and a second value for the second visit to the node (after visiting the descendants). The computation is structured in such a way that the value for a given node can depend only on the value for the previous node in document order together with the data available when positioned at the current node (for example, the attribute values). Based on the well-established fold operation of functional programming languages, accumulators provide the convenience and economy of mutable variables while remaining within the constraints of a purely declarative processing model.</p><p>When streaming is initiated, for example using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, it is necessary to declare which accumulators are applicable to the streamed document.</p><p>Streaming applications often fall into one of the following categories:</p><ul><li><p>Aggregation applications, where a single aggregation operation (perhaps <a href="https://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>, or <a href="https://www.w3.org/TR/xpath-functions-30/#func-distinct-values"><code>distinct-values</code></a><sup><small>FO30</small></sup>) is applied to a set of elements selected from the streamed source document by means of a path expression.</p></li><li><p>Record-at-a-time applications, where the source document consists of a long sequence of elements with similar structure (“records”), and each “record” is processed using the same logic, independently of any other “records”. This kind of processing is facilitated using the <a href="#func-snapshot"><code>snapshot</code></a> and <a href="#func-copy-of"><code>copy-of</code></a> function mentioned earlier.</p></li><li><p>Grouping applications, where the output follows the structure of the input, except that an extra layer of hierarchy is added. For example, the input might be a flat series of banking transactions in date/time order, and the output might contain the same transactions grouped by date.</p></li><li><p>Accumulator applications, which are the same as record-at-a-time applications, except that the processing of one “record” might depend on data encountered earlier in the document. A classic example is processing a sequence of banking transactions in which the input transaction contains a debit or credit amount, and the output adds a running total (the account balance). The <a href="#element-iterate"><code>xsl:iterate</code></a> instruction has been introduced to facilitate this style of processing.</p></li><li><p>Isomorphic transformations, in which there is an ordered (often largely one-to-one) relationship between the nodes of the source tree and the nodes of the result tree: for example, transformations that involve only the renaming or selective deletion of nodes, or scalar manipulations of the values held in the leaf nodes. Such transformations are most conveniently expressed using recursive application of template rules. This is possible with a streamed input document only if all the template rules adhere to the constraints required for streamability. To enforce these rules, while still allowing unrestricted processing of other documents within the same transformation, all streaming evaluation must be carried out using a specific <a title="mode" class="termref" href="#dt-mode">mode</a>, which is declared to be a streaming mode by means of an <a href="#element-mode"><code>xsl:mode</code></a> declaration in the stylesheet.</p></li></ul><p>There are important classes of application in which streaming is possible only if multiple streams can be processed in parallel. This specification therefore provides facilities:</p><ol class="enumar"><li><p>allowing multiple sorted input sequences to be merged into one sorted output sequence (the <a href="#element-merge"><code>xsl:merge</code></a> instruction)</p></li><li><p>allowing multiple output sequences to be generated during a single pass of an input sequence (the <a href="#element-fork"><code>xsl:fork</code></a> instruction).</p></li></ol><p>These facilities have been designed in such a way that they can readily be implemented using streaming, that is, without materializing the input or output sequences in memory.</p></div><div class="div2"><h3><a id="streamed-validation"></a>2.12 <a href="#streamed-validation" style="text-decoration: none">Streamed Validation</a></h3><p>Streaming can be combined with schema-aware processing: that is, the streamed input to a transformation can be subjected to on-the-fly validation, a process which typically accepts an input stream from the XML parser and delivers an output stream (of type-annotated nodes) to the transformation processor. The XSD specification is designed so that validation is, with one or two exceptions, a streamable process. The exceptions include: </p><ul><li><p>There may be a need to allocate memory to hold keys, in order to enforce uniqueness and referential integrity constraints (<code>xs:unique</code>, <code>xs:key</code>, <code>xs:keyref</code>). </p></li><li><p>In XSD 1.1, assertions can be defined by means of XPath expressions. These are not constrained to be streamable; in the general case, any subtree of the document that is validated using an assertion may need to be buffered in memory while the assertion is processed. </p></li></ul><p>Applications that need to run in finite memory may therefore need to avoid these XSD features, or to use them with care. </p><p>XSD is designed so that the intended type of an element (the “governing type”) can be determined as soon as the start tag of the element is encountered: the process of validation checks whether the content of the element actually conforms to this type, and by the time the end tag is encountered, the process will have established either that the element is valid against the governing type, or that it is invalid. </p><p>By default, dynamic errors occurring during streamed processing are fatal: they typically cause the transformation to fail immediately. XSLT 3.0 introduced the ability to catch dynamic errors and recover from them. Schema invalidity, however, is treated as a dynamic error of the instruction that processes the entire input stream, so after a validation failure, no further processing of that input stream is possible. </p><p>In consequence, a streamed validator that is running in tandem with a streamed transformation can present the transformer with element nodes that carry a provisional type annotation representing the type that the element will have if it turns out to be valid. As soon as a node is encountered that violates this assumption, the validator should stop the flow of data to the transformer, so that the transformer never sees invalid data. This allows the stylesheet code to be compiled with the assumption of type-safety: at run-time, all nodes seen by the transformation will conform to their XSLT-declared types (for example, a type declared implicitly using <code>match="schema-element(invoice)"</code> on an <a href="#element-template"><code>xsl:template</code></a> element). </p><p>A streamed transformation that only accesses part of the input document (for example, a header at the start of a document) is not required to continue reading once the data it needs has been read. This means that XML well-formedness or validity errors occurring in the unread part of the input stream may go undetected. </p></div><div class="div2"><h3><a id="streaming-non-xml"></a>2.13 <a href="#streaming-non-xml" style="text-decoration: none">Streaming of non-XML data</a></h3><p>The facilities in this specification designed to enable large data sets to be processed in a streaming manner are oriented almost entirely to XML data. This does not mean that there is never a requirement to stream non-XML data, or that the Working Group has ignored this requirement; rather, the Working Group has concluded that for the most part, streaming of non-XML data can be achieved by implementations without the need for specific language features in XSLT.</p><p>To make streamed processing of unparsed text files easier, the function <a href="https://www.w3.org/TR/xpath-functions-30/#func-unparsed-text-lines"><code>unparsed-text-lines</code></a><sup><small>FO30</small></sup> has been introduced. This is not only more convenient for stylesheet authors than reading the entire input using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-unparsed-text"><code>unparsed-text</code></a><sup><small>FO30</small></sup> function and then tokenizing the result, it is also easier for implementations to optimize, allowing each line of text to be discarded from memory after it has been processed.</p><p>For all functions that access external data, including <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-unparsed-text"><code>unparsed-text</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-unparsed-text-lines"><code>unparsed-text-lines</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-json-doc"><code>json-doc</code></a><sup><small>FO40</small></sup>, the requirements on determinism can now be relaxed using <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> configuration options. This is significant because it means that when a transformation reads the same external resource more than once, it becomes legitimate for the contents of the resource to be different on different invocations, and this eliminates the need for the processor to cache the contents of the resource in memory.</p><p>In the XDM data model, every value is a sequence, and (as with most functional programming languages), processing of sequences of items is pervasive throughout the XSLT and XPath languages and their function library. Good performance of a functional programming language often depends on sequence-based operations being pipelined, and being evaluated in a lazy fashion (that is, many operations process items in a sequence one at a time, in order; and many operations can deliver a result without processing the entire sequence). The semantics of XSLT and XPath permit pipelined and lazy evaluation (for example, the error handling semantics are carefully written to ensure this), but they do not require it: the details are left to implementations. Pipelined processing of a sequence is not the same thing as streamed processing of a tree, and where the XSLT specification talks of operations being “guaranteed streamable”, this is always referring to processing of trees, not of sequences.</p><p>The facilities for streaming of XML trees include operations such as <a href="#func-copy-of"><code>copy-of</code></a> and <a href="#func-snapshot"><code>snapshot</code></a> which are able to take a sequence of streamed nodes as input, and produce a sequence of in-memory (unstreamed) nodes as output. It is also possible to generate a sequence of strings or other atomic values through the process of <a title="atomize" class="termref" href="#dt-atomization">atomization</a>. The actual memory usage of a streamed XSLT application may depend significantly on whether the processing of the resulting sequence of in-memory nodes or atomic values is pipelined or not. The specification, however, has nothing to say on this matter: it is considered an area where implementers can exercise their discretion and ingenuity.</p><p>Streaming of JSON input receives little attention in this specification. One can envisage an implementation of the <a href="#func-json-to-xml"><code>json-to-xml</code></a> function in which the XML delivered by the function consists of streamed nodes; but the Working Group has not researched the feasibility of such an implementation in any detail.</p></div><div class="div2"><h3><a id="errors"></a>2.14 <a href="#errors" style="text-decoration: none">Error Handling</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-static-error" title="static error"></a>An error that can be detected by examining a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> before execution starts (that is, before the source document and values of stylesheet parameters are available) is referred to as a <b>static error</b>.<span class="definition">]</span></p><p>Generally, errors in the structure of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, or in the syntax of XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> contained in the stylesheet, are classified as <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Where this specification states that an element in the stylesheet <span class="verb">must</span> or <span class="verb">must not</span> appear in a certain position, or that it <span class="verb">must</span> or <span class="verb">must not</span> have a particular attribute, or that an attribute <span class="verb">must</span> or <span class="verb">must not</span> have a value satisfying specified conditions, then any contravention of this rule is a static error unless otherwise specified. </p><p>A processor <span class="verb">must</span> provide a mode of operation that takes a (possibly erroneous) stylesheet <a title="package" class="termref" href="#dt-package">package</a> as input and enables the user to determine whether or not that package contains any <a title="static error" class="termref" href="#dt-static-error">static errors</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The manner in which static errors are reported, and the behavior when there are multiple static errors, are left as design choices for the implementer. It is <span class="verb">recommended</span> that the error codes defined in this specification should be made available in any diagnostics. </p></div><p>A processor <span class="verb">may</span> also provide a mode of operation in which <a title="static error" class="termref" href="#dt-static-error">static errors</a> in parts of the stylesheet that are not evaluated can go unreported. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, when operating in this mode, a processor might report static errors in a template rule only if the input document contains nodes that match that template rule. Such a mode of operation can provide performance benefits when large and well-tested stylesheets are used to process source documents that might only use a small part of the XML vocabulary that the stylesheet is designed to handle. </p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-dynamic-error" title="dynamic error"></a>An error that is not capable of detection until a source document is being transformed is referred to as a <b>dynamic error</b>.<span class="definition">]</span></p><p>When a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs, and is not caught using <a href="#element-catch"><code>xsl:catch</code></a>, the <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">must</span> signal the error, and the transformation fails.</p><p>Because different implementations may optimize execution of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> in different ways, the detection of dynamic errors is to some degree <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. In cases where an implementation is able to produce a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> without evaluating a particular construct, the implementation is never <span class="verb">required</span> to evaluate that construct solely in order to determine whether doing so causes a dynamic error. For example, if a <a title="variable" class="termref" href="#dt-variable">variable</a> is declared but never referenced, an implementation <span class="verb">may</span> choose whether or not to evaluate the variable declaration, which means that if evaluating the variable declaration causes a dynamic error, some implementations will signal this error and others will not.</p><p>There are some cases where this specification requires that a construct <span class="verb">must not</span> be evaluated: for example, the content of an <a href="#element-if"><code>xsl:if</code></a> instruction <span class="verb">must not</span> be evaluated if the test condition is false. This means that an implementation <span class="verb">must not</span> signal any dynamic errors that would arise if the construct were evaluated.</p><p>An implementation <span class="verb">may</span> signal a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> before any source document is available, but only if it can determine that the error would be signaled for every possible source document and every possible set of parameter values. For example, some <a title="circularity" class="termref" href="#dt-circularity">circularity</a> errors fall into this category: see <a href="#circularity"><i>9.11 Circular Definitions</i></a>.</p><p>There are also some <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> where the specification gives a processor license to signal the error during the analysis phase even if the construct might never be executed; an example is the use of an invalid QName as a literal argument to a function such as <a href="#func-key"><code>key</code></a>, or the use of an invalid regular expression in the <code>regex</code> attribute of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction.</p><p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> is also signaled during the static analysis phase if the error occurs during evaluation of a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>.</p><p>The XPath specification states (see <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-kinds-of-errors">Section 2.4.1 Kinds of Errors</a><sup><small>XP40</small></sup>) that if any expression (at any level) can be evaluated during the analysis phase (because all its explicit operands are known and it has no dependencies on the dynamic context), then any error in performing this evaluation <span class="verb">may</span> be reported as a static error. For XPath expressions used in an XSLT stylesheet, however, any such errors <span class="verb">must not</span> be reported as static errors in the stylesheet unless they would occur in every possible evaluation of that stylesheet; instead, they must be signaled as dynamic errors, and signaled only if the XPath expression is actually evaluated.</p><div class="example"><div class="exampleHeader"><a id="d8e3323"></a><a id="d8e3395"></a>Example: Errors in Constant Subexpressions</div><p>An XPath processor may report statically that the expression <code>1 div 0</code> fails with a “divide by zero” error. But suppose this XPath expression occurs in an XSLT construct such as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">system-property</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">xsl:version</span><span class="op">'</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="op">'</span><span class="literal">1.0</span><span class="op">'</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">div</span><span class="whitespace"></span><span class="numeric">0</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:double</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">INF</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Then the XSLT processor must not report an error, because the relevant XPath construct appears in a context where it will never be executed by an XSLT <span>4.0</span>. (An XSLT 1.0 processor will execute this code successfully, returning positive infinity, because it uses double arithmetic rather than decimal arithmetic.)</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-type-error" title="type error"></a>Certain errors are classified as <b>type errors</b>. A type error occurs when the value supplied as input to an operation is of the wrong type for that operation, for example when an integer is supplied to an operation that expects a node.<span class="definition">]</span> If a type error occurs in an instruction that is actually evaluated, then it <span class="verb">must</span> be signaled in the same way as a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a>. Alternatively, an implementation <span class="verb">may</span> signal a type error during the analysis phase in the same way as a <a title="static error" class="termref" href="#dt-static-error">static error</a>, even if it occurs in part of the stylesheet that is never evaluated, provided it can establish that execution of a particular construct would never succeed.</p><p>It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether type errors are signaled statically.</p><div class="example"><div class="exampleHeader"><a id="d8e3361"></a><a id="d8e3433"></a>Example: A Type Error</div><p>The following construct contains a type error, because <code>42</code> is not allowed as the value of the <code>select</code> expression of the <a href="#element-number"><code>xsl:number</code></a> instruction (it must be a node). An implementation <span class="verb">may</span> optionally signal this as a static error, even though the offending instruction will never be evaluated, and the type error would therefore never be signaled as a dynamic error.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">false</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">42</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>On the other hand, in the following example it is not possible to determine statically whether the operand of <a href="#element-number"><code>xsl:number</code></a> will have a suitable dynamic type. An implementation <span class="verb">may</span> produce a warning in such cases, but it <span class="verb">must not</span> treat it as an error.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">para</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">p</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">item()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$p</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>If more than one error arises, an implementation is not <span class="verb">required</span> to signal any errors other than the first one that it detects. It is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> which of the several errors is signaled. This applies both to static errors and to dynamic errors. An implementation is allowed to signal more than one error, but if any errors have been signaled, it <span class="verb">must not</span> finish as if the transformation were successful.</p><p>When a transformation signals one or more dynamic errors, the final state of any persistent resources updated by the transformation is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Implementations are not <span class="verb">required</span> to restore such resources to their initial state. In particular, where a transformation produces multiple result documents, it is possible that one or more serialized result documents <span class="verb">may</span> be written successfully before the transformation terminates, but the application cannot rely on this behavior.</p><p>Everything said above about error handling applies equally to errors in evaluating XSLT instructions, and errors in evaluating XPath <a title="expression" class="termref" href="#dt-expression">expressions</a>. Static errors and dynamic errors may occur in both cases.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-serialization-error" title="serialization error"></a>If a transformation has successfully produced a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>, it is still possible that errors may occur in serializing that result . For example, it may be impossible to serialize the result using the encoding selected by the user. Such an error is referred to as a <b>serialization error</b>.<span class="definition">]</span> If the processor performs serialization, then it <span class="verb">must</span> do so as specified in <a href="#serialization"><i>27 Serialization</i></a>, and in particular it <span class="verb">must</span> signal any serialization errors that occur.</p><p>Errors are identified by a QName. For errors defined in this specification, the namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and is therefore not given explicitly), while the local part is an 8-character code in the form <var>PPSSNNNN</var>. Here <var>PP</var> is always <code>XT</code> (meaning XSLT), and <var>SS</var> is one of <code>SE</code> (static error), <code>DE</code> (dynamic error), or <code>TE</code> (type error). Note that the allocation of an error to one of these categories is purely for convenience and carries no normative implications about the way the error is handled. Many errors, for example, can be reported either dynamically or statically. These error codes are used to label error conditions in this specification, and are summarized in <a href="#error-summary"><i>E Summary of Error Conditions</i></a>. </p><p>Errors defined in related specifications (<a href="#xpath-40">[XPath 4.0]</a>, <a href="#xpath-functions-40">[Functions and Operators 4.0]</a><a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>) use QNames with a similar structure, in the same namespace. When errors occur in processing XPath expressions, an XSLT processor <span class="verb">should</span> use the original error code reported by the XPath processor, unless a more specific XSLT error code is available.</p><p>Implementations <span class="verb">must</span> use the codes defined in these specifications when signaling dynamic errors, to ensure that <a href="#element-catch"><code>xsl:catch</code></a> behaves in an interoperable way across implementations. Stylesheet authors should note, however, that there are many examples of errors where more than one rule in this specification is violated, and where the processor therefore has discretion in deciding which error code to associate with the condition: there is therefore no guarantee that different processors will always use the same error code for the same erroneous input.</p><p>Additional errors defined by an implementation (or by an application) <span class="verb">may</span> use QNames in an implementation-defined (or user-defined) namespace without risk of collision.</p></div></div><div class="div1"><h2><a id="stylesheet-structure"></a>3 <a href="#stylesheet-structure" style="text-decoration: none">Stylesheet Structure</a></h2><p>This section describes the overall structure of a stylesheet as a collection of XML documents.</p><div class="div2"><h3><a id="xslt-namespace"></a>3.1 <a href="#xslt-namespace" style="text-decoration: none">XSLT Namespace</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-namespace" title="XSLT namespace"></a>The <b>XSLT namespace</b> has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify elements, attributes, and other names that have a special meaning defined in this specification.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>1999</code> in the URI indicates the year in which the URI was allocated by the W3C. It does not indicate the version of XSLT being used, which is specified by attributes (see <a href="#stylesheet-element"><i>3.7 Stylesheet Element</i></a> and <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>).</p></div><p>XSLT <a title="processor" class="termref" href="#dt-processor">processors</a><span class="verb">must</span> use the XML namespaces mechanism <a href="#xml-names">[Namespaces in XML]</a> to recognize elements and attributes from this namespace. Elements from the XSLT namespace are recognized only in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> and not in the source document. The complete list of XSLT-defined elements is specified in <a href="#element-syntax-summary"><i>D Element Syntax Summary</i></a>. <a title="implementation" class="termref" href="#dt-implementation">Implementations</a><span class="verb">must not</span> extend the XSLT namespace with additional elements or attributes. Instead, any extension <span class="verb">must</span> be in a separate namespace. Any namespace that is used for additional instruction elements <span class="verb">must</span> be identified by means of the <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism specified in <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a>.</p><p>Except where the rules for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> dictate otherwise, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for any element in the stylesheet to be in the XSLT namespace unless it is an element defined in this specification <span class="error">[see <a href="#err-XTSE0010">ERR XTSE0010</a>]</span>.</p><p>This specification uses a prefix of <code>xsl:</code> for referring to elements in the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided that there is a namespace declaration that binds the prefix to the URI of the XSLT namespace.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Throughout this specification, an element or attribute that is in no namespace, or an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> whose namespace part is an empty sequence, is referred to as having a <b>null namespace URI</b>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>By convention, the names of <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>, attributes and functions are all lower-case; they use hyphens to separate words, and they use abbreviations only if these already appear in the syntax of a related language such as XML or HTML. Names of types defined in XML Schema are regarded as single words and are capitalized exactly as in XML Schema. This sometimes leads to composite function names such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>current-dateTime</code></a><sup><small>FO30</small></sup>.</p></div></div><div class="div2"><h3><a id="extension-attributes"></a>3.2 <a href="#extension-attributes" style="text-decoration: none">Extension Attributes</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-attribute" title="extension attribute"></a>An element from the XSLT namespace may have any attribute not from the XSLT namespace, provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (see <a href="#xpath-30">[XPath 3.0]</a>) of the attribute has a non-null namespace URI. These attributes are referred to as <b>extension attributes</b>.<span class="definition">]</span> The presence of an extension attribute <span class="verb">must not</span> cause the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or any <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> of the transformation to be different from the results that a conformant XSLT 4.0 processor might produce. They <span class="verb">must not</span> cause the processor to fail to signal an error that a conformant processor is required to signal. This means that an extension attribute <span class="verb">must not</span> change the effect of any <a title="instruction" class="termref" href="#dt-instruction">instruction</a> except to the extent that the effect is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> or <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>Furthermore, if serialization is performed using one of the serialization methods described in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>, the presence of an extension attribute must not cause the serializer to behave in a way that is inconsistent with the mandatory provisions of that specification.</p><div class="note"><p class="prefix"><b>Note:</b></p><p><a title="extension attribute" class="termref" href="#dt-extension-attribute">Extension attributes</a> may be used to modify the behavior of <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> and <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>. They may be used to select processing options in cases where the specification leaves the behavior <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> or <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. They may also be used for optimization hints, for diagnostics, or for documentation.</p><p><a title="extension attribute" class="termref" href="#dt-extension-attribute">Extension attributes</a> may also be used to influence the behavior of the serialization methods <code>xml</code>, <code>xhtml</code>, <code>html</code>, or <code>text</code>, to the extent that the behavior of the serialization method is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> or <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. For example, an extension attribute might be used to define the amount of indentation to be used when <code>indent="yes"</code> is specified. If a serialization method other than one of these four is requested (using a prefixed QName in the method parameter) then extension attributes may influence its behavior in arbitrary ways. Extension attributes must not be used to cause the standard serialization methods to behave in a non-conformant way, for example by failing to report serialization errors that a serializer is required to report. An implementation that wishes to provide such options must create a new serialization method for the purpose.</p><p>An implementation that does not recognize the name of an extension attribute, or that does not recognize its value, must perform the transformation as if the extension attribute were not present. As always, it is permissible to produce warning messages.</p><p>The namespace used for an extension attribute will be copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> in the normal way if it is in scope for a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. This can be prevented using the <code>[xsl:]exclude-result-prefixes</code> attribute.</p></div><div class="example"><div class="exampleHeader"><a id="d8e3708"></a>Example: An Extension Attribute for <code>xsl:message</code><a id="d8e3708"></a>Example: An Extension Attribute for <code>xsl:message</code></div><p>The following code might be used to indicate to a particular implementation that the <a href="#element-message"><code>xsl:message</code></a> instruction is to ask the user for confirmation before continuing with the transformation:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="z"></span><span class="atn">abc:pause</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:abc</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://vendor.example.com/xslt/extensions</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"> Phase 1 complete </span><span class="ez">&lt;/</span><span class="clxsl">xsl:message</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Implementations that do not recognize the namespace <code>http://vendor.example.com/xslt/extensions</code> will simply ignore the extra attribute, and evaluate the <a href="#element-message"><code>xsl:message</code></a> instruction in the normal way.</p></div><p><a id="err-XTSE0090"><span class="error">[ERR XTSE0090] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an element from the XSLT namespace to have an attribute whose namespace is either null (that is, an attribute with an unprefixed name) or the XSLT namespace, other than attributes defined for the element in this document. </p></div><div class="div2"><h3><a id="xslt-media-type"></a>3.3 <a href="#xslt-media-type" style="text-decoration: none">XSLT Media Type</a></h3><p>The media type <code>application/xslt+xml</code> has been registered for XSLT stylesheet modules.</p><p>The definition of the media type is at <a href="#XSLT-Mime-Type">[XSLT Media Type]</a>.</p><p>This media type <span class="verb">should</span> be used for an XML document containing a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> at its top level, and it <span class="verb">may</span> also be used for a <a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module">simplified stylesheet module</a>. It <span class="verb">should not</span> be used for an XML document containing an <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a>.</p></div><div class="div2"><h3><a id="standard-attributes"></a>3.4 <a href="#standard-attributes" style="text-decoration: none">Standard Attributes</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-attributes" title="standard attributes"></a>There are a number of <b>standard attributes</b> that may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>: specifically <code>default-collation</code>, <code>default-element-namespace</code>, <code>default-mode</code>, <code>default-type-namespace</code>, <code>default-validation</code>, <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>, <code>use-when</code>, <code>version</code>, and <code>xpath-default-namespace</code>.<span class="definition">]</span></p><p>These attributes may also appear on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, but in this case, to distinguish them from user-defined attributes, the names of the attributes are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. They are thus typically written as <code>xsl:default-collation</code>, <code>xsl:default-element-namespace</code>, <code>xsl:default-mode</code>, <code>xsl:default-type-namespace</code>, <code>xsl:default-validation</code>, <code>xsl:exclude-result-prefixes</code>, <code>xsl:expand-text</code>, <code>xsl:extension-element-prefixes</code>, <code>xsl:use-when</code>, <code>xsl:version</code>, or <code>xsl:xpath-default-namespace</code>.</p><p>It is <span class="verb">recommended</span> that all these attributes should also be permitted on <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, but this is at the discretion of the implementer of each extension instruction. They <span class="verb">may</span> also be permitted on <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>, though they will only have any useful effect in the case of data elements that are designed to behave like XSLT declarations or instructions.</p><p>In the following descriptions, these attributes are referred to generically as <code>[xsl:]version</code>, and so on.</p><p>These attributes all affect the element they appear on, together with any elements and attributes that have that element as an ancestor. The two forms with and without the XSLT namespace have the same effect; the XSLT namespace is used for the attribute if and only if its parent element is <em>not</em> in the XSLT namespace.</p><p><span style="display: none;" class="delete_version">In the case of <code>[xsl:]default-collation</code>, <code>[xsl:]default-element-namespace</code>, <code>[xsl:]default-type-namespace</code>, <code>[xsl:]expand-text</code>, <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value can be overridden by a different value for the same attribute appearing on a descendant element. The effective value of the attribute for a particular stylesheet element is determined by the innermost ancestor-or-self element on which the attribute appears.</span><span style="display: none;" class="add_version">In the case of <code>[xsl:]default-collation</code>, <code>[xsl:]default-element-namespace</code>, <code>[xsl:]default-type-namespace</code>, <code>[xsl:]expand-text</code>, <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value can be overridden by a different value for the same attribute appearing on a descendant element. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute for a particular stylesheet element is determined by the innermost ancestor-or-self element on which the attribute appears.</span><span class="modify_version">In the case of <code>[xsl:]default-collation</code>, <code>[xsl:]default-element-namespace</code>, <code>[xsl:]default-type-namespace</code>, <code>[xsl:]expand-text</code>, <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value can be overridden by a different value for the same attribute appearing on a descendant element. The <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the attribute for a particular stylesheet element is determined by the innermost ancestor-or-self element on which the attribute appears.</span></p><p>In an <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a>, <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attributes</a> appearing on ancestors of the outermost element of the stylesheet module have no effect.</p><p><span style="display: none;" class="delete_version">In the case of <code>[xsl:]exclude-result-prefixes</code> and <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these attributes, the value is given as a whitespace-separated list of namespace prefixes, and the effective value for an element is the combined set of namespace URIs designated by the prefixes that appear in this attribute for that element and any of its ancestor elements. Again, the two forms with and without the XSLT namespace are equivalent.</span><span style="display: none;" class="add_version">In the case of <code>[xsl:]exclude-result-prefixes</code> and <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these attributes, the value is given as a whitespace-separated list of namespace prefixes, and the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> for an element is the combined set of namespace URIs designated by the prefixes that appear in this attribute for that element and any of its ancestor elements. Again, the two forms with and without the XSLT namespace are equivalent.</span><span class="modify_version">In the case of <code>[xsl:]exclude-result-prefixes</code> and <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these attributes, the value is given as a whitespace-separated list of namespace prefixes, and the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>for an element is the combined set of namespace URIs designated by the prefixes that appear in this attribute for that element and any of its ancestor elements. Again, the two forms with and without the XSLT namespace are equivalent.</span></p><p>The effect of the <code>[xsl:]use-when</code> attribute is described in <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>.</p><p>Because these attributes may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, they are not listed in the syntax summary of each individual element. Instead they are listed and described in the entry for the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, and <a href="#element-package"><code>xsl:package</code></a> elements only. This reflects the fact that these attributes are often used on the outermost element of the stylesheet, in which case they apply to the entire <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>.</p><p>Note that the effect of these attributes does <em>not</em> extend to <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> referenced by <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> declarations, nor to packages referenced using <a href="#element-use-package"><code>xsl:use-package</code></a>.</p><p>For the detailed effect of each attribute, see the following sections:</p><dl><dt class="label"><code>[xsl:]default-collation</code></dt><dd><p>see <a href="#default-collation-attribute"><i>3.7.1 The default-collation Attribute</i></a></p></dd><dt class="label"><code>[xsl:]default-element-namespace</code></dt><dd><p>see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a></p></dd><dt class="label"><code>[xsl:]default-mode</code></dt><dd><p>see <a href="#default-mode"><i>3.7.2 The default-mode Attribute</i></a></p></dd><dt class="label"><code>[xsl:]default-type-namespace</code></dt><dd><p>see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a></p></dd><dt class="label"><code>[xsl:]default-validation</code></dt><dd><p>see <a href="#validation"><i>26.4 Validation</i></a></p></dd><dt class="label"><code>[xsl:]exclude-result-prefixes</code></dt><dd><p>see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a></p></dd><dt class="label"><code>[xsl:]expand-text</code></dt><dd><p>see <a href="#text-value-templates"><i>5.7.2 Text Value Templates</i></a></p></dd><dt class="label"><code>[xsl:]extension-element-prefixes</code></dt><dd><p>see <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a></p></dd><dt class="label"><code>[xsl:]use-when</code></dt><dd><p>see <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a></p></dd><dt class="label"><code>[xsl:]version</code></dt><dd><p>see <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a> and <a href="#forwards"><i>3.10 Forwards Compatible Processing</i></a></p></dd><dt class="label"><code>[xsl:]xpath-default-namespace</code></dt><dd><p>see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a></p></dd></dl></div><div class="div2"><h3><a id="packages"></a>3.5 <a href="#packages" style="text-decoration: none">Packages</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-package" title="package"></a>An explicit <b>package</b> is represented by an <a href="#element-package"><code>xsl:package</code></a> element, which will generally be the outermost element of an XML document. When the <a href="#element-package"><code>xsl:package</code></a> element is not used explicitly, the entire stylesheet comprises a single implicit package.<span class="definition">]</span> (This specification does not preclude the <a href="#element-package"><code>xsl:package</code></a> being embedded in another XML document, but it will never have any other XSLT element as an ancestor).</p><p class="element-syntax"><a id="element-package"></a><code>&lt;xsl:package<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;name? = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"<br>&nbsp;&nbsp;declared-modes? = <var>boolean</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;default-element-namespace? = <var>uri</var><br>&nbsp;&nbsp;default-type-namespace? = <var>uri</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;use-when? = <var>expression</var><br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-expose">xsl:expose</a> | <var>declarations</var>)*) --&gt;<br>&lt;/xsl:package&gt;</code></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-package-manifest" title="package manifest"></a>The content of the <a href="#element-package"><code>xsl:package</code></a> element is referred to as the <b>package manifest</b><span class="definition">]</span>.</p><p>The <code>version</code> attribute indicates the version of the XSLT language specification to which the package manifest conforms. The value <span class="verb">should</span> normally be <span><code>4.0</code></span>. If the value is numerically less than <span><code>4.0</code></span>, the content of the <a href="#element-package"><code>xsl:package</code></a> element is processed using the rules for <a title="backwards compatible behavior" class="termref" href="#dt-backwards-compatible-behavior">backwards compatible behavior</a> (see <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>). If the value is numerically greater than <span><code>4.0</code></span>, it is processed using the rules for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.10 Forwards Compatible Processing</i></a>).</p><p>A package typically has a name, given in its <code>name</code> attribute, which <span class="verb">must</span> be an absolute URI. Unnamed packages are allowed, but they can only be used as the “top level” of an application; they cannot be the target of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration in another package.</p><p>A package may have a version identifier, given in its <code>package-version</code> attribute. This is used to distinguish different versions of a package. The value of the version attribute, after trimming leading and trailing whitespace, <span class="verb">must</span> conform to the syntax given in <a href="#package-versions"><i>3.5.1 Versions of a Package</i></a>. If no version number is specified for a package, version <code>1</code> is assumed.</p><p>The attributes <code>default-collation</code>, <code>default-mode</code>, <code>default-validation</code>, <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>, <code>use-when</code>, <code>version</code>, and <code>xpath-default-namespace</code> are standard attributes that can appear on any XSLT element, and potentially affect all descendant elements. Their meaning is described in <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>.</p><p>The package manifest contains the following elements, arbitrarily ordered:</p><ol class="enumar"><li><p>Zero or more <a href="#element-expose"><code>xsl:expose</code></a> declarations that define the interface offered by this package to the outside world. An <a href="#element-expose"><code>xsl:expose</code></a> declaration may appear only as a child of <a href="#element-package"><code>xsl:package</code></a>.</p></li><li><p>Zero or more additional <a title="declaration" class="termref" href="#dt-declaration">declarations</a>. These are the same as the declarations permitted as children of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a>.</p><p>Some declarations of particular relevance to packages include:</p><ol class="enumla"><li><p>The <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, which declares the names and versions of the packages on which this package is dependant.</p></li><li><p>The optional <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element; if present this element defines constraints on the existence and type of the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p></li><li><p>Zero or more <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> declarations, which define additional stylesheet modules to be incorporated into this package.</p></li><li><p><span style="display: none;" class="delete_version">Zero or more ordinary <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, that is, elements that are permitted as children of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a>. One possible coding style is to include in the package manifest just a single <a href="#element-import"><code>xsl:import</code></a> or <a href="#element-include"><code>xsl:include</code></a> declaration as a reference to the effective top-level stylesheet module; this approach is particularly suitable when writing code that is required to run under earlier releases of XSLT as well as under XSLT 3.0 <span>and 4.0</span>. Another approach is to include the substance of the top-level stylesheet module inline within the package manifest.</span><span style="display: none;" class="add_version">Zero or more ordinary <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, that is, elements that are permitted as children of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a>. One possible coding style is to include in the package manifest just a single <a href="#element-import"><code>xsl:import</code></a> or <a href="#element-include"><code>xsl:include</code></a> declaration as a reference to the effective top-level stylesheet module; this approach is particularly suitable when writing code that is required to run under releases of XSLT <span>earlier than 3.0</span>. Another approach is to include the substance of the top-level stylesheet module inline within the package manifest.</span><span class="modify_version">Zero or more ordinary <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, that is, elements that are permitted as children of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a>. One possible coding style is to include in the package manifest just a single <a href="#element-import"><code>xsl:import</code></a> or <a href="#element-include"><code>xsl:include</code></a> declaration as a reference to the effective top-level stylesheet module; this approach is particularly suitable when writing code that is required to run under <span class="deltaxml-old" style="background:#FF5555">earlier </span>releases of XSLT <span><span class="deltaxml-old" style="background:#FF5555">as well as under XSLT</span><span class="deltaxml-new" style="background:#90EE90">earlier than</span> 3.0<span class="deltaxml-old" style="background:#FF5555"> </span><span class="deltaxml-old" style="background:#FF5555">and 4.0</span></span>. Another approach is to include the substance of the top-level stylesheet module inline within the package manifest.</span></p></li></ol></li></ol><div class="example"><div class="exampleHeader"><a id="d8e4155"></a><a id="d8e4231"></a>Example: An example package</div><p>The following example shows a package that offers a number of functions for manipulating complex numbers. A complex number is represented as a map with two entries, the keys being 0 for the real part, and 1 for the imaginary part.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.org/complex-arithmetic.xsl</span><span class="z">"</span><span class="z"></span><span class="atn">package-version</span><span class="atneq">=</span><span class="z">"</span><span class="av">1.0</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xs</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:f</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.org/complex-arithmetic.xsl</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:complex-number</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">real</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">imaginary</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="whitespace"></span><span class="numeric">0</span><span class="op">:</span><span class="variable">$real</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">1</span><span class="op">:</span><span class="variable">$imaginary</span><span class="whitespace"></span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:real</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">complex</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">$complex</span><span class="parenthesis">(</span><span class="numeric">0</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:imag</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">complex</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">$complex</span><span class="parenthesis">(</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:add</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">x</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">y</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="whitespace"></span><span class="function">f:complex-number</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="function">f:real</span><span class="parenthesis">(</span><span class="variable">$x</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">f:real</span><span class="parenthesis">(</span><span class="variable">$y</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="function">f:imag</span><span class="parenthesis">(</span><span class="variable">$x</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">f:imag</span><span class="parenthesis">(</span><span class="variable">$y</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:multiply</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">x</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">y</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:integer, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="whitespace"></span><span class="function">f:complex-number</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="function">f:real</span><span class="parenthesis">(</span><span class="variable">$x</span><span class="parenthesis">)</span><span class="function">*f:real</span><span class="parenthesis">(</span><span class="variable">$y</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">-</span><span class="whitespace"></span><span class="function">f:imag</span><span class="parenthesis">(</span><span class="variable">$x</span><span class="parenthesis">)</span><span class="function">*f:imag</span><span class="parenthesis">(</span><span class="variable">$y</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="function">f:real</span><span class="parenthesis">(</span><span class="variable">$x</span><span class="parenthesis">)</span><span class="function">*f:imag</span><span class="parenthesis">(</span><span class="variable">$y</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">f:imag</span><span class="parenthesis">(</span><span class="variable">$x</span><span class="parenthesis">)</span><span class="function">*f:real</span><span class="parenthesis">(</span><span class="variable">$y</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> etc. </span><span class="z">--&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:package</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>A more complex package might include private or abstract functions as well as public functions; it might expose components other than functions (for example, templates or global variables), and it might contain <a href="#element-use-package"><code>xsl:use-package</code></a> elements to allow it to call on the services of other packages.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In this example, the way in which complex numbers are represented is exposed to users of the package. It would be possible to hide the representation by declaring the types on public functions simply as <code>item()</code>; but this would be at the cost of type safety.</p></div></div><p>A package that does not itself expose any components may be written using a simplified syntax: the <a href="#element-package"><code>xsl:package</code></a> element is omitted, and the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element is now the outermost element of the stylesheet module. For compatibility reasons, all the named templates and modes declared in the package are made public. More formally, the principal stylesheet module of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> may be expressed as an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element, which is equivalent to the package represented by the output of the following transformation, preserving the base URI of the source:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:transform</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:t</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/TransformAlias</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:namespace-alias</span><span class="z"></span><span class="atn">stylesheet-prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">t</span><span class="z">"</span><span class="z"></span><span class="atn">result-prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">xsl:stylesheet</span><span class="op">|</span><span class="qname">xsl:transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">t:package</span><span class="z"></span><span class="atn">declared-modes</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">t:expose</span><span class="z"></span><span class="atn">component</span><span class="atneq">=</span><span class="z">"</span><span class="av">mode</span><span class="z">"</span><span class="z"></span><span class="atn">names</span><span class="atneq">=</span><span class="z">"</span><span class="av">*</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">t:expose</span><span class="z"></span><span class="atn">component</span><span class="atneq">=</span><span class="z">"</span><span class="av">template</span><span class="z">"</span><span class="z"></span><span class="atn">names</span><span class="atneq">=</span><span class="z">"</span><span class="av">*</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">t:package</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:transform</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the <code>input-type-annotations</code> attribute is defined in <a href="#stripping-annotations"><i>4.3.1 Stripping Type Annotations from a Source Tree</i></a>.</p><p>A more extensive example of a package, illustrating how components in a package can be overridden in a client package, is given in <a href="#packages-csv-library-example"><i>3.5.7 Worked Example of a Library Package</i></a>.</p><div class="div3"><h4><a id="package-versions"></a>3.5.1 <a href="#package-versions" style="text-decoration: none">Versions of a Package</a></h4><p>If a package has a version number, the version number must conform to the grammar:</p><div class="exampleInner"><pre> PackageVersion ::= NumericPart ( "-" NamePart )? NumericPart ::= IntegerLiteral ( "." IntegerLiteral )* NamePart ::= NCName </pre></div><p>Here <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-IntegerLiteral">IntegerLiteral</a><sup><small>XP40</small></sup> and <code>NCName</code> are as defined in the XPath <span>4.0</span> grammar productions of the same name (including rules on limits). Leading and trailing whitespace is ignored; no other whitespace is allowed.</p><p>Examples of valid version numbers are <code>2.0.5</code> or <code>3.10-alpha</code>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-portion" title="portion"></a>The integer literals and the optional <code>NamePart</code> within the version number are referred to as the <b>portions</b> of the version number.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that <code>1-alpha-2</code> is a valid version number, with two <a title="portion" class="termref" href="#dt-portion">portions</a>: <code>1</code> and <code>alpha-2</code>. The second hyphen is part of the <code>NCName</code>, it does not act as a portion separator.</p></div><p>Versions are ordered. When comparing two versions:</p><ol class="enumar"><li><p>Trailing zero <a title="portion" class="termref" href="#dt-portion">portions</a> (that is, any zero-valued integer that is not followed by another integer) are discarded.</p></li><li><p>Comparison proceeds by comparing <a title="portion" class="termref" href="#dt-portion">portions</a> pairwise from the left.</p></li><li><p>If both versions have the same number of <a title="portion" class="termref" href="#dt-portion">portions</a> and all <a title="portion" class="termref" href="#dt-portion">portions</a> compare equal (under the rules of the XPath <code>eq</code> operator using the Unicode codepoint collation), then the versions compare equal.</p></li><li><p>If the number of <a title="portion" class="termref" href="#dt-portion">portions</a> in the two versions <var>V<sub>1</sub></var> and <var>V<sub>2</sub></var> is <var>N<sub>1</sub></var> and <var>N<sub>2</sub></var>, with <var>N<sub>1</sub></var>&lt;<var>N<sub>2</sub></var>, and if all <a title="portion" class="termref" href="#dt-portion">portions</a> in positions 1 to <var>N</var> compare equal, then <var>V<sub>1</sub></var> is less than <var>V<sub>2</sub></var> if the <a title="portion" class="termref" href="#dt-portion">portion</a> of <var>V<sub>2</sub></var> in position <var>N<sub>1</sub></var> is an integer, and is greater than <var>V<sub>2</sub></var> if this <a title="portion" class="termref" href="#dt-portion">portion</a> is an <code>NCName</code>. For example, <code>1.2</code> is less than <code>1.2.5</code>, while <code>2.0</code> is greater than <code>2.0-rc1</code>.</p></li><li><p><a title="portion" class="termref" href="#dt-portion">Portions</a> are compared as follows:</p><ol class="enumla"><li><p>If both <a title="portion" class="termref" href="#dt-portion">portions</a> are integers, they are compared using the rules of XPath value comparisons.</p></li><li><p>If both <a title="portion" class="termref" href="#dt-portion">portions</a> are NCNames, they are compared using the rules of XPath value comparisons, using the Unicode Codepoint Collation.</p></li><li><p>If one <a title="portion" class="termref" href="#dt-portion">portion</a> is an integer and the other is an <code>NCName</code>, the <code>NCName</code> comes first.</p></li></ol></li></ol><p>For example, the following shows a possible ordered sequence of version numbers:</p><div class="exampleInner"><pre>0-rc1 &lt; 0-rc2 &lt; 0 &lt; 1 = 1.0 &lt; 1.0.2 &lt; 1.0.3-rc1 &lt; 1.0.3 &lt; 1.0.3.2 &lt; 1.0.10</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The version number format defined here is designed to be general enough to accommodate a variety of conventions in common use, and to allow useful semantics for matching of versions and ranges of versions, without being over-prescriptive. It is influenced by <a href="#SemVer">[SemVer]</a>, but is not as prescriptive, and it imposes no assumptions about backwards compatibility of packages between successive versions.</p></div><p>Implementations <span class="verb">may</span> impose limits on the values used in a version number (or a version range: see below). Such limits are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. As a minimum, a processor <span class="verb">must</span> accept version numbers including:</p><ul><li><p>A numeric part containing four integers;</p></li><li><p>Each integer being in the range 0 to 999999;</p></li><li><p>An <code>NCName</code> of up to 100 characters</p></li></ul><p>Dependencies between packages may specify a version range (see <a href="#package-dependencies"><i>3.5.2 Dependencies between Packages</i></a>). A version range represents a set of accepted versions. The syntax of a version range is shown below. Whitespace is permitted only where indicated, using the terminal symbol <var>S</var>.</p><div class="exampleInner"><pre> PackageVersionRange ::= AnyVersion | VersionRanges AnyVersion ::= "*" VersionRanges ::= VersionRange (S? "," S? VersionRange)* VersionRange ::= PackageVersion | VersionPrefix | VersionFrom | VersionTo | VersionFromTo VersionPrefix ::= PackageVersion ".*" VersionFrom ::= PackageVersion "+" VersionTo ::= "to" S (PackageVersion | VersionPrefix) VersionFromTo ::= PackageVersion S "to" S (PackageVersion | VersionPrefix) </pre></div><p>The meanings of the various forms of version range are defined below:</p><ul><li><p>The range <code>AnyVersion</code> matches any version.</p></li><li><p>The range <code>VersionRanges</code> matches a version if any constituent <code>VersionRange</code> matches that version.</p><p>For example, <code>9.5.0.8, 9.6.1.2</code> matches those specific versions only, while <code>9.5.0.8, 9.6+</code> matches either version 9.5.0.8 or any version from 9.6 onwards.</p></li><li><p>A range that is a <code>PackageVersion</code> matches that version only.</p></li><li><p>The range <code>VersionPrefix</code> matches any version whose leading <a title="portion" class="termref" href="#dt-portion">portions</a> are the same as the <a title="portion" class="termref" href="#dt-portion">portions</a> in the <code>PackageVersion</code> part of the <code>VersionPrefix</code>.</p><p>For example, <code>1.3.*</code> matches <code>1.3</code>,&nbsp; <code>1.3.5</code>,&nbsp; <code>1.3.10.2</code>,&nbsp; and <code>1.3-beta</code> (but not <code>1</code> or <code>1.4</code>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>.*</code> indicates that additional <a title="portion" class="termref" href="#dt-portion">portions</a> may follow; it does not indicate a substring match on the final <a title="portion" class="termref" href="#dt-portion">portion</a>. So <code>1.3.*</code> does not match <code>1.35</code>, and <code>3.3-beta.*</code> does not match <code>3.3-beta12</code>. Also, <code>3.3-beta.*</code> does not match <code>3.3-beta.5</code>: this is because the last dot is not a portion separator, but is part of the final <code>NCName</code>. In fact, using <code>.*</code> after a version number that includes an <code>NCName</code> portion is pointless, because an <code>NCName</code> portion can never be followed by further portions.</p></div></li><li><p>The range <code>VersionFrom</code> matches any version that is greater than or equal to the version supplied.</p><p>For example <code>1.3+</code> matches <code>1.3</code>,&nbsp; <code>1.3.2</code>,&nbsp; <code>1.4</code>,&nbsp; and <code>2.1</code> (but not <code>1.3-beta</code> or <code>1.2</code>). And <code>1.3-beta+</code> matches <code>1.3-beta</code>,&nbsp; <code>1.3-gamma</code>,&nbsp; <code>1.3.0</code>,&nbsp; <code>1.4</code>, and <code>8.0</code>, but not <code>1.3-alpha</code> or <code>1.2</code>.</p></li><li><p>The range <code>VersionTo</code> matches any version that is less than or equal to some version that matches the <code>VersionPrefix</code>.</p><p>For example, <code>to 4.0</code> matches <code>1.5</code>,&nbsp; <code>2.3</code>,&nbsp; <code>3.8</code>,&nbsp; <code>4.0</code>,&nbsp; and <code>4.0-beta</code> (but not <code>4.0.1</code>), while <code>to 3.3.*</code> matches <code>1.5</code> or <code>2.0.6</code> or <code>3.3.4621</code>, but not <code>3.4.0</code> or <code>3.4.0-beta</code>. </p></li><li><p>The range <code>VersionFromTo</code> matches any version that is greater than or equal to the starting <code>PackageVersion</code>, and less than or equal to some version that matches the <code>VersionPrefix</code>.</p><p>For example, <code>1 to 5</code> matches <code>1.1</code>,&nbsp; <code>2.1</code>,&nbsp; <code>3.1</code>,&nbsp; or <code>5.0</code> (but not <code>5.1</code>), while <code>1 to 5.*</code> matches all of these, plus versions such as <code>5.7.2</code> (but not <code>6.0</code> or <code>6.0-beta</code>). Similarly, <code>1.0-beta to 1.0</code> matches <code>1.0-beta</code>, <code>1.0-beta.2</code>, <code>1.0-gamma</code>, and <code>1.0</code>, but not <code>1.0-alpha</code> or <code>1.0.1</code>.</p></li></ul></div><div class="div3"><h4><a id="package-dependencies"></a>3.5.2 <a href="#package-dependencies" style="text-decoration: none">Dependencies between Packages</a></h4><p>When <a title="component" class="termref" href="#dt-component">components</a> in one <a title="package" class="termref" href="#dt-package">package</a> reference components in another, the dependency of the first package on the second must be represented by an <a href="#element-use-package"><code>xsl:use-package</code></a> element. This may appear in the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the first package (which may be a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>), or it may appear in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is referenced from the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> via one or more <a href="#element-include"><code>xsl:include</code></a> declarations; however it must not be referenced via <a href="#element-import"><code>xsl:import</code></a> declarations (this is to avoid complications caused by multiple <a href="#element-use-package"><code>xsl:use-package</code></a> declarations with different <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>).</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-use" title="use"></a>If a package <var>Q</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package <var>P</var>, then package <var>Q</var> is said to <b>use</b> package <var>P</var>. In this relationship package <var>Q</var> is referred to as the <b>using</b> package, package <var>P</var> as the <b>used</b> package.<span class="definition">]</span></p><p>The phrase <b>directly uses</b> is synonymous with <b>uses</b> as defined above, while <b>directly or indirectly uses</b> refers to the transitive closure of this relationship.</p><p class="element-syntax"><a id="element-use-package"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:use-package<br>&nbsp;&nbsp;<b>name</b> = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-accept">xsl:accept</a> | <a href="#element-override">xsl:override</a>)* --&gt;<br>&lt;/xsl:use-package&gt;</code></p><p>A <a title="package" class="termref" href="#dt-package">package</a> may be <a title="use" class="termref" href="#dt-use">used</a> by more than one other package, but the relationship <span class="verb">must not</span> be cyclic. It is possible, but by no means inevitable, that using the same package in more than one place within a stylesheet will cause static errors due to the presence of conflicting components according to the above rules. Where a package is successfully used by more than one other package, its components may be overridden in different ways by different using packages.</p><p>The <code>name</code> and <code>package-version</code> attributes together identify the used package. The value of the <code>package-version</code> attribute, if present, must conform to the rules for a <code>PackageVersionRange</code> given in <a href="#package-versions"><i>3.5.1 Versions of a Package</i></a>; if omitted the value <code>*</code> is assumed, which matches any version. The used package must have a name that is an exact match for the name in the <code>name</code> attribute (using codepoint comparison), and its explicit or implicit <code>package-version</code> must match the version range given in the <code>package-version</code> attribute.</p><p>This specification does not define how the implementation locates a package given its name and version. If several matching versions of a package are available, it does not define which of them is chosen. Nor does it define whether this process locates source code or some other representation of the package contents. Such mechanisms are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Use of the package name as a dereferenceable URI is <span class="verb">not recommended</span>, because the intent of the packaging feature is to allow a package to be distributed as reusable code and therefore to exist in many different locations.</p><p><a id="err-XTSE3000"><span class="error">[ERR XTSE3000] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if no package matching the package name and version specified in an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration can be located.</p><p><a id="err-XTSE3005"><span class="error">[ERR XTSE3005] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package is dependent on itself, where package <var>A</var> is defined as being dependent on package <var>B</var> if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references <var>B</var>, or if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references a package <var>C</var> that is itself dependent on <var>B</var>.</p><p><a id="err-XTSE3008"><span class="error">[ERR XTSE3008] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is not in the same <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> as the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the <a title="package" class="termref" href="#dt-package">package</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Depending on the implementation architecture, there may be a need to locate used packages both during static analysis (for example, to get information about the names and type signatures of the components exposed by the used package), and also at evaluation time (to link to the implementation of these components so they can be invoked). A failure to locate a package may cause an error at either stage.</p></div><p>The <a href="#element-accept"><code>xsl:accept</code></a> and <a href="#element-override"><code>xsl:override</code></a> elements are used to modify the visibility or behavior of components acquired from the used package; they are described in <a href="#accepting-components"><i>3.5.3.2 Accepting Components</i></a> below.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not intrinsically an error to have two <a href="#element-use-package"><code>xsl:use-package</code></a> declarations that identify the same package (or different versions of the same package). This has the same effect as having two declarations that identify packages with different names but identical content. In most cases it will result in an error (<span class="error">[see <a href="#err-XTSE3050">ERR XTSE3050</a>]</span>) due to the presence of multiple components with the same name; but no error would occur, for example, if the used package is empty, or if the two <a href="#element-use-package"><code>xsl:use-package</code></a> declarations use <a href="#element-accept"><code>xsl:accept</code></a> to accept non-overlapping subsets of the components in the used package.</p></div></div><div class="div3"><h4><a id="named-components"></a>3.5.3 <a href="#named-components" style="text-decoration: none">Named Components in Packages</a></h4><p>This section discusses the use of named components in packages.</p><p>The components which can be declared in one package and referenced in another are: <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">functions</a>, <a title="named template" class="termref" href="#dt-named-template">named templates</a>, <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a>, <a title="mode" class="termref" href="#dt-mode">modes</a>, and <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">parameters</a>.</p><p>In addition, <a title="key" class="termref" href="#dt-key">keys</a> and <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a> are classified as named components because they can contain references to components in another package, even though they cannot themselves be referenced from outside the package.</p><p>Named and unnamed <a title="mode" class="termref" href="#dt-mode">modes</a> come within the scope of this section, but there are differences noted in <a href="#modes-and-packages"><i>3.5.4 Overriding Template Rules from a Used Package</i></a>.</p><p>Not all <a title="declaration" class="termref" href="#dt-declaration">declarations</a> result in <a title="component" class="termref" href="#dt-component">components</a>:</p><ul><li><p>Named <a title="declaration" class="termref" href="#dt-declaration">declarations</a> that can neither be referenced from outside their containing package, nor can contain references to components in other packages (examples are <a href="#element-output"><code>xsl:output</code></a>, <a href="#element-character-map"><code>xsl:character-map</code></a>, and <a href="#element-decimal-format"><code>xsl:decimal-format</code></a>) are not considered to be components and are therefore outside the scope of this section.</p></li><li><p>Some declarations, such as <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> and <a href="#element-strip-space"><code>xsl:strip-space</code></a>, declare aspects of the processing context which are not considered to be components as defined here.</p></li><li><p><a title="template rule" class="termref" href="#dt-template-rule">Template rules</a> (<a href="#element-template"><code>xsl:template</code></a> with a <code>match</code> attribute) are also not considered to be components for the purposes of this section, which is concerned only with components that are bound by name. However, when an <a href="#element-template"><code>xsl:template</code></a> has both a <code>match</code> attribute and a <code>name</code> attribute, then it establishes both a template rule and a <a title="named template" class="termref" href="#dt-named-template">named template</a>, and in its role as a named template it comes within the scope of this discussion.</p></li><li><p>A named declaration, for example a named template, a function, or a global variable, may be overridden within the same package by another like-named declaration having higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. When a declaration is overridden in this way it cannot be referenced by name either from within its containing package or from outside that package. </p></li><li><p>In the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> and <a href="#element-key"><code>xsl:key</code></a> declarations, several declarations combine to form a single component.</p></li></ul><p>The section is largely concerned with details of the rules that affect references from one component to another by name, whether the components are in the same package or in different packages. The rules are designed to meet a number of requirements:</p><ul><li><p>A component defined in one package can be overridden by a component in another package, provided the signatures are type-compatible.</p></li><li><p>The author of a package can declare whether the components in the package are public or private (that is, whether or not they can be used from outside the package) and whether they are final, overridable, or abstract (that is whether they can or must be overridden by the using package).</p></li><li><p>Within an application, two packages can make use of a common library and override its components in different ways.</p></li><li><p>Visibility of components can be defined either as part of the declaration of the component, or in the package manifest.</p></li><li><p>An application that wishes to make use of a <a title="library package" class="termref" href="#dt-library-package">library package</a> can be selective about which components from the library it acquires, perhaps to avoid name clashes between components acquired from different libraries.</p></li></ul><p><span class="definition">[Definition:&nbsp;</span><a id="dt-component" title="component"></a>The term <b>component</b> is used to refer to any of the following: a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="accumulator function" class="termref" href="#dt-accumulator-function">accumulator</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, or a <a title="mode" class="termref" href="#dt-mode">mode</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-symbolic-identifier" title="symbolic identifier"></a>The <b>symbolic identifier</b> of a <a title="component" class="termref" href="#dt-component">component</a> is a composite name used to identify the component uniquely within a package. The symbolic identifier comprises the kind of component (stylesheet function, named template, accumulator, attribute set, global variable, key, or mode), the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the component (namespace URI plus local name), and in the case of stylesheet functions, <span>the upper bound of the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a></span>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the case of the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, the expanded QName of the component may be considered to be some system-allocated name different from any user-defined mode name.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-homonymous" title="homonymous"></a>Two <a title="component" class="termref" href="#dt-component">components</a> are said to be <b>homonymous</b> if they have the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>.<span class="definition">]</span></p><p>Every <a title="component" class="termref" href="#dt-component">component</a> has a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> in some <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> and therefore within some <a title="package" class="termref" href="#dt-package">package</a>. In the case of <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a> and <a title="key" class="termref" href="#dt-key">keys</a>, there may be several declarations. The declaration is an element in an XDM tree representing the stylesheet module. Declarations therefore have identity, based on XDM node identity.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-declaring-package" title="declaring package"></a>The <b>declaring package</b> of a <a title="component" class="termref" href="#dt-component">component</a> is the package that contains the declaration (or, in the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> and <a href="#element-key"><code>xsl:key</code></a>, multiple declarations) of the component.<span class="definition">]</span></p><p>When a <a title="component" class="termref" href="#dt-component">component</a> declared in one <a title="package" class="termref" href="#dt-package">package</a> is made available in another, the using package will contain a separate component that can be regarded as a modified copy of the original. The new component shares the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> as the original, and it has the same <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, but it has other properties such as its <a title="visibility" class="termref" href="#dt-visibility">visibility</a> that may differ from the original.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-containing-package" title="containing package"></a>A component declaration results in multiple components, one in the package in which the declaration appears, and potentially one in each package that uses the declaring package, directly or indirectly, subject to the visibility of the component. Each of these multiple components has the same <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, but each has a different <b>containing package</b>. For the original component, the declaring package and the containing package are the same; for a copy of a component made as a result of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, the declaring package will be the original package, and the containing package will be the package in which the <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within this specification, we generally use the notation <var>C<sub>P</sub></var> for a component named C whose declaring package and containing package are both <var>P</var>; and the notation <var>C<sub>PQ</sub></var> for a component whose containing package is <var>P</var> and whose declaring package is <var>Q</var> (that is, a component in <var>P</var> that is derived from a component <var>C<sub>Q</sub></var> in the used package <var>Q</var>).</p></div><p>The properties of a <a title="component" class="termref" href="#dt-component">component</a> are as follows:</p><ul><li><p>The original <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of the component.</p></li><li><p>The <a title="package" class="termref" href="#dt-package">package</a> to which the component belongs (called its <b>containing</b> package, not to be confused with the <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>).</p></li><li><p>The <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> of the component.</p></li><li><p>The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component, which determines the way in which the component is seen by other components within the same package and within using packages. This is one of <code>public</code>, <code>private</code>, <code>abstract</code>, <code>final</code>, or <code>hidden</code>. The visibility of components is discussed further in <a href="#visibility"><i>3.5.3.1 Visibility of Components</i></a>.</p></li><li><p>A set of bindings for the <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic references</a> in the component. The way in which these bindings are established is discussed further in <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>When a function <var>F</var> defined in a package <var>P</var> is acquired by two using packages <var>Q</var> and <var>R</var>, we may think of <var>P</var>, <var>Q</var>, and <var>R</var> as all providing access to the “same” function. The detailed semantics, however, demand an understanding that there is one function declaration, but three components. The three components representing the function <var>F</var> within packages <var>P</var>, <var>Q</var>, and <var>R</var> have some properties in common (the same symbolic identifier, the same declaration), but other properties (the visibility and the bindings of symbolic references) that may vary from one of these components to another.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-symbolic-reference" title="symbolic reference"></a>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a component includes constructs that can be interpreted as references to other <a title="component" class="termref" href="#dt-component">components</a> by means of their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. These constructs are generically referred to as <b>symbolic references</b>. Examples of constructs that give rise to symbolic references are the <code>name</code> attribute of <a href="#element-call-template"><code>xsl:call-template</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute of <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>; the explicit or implicit <code>mode</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>; XPath variable references referring to global variables; XPath static function calls (including partial function applications) referring to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; and named function references (example: <code>my:f#1</code>) referring to stylesheet functions. <span class="definition">]</span></p><p>Symbolic references exist as properties of the <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a <a title="component" class="termref" href="#dt-component">component</a>. The <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> being referred to can be determined straightforwardly from the syntactic form and context of the reference: for example, the instruction <code>&lt;xsl:value-of select="f:price($o)" xmlns:f="http://f.com/"/&gt;</code> contains a symbolic reference to a function with expanded name <code>{http://f.com/}price</code> and with arity=1. However, because there may be several (homonymous) function components with this symbolic identifier, translating this symbolic reference into a reference to a specific component (a process called “binding”) is less straightforward, and is described in the text that follows. </p><p>The process of assembling a stylesheet from its constituent packages is primarily a process of binding these symbolic references to actual components. Within any <a title="component" class="termref" href="#dt-component">component</a> whose <a title="declaration" class="termref" href="#dt-declaration">declaration</a> is <var>D</var>, there is a set of bindings; each binding is an association between a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> in <var>D</var> and a <a title="component" class="termref" href="#dt-component">component</a> whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> matches the outward reference. Outward references for which a component <var>C</var> contains a binding are said to be <b>bound</b> in <var>C</var>; those for which <var>C</var> contains no binding are said to be <b>unbound</b>.</p><p>For example, suppose that in some package <var>Q</var>, function <var>A</var> calls <var>B</var>, which in turn calls <var>C</var>, and that <var>B</var> is <code>private</code>. Now suppose that in some package <var>P</var> which uses <var>Q</var>, <var>C</var> is overridden. The effect of the binding process is that <var>P</var> will contain three components corresponding to <var>A</var>, <var>B</var>, and <var>C</var>, which we might call <var>A<sub>P</sub></var>, <var>B<sub>P</sub></var>, and <var>C<sub>P</sub></var>. The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> of <var>A<sub>P</sub></var> and <var>B<sub>P</sub></var> are in package <var>Q</var>, but the declaration of <var>C<sub>P</sub></var> is in <var>P</var>. The internal visibility of <var>B<sub>P</sub></var> will be <code>hidden</code> (meaning that it cannot be referenced from within <var>P</var>), and <var>B<sub>P</sub></var> will contain a binding for the component <var>C<sub>P</sub></var> that corresponds to the outward reference from <var>B</var> to <var>C</var>. The effect is that when <var>A</var> calls <var>B</var> and <var>B</var> calls <var>C</var>, it is the overriding version of <var>C</var> that is executed.</p><p>In another package <var>R</var> that uses <var>Q</var> without overriding <var>C</var>, there will be three different components <var>A<sub>R</sub></var>, <var>B<sub>R</sub></var>, and <var>C<sub>R</sub></var>. This time the declaration of all three components is in the original package <var>Q</var>. Component <var>B<sub>R</sub></var> will contain a binding to <var>C<sub>R</sub></var>, so in this package, the original version of <var>C</var> is executed. The fact that one package <var>P</var> overrides <var>C</var> thus has no effect on <var>R</var>, which does not override it.</p><p>The binding process outlined above is described in more detail in <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>.</p><p>Template rules are not components in their own right; unlike named templates, they are never referenced by name. Component references within a template rule (for example, references to functions, global variables, or named templates) are treated as occurring within the component that represents the containing mode. This includes component references within the match patterns of template rules. If a template rule lists several modes, it is treated as if there were multiple template rules one in each mode.</p><p>An <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>mode</code> attribute is treated as a reference to the default mode defined for that <a title="instruction" class="termref" href="#dt-instruction">instruction</a> (see <a href="#default-mode"><i>3.7.2 The default-mode Attribute</i></a>), which in turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. An implicit reference to the unnamed made is treated in the same way as any other <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a>. Note that there is an unnamed mode in every package, and the unnamed mode always has private visibility.</p><p>Where an <a href="#element-template"><code>xsl:template</code></a> element has both a <code>name</code> and a <code>match</code> attribute, it is treated as if there were two separate <a href="#element-template"><code>xsl:template</code></a> elements, one with a <code>name</code> attribute and one with a <code>match</code> attribute. </p><p><a title="key" class="termref" href="#dt-key">Keys</a> and <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a> behave rather differently from other components. Their visibility is always private, which means they can only be used within their declaring package. In addition, the component binding is generally made dynamically rather than statically, by virtue of a string passed as an argument to the function <a href="#func-key"><code>key</code></a>, <a href="#func-accumulator-before"><code>accumulator-before</code></a>, or <a href="#func-accumulator-after"><code>accumulator-after</code></a>. (In the case of accumulators, there can also be static references: see the <code>use-accumulators</code> attribute of <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-merge-source"><code>xsl:merge-source</code></a>, and <a href="#element-mode"><code>xsl:mode</code></a>.) However, outward references from key definitions and <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a> to other components (such as global variables and functions) behave in the same way as component references contained in any other private component, in that they may be re-bound to an overriding declaration of the target component.</p><div class="div4"><h5><a id="visibility"></a>3.5.3.1 <a href="#visibility" style="text-decoration: none">Visibility of Components</a></h5><p><span class="definition">[Definition:&nbsp;</span><a id="dt-visibility" title="visibility"></a>The <b>visibility</b> of a <a title="component" class="termref" href="#dt-component">component</a> is one of: <code>private</code>, <code>public</code>, <code>abstract</code>, <code>final</code>, or <code>hidden</code>.<span class="definition">]</span></p><p>The meanings of these visibility values is as follows:</p><dl><dt class="label">public</dt><dd><p>The component can be referenced from other components in this package or in any using package; it can be overridden by a different component in any using package.</p></dd><dt class="label">private</dt><dd><p>The component can be referenced from other components in this package; it cannot be referenced or overridden within a using package.</p></dd><dt class="label">abstract</dt><dd><p>The component can be referenced from other components in this package or in any using package; in a using package it can either remain abstract or be overridden by a different component. </p></dd><dt class="label">final</dt><dd><p>The component can be referenced from other components in this package or in any using package; it cannot be overridden by a different component in any using package.</p></dd><dt class="label">hidden</dt><dd><p>The component cannot be referenced from other components in this package; it cannot be referenced or overridden within a using package.</p></dd></dl><div class="note"><p class="prefix"><b>Note:</b></p><p>The visibility of a component in a package <var>P</var> primarily affects how the component can be used in other packages, specifically, packages that use <var>P</var>. There is one exception: if the visibility is <code>hidden</code>, it also affects how the component can be used within <var>P</var>.</p></div><p>When a component is declared within a particular package, its <a title="visibility" class="termref" href="#dt-visibility">visibility</a>, which affects how it can be used in other (using) packages, depends on two factors: the value of the <code>visibility</code> declaration on the declaration itself (if present), and the rules given in the <a href="#element-expose"><code>xsl:expose</code></a> declarations of the package manifest.</p><p>The <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-template"><code>xsl:template</code></a>, <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>, <a href="#element-variable"><code>xsl:variable</code></a>, and <a href="#element-mode"><code>xsl:mode</code></a><a title="declaration" class="termref" href="#dt-declaration">declarations</a> each have an optional <code>visibility</code> attribute. The value is one of <code>private</code>, <code>public</code>, <code>abstract</code>, or <code>final</code> (never <code>hidden</code>). In the case of an <a href="#element-param"><code>xsl:param</code></a> element there is no explicit <code>visibility</code> attribute; rather the declaration has the implicit attribute <code>visibility="public"</code>.</p><p>Any <a href="#element-expose"><code>xsl:expose</code></a> declarations that appear as children of <a href="#element-package"><code>xsl:package</code></a> define the visibility of components whose declaration has no explicit <code>visibility</code> attribute, and can also be used to reduce the visibility of components where this attribute is present.</p><p class="element-syntax"><a id="element-expose"></a><code>&lt;xsl:expose<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract"&nbsp;/&gt;</code></p><p>The <a href="#element-expose"><code>xsl:expose</code></a> element allows the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of selected components within a package to be defined.</p><p>The components in question are identified using their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. The <code>component</code> attribute defines the kind of component that is selected. The value <code>*</code> means “all component kinds”; in this case the value of the <code>names</code> attribute must be a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Wildcard">Wildcard</a><sup><small>XP40</small></sup>.</p><p>An <a href="#element-expose"><code>xsl:expose</code></a> declaration has no effect on the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, which is always private to a package.</p><p>The <code>names</code> attribute selects a subset of these components by name (and in the case of functions, arity); its value is a whitespace-separated sequence of tokens each of which is either a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP40</small></sup> or a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NamedFunctionRef">NamedFunctionRef</a><sup><small>XP40</small></sup>. (Examples are <code>*</code>, <code>p:*</code>, <code>*:local</code>, <code>p:local</code>, and <code>p:local#2</code>.)</p><p>The value may be a <code>NamedFunctionRef</code> only in the case of stylesheet functions, and distinguishes functions with the same name and different arity. <span>A <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP40</small></sup> on its own (that is, with no arity) cannot be used to identify a function. [XSLT 3.0 Erratum E36, bug 30323].</span></p><p>The visibility of a named template, function, variable, attribute set, or mode declared within a package is the first of the following that applies, subject to consistency constraints which are defined below:</p><ol class="enumar"><li><p>The visibility of a variable declared using an <a href="#element-param"><code>xsl:param</code></a> element is always <code>public</code>. No <a href="#element-expose"><code>xsl:expose</code></a> element ever matches an <a href="#element-param"><code>xsl:param</code></a> component.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Attempting to match an <a href="#element-param"><code>xsl:param</code></a> with an explicit <code>EQName</code> will therefore always give an error, while using a wildcard has no effect.</p></div></li><li><p>If the package manifest contains an <a href="#element-expose"><code>xsl:expose</code></a> element that matches this component by virtue of an explicit <code>EQName</code> or <code>NamedFunctionRef</code> (that is, not by virtue of a wildcard match), then the value of the <code>visibility</code> attribute of the last such <a href="#element-expose"><code>xsl:expose</code></a> element in document order (call this the <b>explicit exposed visibility</b>).</p></li><li><p>If the declaration of the component has a <code>visibility</code> attribute, then the value of this attribute (call this the <b>declared visibility</b>).</p></li><li><p>If the package manifest contains an <a href="#element-expose"><code>xsl:expose</code></a> element that matches this component by virtue of a wildcard match that specifies either the namespace part of the component name or the local part of the name (for example, <code>prefix:*</code> or <code>*:local</code> or <code>Q{uri}*</code>), then the value of the <code>visibility</code> attribute of the last such <a href="#element-expose"><code>xsl:expose</code></a> element in document order.</p></li><li><p>If the package manifest contains an <a href="#element-expose"><code>xsl:expose</code></a> element that matches this component by virtue of a wildcard match that matches all names (that is, <code>*</code>), then the value of the <code>visibility</code> attribute of the last such <a href="#element-expose"><code>xsl:expose</code></a> element in document order.</p></li><li><p>Otherwise, <code>private</code>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>In the above rules, no distinction is made between declarations that specify a specific component kind, and those that specify <code>component="*"</code>. If both match, the value of the <code>component</code> attribute plays no role in deciding which declaration wins.</p></div><p>If both a declared visibility and an explicit exposed visibility exist for the same component, then as mentioned above, they must be consistent. This is determined by reference to the following table, where the entry N/P means “not permitted”. (In cases where the combination is permitted, the actual visibility is always the same as the visibility determined by <a href="#element-expose"><code>xsl:expose</code></a>.)</p><table class="data"><caption>Relationship of Exposed Visibility to Potential Visibility</caption><thead><tr><th style="text-align:left; vertical-align:top" rowspan="2">Explicit exposed visibility</th><th style="text-align:left; vertical-align:top" colspan="4">Declared visibility</th></tr><tr><th style="text-align:left; vertical-align:top">public</th><th style="text-align:left; vertical-align:top">private</th><th style="text-align:left; vertical-align:top">final</th><th style="text-align:left; vertical-align:top">abstract</th></tr></thead><tbody><tr><th style="text-align:left; vertical-align:top">public</th><td style="text-align:left; vertical-align:top">public</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td></tr><tr><th style="text-align:left; vertical-align:top">private</th><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top">N/P</td></tr><tr><th style="text-align:left; vertical-align:top">final</th><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top">N/P</td></tr><tr><th style="text-align:left; vertical-align:top">abstract</th><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">abstract</td></tr></tbody></table><p><a id="err-XTSE3010"><span class="error">[ERR XTSE3010] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the explicit exposed visibility of a component is inconsistent with its declared visibility, as defined in the above table. (This error occurs only when the component declaration has an explicit <code>visibility</code> attribute, and the component is also listed explicitly by name in an <a href="#element-expose"><code>xsl:expose</code></a> declaration.) </p><p><a id="err-XTSE3020"><span class="error">[ERR XTSE3020] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a>, other than a wildcard, matches no component in the containing package. </p><p><a id="err-XTSE3022"><span class="error">[ERR XTSE3022] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>component</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a> specifies <code>*</code> (meaning all component kinds) and the <code>names</code> attribute is not a wildcard. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no ambiguity, and no error, if several tokens within the same <a href="#element-expose"><code>xsl:expose</code></a> element match the same component.</p></div><p>If the visibility of a component as established by the above rules is <code>abstract</code>, then the component must have a declared visibility of <code>abstract</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In other words, the <a href="#element-expose"><code>xsl:expose</code></a> declaration cannot be used to make a component abstract unless it was declared as abstract to start with.</p></div><p><a id="err-XTSE3025"><span class="error">[ERR XTSE3025] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the effect of an <a href="#element-expose"><code>xsl:expose</code></a> declaration would be to make a component <code>abstract</code>, unless the component is already <code>abstract</code> in the absence of the <a href="#element-expose"><code>xsl:expose</code></a> declaration. </p><p>For a component accepted into a package <var>P</var> from another package <var>Q</var>, the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in <var>P</var> (which primarily affects how it can be used in a package <var>R</var> that uses <var>P</var>) depends on the visibility declared in the relevant <a href="#element-accept"><code>xsl:accept</code></a> or <a href="#element-override"><code>xsl:override</code></a> element in <var>P</var> (see <a href="#accepting-components"><i>3.5.3.2 Accepting Components</i></a>); this in turn has a default that depends on the visibility of the corresponding component in <var>Q</var>. In this case the visibility is unaffected by any <a href="#element-expose"><code>xsl:expose</code></a> declaration in <var>P</var>.</p></div><div class="div4"><h5><a id="accepting-components"></a>3.5.3.2 <a href="#accepting-components" style="text-decoration: none">Accepting Components</a></h5><p>When a package <var>P</var> uses a package <var>Q</var>, by virtue of an <a href="#element-use-package"><code>xsl:use-package</code></a> element in the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> of <var>P</var>, then <var>P</var> will contain a <a title="component" class="termref" href="#dt-component">component</a> corresponding to every component in <var>Q</var>. The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component within <var>P</var> depends on the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in <var>Q</var>, optionally modified by two elements that may appear as children of the <a href="#element-use-package"><code>xsl:use-package</code></a> element, namely <a href="#element-accept"><code>xsl:accept</code></a> and <a href="#element-override"><code>xsl:override</code></a>.</p><p>For every component <var>C<sub>Q</sub></var> in package <var>Q</var> that is not matched by any <a href="#element-override"><code>xsl:override</code></a> or <a href="#element-accept"><code>xsl:accept</code></a> element in the package manifest of <var>P</var>, there will be a corresponding component <var>C<sub>P</sub></var> in package <var>P</var> that has the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> and <a title="declaration" class="termref" href="#dt-declaration">declaration</a> as <var>C<sub>Q</sub></var>.</p><p>If <var>C<sub>Q</sub></var> is an <a href="#element-param"><code>xsl:param</code></a> component, then the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of <var>C<sub>P</sub></var> is <code>public</code>.</p><p>In other cases, the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of <var>C<sub>P</sub></var> depends on the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of <var>C<sub>Q</sub></var>, as defined by the following table:</p><table class="data"><caption>Visibility of Components in Used and Using Packages</caption><thead><tr><th style="text-align:left; vertical-align:top">Visibility in used package <var>C<sub>Q</sub></var></th><th style="text-align:left; vertical-align:top">Visibility in using package <var>C<sub>P</sub></var></th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">public</td><td style="text-align:left; vertical-align:top">private</td></tr><tr><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top">private</td></tr><tr><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top">hidden</td></tr><tr><td style="text-align:left; vertical-align:top">hidden</td><td style="text-align:left; vertical-align:top">hidden</td></tr><tr><td style="text-align:left; vertical-align:top">abstract</td><td style="text-align:left; vertical-align:top">hidden</td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of these rules is as follows:</p><ul><li><p>Components that are public or final in the used package <var>Q</var> become private in the using package <var>P</var>. This means that they can be referenced within <var>P</var> but are not (by default) visible within a package <var>R</var> that uses <var>P</var>.</p></li><li><p>Components that are private or hidden in the used package <var>Q</var> become hidden in the using package <var>P</var>. This means that they cannot be referenced within <var>P</var>; but if they contain references to components that are overridden in <var>P</var>, the hidden component’s references are bound to the overriding components in <var>P</var>.</p></li><li><p>Components that are abstract in the used package <var>Q</var> become hidden in the using package <var>P</var>. The hidden component in this case raises a dynamic error if it is invoked. Such an invocation cannot originate within <var>P</var>, because the component is not visible within <var>P</var>; but it can occur if a public component in <var>Q</var> is invoked, which in turn invokes the abstract component.</p></li></ul></div><p class="element-syntax"><a id="element-accept"></a><code>&lt;xsl:accept<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract" | "hidden"&nbsp;/&gt;</code></p><p>The <a href="#element-accept"><code>xsl:accept</code></a> element has very similar syntax and semantics to <a href="#element-expose"><code>xsl:expose</code></a>. Whereas <a href="#element-expose"><code>xsl:expose</code></a> allows a package to restrict the visibility of its own components to other (using) packages, <a href="#element-accept"><code>xsl:accept</code></a> allows a package to restrict the visibility of components exposed by a package that it uses. This may be necessary if, for example, it uses two different packages whose component names conflict. It may also simply be good practice if the package author knows that only a small subset of the functionality of a used package is required.</p><p>The rules for determining whether an <a href="#element-accept"><code>xsl:accept</code></a> element matches a particular component, and for which element to use if there are several matches, are the same as the rules for the <a href="#element-expose"><code>xsl:expose</code></a> element.</p><p>No <a href="#element-accept"><code>xsl:accept</code></a> element ever matches a variable declared using <a href="#element-param"><code>xsl:param</code></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Attempting to match an <a href="#element-param"><code>xsl:param</code></a> with an explicit <code>EQName</code> will therefore always give an error, while using a wildcard has no effect.</p></div><p><a id="err-XTSE3030"><span class="error">[ERR XTSE3030] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other than a wildcard, matches no component in the used package. </p><p><a id="err-XTSE3032"><span class="error">[ERR XTSE3032] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>component</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a> specifies <code>*</code> (meaning all component kinds) and the <code>names</code> attribute is not a wildcard. </p><p>In the absence of a matching <a href="#element-override"><code>xsl:override</code></a> element (see <a href="#package-overriding-components"><i>3.5.3.3 Overriding Components from a Used Package</i></a>), the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of a component that matches an <a href="#element-accept"><code>xsl:accept</code></a> element depends both on the <code>visibility</code> attribute of the best-matching <a href="#element-accept"><code>xsl:accept</code></a> element and on the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the corresponding component in the used package, according to the following table. In this table the entry “N/P” means “not permitted”.</p><table class="data"><caption>Relationship of the Visibility given in xsl:accept to Visibility in the Used Package</caption><thead><tr><th style="text-align:left; vertical-align:top" rowspan="2">Visibility in <a href="#element-accept"><code>xsl:accept</code></a> element</th><th style="text-align:left; vertical-align:top" colspan="4">Visibility in used package</th></tr><tr><th style="text-align:left; vertical-align:top">public</th><th style="text-align:left; vertical-align:top">private</th><th style="text-align:left; vertical-align:top">final</th><th style="text-align:left; vertical-align:top">abstract</th></tr></thead><tbody><tr><th style="text-align:left; vertical-align:top">public</th><td style="text-align:left; vertical-align:top">public</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td></tr><tr><th style="text-align:left; vertical-align:top">private</th><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top">N/P</td></tr><tr><th style="text-align:left; vertical-align:top">final</th><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top">N/P</td></tr><tr><th style="text-align:left; vertical-align:top">abstract</th><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">abstract</td></tr><tr><th style="text-align:left; vertical-align:top">hidden</th><td style="text-align:left; vertical-align:top">hidden</td><td style="text-align:left; vertical-align:top">N/P</td><td style="text-align:left; vertical-align:top">hidden</td><td style="text-align:left; vertical-align:top">hidden</td></tr></tbody></table><p><a id="err-XTSE3040"><span class="error">[ERR XTSE3040] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the visibility assigned to a component by an <a href="#element-accept"><code>xsl:accept</code></a> element is incompatible with the visibility of the corresponding component in the used package, as defined by the above table, unless the token that matches the component name is a wildcard, in which case the <a href="#element-accept"><code>xsl:accept</code></a> element is treated as not matching that component. </p><p><a id="err-XTSE3050"><span class="error">[ERR XTSE3050] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-use-package"><code>xsl:use-package</code></a> elements in a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> cause two or more <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> components to be accepted with a visibility other than <code>hidden</code>. </p><p>Conflicts between the components accepted from used packages and those declared within the package itself are handled as follows:</p><ol class="enumar"><li><p>If the conflict is between two components both declared within the package itself, then it is resolved by the rules relating to <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> defined for each kind of component.</p></li><li><p>If the conflict is between two components both accepted from used packages, or between a component declared within the package and an accepted component, then a static error occurs.</p></li><li><p>If a component is explicitly accepted from a used package (by name, rather than by a matching wildcard), and if the same component is the subject of an <a href="#element-override"><code>xsl:override</code></a> declaration, then a static error occurs (see below). There is no conflict, however, if a component declared within <a href="#element-override"><code>xsl:override</code></a> also matches a wildcard in an <a href="#element-accept"><code>xsl:accept</code></a> element.</p><p><a id="err-XTSE3051"><span class="error">[ERR XTSE3051] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other than a wildcard, matches the symbolic name of a component declared within an <a href="#element-override"><code>xsl:override</code></a> child of the same <a href="#element-use-package"><code>xsl:use-package</code></a> element. </p></li></ol><p>Where the used package <var>Q</var> contains a component whose visibility is <code>abstract</code>, the using package <var>P</var> has three options:</p><ol class="enumar"><li><p><var>P</var> can accept the component with <code>visibility="abstract"</code>. In this case <var>P</var> can contain references to the component, but invocation via these references will fail unless a non-abstract overriding component has been supplied in some package <var>R</var> that (directly or indirectly) uses <var>P</var>.</p></li><li><p><var>P</var> can accept the component with <code>visibility="hidden"</code>. In this case <var>P</var> cannot contain references to the component, and invocation via references in <var>Q</var> will always fail with a dynamic error. This is the default if <var>P</var> does not explicitly accept or override the component.</p></li><li><p><var>P</var> can provide a concrete implementation of the component within an <a href="#element-override"><code>xsl:override</code></a> element.</p></li></ol><p>Any invocation of the absent component (typically from within its declaring package) causes a dynamic error, as if the component were overridden by a component that unconditionally raises a dynamic error.</p><p><a id="err-XTDE3052"><span class="error">[ERR XTDE3052] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an invocation of an abstract component is evaluated. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This can occur when a public component in the used package invokes an abstract component in the used package, and the using package provides no concrete implementation for the component in an <a href="#element-override"><code>xsl:override</code></a> element.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>To override a component accepted from a used package, the overriding declaration must appear as a child of the <a href="#element-override"><code>xsl:override</code></a> element.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no rule that prevents a function (say) being declared in the using package with the same name as a <code>private</code> function in the used package. This does not create a conflict, since all references in the used package are bound to one function and all those in the using package are bound to another.</p></div></div><div class="div4"><h5><a id="package-overriding-components"></a>3.5.3.3 <a href="#package-overriding-components" style="text-decoration: none">Overriding Components from a Used Package</a></h5><p><span class="definition">[Definition:&nbsp;</span><a id="dt-override" title="override"></a>A component in a using package may <b>override</b> a component in a used package, provided that the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in the used package is either <code>abstract</code> or <code>public</code>. The overriding declaration is written as a child of the <a href="#element-override"><code>xsl:override</code></a> element, which in turn appears as a child of <a href="#element-use-package"><code>xsl:use-package</code></a>.<span class="definition">]</span></p><p class="element-syntax"><a id="element-override"></a><code>&lt;xsl:override&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a> | <a href="#element-function">xsl:function</a> | <a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a> | <a href="#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br>&lt;/xsl:override&gt;</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This mechanism is distinct from the mechanism for overriding declarations within the same package by relying on <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. It imposes stricter rules: the overriding component is required to be type-compatible with the component that it overrides.</p></div><p>If the used package <var>Q</var> contains a <a title="component" class="termref" href="#dt-component">component</a><var>C<sub>Q</sub></var> and the <a href="#element-use-package"><code>xsl:use-package</code></a> element contains an <a href="#element-override"><code>xsl:override</code></a> element which contains a declaration <var>D</var> whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> matches the symbolic identifier of <var>C<sub>Q</sub></var>, then the using package <var>P</var> will contain a component <var>C<sub>P</sub></var> whose declaration is D, whose symbolic identifier is that of D, and whose <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is equal to the value of the <code>visibility</code> attribute of <var>D</var>, or <code>private</code> if this is absent, except in the case of <a href="#element-param"><code>xsl:param</code></a>, which is implicitly <code>public</code>.</p><p>The using package <var>P</var> will also contain a component <var>C<sub>PQ</sub></var> whose body is the same as the body of <var>C<sub>Q</sub></var> and whose <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is <code>hidden</code>. This component is used as the target of a binding for the symbolic reference <code>xsl:original</code> described below.</p><p>Other than its appearance as a child of <a href="#element-override"><code>xsl:override</code></a>, the overriding declaration is a normal <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-template"><code>xsl:template</code></a>, , <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, or <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element. In the case of <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a>, the variable that is declared is a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>.</p><p>The rules in the remainder of this section apply to components having a <code>name</code> attribute (<b>named components</b>). The only element with no <code>name</code> attribute that can appear as a child of <a href="#element-override"><code>xsl:override</code></a> is an <a href="#element-template"><code>xsl:template</code></a> declaration having a <code>match</code> attribute (that is, a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>). The rules for overriding of template rules appear in <a href="#modes-and-packages"><i>3.5.4 Overriding Template Rules from a Used Package</i></a>. If an <a href="#element-template"><code>xsl:template</code></a> element has both a <code>name</code> attribute and a <code>match</code> attribute, then it defines both a named component and a template rule, and both sections apply.</p><p><a id="err-XTSE3055"><span class="error">[ERR XTSE3055] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a component declaration appearing as a child of <a href="#element-override"><code>xsl:override</code></a> is <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with any other declaration in the using package, regardless of <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, including any other overriding declaration in the package manifest of the using package.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When an attribute set is overridden, the overriding attribute set must be defined using a single <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element. Attribute sets defined in different packages are never merged by virtue of having the same name, though they may be merged explicitly by using the <code>use-attribute-sets</code> attribute.</p></div><p><a id="err-XTSE3058"><span class="error">[ERR XTSE3058] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a component declaration appearing as a child of <a href="#element-override"><code>xsl:override</code></a> does not match (is not <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with) some component in the used package.</p><p><a id="err-XTSE3060"><span class="error">[ERR XTSE3060] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the component referenced by an <a href="#element-override"><code>xsl:override</code></a> declaration has <a title="visibility" class="termref" href="#dt-visibility">visibility</a> other than <code>public</code> or <code>abstract</code></p><p>A package is executable if and only if it contains no <a title="component" class="termref" href="#dt-component">component</a> whose <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is <code>abstract</code>. A package that is not executable is not a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and therefore cannot be nominated as the stylesheet to be used when initiating a transformation.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In other words, if a component is declared as abstract, then some package that uses the declaring package of that component directly or indirectly must override that component with one that is not abstract. It is not necessary for the override to happen in the immediately using package.</p></div><p><a id="err-XTSE3070"><span class="error">[ERR XTSE3070] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the signature of an overriding component is not <a title="compatible" class="termref" href="#dt-compatible">compatible</a> with the signature of the component that it is overriding. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-compatible" title="compatible"></a>The signatures of two <a title="component" class="termref" href="#dt-component">components</a> are <b>compatible</b> if they present the same interface to the user of the component. The additional rules depend on the kind of component.<span class="definition">]</span></p><p>Compatibility is only relevant when comparing two components that have the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>. The compatibility rules for each kind of component are as follows:</p><ul><li><p>Two attribute sets with the same name are compatible if and only if they satisfy the following rule:</p><ol class="enumar"><li><p>If the overridden attribute set specifies <code>streamable="yes"</code> then the overriding attribute set also specifies <code>streamable="yes"</code>.</p></li></ol></li><li><p>Two functions with the same symbolic identifier are compatible if and only if they satisfy all the following rules:</p><ol class="enumar"><li><p>They have the same <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> (which implies they have the same number of required and optional parameters)</p></li><li><p>The declared types of the parameters (defaulting to <code>item()*</code>) are pairwise <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>.</p></li><li><p>The declared return types (defaulting to <code>item()*</code>) are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>.</p></li><li><p><span style="display: none;" class="delete_version">The effective value of the <code>new-each-time</code> attribute on the overriding function is the same as its value on the overridden function.</span><span style="display: none;" class="add_version">The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>new-each-time</code> attribute on the overriding function is the same as its value on the overridden function.</span><span class="modify_version">The <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>new-each-time</code> attribute on the overriding function is the same as its value on the overridden function.</span></p></li><li><p>If the overridden function has a <code>streamability</code> attribute with a value other than <code>unspecified</code>, then the overriding function has a <code>streamability</code> attribute with the same value. [XSLT 3.0 Erratum E32, bug 30297]</p></li></ol><p>It is <span class="verb">recommended</span> that the parameter names on the overriding function should be the same as on the overridden function. (However, in order to maintain backwards compatibility with XSLT 3.0, this is not <span class="verb">required</span>.) If the parameter names are not the same, then the parameter names on the overriding function are effectively replaced with the names declared on the overridden function, so that any static function calls using keyword arguments to set the values of arguments must use the names defined on the overridden function.</p></li><li><p>Two named templates with the same name are compatible if and only if they satisfy all the following rules:</p><ol class="enumar"><li><p>Their return types are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>.</p></li><li><p><span style="display: none;" class="delete_version">For every non-tunnel parameter on the overridden template, there is a non-tunnel parameter on the overriding template that has the same name, an <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a> required type, and the same effective value for the <code>required</code> attributes.</span><span style="display: none;" class="add_version">For every non-tunnel parameter on the overridden template, there is a non-tunnel parameter on the overriding template that has the same name, an <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a> required type, and the same <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> for the <code>required</code> attributes.</span><span class="modify_version">For every non-tunnel parameter on the overridden template, there is a non-tunnel parameter on the overriding template that has the same name, an <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a> required type, and the same <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>for the <code>required</code> attributes.</span></p></li><li><p>For every tunnel parameter <var>P</var> on the overridden template, if there is a parameter <var>Q</var> on the overriding template that has the same name as <var>P</var> then <var>Q</var> is also a tunnel parameter, and <var>P</var> and <var>Q</var> have <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a> required types.</p></li><li><p>Any parameter on the overriding template for which there is no corresponding parameter on the overridden template specifies <code>required="no"</code>.</p></li><li><p>The two templates have equivalent <a href="#element-context-item"><code>xsl:context-item</code></a> children, where equivalence means that the <code>use</code> attributes are the same and the required types are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>; an absent <a href="#element-context-item"><code>xsl:context-item</code></a> is equivalent to one that specifies <code>use="optional"</code> and <code>as="item()"</code>.</p></li></ol></li><li><p>Two variables (including parameters) with the same name are compatible if and only if they satisfy all the following rules:</p><ol class="enumar"><li><p>Their declared types are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>. <span>For this purpose, the declared type is the first of the following that applies:</span></p><ul><li><p>If there is an <code>as</code> attribute, then the type defined by that attribute.</p></li><li><p>If there is a <code>select</code> attribute, then <code>item()*</code>.</p></li><li><p>If there is a non-empty sequence constructor, then <code>document-node()</code>.</p></li><li><p>Otherwise, <code>xs:string</code>. [XSLT 3.0 Erratum E35, bug 30313].</p></li></ul></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>A variable may override a parameter or vice-versa, and the initial value may differ.</p><p>Because static variables and parameters are constrained to have visibility <code>private</code> , they cannot be overridden in another package. The compatibility rules therefore do not arise. The reason that such variables cannot be overridden is that they are typically used during stylesheet compilation (for example, in <code>[xsl:]use-when</code> expressions and shadow attributes) and it is a design goal that packages should be capable of independent compilation.</p></div></li></ul><p><span class="definition">[Definition:&nbsp;</span><a id="dt-identical-types" title="identical (types)"></a>Types S and T are considered <b>identical</b> for the purpose of these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T, S)</code> both hold, where the subtype relation is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-seqtype-subtype">Section 3.7.1 Subtypes of Sequence Types</a><sup><small>XP40</small></sup>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><ol class="enumar"><li><p>One consequence of this rule is that two plain union types are considered identical if they have the same set of member types, even if the union types have different names or the ordering of the member types is different.</p><p>Consider a function that accepts an argument whose declared type is a union type with member types <code>xs:double</code> and <code>xs:decimal</code>, in that order (we might write this as <code>union(xs:double, xs:decimal)</code>). Using the same notation, this can be overridden by a function that declares the argument type as <code>union(xs:decimal, xs:double)</code>. This does not affect type checking: a function call that passes the type checking rules with one signature will also pass the type checking rules with the other. It does however affect the way that the function conversion rules work: a call that passes the <code>xs:untypedAtomic</code> value <code>"93.7"</code> (or an untyped node with this as its string value) will be converted to an <code>xs:decimal</code> in one case and an <code>xs:double</code> in the other.</p></li><li><p>While this rule may appear formal, it is not as straightforward as might be supposed, because the subtype relation in XPath has a dependency on the “Type derivation OK (Simple)” relation in XML Schema, which itself appeals to a judgement as to whether the two type definitions being compared “are the same type definition”. Both XSD 1.0 and XSD 1.1 add the note “The wording of [this rule] appeals to a notion of component identity which is only incompletely defined by this version of this specification.” However, they go on to say that component identity is well defined if the components are named simple type definitions, which will always apply in this case. For named atomic types, the final result of these rules is that two atomic types are identical if and only if they have the same name.</p></li></ol></div><p>Modes are not overridable, so the <a href="#element-mode"><code>xsl:mode</code></a> declaration cannot appear as a child of <a href="#element-override"><code>xsl:override</code></a>.</p></div><div class="div4"><h5><a id="refer-to-overridden"></a>3.5.3.4 <a href="#refer-to-overridden" style="text-decoration: none">Referring to Overridden Components</a></h5><p>Within the declaration of an overriding named <a title="component" class="termref" href="#dt-component">component</a> (that is, a component whose declaration is a child of <a href="#element-override"><code>xsl:override</code></a>, and has a <code>name</code> attribute), where the overridden component has public <a title="visibility" class="termref" href="#dt-visibility">visibility</a>, it is possible to use the name <code>xsl:original</code> as a symbolic reference to the overridden component. More specifically: </p><ul><li><p>Within a <a title="named template" class="termref" href="#dt-named-template">named template</a> appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, the name <code>xsl:original</code> may appear as the value of the <code>name</code> attribute of <a href="#element-call-template"><code>xsl:call-template</code></a>: for example, <code>&lt;xsl:call-template name="xsl:original"/&gt;</code>. </p></li><li><p>Within a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, the static context for contained XPath expressions (other than <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>) is augmented as follows: the <b>statically known function signatures</b> includes a mapping from the name <code>xsl:original</code> to the signature of the overridden function (which is the same as the signature of the overriding function). This means that the name <code>xsl:original</code> can be used in static function calls, including calls that use partial function application (where one of the arguments is given as "?"), and also in named function references. For example: <code>xsl:original($x)</code>, <code>xsl:original($x, ?)</code>, <code>xsl:original#2</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The result of calling <code>function-name(xsl:original#2)</code> is the name of the overridden function, not <code>xsl:original</code>.</p></div><p>Neither <code>xsl:original</code>, nor the overridden function, is added to the <b>named functions</b> component of the dynamic context for XPath expressions within the overriding function. This means that any attempt to bind the function name <code>xsl:original</code> dynamically (for example using <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>, or <a href="#func-function-available"><code>function-available</code></a>, or <a href="#element-evaluate"><code>xsl:evaluate</code></a>) will fail, and any attempt to bind the name of the overriding/overridden function dynamically will return the overriding function. </p></li><li><p>Within a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or parameter appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, the static context for contained XPath expressions (other than <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>) is augmented as follows: the <b>in-scope variables</b> includes a mapping from the name <code>xsl:original</code> to the declared type of the overridden variable or parameter (which is the same as the type of the overriding global variable or parameter). </p></li><li><p>Within an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, any <code>[xsl:]use-attribute-sets</code> attribute (whether on the <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element itself, or on any descendant element) may include the name <code>xsl:original</code> as a reference to the overridden attribute set. </p></li></ul><p>Within the overriding component <var>C<sub>P</sub></var>, the <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a><code>xsl:original</code> is bound to the hidden component <var>C<sub>PQ</sub></var> described earlier, whose body is that of the component <var>C<sub>Q</sub></var> in the used package. </p><p><a id="err-XTSE3075"><span class="error">[ERR XTSE3075] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use the component reference <code>xsl:original</code> when the overridden component has <code>visibility="abstract"</code>. </p><p>Modes are not overridable, so the name <code>xsl:original</code> cannot be used to refer to a <a title="mode" class="termref" href="#dt-mode">mode</a> (for example in the <code>mode</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>). </p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the case of variables, templates, and attribute sets, the invocation of the overridden component can occur only within the lexical scope of the overriding component. With functions, however, there is greater flexibility. The overriding component can obtain a reference to the overridden component in the form of a function item, and can export this value by passing it to other functions or returning it in its result. A dynamic invocation of this function item (and hence, of the overridden function) can thus occur anywhere. </p></div></div><div class="div4"><h5><a id="component-references"></a>3.5.3.5 <a href="#component-references" style="text-decoration: none">Binding References to Components</a></h5><p><span class="definition">[Definition:&nbsp;</span><a id="dt-reference-binding" title="reference binding"></a>The process of identifying the <a title="component" class="termref" href="#dt-component">component</a> to which a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> applies (possibly chosen from several <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> alternatives) is called <b>reference binding</b>.<span class="definition">]</span></p><p>The process of <a title="reference binding" class="termref" href="#dt-reference-binding">reference binding</a> in the presence of overriding declarations is best illustrated by an example. The formal rules follow later in the section.</p><div class="example"><div class="exampleHeader"><a id="example-of-component-binding"></a>Example: Binding References to Named Components</div><p>Consider a package <var>Q</var> defined as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Q</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">A</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">final</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$B</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">B</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">private</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$C</span><span class="whitespace"></span><span class="op">*</span><span class="whitespace"></span><span class="numeric">2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">C</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">22</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:package</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>(The process is illustrated here using variables as the components, but the logic would be the same if the example used functions, named templates, or attribute sets.)</p><p>There are three components in this package, and their properties are illustrated in the following table. (The ID column is an arbitrary component identifier used only for the purposes of this exposition.)</p><table class="data"><caption>Components in the above Package and their Properties</caption><thead><tr><th style="text-align:left; vertical-align:top">ID</th><th style="text-align:left; vertical-align:top">Symbolic Name</th><th style="text-align:left; vertical-align:top">Declaring Package</th><th style="text-align:left; vertical-align:top">Containing Package</th><th style="text-align:left; vertical-align:top">Visibility</th><th style="text-align:left; vertical-align:top">Body</th><th style="text-align:left; vertical-align:top">Bindings</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top"><var>A<sub>Q</sub></var></td><td style="text-align:left; vertical-align:top">variable <var>A</var></td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top"><code>$B + 1</code></td><td style="text-align:left; vertical-align:top">$B → <var>B<sub>Q</sub></var></td></tr><tr><td style="text-align:left; vertical-align:top"><var>B<sub>Q</sub></var></td><td style="text-align:left; vertical-align:top">variable <var>B</var></td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top"><code>$C * 2</code></td><td style="text-align:left; vertical-align:top">$C → <var>C<sub>Q</sub></var></td></tr><tr><td style="text-align:left; vertical-align:top"><var>C<sub>Q</sub></var></td><td style="text-align:left; vertical-align:top">variable <var>C</var></td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">public</td><td style="text-align:left; vertical-align:top"><code>22</code></td><td style="text-align:left; vertical-align:top">none</td></tr></tbody></table><p>Now consider a package <var>P</var> that uses <var>Q</var>, and that overrides one of the variables declared in <var>Q</var>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">P</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:use-package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Q</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:override</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">C</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">private</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$xsl:original</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="numeric">3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:override</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:use-package</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">T</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$A</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:package</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Package <var>P</var> has five components, whose properties are shown in the following table:</p><table class="data"><caption>Components in the above Package and their Properties</caption><thead><tr><th style="text-align:left; vertical-align:top">ID</th><th style="text-align:left; vertical-align:top">Symbolic Name</th><th style="text-align:left; vertical-align:top">Declaring Package</th><th style="text-align:left; vertical-align:top">Containing Package</th><th style="text-align:left; vertical-align:top">Visibility</th><th style="text-align:left; vertical-align:top">Body</th><th style="text-align:left; vertical-align:top">Bindings</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top"><var>A<sub>PQ</sub></var></td><td style="text-align:left; vertical-align:top">variable <var>A</var></td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">P</td><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top"><code>$B + 1</code></td><td style="text-align:left; vertical-align:top">$B → <var>B<sub>PQ</sub></var></td></tr><tr><td style="text-align:left; vertical-align:top"><var>B<sub>PQ</sub></var></td><td style="text-align:left; vertical-align:top">variable <var>B</var></td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">P</td><td style="text-align:left; vertical-align:top">hidden</td><td style="text-align:left; vertical-align:top"><code>$C * 2</code></td><td style="text-align:left; vertical-align:top">$C → <var>C<sub>P</sub></var></td></tr><tr><td style="text-align:left; vertical-align:top"><var>C<sub>PQ</sub></var></td><td style="text-align:left; vertical-align:top">variable <var>C</var></td><td style="text-align:left; vertical-align:top">Q</td><td style="text-align:left; vertical-align:top">P</td><td style="text-align:left; vertical-align:top">hidden</td><td style="text-align:left; vertical-align:top"><code>22</code></td><td style="text-align:left; vertical-align:top">none</td></tr><tr><td style="text-align:left; vertical-align:top"><var>C<sub>P</sub></var></td><td style="text-align:left; vertical-align:top">variable <var>C</var></td><td style="text-align:left; vertical-align:top">P</td><td style="text-align:left; vertical-align:top">P</td><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top"><code>$xsl:original + 3</code></td><td style="text-align:left; vertical-align:top">$xsl:original → <var>C<sub>PQ</sub></var></td></tr><tr><td style="text-align:left; vertical-align:top"><var>T<sub>P</sub></var></td><td style="text-align:left; vertical-align:top">template <var>T</var></td><td style="text-align:left; vertical-align:top">P</td><td style="text-align:left; vertical-align:top">P</td><td style="text-align:left; vertical-align:top">public</td><td style="text-align:left; vertical-align:top"><code>value-of select="$A</code></td><td style="text-align:left; vertical-align:top">$A → <var>A<sub>PQ</sub></var></td></tr></tbody></table><p>The effect of these bindings is that when template <var>T</var> is called, the result is <code>51</code>. This is why:</p><ol class="enumar"><li><p>The result of <var>T</var> is the value of <var>A<sub>PQ</sub></var>.</p></li><li><p>The value of <var>A<sub>PQ</sub></var> is the value of <var>B<sub>PQ</sub></var> plus 1.</p></li><li><p>The value of <var>B<sub>PQ</sub></var> is the value of <var>C<sub>P</sub></var> times 2.</p></li><li><p>The value of <var>C<sub>P</sub></var> is the value of <var>C<sub>PQ</sub></var> plus 3.</p></li><li><p>The value of <var>C<sub>PQ</sub></var> is 22.</p></li><li><p>So the final result is ((22 + 3) * 2) + 1</p></li></ol><p>In this example, the components of <var>P</var> are established in three different ways:</p><ol class="enumar"><li><p>Components <var>A<sub>PQ</sub></var>, <var>B<sub>PQ</sub></var>, and <var>C<sub>PQ</sub></var> are modified copies of the corresponding component <var>A<sub>Q</sub></var>, <var>B<sub>Q</sub></var>, and <var>C<sub>Q</sub></var> in the used package <var>Q</var>. The properties of these components are modified as follows:</p><ol class="enumla"><li><p>The <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>, <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, and body are unchanged.</p></li><li><p>The <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> is changed to <var>P</var>.</p></li><li><p>The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is changed according to the rules in <a href="#accepting-components"><i>3.5.3.2 Accepting Components</i></a>: in particular, <code>visibility="private"</code> changes to <code>visibility="hidden"</code>.</p></li><li><p>The references to other components are rebound as described in this section.</p></li></ol></li><li><p>Component <var>C<sub>P</sub></var> is the overriding component. Its properties are exactly as if it were declared as a top-level component in <var>P</var> (outside the <a href="#element-use-package"><code>xsl:use-package</code></a> element), except that (a) it must adhere to the constraints on overriding components (see <a href="#package-overriding-components"><i>3.5.3.3 Overriding Components from a Used Package</i></a>), (b) it is allowed to use the variable reference <code>$xsl:original</code>, and (c) the fact that it overrides <var>C<sub>Q</sub></var> affects the way that references from other components are rebound.</p></li><li><p>Component <var>T<sub>P</sub></var> is a new component declared locally in <var>P</var>.</p></li></ol></div><p>The general rules for <a title="reference binding" class="termref" href="#dt-reference-binding">reference binding</a> can now be stated:</p><ol class="enumar"><li><p>If the <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> of a component <var>C<sub>P</sub></var> is <var>P</var>, then all <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic references</a> in <var>C<sub>P</sub></var> are bound to components whose <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> is <var>P</var>.</p></li><li><p>When a package <var>P</var> uses a package <var>Q</var>, then for every component <var>C<sub>Q</sub></var> in <var>Q</var>, there is a <b>corresponding component</b><var>C<sub>P</sub></var> in <var>P</var>, as described in <a href="#accepting-components"><i>3.5.3.2 Accepting Components</i></a>.</p></li><li><p>Given a component <var>C<sub>P</sub></var> whose <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> and <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a> are the same package <var>P</var>, then (as a consequence of rules elsewhere in this specification) for every <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a><var>D</var> within <var>C<sub>P</sub></var>, other than a reference using the name <code>xsl:original</code>, there will always be exactly one non-hidden component <var>D<sub>P</sub></var> whose containing package is <var>P</var> and whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> matches <var>D</var> (otherwise a static error will have been reported). The reference is then bound to <var>D<sub>P</sub></var>.</p></li><li><p>In the case of a component reference using the name <code>xsl:original</code>, this will in general appear within a component <var>C<sub>P</sub></var> that overrides a component <var>C<sub>Q</sub></var> whose corresponding component in <var>P</var> is <var>C<sub>PQ</sub></var>, and the <code>xsl:original</code> reference is bound to <var>C<sub>PQ</sub></var>.</p></li><li><p>Given a component <var>C<sub>P</sub></var> whose <a title="containing package" class="termref" href="#dt-containing-package">containing package</a><var>P</var> is a different package from its <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a><var>R</var> (that is, <var>C<sub>P</sub></var> is present in <var>P</var> by virtue of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration referencing package <var>Q</var>, which may or may not be the same as <var>R</var>), then the component bindings in <var>C<sub>P</sub></var> are derived from the component bindings in the corresponding component <var>C<sub>Q</sub></var> as follows: if the component binding within <var>C<sub>Q</sub></var> is to a component <var>D<sub>Q</sub></var>, then:</p><ol class="enumla"><li><p>If <var>D<sub>Q</sub></var> is overridden within <var>P</var> by a component <var>D<sub>P</sub></var>, then the reference is bound to <var>D<sub>P</sub></var>;</p></li><li><p>Otherwise, the reference is bound to the component <var>D<sub>PQ</sub></var> in <var>P</var> whose corresponding component in <var>Q</var> is <var>D<sub>Q</sub></var>.</p></li></ol></li></ol><p>When reference resolution is performed on a package that is intended to be used as a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (that is, for the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>), there must be no symbolic references referring to components whose visibility is <code>abstract</code> (that is, an implementation must be provided for every abstract component). </p><p><a id="err-XTSE3080"><span class="error">[ERR XTSE3080] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> (as distinct from a <a title="library package" class="termref" href="#dt-library-package">library package</a>) contains components whose visibility is <code>abstract</code>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Abstract components in a used package by default become hidden in the using package, which means that a reference to the component in the top-level package will fail to resolve (resulting in a different static error). This particular error occurs only if the abstract component is declared within the top-level package. [XSLT 3.0 Erratum E4, bug 30142].</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Unresolved references are allowed at the module level but not at the package level. A stylesheet module can contain references to components that are satisfied only when the module is imported into another module that declares the missing component.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The process of resolving references (or linking) is critical to an implementation that uses separate compilation. One of the aims of these rules is to ensure that when compiling a package, it is always possible to determine the signature of called functions, templates, and other components. A further aim is to establish unambiguously in what circumstances components can be overridden, so that compilers know when it is possible to perform optimizations such as inlining of function and variable references.</p><p>Suppose a public template <var>T</var> calls a private function <var>F</var>. When the package containing these two components is referenced by a using package, the template remains public, while the function becomes hidden. Because the function becomes hidden, it can no longer conflict with any other function of the same name, or be overridden by any other function; at this stage the compiler knows exactly which function <var>T</var> will be calling, and can perform optimizations based on this knowledge.</p></div><p>The mechanism for resolving component references described in this section is consistent with the mechanism used for binding function and variable references described in the XPath specification. XPath requires these variable and function names to be present in the static context for an XPath expression. XSLT ensures that all the non-hidden functions, global variables, and global parameters in a package are present in the static context for every XPath expression that appears in that package, along with required information such as the type of a variable and the signature of a function.</p><div class="example"><div class="exampleHeader"><a id="d8e7369"></a><a id="d8e7449"></a>Example: Named Component References in Inline Functions</div><p>Named component references within inline functions follow the standard rules, but the rules need to be interpreted with care. Suppose that in package <var>P</var> we find the declarations:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">v</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:factory</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">function(*)</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">final</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="type">function</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">{</span><span class="variable">$v</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>and that in a using package Q we find:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:use-package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">P</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:override</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">v</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">4</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:override</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:use-package</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">xsl:initial-template</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">v</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">f:factory</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The correct output here is <code>&lt;v value="4"/&gt;</code>.</p><p>The explanation for this is as follows. Package <var>Q</var> contains a function <var>f:factory<sub>QP</sub></var> whose declaring package is <var>P</var> and whose containing package is <var>Q</var>. The symbolic reference <code>$v</code> within the body of this function is resolved in the normal way; since the containing package is <var>Q</var>, it is resolved to the global variable <var>v<sub>Q</sub></var>: that is, the overriding declaration of <code>$v</code> that appears within the <a href="#element-override"><code>xsl:override</code></a> element within package <var>Q</var>, whose value is 4.</p><p>In terms of internal implementation, one way of looking at this is that the anonymous function returned by <code>f:factory</code> contains within its closure bindings for the global variables and functions that the anonymous function references; these bindings are inherited from the component bindings of the component that lexically contains these symbolic references, which in this case is <code>f:factory</code>, and more specifically the version of the <code>f:factory</code> component in package <var>Q</var>.</p></div></div><div class="div4"><h5><a id="dynamic-component-references"></a>3.5.3.6 <a href="#dynamic-component-references" style="text-decoration: none">Dynamic References to Components</a></h5><p>There are several functions in which a dynamically evaluated QName is used to identify a component: these include <a href="#func-key"><code>key</code></a>, <a href="#func-accumulator-before"><code>accumulator-before</code></a>, <a href="#func-accumulator-after"><code>accumulator-after</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>, and <a href="#func-function-available"><code>function-available</code></a>. Dynamic references can also occur in the XPath expression supplied to the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction. </p><p>In all these cases, the set of components that are available to be referenced are those that are declared in the package where this function call appears, including components declared within an <a href="#element-override"><code>xsl:override</code></a> declaration in that package, but excluding components declared with <code>visibility="abstract"</code>. If the relevant component has been overridden in a different package, the overriding declarations are not considered. </p><p>If one of these functions (for example <a href="#func-key"><code>key</code></a> or <a href="#func-accumulator-before"><code>accumulator-before</code></a>) is invoked via a dynamic function invocation, then the relevant package is the one in which the function item is created (using a construct such as <code>key#2</code>, <code>key('my-key', ?)</code>, or <code>function-lookup($KEYFN, 2)</code>). Function items referring to context-dependent functions bind the context at the point where the function item is created, not the context at the point where the function item is invoked.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that if a package wishes to make a key available for use by a calling package, it can do so by creating a public global variable whose value is a partial application of the <a href="#func-key"><code>key</code></a> function:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">get-order</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">key</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">orders-key</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">?</span><span class="op">,</span><span class="whitespace"></span><span class="op">?</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>which the calling code can invoke as <code>$get-order('123-456', /)</code>.</p></div></div></div><div class="div3"><h4><a id="modes-and-packages"></a>3.5.4 <a href="#modes-and-packages" style="text-decoration: none">Overriding Template Rules from a Used Package</a></h4><p>The rules in the previous section apply to named components including functions, named templates, global variables, and named attribute sets. The rules for <a title="mode" class="termref" href="#dt-mode">modes</a>, and the <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> appearing within a mode, are slightly different.</p><p>The unnamed mode is local to a package: in effect, each package has its own private unnamed mode, and the unnamed mode of one package does not interact with the unnamed mode of any other package. An <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>mode</code> attribute is treated as a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> to the default mode defined for that instruction (see <a href="#default-mode"><i>3.7.2 The default-mode Attribute</i></a>), which in turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. Because the unnamed mode always has private visibility, it cannot be overridden in another package.</p><p>A named mode may be declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration as being either <code>public</code>, <code>private</code>, or <code>final</code>. The values of the <code>visibility</code> attribute are interpreted as follows:</p><table class="def"><caption>Visibility Values for Named Modes, and their Meaning</caption><thead><tr><th style="text-align:left; vertical-align:top">Value</th><th style="text-align:left; vertical-align:top">Meaning</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">public</td><td style="text-align:left; vertical-align:top">A <b>using</b> package may use <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> to invoke templates in this mode; it may also declare additional template rules in this mode, which are selected in preference to template rules in the used package. These may appear only as children of the <a href="#element-override"><code>xsl:override</code></a> element within the <a href="#element-use-package"><code>xsl:use-package</code></a> element.</td></tr><tr><td style="text-align:left; vertical-align:top">private</td><td style="text-align:left; vertical-align:top">A <b>using</b> package may neither reference the mode nor provide additional templates in this mode; the name of the mode is not even visible in the using package, so no such attempt is possible. The using package can use the same name for its own modes without risk of conflict. </td></tr><tr><td style="text-align:left; vertical-align:top">final</td><td style="text-align:left; vertical-align:top">A <b>using</b> package may use <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> to invoke templates in this mode, but it must not provide additional template rules in this mode. </td></tr></tbody></table><p>As with other named components, an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration may contain an <a href="#element-accept"><code>xsl:accept</code></a> element to control the visibility of a mode acquired from the <b>used</b> package. The allowed values of its <code>visibility</code> attribute are <code>public</code>, <code>private</code>, and <code>final</code>.</p><p>The <a href="#element-mode"><code>xsl:mode</code></a> declaration itself must not be overridden. A using package must not contain an <a href="#element-mode"><code>xsl:mode</code></a> declaration whose name matches that of a <code>public</code> or <code>final</code><a href="#element-mode"><code>xsl:mode</code></a> component accepted from a used package.</p><p>The <a href="#element-expose"><code>xsl:expose</code></a> and <a href="#element-accept"><code>xsl:accept</code></a> elements may be used to reduce the visibility of a mode in a using package; the same rules apply in general, though some of the rules are not applicable because, for example, modes cannot be <code>abstract</code>.</p><p>It is not possible for a package to combine the template rules from two other packages into a single mode. When <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used without specifying a mode, the chosen template rules will always come from the same package; when it is used with a named mode, then they will come from the package where the mode is defined, or any package that uses that package and adds template rules to the mode. If two template rules defined in different packages match the same node, then the rule in the using package wins over any rule in the used package; this decision is made before taking other factors such as import precedence and priority into account.</p><p>A static error occurs if two modes with the same name are visible within a package, either because they are both declared within the package, or because one is declared within the package and the other is acquired from a used package, or because both are accepted from different used packages.</p><p>The rules for matching template rules by <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a> operate as normal, with the addition that template rules declared within an <a href="#element-use-package"><code>xsl:use-package</code></a> element have higher precedence than any template rule declared in the used package. More specifically, given an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in package <var>P</var>, naming a mode <var>M</var> that is declared in a used package <var>Q</var> and is overridden in <var>P</var>, the search order for template rules is:</p><ol class="enumar"><li><p>Rules declared within <var>P</var> (specifically, <a href="#element-template"><code>xsl:template</code></a> rules declared as children of an <a href="#element-override"><code>xsl:override</code></a> element within the <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package <var>Q</var>). If there are multiple rules declared within <var>P</var> that match a selected node, they are resolved on the basis of their explicit or implicit <a title="priority" class="termref" href="#dt-priority">priority</a>, and if the priorities are equal, the last one in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> wins.</p></li><li><p>Rules declared within <var>Q</var>, taking <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, <a title="priority" class="termref" href="#dt-priority">priority</a>, and <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> into account in the usual way (see <a href="#conflict"><i>6.5 Conflict Resolution for Template Rules</i></a>).</p></li><li><p>Built-in template rules (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>) selected according to the <code>on-no-match</code> attribute of the <a href="#element-mode"><code>xsl:mode</code></a> declaration (in <var>Q</var>), or its default.</p></li></ol><p>If the mode is overridden again in a package <var>R</var> that uses <var>P</var>, then this search order is extended by adding <var>R</var> at the start of the search list, and so on recursively.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If existing XSLT code has been written to use template rules in the unnamed mode, a convenient way to incorporate this code into a <a title="library package" class="termref" href="#dt-library-package">library package</a> is to add a stub module that defines a new named <code>public</code> or <code>final</code> mode, in which there is a single template rule whose content is the single instruction <code>&lt;xsl:apply-templates select="."/&gt;</code>. This in effect redirects <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions using the named mode to the rules defined in the unnamed mode.</p></div><div class="div4"><h5><a id="requiring-explicit-modes"></a>3.5.4.1 <a href="#requiring-explicit-modes" style="text-decoration: none">Requiring Explicit Mode Declarations</a></h5><p>In previous versions of XSLT, modes were implicitly declared by simply using a mode name in the <code>mode</code> attribute of <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>. XSLT 3.0 introduced the ability to declare a mode explicitly using an <a href="#element-mode"><code>xsl:mode</code></a> declaration (see <a href="#declaring-modes"><i>6.7.1 Declaring Modes</i></a>).</p><p>By default, within a package that is defined using an explicit <a href="#element-package"><code>xsl:package</code></a> element, all modes must be explicitly declared. In an implicit package, however (that is, one rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element), modes can be implicitly declared as in previous XSLT versions.</p><p>The <code>declared-modes</code> attribute of <a href="#element-package"><code>xsl:package</code></a> determines whether or not modes that are referenced within the package must be explicitly declared. If the value is <code>yes</code> (the default), then it is an error to use a mode name unless the package either contains an explicit <a href="#element-mode"><code>xsl:mode</code></a> declaration for that mode, or accepts the mode from a used package. If the value is <code>no</code>, then this is not an error. </p><p>This attribute affects all modules making up the package, it is not confined to declarations appearing as children of the <a href="#element-package"><code>xsl:package</code></a> element.</p><p><span style="display: none;" class="delete_version"><a id="err-XTSE3085"><span class="error">[ERR XTSE3085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, when the effective value of the <code>declared-modes</code> attribute of an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the package contains an explicit reference to an undeclared mode, or if it implicitly uses the unnamed mode and the unnamed mode is undeclared.</span><span style="display: none;" class="add_version"><a id="err-XTSE3085"><span class="error">[ERR XTSE3085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, when the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the package contains an explicit reference to an undeclared mode, or if it implicitly uses the unnamed mode and the unnamed mode is undeclared.</span><span class="modify_version"><a id="err-XTSE3085"><span class="error">[ERR XTSE3085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, when the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>declared-modes</code> attribute of an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the package contains an explicit reference to an undeclared mode, or if it implicitly uses the unnamed mode and the unnamed mode is undeclared.</span></p><p>For the purposes of the above rule:</p><ol class="enumar"><li><p>A mode is <b>declared</b> if either of the following conditions is true:</p><ol class="enumla"><li><p>The package contains an <a href="#element-mode"><code>xsl:mode</code></a> declaration for that mode.</p></li><li><p>The mode is a public or final mode accepted from a used package. </p></li></ol></li><li><p>The offending reference may be either an explicit mode name, or the token <code>#unnamed</code> treated as a reference to the unnamed mode, or a defaulted mode attribute, and it may occur in any of the following:</p><ol class="enumla"><li><p>The <code>mode</code> attribute of an <a href="#element-template"><code>xsl:template</code></a> declaration</p></li><li><p>The <code>mode</code> attribute of an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction</p></li><li><p>An <code>[xsl:]default-mode</code> attribute.</p></li></ol></li><li><p>A package <b>implicitly uses the unnamed mode</b> if either of the following conditions is true:</p><ol class="enumla"><li><p>There is an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element with no <code>mode</code> attribute, and with no ancestor-or-self having an <code>[xsl:]default-mode</code> attribute.</p></li><li><p>There is an <a href="#element-template"><code>xsl:template</code></a> element with a <code>match</code> attribute and no <code>mode</code> attribute, and with no ancestor-or-self having an <code>[xsl:]default-mode</code> attribute.</p></li></ol></li></ol></div></div><div class="div3"><h4><a id="package-local-declarations"></a>3.5.5 <a href="#package-local-declarations" style="text-decoration: none">Declarations Local to a Package</a></h4><p>The <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a> declarations are local to a package.</p><p>Declarations of <a title="key" class="termref" href="#dt-key">keys</a>, <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a>, <a title="decimal format" class="termref" href="#dt-decimal-format">decimal formats</a>, namespace aliases (see <a href="#namespace-aliasing"><i>11.1.4 Namespace Aliasing</i></a>), <a title="output definition" class="termref" href="#dt-output-definition">output definitions</a>, and <a title="character map" class="termref" href="#dt-character-map">character maps</a> within a package have local scope within that package — they are all effectively private. The elements that declare these constructs do not have a <code>visibility</code> attribute. The unnamed decimal format and the unnamed output format are also local to a package.</p><p>If <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations appear within a <a title="library package" class="termref" href="#dt-library-package">library package</a>, they only affect calls to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="#func-document"><code>document</code></a> functions appearing within that package. Such a declaration within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> additionally affects stripping of whitespace in the document that contains the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p><p>An <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration within a package applies only to calls on <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> appearing within that package.</p><p>An <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration within a package applies only to literal result elements within the same package.</p><p>An <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration within a package adds the names of the imported schema components to the static context for that package only; these names are effectively private, in the sense that they do not become available for use in any other packages. However, the names of schema components must be consistent across the stylesheet as a whole: it is not possible for two different packages within a stylesheet to use a type-name such as <code>part-number</code> to refer to different schema-defined simple or complex types.</p><p>Type names used in the interface of public components in a package (for example, in the arguments of a function) must be respected by callers of those components, in the sense that the caller must supply values of the correct type. Often this will mean that the using component, if it contains calls on such interfaces, must itself import the necessary schema components. However, the requirement for an explicit schema import applies only where the package contains explicit use of the names of schema components required to call such interfaces.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, suppose a <a title="library package" class="termref" href="#dt-library-package">library package</a> contains a function which requires an argument of type <code>mfg:part-number</code>. The caller of this function must supply an argument of the correct type, but does not need to import the schema unless it explicitly uses the schema type name <code>mfg:part-number</code>. If it obtains an instance of this type from outside the package, for example as the result of another function call, then it can supply this instance to the acquired function even though it has not imported a schema that defines this type.</p></div><p>At execution time, the schema available for validating instance documents contains (at least) the union of the schema components imported into all constituent packages of the stylesheet.</p></div><div class="div3"><h4><a id="declaring-global-context-item"></a>3.5.6 <a href="#declaring-global-context-item" style="text-decoration: none">Declaring the Global Context Item</a></h4><p>The <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element is used to declare whether a <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is required, and if so, what its <a title="required type" class="termref" href="#dt-required-type">required type</a> is.</p><p>The element is a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> that can appear at most once in any stylesheet module; and if more than one <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a <a title="package" class="termref" href="#dt-package">package</a>, then the declarations must be consistent. Specifically, all the attributes <span class="verb">must</span> have semantically equivalent values.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that omitting an attribute is equivalent to specifying its default value explicitly; and purely lexical variations, such as the presence of whitespace in an attribute value, are not considered significant.</p></div><p><a id="err-XTSE3087"><span class="error">[ERR XTSE3087] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if more than one <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, or if several modules within a single <a title="package" class="termref" href="#dt-package">package</a> contain inconsistent <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declarations</p><p>If there is no <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration for a package, this is equivalent to specifying the empty element <code>&lt;xsl:global-context-item/&gt;</code>, which imposes no constraints.</p><p class="element-syntax"><a id="element-global-context-item"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:global-context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"&nbsp;/&gt;</code></p><p>The <code>use</code> attribute takes the value <code>required</code>, <code>optional</code>, or <code>absent</code>. The default is <code>optional</code>.</p><ul><li><p>If the value <code>required</code> is specified, then there must be a global context item. </p></li><li><p>If the value <code>optional</code> is specified, or if the attribute is omitted, or if the <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element is omitted, then there may or may not be a global context item.</p></li><li><p>If the value <code>absent</code> is specified, then the global focus (context item, position, and size) will be <a title="absent" class="termref" href="#dt-absent">absent</a></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification does not define whether supplying a global context item in this situation results in an error or warning, or whether the supplied context item is simply ignored.</p></div></li></ul><p>If the <code>as</code> attribute is present then its value must be an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP40</small></sup>. If the attribute is omitted this is equivalent to specifying <code>as="item()"</code>.</p><p>The <code>as</code> attribute defines the required type of the global context item. The default value is <code>as="item()"</code>. If a global context item is supplied then it must conform to the required type, after conversion (if necessary) using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p><a id="err-XTSE3089"><span class="error">[ERR XTSE3089] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is present when <code>use="absent"</code> is specified.</p><p>The global context item is available only within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>. If a valid <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a <a title="library package" class="termref" href="#dt-library-package">library package</a>, then it is ignored, unless it specifies <code>use="required"</code>, in which case an error is signaled: <span class="error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In earlier releases of this specification, the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> and the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> were essentially the same thing, often referred to as the <em>principal source document</em>. In XSLT 3.0, they were separated: the global context item is a single item accessible to the initializers of global variables as the value of the expression <code>.</code> (dot), while the initial match selection is a sequence of nodes or other items supplied to an initial implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> invocation.</p><p>APIs that were originally designed for use with earlier versions of XSLT are likely to bundle the two concepts together.</p><p>With a streamable processor, the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> can consist of streamed nodes, but the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is always <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, because it is available to all global variables and there is no control over the sequence of processing.</p></div><p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> is signaled if <span>the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> contains</span> an <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration specifying a required type that does not match the supplied <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>. The error code is the same as for <a href="#element-param"><code>xsl:param</code></a>: <span class="error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>. <span>[XSLT 3.0 Erratum E7, bug 30179].</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>If the <code>ItemType</code> is one that can only be satisfied by a schema-validated input document, for example <code>as="schema-element(invoice)"</code>, the <a title="processor" class="termref" href="#dt-processor">processor</a> may interpret this as a request to apply schema validation to the input. Similarly, if the <code>KindTest</code> indicates that an element node is required, the processor may interpret this as a request to supply the document element rather than the document node of a supplied input document.</p></div><p><a id="err-XTDE3086"><span class="error">[ERR XTDE3086] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration specifies <code>use="required"</code>, and no global context item is supplied. [XSLT 3.0 Erratum E6, bug 30173].</p></div><div class="div3"><h4><a id="packages-csv-library-example"></a>3.5.7 <a href="#packages-csv-library-example" style="text-decoration: none">Worked Example of a Library Package</a></h4><p>The example in this section illustrates the use of overrides to customize or extend a (fictional) library package named <code>http://example.com/csv-parser</code>, which provides a parsing function for data formatted as lines containing comma-separated values. For simplicity of exposition, the example shows a simple, naive implementation; a realistic CSV parser would be more complicated and make the example harder to follow.</p><div class="div4"><h5><a id="csv-example-default-functionality"></a>3.5.7.1 <a href="#csv-example-default-functionality" style="text-decoration: none">Default Functionality of the CSV Package</a></h5><p>The basic functionality of the package is provided by the function <code>csv:parse</code>, which expects a string parameter named <code>input</code>. By default, the function parses the input into lines, and breaks lines on commas, returning as result an element named <code>csv</code> containing one <code>row</code> element per line, each <code>row</code> containing a sequence of <code>field</code> elements.</p><p>A simple stylesheet which uses this library and applies it to a string might look like the following. The initial template applies <code>csv:parse</code> to a suitable string and returns a copy of the result:</p><div class="exampleInner"><pre class="spectrum"><span class="z">&lt;?</span><span class="pi">xml version="1.0" encoding="UTF-8"</span><span class="z">?&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xs</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:csv</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/csv</span><span class="z">"</span><span class="z"></span><span class="atn">exclude-result-prefixes</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs csv</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output</span><span class="z"></span><span class="atn">indent</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:use-package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/csv-parser</span><span class="z">"</span><span class="z"></span><span class="atn">package-version</span><span class="atneq">=</span><span class="z">"</span><span class="av">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> example input "file" </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"> name,id,postal code "Abel Braaksma",34291,1210 KA "Anders Berglund",473892,9843 ZD </span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> entry point </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">xsl:initial-template</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">csv:parse</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The result returned by this stylesheet would be:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">csv</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">name</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">id</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">postal code</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Abel Braaksma</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">34291</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">1210 KA</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Anders Berglund</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">473892</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">9843 ZD</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">csv</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Variations on this default behavior are achieved by overriding selected declarations in the package, as described below.</p></div><div class="div4"><h5><a id="csv-example-package-structure"></a>3.5.7.2 <a href="#csv-example-package-structure" style="text-decoration: none">Package Structure</a></h5><p>The package module itself is version 1.0.0 of a package called <code>http://example.com/csv-parser</code>; it has the following structure:</p><div class="exampleInner"><pre class="spectrum"><span class="z">&lt;?</span><span class="pi">xml version="1.0" encoding="UTF-8"</span><span class="z">?&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/csv-parser</span><span class="z">"</span><span class="z"></span><span class="atn">package-version</span><span class="atneq">=</span><span class="z">"</span><span class="av">1.0.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xs</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:csv</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/csv</span><span class="z">"</span><span class="z"></span><span class="atn">exclude-result-prefixes</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs csv</span><span class="z">"</span><span class="z"></span><span class="atn">declared-modes</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm">* Mode declarations ... *</span><span class="z">--&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm">* Variable declarations ... *</span><span class="z">--&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm">* Attribute-set declaration ... *</span><span class="z">--&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm">* Function declarations ... *</span><span class="z">--&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm">* Templates ... *</span><span class="z">--&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:package</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The contents of the package (represented here by comments) are described more fully below.</p></div><div class="div4"><h5><a id="csv-example-customizing-parse"></a>3.5.7.3 <a href="#csv-example-customizing-parse" style="text-decoration: none">The </a><code>csv:parse</code><a href="#csv-example-customizing-parse" style="text-decoration: none"> Function and its User-customization Hooks</a></h5><p>The <code>csv:parse</code> function is final and cannot be overridden. As can be seen from the code below, it (1) parses its <code>input</code> parameter into lines, (2) calls function <code>csv:preprocess-line</code> on each line, then (3) applies the templates of mode <code>csv:parse-line</code> to the pre-processed value. The result is then (4) processed again by mode <code>csv:post-process</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">csv:parse</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">final</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">result</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element()</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">csv</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="function">tokenize</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$csv:line-separator</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">!</span><span class="whitespace"></span><span class="function">csv:preprocess-line</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:parse-line</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">csv</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$result</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:post-process</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The default code for this processing is given below. Each part of the processing except the first (the tokenization into lines) can be overridden by the user of the package.</p></div><div class="div4"><h5><a id="csv-example-line-breaking"></a>3.5.7.4 <a href="#csv-example-line-breaking" style="text-decoration: none">Breaking the Input into Lines</a></h5><p>The first user-customization hook is given by the global variable <code>csv:line-separator</code>, which specifies the line separator used to break the input string into lines. It can be overridden by the user if need be. The default declaration attempts to handle the line-separator sequences used by most common operating systems in text files:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">csv:line-separator</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">\r\n?|\n\r?</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><div class="div4"><h5><a id="csv-example-preprocessing-lines"></a>3.5.7.5 <a href="#csv-example-preprocessing-lines" style="text-decoration: none">Pre-processing the Lines</a></h5><p>The function <code>csv:preprocess-line</code> calls <code>normalize-space()</code> on its argument:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">csv:preprocess-line</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string?</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">line</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">normalize-space</span><span class="parenthesis">(</span><span class="variable">$line</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Because the function is declared <code>public</code>, it can be overridden by a user. (This might be necessary, for example, if whitespace within quoted strings needs to be preserved.)</p></div><div class="div4"><h5><a id="example-csv-mode-parse-line"></a>3.5.7.6 <a href="#example-csv-mode-parse-line" style="text-decoration: none">The Mode </a><code>csv:parse-line</code></h5><p>By default, the mode <code>csv:parse-line</code> parses the current item (this will be one line of the input data) into fields, using mode <code>csv:parse-field</code> on the individual fields and (by default) wrapping the result in a <code>row</code> element.</p><p>The mode is declared with <code>visibility="public"</code> to allow it to be called from elsewhere and overridden:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:parse-line</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:parse-line</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">tokenize</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$csv:field-separator</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:parse-field</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This relies on the variable <code>csv:field-separator</code>, which is a comma by default but which can be overridden by the user to parse tab-separated data or data with other delimiters.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">csv:field-separator</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">,</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The default implementation of <code>csv:parse-line</code> does not handle occurrences of the field separator occurring within quoted strings. The user can add templates to the mode to provide that functionality. </p></div><div class="div4"><h5><a id="csv-example-mode"></a>3.5.7.7 <a href="#csv-example-mode" style="text-decoration: none">Mode </a><code>csv:parse-field</code></h5><p>Mode <code>csv:parse-field</code> processes the current item as a field; by default it strips quotation marks from the value, calls the function <code>csv:preprocess-field()</code> on it, and wraps the result in a <code>field</code> element, which carries the attributes declared in the attribute set <code>csv:field-attributes</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:parse-field</span><span class="z">"</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">string-body-pattern</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">([^</span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="variable">$csv:validated-quote</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">]*)</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">quoted-value</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$csv:validated-quote</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="variable">$string-body-pattern</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="variable">$csv:validated-quote</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">unquoted-value</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">(.+)</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">xsl:use-attribute-sets</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:field-attributes</span><span class="z">"</span><span class="scx">&gt;</span><span class="op">{</span><span class="whitespace"></span><span class="function">csv:preprocess-field</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="function">replace</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$quoted-value</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">|</span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="variable">$unquoted-value</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">$1$2</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The attribute set <code>csv:field-attributes</code> includes, by default, a <code>quoted</code> attribute which has the values <code>yes</code> or <code>no</code> to show whether the input value was quoted or not.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:attribute-set</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:field-attributes</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">quoted</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="function">starts-with</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$csv:validated-quote</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="op">'</span><span class="literal">yes</span><span class="op">'</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="op">'</span><span class="literal">no</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute-set</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The mode <code>csv:parse-field</code> is declared with <code>visibility="public"</code> to allow it to be called from elsewhere and overridden; it specifies <code>on-no-match="shallow-copy"</code> so that any string not matching a template will simply be copied:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:parse-field</span><span class="z">"</span><span class="z"></span><span class="atn">on-no-match</span><span class="atneq">=</span><span class="z">"</span><span class="av">shallow-copy</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><div class="div4"><h5><a id="csv-example-variable"></a>3.5.7.8 <a href="#csv-example-variable" style="text-decoration: none">The </a><code>csv:quote</code><a href="#csv-example-variable" style="text-decoration: none"> Variable</a></h5><p>The variable <code>csv:quote</code> can be used to specify the character used in a particular input stream to quote values.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">csv:quote</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">&amp;quot;</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The template given above assumes that the variable is one character long. To ensure that any overriding value of the variable is properly checked, references to the value use a second variable <code>csv:validated-quote</code>, which is declared <code>private</code> to ensure that the checking cannot be disabled.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">csv:validated-quote</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">private</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="whitespace"></span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="function">string-length</span><span class="parenthesis">(</span><span class="variable">$csv:quote</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">ne</span><span class="whitespace"></span><span class="numeric">1</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="function">error</span><span class="parenthesis">(</span><span class="function">xs:QName</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">csv:ERR001</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">Incorrect length for $csv:quote, should be 1</span><span class="op">'</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="variable">$csv:quote</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>When the value of <code>csv:quote</code> is not exactly one character long, the reference to <code>csv:validated-quote</code> will cause an error (csv:ERR001) to be raised.</p></div><div class="div4"><h5><a id="csv-example-preprocess-field"></a>3.5.7.9 <a href="#csv-example-preprocess-field" style="text-decoration: none">The </a><code>csv:preprocess-field</code><a href="#csv-example-preprocess-field" style="text-decoration: none"> Function</a></h5><p>The function <code>csv:preprocess-field</code> is called on each field after any quotation marks are stripped and before it is written out as the value of a <code>field</code> element:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">csv:preprocess-field</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">field</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$field</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>As can be seen, the function does nothing but return its input; its only purpose is to provide the opportunity for the user to supply a suitable function to be invoked at this point in the processing of each field.</p></div><div class="div4"><h5><a id="csv-example-postprocess"></a>3.5.7.10 <a href="#csv-example-postprocess" style="text-decoration: none">The Mode </a><code>csv:post-process</code></h5><p>The mode <code>csv:post-process</code> is intended solely as a hook for user code. By default, it does nothing.</p><p>The package defines no templates for this mode; the mode definition makes it return a copy of its input:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:post-process</span><span class="z">"</span><span class="z"></span><span class="atn">on-no-match</span><span class="atneq">=</span><span class="z">"</span><span class="av">shallow-copy</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><div class="div4"><h5><a id="csv-example-overriding"></a>3.5.7.11 <a href="#csv-example-overriding" style="text-decoration: none">Overriding the Default Behavior</a></h5><p>As can be seen from the code shown above, the package provides several opportunities for users to override the default behavior:</p><ul><li><p>The global variables <code>csv:line-separator</code>, <code>csv:field-separator</code>, and <code>csv:quote</code> can be overridden to specify the character strings used to separate lines and fields and to quote individual field values.</p></li><li><p>The function <code>csv:preprocess-line</code> can be overridden to do more (or less) than stripping white space; the function <code>csv:preprocess-field</code> can be overridden to process individual field values.</p></li><li><p>Templates can be added to the modes <code>csv:parse-line</code>, <code>csv:parse-field</code>, and <code>csv:post-process</code> to change their behavior.</p></li><li><p>The attribute set <code>csv:field-attributes</code> can be overridden to specify a different set of attributes (or none) for <code>field</code> elements.</p></li></ul><p>The following using stylesheet illustrates the use of the <a href="#element-override"><code>xsl:override</code></a> element to take advantage of several of these opportunities:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xs</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:csv</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/csv</span><span class="z">"</span><span class="z"></span><span class="atn">exclude-result-prefixes</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs csv</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output</span><span class="z"></span><span class="atn">indent</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:use-package</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/csv-parser</span><span class="z">"</span><span class="z"></span><span class="atn">package-version</span><span class="atneq">=</span><span class="z">"</span><span class="av">*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:override</span><span class="scx">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> Change the root element from 'csv' to 'root' </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">csv</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:post-process</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">root</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:post-process</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">root</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> add an extra attribute that uses the context item </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute-set</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">csv:field-attributes</span><span class="z">"</span><span class="z"></span><span class="atn">use-attribute-sets</span><span class="atneq">=</span><span class="z">"</span><span class="av">xsl:original</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">type</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="context">.</span><span class="whitespace"></span><span class="type-op">castable as</span><span class="whitespace"></span><span class="type-name">xs:decimal</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="op">'</span><span class="literal">numeric</span><span class="op">'</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="op">'</span><span class="literal">string</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute-set</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> use semicolon not comma between fields </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">csv:field-separator</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">;</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> prevent empty rows from appearing with empty lines </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">csv:preprocess-line</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string?</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">line</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">norm-line</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">normalize-space</span><span class="parenthesis">(</span><span class="function">xsl:original</span><span class="parenthesis">(</span><span class="variable">$line</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="function">string-length</span><span class="parenthesis">(</span><span class="variable">$norm-line</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">&gt;</span><span class="whitespace"></span><span class="numeric">0</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="variable">$norm-line</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:override</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:use-package</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> example input "file" </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"> name;id;postal code "Braaksma Abel";34291;1210 KA "Berglund Anders";473892;9843 ZD </span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> entry point </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">xsl:initial-template</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">csv:parse</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><ul><li><p>As it does elsewhere, the visibility of components declared within <a href="#element-override"><code>xsl:override</code></a> defaults to <code>private</code>; to keep the component public, it is necessary to specify visibility explicitly.</p></li><li><p>The types and optionality of all function parameters must match those of the function being overridden; for function overriding to be feasible, packages must document the function signature thoroughly.</p></li><li><p>The names, types, and optionality of all named-template parameters must match those of the template being overridden; for overriding to be feasible, packages must document the template signature thoroughly.</p></li><li><p>The values for the attributes in the attribute set <code>csv:field-attributes</code> are calculated once for each element for which the attribute set is supplied; the <code>select</code> attributes which determine the values can thus refer to the context item. Here, the value specification for the <code>type</code> attribute checks to see whether the string value of the context item is numeric by inquiring whether it can be cast to decimal, and sets the value for the <code>type</code> attribute accordingly.</p></li></ul></div><p>The result returned by this stylesheet would be:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">root</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">name</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">id</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">postal code</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Braaksma Abel</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">numeric</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">34291</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">1210 KA</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Berglund Anders</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">numeric</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">473892</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">field</span><span class="z"></span><span class="atn">quoted</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">9843 ZD</span><span class="ez">&lt;/</span><span class="cl">field</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">root</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div2"><h3><a id="stylesheet-modules"></a>3.6 <a href="#stylesheet-modules" style="text-decoration: none">Stylesheet Modules</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-module" title="stylesheet module"></a>A <a title="package" class="termref" href="#dt-package">package</a> consists of one or more <b>stylesheet modules</b>, each one forming all or part of an XML document.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>A stylesheet module is represented by an XDM element node (see <a href="#xpath-datamodel-30">[XDM 3.0]</a>). In the case of a standard stylesheet module, this will be an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element. In the case of a simplified stylesheet module, it can be any element (not in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) that has an <code>xsl:version</code> attribute.</p><p>Although stylesheet modules will commonly be maintained in the form of documents conforming to XML 1.0 or XML 1.1, this specification does not mandate such a representation. As with <a title="source tree" class="termref" href="#dt-source-tree">source trees</a>, the way in which stylesheet modules are constructed, from textual XML or otherwise, is outside the scope of this specification.</p></div><p>The principal stylesheet module of a package may take one of three forms:</p><ul><li><p>A package manifest, as described in <a href="#packages"><i>3.5 Packages</i></a>, which is a subtree rooted at an <a href="#element-package"><code>xsl:package</code></a> element</p></li><li><p>An implicit package, which is a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element. This is transformed automatically to a package as described in <a href="#packages"><i>3.5 Packages</i></a>. </p></li><li><p>A simplified stylesheet, which is a subtree rooted at a literal result element, as described in <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>. This is first converted to an implicit package by wrapping it in an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element using the transformation described in <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>, and then to an explicit package (rooted at an <a href="#element-package"><code>xsl:package</code></a> element) using the transformation described in <a href="#packages"><i>3.5 Packages</i></a>. </p></li></ul><p>A stylesheet module other than the principal stylesheet module of a package may take either of two forms:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-stylesheet-module" title="standard stylesheet module"></a>A <b>standard stylesheet module</b>, which is a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-simplified-stylesheet-module" title="simplified stylesheet"></a>A <b>simplified stylesheet</b>, which is a subtree rooted at a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, as described in <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>. This is first converted to a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> by wrapping it in an xsl:stylesheet element using the transformation described in <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>.<span class="definition">]</span></p></li></ul><p>Whichever of the above forms a module takes, the outermost element (<a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>) <span class="verb">may</span> either be the outermost element of an XML document, or it <span class="verb">may</span> be a child of some (non-XSLT) element in a host document. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-embedded-stylesheet-module" title="embedded stylesheet module"></a>A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>. See <a href="#embedded"><i>3.12 Embedded Stylesheet Modules</i></a>.<span class="definition">]</span></p></div><div class="div2"><h3><a id="stylesheet-element"></a>3.7 <a href="#stylesheet-element" style="text-decoration: none">Stylesheet Element</a></h3><p class="element-syntax"><a id="element-stylesheet"></a><code>&lt;xsl:stylesheet<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;default-element-namespace? = <var>uri</var><br>&nbsp;&nbsp;default-type-namespace? = <var>uri</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;use-when? = <var>expression</var><br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:stylesheet&gt;</code></p><p class="element-syntax"><a id="element-transform"></a><code>&lt;xsl:transform<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;default-element-namespace? = <var>uri</var><br>&nbsp;&nbsp;default-type-namespace? = <var>uri</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;use-when? = <var>expression</var><br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:transform&gt;</code></p><p>A stylesheet module is represented by an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element in an XML document. <a href="#element-transform"><code>xsl:transform</code></a> is allowed as a synonym for <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>; everything this specification says about the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element applies equally to <a href="#element-transform"><code>xsl:transform</code></a>.</p><p>The <code>version</code> attribute indicates the version of XSLT that the stylesheet module requires. The attribute is <span class="verb">required</span>.</p><p><a id="err-XTSE0110"><span class="error">[ERR XTSE0110] </span></a>The value of the <code>version</code> attribute <span class="verb">must</span> be a number: specifically, it <span class="verb">must</span> be a valid instance of the type <code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>. </p><p>The <code>version</code> attribute is intended to indicate the version of the XSLT specification against which the stylesheet is written. In a stylesheet written to use XSLT 4.0, the value <span class="verb">should</span> normally be set to <code>4.0</code>. If the value is numerically less than 4.0, the stylesheet is processed using the rules for <a title="backwards compatible behavior" class="termref" href="#dt-backwards-compatible-behavior">backwards compatible behavior</a> (see <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>). If the value is numerically greater than <span>4.0</span>, the stylesheet is processed using the rules for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.10 Forwards Compatible Processing</i></a>).</p><p>The effect of the <code>input-type-annotations</code> attribute is described in <a href="#stripping-annotations"><i>4.3.1 Stripping Type Annotations from a Source Tree</i></a>.</p><p>The <code>[xsl:]default-validation</code> attribute defines the default value of the <code>validation</code> attribute of all relevant instructions appearing within its scope. For details of the effect of this attribute, see <a href="#validation"><i>26.4 Validation</i></a>.</p><p>The optional <code>main-module</code> attribute is purely documentary. By including this attribute in every <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> of a <a title="package" class="termref" href="#dt-package">package</a>, an XSLT editing tool may be enabled to locate the top-level module of the relevant package, and thus to gather information about all the global variables, templates, and functions available within the module being edited. This information can be used (for example) to enable auto-completion and error highlighting of the code as it is entered. Note that it may be inconvenient or misleading to use this attribute when the stylesheet module is used as a shared component within multiple stylesheets. </p><p><a id="err-XTSE0120"><span class="error">[ERR XTSE0120] </span></a>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any text node children. (This rule applies after stripping of <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> as described in <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>.)</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-top-level" title="top-level"></a>An element occurring as a child of an <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a> element is called a <b>top-level</b> element.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-declaration" title="declaration"></a>Top-level elements fall into two categories: declarations, and user-defined data elements. Top-level elements whose names are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> are <b>declarations</b>. Top-level elements in any other namespace are <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.7.3 User-defined Data Elements</i></a>)<span class="definition">]</span>.</p><p>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> elements permitted in the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element are:</p><blockquote><p><a href="#element-accumulator"><code>xsl:accumulator</code></a><br><a href="#element-attribute-set"><code>xsl:attribute-set</code></a><br><a href="#element-character-map"><code>xsl:character-map</code></a><br><a href="#element-decimal-format"><code>xsl:decimal-format</code></a><br><a href="#element-function"><code>xsl:function</code></a><br><a href="#element-global-context-item"><code>xsl:global-context-item</code></a><br><a href="#element-import"><code>xsl:import</code></a><br><a href="#element-import-schema"><code>xsl:import-schema</code></a><br><a href="#element-include"><code>xsl:include</code></a><br><a href="#element-key"><code>xsl:key</code></a><br><a href="#element-mode"><code>xsl:mode</code></a><br><a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a><br><a href="#element-output"><code>xsl:output</code></a><br><a href="#element-param"><code>xsl:param</code></a><br><a href="#element-preserve-space"><code>xsl:preserve-space</code></a><br><a href="#element-strip-space"><code>xsl:strip-space</code></a><br><a href="#element-template"><code>xsl:template</code></a><br><a href="#element-use-package"><code>xsl:use-package</code></a><br><a href="#element-variable"><code>xsl:variable</code></a></p></blockquote><p>Note that the <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> elements can act either as <a title="declaration" class="termref" href="#dt-declaration">declarations</a> or as <a title="instruction" class="termref" href="#dt-instruction">instructions</a>. A global variable or parameter is defined using a declaration; a local variable or parameter using an instruction.</p><p>The child elements of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may appear in any order. In most cases, the ordering of these elements does not affect the results of the transformation; however:</p><ul><li><p>As described in <a href="#conflict"><i>6.5 Conflict Resolution for Template Rules</i></a>, when two template rules with the same <a title="priority" class="termref" href="#dt-priority">priority</a> match the same nodes, there are situations where the order of the template rules will affect which is chosen.</p></li><li><p>Forwards references to <a title="static variable" class="termref" href="#dt-static-variable">static variables</a> are not allowed in <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>.</p></li></ul><div class="div3"><h4><a id="default-collation-attribute"></a>3.7.1 <a href="#default-collation-attribute" style="text-decoration: none">The </a><code>default-collation</code><a href="#default-collation-attribute" style="text-decoration: none"> Attribute</a></h4><p>The <code>default-collation</code> attribute is a <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attribute</a> that may appear on any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p><p>The attribute, when it appears on an element <var>E</var>, is used to specify the default collation used by all XPath expressions appearing in attributes or <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a> that have <var>E</var> as an ancestor, unless overridden by another <code>default-collation</code> attribute on an inner element. It also determines the collation used by certain XSLT constructs (such as <a href="#element-key"><code>xsl:key</code></a> and <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>) within its scope.</p><p>The value of the attribute is a whitespace-separated list of collation URIs. If any of these URIs is a relative URI reference, then it is resolved relative to the base URI of the attribute’s parent element. If the implementation recognizes one or more of the resulting absolute collation URIs, then it uses the first one that it recognizes as the default collation.</p><p><a id="err-XTSE0125"><span class="error">[ERR XTSE0125] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of an <code>[xsl:]default-collation</code> attribute, after resolving against the base URI, contains no URI that the implementation recognizes as a collation URI. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The reason the attribute allows a list of collation URIs is that collation URIs will often be meaningful only to one particular XSLT implementation. Stylesheets designed to run with several different implementations can therefore specify several different collation URIs, one for use with each. To avoid the above error condition, it is possible to include as the last collation URI in the list either the Unicode Codepoint Collation or a collation in the UCA family (see <a href="#uca-collations"><i>13.4 The Unicode Collation Algorithm</i></a>) with the parameter <code>fallback=yes</code>.</p></div><p>The <code>[xsl:]default-collation</code> attribute does not affect the collation used by <a href="#element-sort"><code>xsl:sort</code></a> or by <a href="#element-merge"><code>xsl:merge</code></a>.</p><p>In the absence of an <code>[xsl:]default-collation</code> attribute, the default collation <span class="verb">may</span> be set by the calling application in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. The recommended default, unless the user chooses otherwise, is to use the Unicode codepoint collation.</p></div><div class="div3"><h4><a id="default-mode"></a>3.7.2 <a href="#default-mode" style="text-decoration: none">The </a><code>default-mode</code><a href="#default-mode" style="text-decoration: none"> Attribute</a></h4><p>The <code>[xsl:]default-mode</code> attribute defines the default value for the <a title="mode" class="termref" href="#dt-mode">mode</a> attribute of all <a href="#element-template"><code>xsl:template</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements within its scope.</p><p><span style="display: none;" class="delete_version">More specifically, when an element <var>E</var> matches the pattern <code>(xsl:template[@match] | xsl:apply-templates)[not(@mode) or normalize-space(@mode) eq "#default"]</code> (using the Unicode codepoint collation), then the effective value of the <code>mode</code> attribute is taken from the value of the <code>[xsl:]default-mode</code> attribute of the innermost ancestor-or-self element of <var>E</var> that has such an attribute. If there is no such element, then the default is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. This is equivalent to specifying <code>#unnamed</code>.</span><span style="display: none;" class="add_version">More specifically, when an element <var>E</var> matches the pattern <code>(xsl:template[@match] | xsl:apply-templates)[not(@mode) or normalize-space(@mode) eq "#default"]</code> (using the Unicode codepoint collation), then the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>mode</code> attribute is taken from the value of the <code>[xsl:]default-mode</code> attribute of the innermost ancestor-or-self element of <var>E</var> that has such an attribute. If there is no such element, then the default is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. This is equivalent to specifying <code>#unnamed</code>.</span><span class="modify_version">More specifically, when an element <var>E</var> matches the pattern <code>(xsl:template[@match] | xsl:apply-templates)[not(@mode) or normalize-space(@mode) eq "#default"]</code> (using the Unicode codepoint collation), then the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>mode</code> attribute is taken from the value of the <code>[xsl:]default-mode</code> attribute of the innermost ancestor-or-self element of <var>E</var> that has such an attribute. If there is no such element, then the default is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. This is equivalent to specifying <code>#unnamed</code>.</span></p><p>In addition, when the attribute appears on the <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or <a href="#element-transform"><code>xsl:transform</code></a> element of the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, it provides a default value for the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> used on stylesheet invocation.</p><p>The value of the <code>[xsl:]default-mode</code> attribute <span class="verb">must</span> either be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or the token <code>#unnamed</code> which refers to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This attribute is provided to support an approach to stylesheet modularity in which all the template rules for one <a title="mode" class="termref" href="#dt-mode">mode</a> are collected together into a single <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. Using this attribute reduces the risk of forgetting to specify the mode in one or more places where it is needed, and it also makes it easier to reuse an existing stylesheet module that does not use modes in an application where modes are needed to avoid conflicts with existing template rules.</p><p>It is not necessary for the referenced mode to be explicitly declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration, unless this is mandated by the <code>declared-modes</code> attribute (which defaults to <code>yes</code> on an <a href="#element-package"><code>xsl:package</code></a> element).</p></div></div><div class="div3"><h4><a id="user-defined-top-level"></a>3.7.3 <a href="#user-defined-top-level" style="text-decoration: none">User-defined Data Elements</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-data-element" title="user-defined data element"></a>In addition to <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain among its children any element not from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element has a non-null namespace URI. Such elements are referred to as <b>user-defined data elements</b>.<span class="definition">]</span></p><p><a id="err-XTSE0130"><span class="error">[ERR XTSE0130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element has a child element whose name has a null namespace URI. </p><p>An implementation <span class="verb">may</span> attach an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> meaning to user-defined data elements that appear in particular namespaces. The set of namespaces that are recognized for such data elements is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The presence of a user-defined data element <span class="verb">must not</span> change the behavior of <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a> and functions defined in this document; for example, it is not permitted for a user-defined data element to specify that <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> should use different rules to resolve conflicts. The constraints on what user-defined data elements can and cannot do are exactly the same as the constraints on <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>, described in <a href="#extension-attributes"><i>3.2 Extension Attributes</i></a>. Thus, an implementation is always free to ignore user-defined data elements, and <span class="verb">must</span> ignore such data elements without giving an error if it does not recognize the namespace URI. </p><p>User-defined data elements can provide, for example,</p><ul><li><p>information used by <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a> or <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> (see <a href="#extension"><i>25 Extensibility and Fallback</i></a>),</p></li><li><p>information about what to do with any <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>,</p></li><li><p>information about how to construct <a title="source tree" class="termref" href="#dt-source-tree">source trees</a>,</p></li><li><p>optimization hints for the <a title="processor" class="termref" href="#dt-processor">processor</a>,</p></li><li><p>metadata about the stylesheet,</p></li><li><p>structured documentation for the stylesheet.</p></li></ul></div></div><div class="div2"><h3><a id="simplified-stylesheet"></a>3.8 <a href="#simplified-stylesheet" style="text-decoration: none">Simplified Stylesheet Modules</a></h3><p>A simplified syntax is allowed for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that defines only a single template rule for the document node. The stylesheet module may consist of just a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> (see <a href="#literal-result-element"><i>11.1 Literal Result Elements</i></a>) together with its contents. The literal result element must have an <code>xsl:version</code> attribute (and it must therefore also declare the XSLT namespace). Such a stylesheet module is equivalent to a standard stylesheet module whose <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element contains a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> containing the literal result element, minus its <code>xsl:version</code> attribute; the template rule has a match <a title="pattern" class="termref" href="#dt-pattern">pattern</a> of <code>/</code>.</p><div class="example"><div class="exampleHeader"><a id="d8e9052"></a><a id="d8e9136"></a>Example: A Simplified Stylesheet</div><p>For example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">html</span><span class="z"></span><span class="atn">xsl:version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/xhtml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">Expense Report Summary</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Total Amount: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">expense-report</span><span class="step">/</span><span class="qname">total</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">html</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>has the same meaning as</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/xhtml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">html</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">Expense Report Summary</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Total Amount: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">expense-report</span><span class="step">/</span><span class="qname">total</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">html</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Note that it is not possible, using a simplified stylesheet, to request that the serialized output contains a <code>DOCTYPE</code> declaration. This can only be done by using a standard stylesheet module, and using the <a href="#element-output"><code>xsl:output</code></a> element.</p></div><p>More formally, a simplified stylesheet module is equivalent to the standard stylesheet module that would be generated by applying the following transformation to the simplified stylesheet module, invoking the transformation by calling the <a title="named template" class="termref" href="#dt-named-template">named template</a><code>expand</code>, with the containing literal result element as the <a title="context node" class="termref" href="#dt-context-node">context node</a>: </p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">expand</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:element</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">xsl:stylesheet</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">version</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">xsl:version</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:element</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">xsl:template</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">match</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">/</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:element</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:element</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p><a id="err-XTSE0150"><span class="error">[ERR XTSE0150] </span></a>A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> that is used as the outermost element of a simplified stylesheet module <span class="verb">must</span> have an <code>xsl:version</code> attribute. This indicates the version of XSLT that the stylesheet requires. For this version of XSLT, the value will normally be <span>4.0</span>; the value <span class="verb">must</span> be a valid instance of the type <code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p><p>The allowed content of a literal result element when used as a simplified stylesheet is the same as when it occurs within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. Thus, a literal result element used as the document element of a simplified stylesheet cannot contain <a title="declaration" class="termref" href="#dt-declaration">declarations</a>. Simplified stylesheets therefore cannot use <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>, <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, <a title="key" class="termref" href="#dt-key">keys</a>, <a title="attribute set" class="termref" href="#dt-attribute-set">attribute-sets</a>, or <a title="output definition" class="termref" href="#dt-output-definition">output definitions</a>. In turn this means that the only useful way to initiate the transformation is to supply a document node as the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, to be matched by the implicit <code>match="/"</code> template rule using the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. </p></div><div class="div2"><h3><a id="backwards"></a>3.9 <a href="#backwards" style="text-decoration: none">Backwards Compatible Processing</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-effective-version" title="effective version"></a>The <b>effective version</b> of an element in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> is the decimal value of the <code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>) on that element or on the innermost ancestor element that has such an attribute, excluding the <code>version</code> attribute on an <a href="#element-output"><code>xsl:output</code></a> element.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-backwards-compatible-behavior" title="backwards compatible behavior"></a>An element is processed with <b>backwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is less than <span>4.0</span>.<span class="definition">]</span></p><p>Specifically:</p><ul><li><p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 1.0, then the element is processed with XSLT 1.0 behavior as described in <a href="#backwards-1.0"><i>3.9.1 XSLT 1.0 Compatibility Mode</i></a>.</p></li><li><p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 2.0, then the element is processed with XSLT 2.0 behavior as described in <a href="#backwards-2.0"><i>3.9.2 XSLT 2.0 Compatibility Mode</i></a>.</p></li><li><p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 3.0, then the element is processed with XSLT 3.0 behavior as described in <a href="#backwards-3.0"><i>3.9.3 XSLT 3.0 Compatibility Mode</i></a>.</p></li><li><p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is any other value less than <span>4.0</span>, the <span class="verb">recommended</span> action is to report a static error; however, processors <span class="verb">may</span> recognize such values and process the element in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSLT 1.0 allowed the <code>version</code> attribute to take any decimal value, and invoked forwards compatible processing for any value other than 1.0. XSLT 2.0 allowed the attribute to take any decimal value, and invoked backwards compatible (i.e. 1.0-compatible) processing for any value less than 2.0. Some stylesheets may therefore be encountered that use values other than 1.0 or 2.0. In particular, the value 1.1 is sometimes encountered, as it was used at one stage in a draft language proposal.</p></div></li></ul><p>These rules do not apply to the <a href="#element-output"><code>xsl:output</code></a> element, whose <code>version</code> attribute has an entirely different purpose: it is used to define the version of the output method to be used for serialization.</p><p>It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether a particular XSLT 4.0 implementation supports backwards compatible behavior for any XSLT version earlier than XSLT 4.0.</p><p><a id="err-XTDE0160"><span class="error">[ERR XTDE0160] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if an element has an <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of <var>V</var> (with <var>V</var> &lt; <span>4.0</span>) when the implementation does not support backwards compatible behavior for XSLT version <var>V</var>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>By making use of backwards compatible behavior, it is possible to write the stylesheet in a way that ensures that its results when processed with an XSLT 4.0 processor are identical to the effects of processing the same stylesheet using a processor for an earlier version of XSLT. To assist with transition, some parts of a stylesheet may be processed with backwards compatible behavior enabled, and other parts with this behavior disabled.</p><p>All data values manipulated by an XSLT 4.0 processor are defined by the XDM data model, whether or not the relevant expressions use backwards compatible behavior. Because the same data model is used in both cases, expressions are fully composable. The result of evaluating instructions or expressions with backwards compatible behavior is fully defined in the XSLT 4.0 and XPath 4.0 specifications, it is not defined by reference to earlier versions of the XSLT and XPath specifications. </p><p>To write a stylesheet that makes use of features that are new in version <var>N</var>, while also working with a processor that only supports XSLT version <var>M</var> (<var>M</var> &lt; <var>N</var>), it is necessary to understand both the rules for backwards compatible behavior in XSLT version <var>N</var>, and the rules for forwards compatible behavior in XSLT version <var>M</var>. If the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element specifies <span>a <code>version</code> attribute with a value greater than 1.0</span>, then an XSLT 1.0 processor will ignore <a title="declaration" class="termref" href="#dt-declaration">declarations</a> that were not defined in XSLT 1.0, for example <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-import-schema"><code>xsl:import-schema</code></a><span>, and <a href="#element-mode"><code>xsl:mode</code></a></span>. If any new XSLT <span>4.0 instructions are used (for example <a href="#element-switch"><code>xsl:switch</code></a> or <a href="#element-array"><code>xsl:array</code></a>)</span>, or if new XPath <span>4.0 features are used (for example, keyword arguments in function calls)</span>, then the stylesheet must provide fallback behavior that relies only on facilities available in the earliest XSLT version supported. The fallback behavior can be invoked by using the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction, or by testing the results of the <a href="#func-function-available"><code>function-available</code></a> or <a href="#func-element-available"><code>element-available</code></a> functions, or by testing the value of the <code>xsl:version</code> property returned by the <a href="#func-system-property"><code>system-property</code></a> function.</p></div><div class="div3"><h4><a id="backwards-1.0"></a>3.9.1 <a href="#backwards-1.0" style="text-decoration: none">XSLT 1.0 Compatibility Mode</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-10-behavior" title="XSLT 1.0 behavior"></a>An element in the stylesheet is processed with <b>XSLT 1.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 1.0.<span class="definition">]</span></p><p>In this mode, if any attribute contains an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>, then the expression is evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to <code>true</code>. For details of this mode, see <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#static_context">Section 2.2.1 Static Context</a><sup><small>XP40</small></sup>. Expressions contained in <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a> are always evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to <code>false</code>, since this construct was not available in XSLT 1.0.</p><p>Furthermore, in such an expression any function call for which no implementation is available (unless it uses the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>) is bound to a fallback error function whose effect when evaluated is to raise a dynamic error <span class="error">[see <a href="#err-XTDE1425">ERR XTDE1425</a>]</span> . The effect is that with backwards compatible behavior enabled, calls on <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> that are not available in a particular implementation do not cause an error unless the function call is actually evaluated. For further details, see <a href="#extension-functions"><i>25.1 Extension Functions</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This might appear to contradict the specification of XPath 3.0, which states that a static error [XPST0017] is raised when an expression contains a call to a function that is not present (with matching name and arity) in the static context. This apparent contradiction is resolved by specifying that the XSLT processor constructs a static context for the expression in which every possible function name and arity (other than names in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>) is present; when no other implementation of the function is available, the function call is bound to a fallback error function whose run-time effect is to raise a dynamic error.</p></div><p>Certain XSLT constructs also produce different results when XSLT 1.0 compatibility mode is enabled. This is described separately for each such construct.</p><p>Processing an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> with XSLT 1.0 behavior is not compatible with streaming. More specifically, and notwithstanding anything stated in <a href="#streamability"><i>19 Streamability</i></a>, an instruction that is processed with XSLT 1.0 behavior is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, which has the effect that any construct containing such an instruction is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p></div><div class="div3"><h4><a id="backwards-2.0"></a>3.9.2 <a href="#backwards-2.0" style="text-decoration: none">XSLT 2.0 Compatibility Mode</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-20-behavior" title="XSLT 2.0 behavior"></a>An element is processed with <b>XSLT 2.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 2.0.<span class="definition">]</span></p><p>In this specification, no differences are defined for XSLT 2.0 behavior. An XSLT <span>4.0</span> processor will therefore produce the same results whether the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of an element is set to 2.0 or <span>4.0</span>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An XSLT 2.0 processor, by contrast, will in some cases produce different results in the two cases. For example, if the stylesheet contains an <a href="#element-switch"><code>xsl:switch</code></a> instruction with an <a href="#element-fallback"><code>xsl:fallback</code></a> child, an XSLT <span>4.0</span> processor will process the <a href="#element-switch"><code>xsl:switch</code></a> instruction regardless whether the effective version is 2.0, 3.0, <span>or 4.0</span>, while an XSLT 2.0 processor will report a static error if the effective version is 2.0, and will take the fallback action if the effective version is 3.0 or 4.0.</p></div></div><div class="div3"><h4><a id="backwards-3.0"></a>3.9.3 <a href="#backwards-3.0" style="text-decoration: none">XSLT 3.0 Compatibility Mode</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-30-behavior" title="XSLT 3.0 behavior"></a>An element is processed with <b>XSLT 3.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 3.0.<span class="definition">]</span></p><p>In this specification, no differences are defined for XSLT 3.0 behavior. An XSLT <span>4.0</span> processor will therefore produce the same results whether the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of an element is set to 3.0 or <span>4.0</span>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An XSLT 3.0 processor, by contrast, will in some cases produce different results in the two cases. For example, if the stylesheet contains an <a href="#element-switch"><code>xsl:switch</code></a> instruction with an <a href="#element-fallback"><code>xsl:fallback</code></a> child, an XSLT <span>4.0</span> processor will process the <a href="#element-switch"><code>xsl:switch</code></a> instruction regardless whether the effective version is 2.0, 3.0, <span>or 4.0</span>, while an XSLT 3.0 processor will report a static error if the effective version is 2.0 or 3.0, and will take the fallback action if the effective version is 4.0.</p></div></div></div><div class="div2"><h3><a id="forwards"></a>3.10 <a href="#forwards" style="text-decoration: none">Forwards Compatible Processing</a></h3><p>The intent of forwards compatible behavior is to make it possible to write a stylesheet that takes advantage of features introduced in some version of XSLT subsequent to XSLT 4.0, while retaining the ability to execute the stylesheet with an XSLT 4.0 processor using appropriate fallback behavior.</p><p>It is always possible to write conditional code to run under different XSLT versions by using the <code>use-when</code> feature described in <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>. The rules for forwards compatible behavior supplement this mechanism in two ways:</p><ul><li><p>Certain constructs in the stylesheet that mean nothing to an XSLT 4.0 processor are ignored, rather than being treated as errors.</p></li><li><p>Explicit fallback behavior can be defined for instructions defined in a future XSLT release, using the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction.</p></li></ul><p>The detailed rules follow.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-forwards-compatible-behavior" title="forwards compatible behavior"></a>An element is processed with <b>forwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is greater than <span>4.0</span>.<span class="definition">]</span></p><p>These rules do not apply to the <code>version</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> element, which has an entirely different purpose: it is used to define the version of the output method to be used for serialization.</p><p>When an element is processed with forwards compatible behavior:</p><ul><li><p>If the element is in the XSLT namespace and appears as a child of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, and XSLT 4.0 does not allow the element to appear as a child of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, then the element and its content <span class="verb">must</span> be ignored.</p></li><li><p>If the element has an attribute that XSLT 4.0 does not allow the element to have, then the attribute <span class="verb">must</span> be ignored.</p></li><li><p>If the element is in the XSLT namespace and appears as a child of an element whose content model requires a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and XSLT <span>4.0</span> does not allow such elements to appear as part of a sequence constructor, then:</p><ol class="enumar"><li><p>If the element has one or more <a href="#element-fallback"><code>xsl:fallback</code></a> children, then no error is reported either statically or dynamically, and the result of evaluating the instruction is the concatenation of the sequences formed by evaluating the sequence constructors within its <a href="#element-fallback"><code>xsl:fallback</code></a> children, in document order. Siblings of the <a href="#element-fallback"><code>xsl:fallback</code></a> elements are ignored, even if they are valid XSLT 4.0 instructions.</p></li><li><p>If the element has no <a href="#element-fallback"><code>xsl:fallback</code></a> children, then a static error is reported in the same way as if forwards compatible behavior were not enabled.</p></li></ol></li></ul><div class="example"><div class="exampleHeader"><a id="d8e9538"></a><a id="d8e9622"></a>Example: Forwards Compatible Behavior</div><p>For example, an XSLT 4.0 <a title="processor" class="termref" href="#dt-processor">processor</a> will process the following stylesheet without error, although the stylesheet includes elements from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> that are not defined in this specification:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">17.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:exciting-new-17.0-feature</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:fly-to-the-moon</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:fallback</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">html</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">XSLT 17.0 required</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Sorry, this stylesheet requires XSLT 17.0.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">html</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fallback</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:exciting-new-17.0-feature</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If a stylesheet depends crucially on a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> introduced by a version of XSLT after <span>4.0</span>, then the stylesheet can use an <a href="#element-message"><code>xsl:message</code></a> element with <code>terminate="yes"</code> (see <a href="#message"><i>24.1 Messages</i></a>) to ensure that implementations that conform to an earlier version of XSLT will not silently ignore the <a title="declaration" class="termref" href="#dt-declaration">declaration</a>.</p></div><div class="example"><div class="exampleHeader"><a id="d8e9570"></a><a id="d8e9654"></a>Example: Testing the XSLT Version</div><p>For example,</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">18.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:important-new-17.0-declaration</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">number</span><span class="parenthesis">(</span><span class="function">system-property</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">xsl:version</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">lt</span><span class="whitespace"></span><span class="numeric">17.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="z"></span><span class="atn">terminate</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">Sorry, this stylesheet requires XSLT 17.0.</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the introduction of the <a href="#element-package"><code>xsl:package</code></a> element. An XSLT 1.0 or 2.0 processor encountering this element will report a static error, regardless of the <code>version</code> setting.</p><p>This problem can be circumvented by using the simplified package syntax (whereby an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is implicitly treated as <a href="#element-package"><code>xsl:package</code></a>), or by writing the stylesheet code in a separate module from the package manifest, and using the separate module as the version of the stylesheet that is presented to a 2.0 processor.</p></div></div><div class="div2"><h3><a id="combining-modules"></a>3.11 <a href="#combining-modules" style="text-decoration: none">Combining Stylesheet Modules</a></h3><p>XSLT provides two mechanisms to construct a <a title="package" class="termref" href="#dt-package">package</a> from multiple <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a>:</p><ul><li><p>an inclusion mechanism that allows stylesheet modules to be combined without changing the semantics of the modules being combined, and</p></li><li><p>an import mechanism that allows stylesheet modules to override each other.</p></li></ul><div class="div3"><h4><a id="locating-modules"></a>3.11.1 <a href="#locating-modules" style="text-decoration: none">Locating Stylesheet Modules</a></h4><p>The include and import mechanisms use two declarations, <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a>, which are defined in the sections that follow.</p><p>These declarations use an <code>href</code> attribute, whose value is a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI reference</a>, to identify the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> to be included or imported. If the value of this attribute is a relative URI reference, it is resolved as described in <a href="#uri-references"><i>5.9 URI References</i></a>.</p><p>After resolving against the base URI, the way in which the URI reference is used to locate a representation of a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, and the way in which the stylesheet module is constructed from that representation, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. In particular, it is implementation-defined which URI schemes are supported, whether fragment identifiers are supported, and what media types are supported. Conventionally, the URI is a reference to a resource containing the stylesheet module as a source XML document, or it may include a fragment identifier that selects an embedded stylesheet module within a source XML document; but the implementation is free to use other mechanisms to locate the stylesheet module identified by the URI reference.</p><p>The referenced <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a><span class="verb">must</span> be either a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> or a <a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module">simplified stylesheet</a>. It <span class="verb">must not</span> be a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>. If it is a simplified stylesheet module then it is transformed into the equivalent standard stylesheet module by applying the transformation described in <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>. </p><p>Implementations <span class="verb">may</span> choose to accept URI references containing a fragment identifier defined by reference to the XPointer specification (see <a href="#xptr-framework">[XPointer Framework]</a>). Note that if the implementation does not support the use of fragment identifiers in the URI reference, then it will not be possible to include an <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a>.</p><p><a id="err-XTSE0165"><span class="error">[ERR XTSE0165] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the processor is not able to retrieve the resource identified by the URI reference, or if the resource that is retrieved does not contain a stylesheet module. </p><div class="note"><p class="prefix"><b>Note:</b></p><p> It is appropriate to use this error code when the resource cannot be retrieved, or when the retrieved resource is not well formed XML. If the resource contains XML that can be parsed but that violates the rules for stylesheet modules, then a more specific error code may be more appropriate.</p></div></div><div class="div3"><h4><a id="include"></a>3.11.2 <a href="#include" style="text-decoration: none">Stylesheet Inclusion</a></h4><p class="element-syntax"><a id="element-include"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:include<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p><p>A stylesheet module may include another stylesheet module using an <a href="#element-include"><code>xsl:include</code></a> declaration.</p><p>The <a href="#element-include"><code>xsl:include</code></a> declaration has a <span class="verb">required</span><code>href</code> attribute whose value is a URI reference identifying the stylesheet module to be included. This attribute is used as described in <a href="#locating-modules"><i>3.11.1 Locating Stylesheet Modules</i></a>.</p><p><a id="err-XTSE0170"><span class="error">[ERR XTSE0170] </span></a>An <a href="#element-include"><code>xsl:include</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-level" title="stylesheet level"></a>A <b>stylesheet level</b> is a collection of <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> connected using <a href="#element-include"><code>xsl:include</code></a> declarations: specifically, two stylesheet modules <var>A</var> and <var>B</var> are part of the same stylesheet level if one of them includes the other by means of an <a href="#element-include"><code>xsl:include</code></a> declaration, or if there is a third stylesheet module <var>C</var> that is in the same stylesheet level as both <var>A</var> and <var>B</var>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>A stylesheet level thus groups the <a title="declaration" class="termref" href="#dt-declaration">declarations</a> in a <a title="package" class="termref" href="#dt-package">package</a> by <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>: two declarations within a package are in the same stylesheet level if and only if they have the same import precedence.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-declaration-order" title="declaration order"></a>The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> within a <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering known as <b>declaration order</b>. The order of declarations within a stylesheet level is the same as the document order that would result if each stylesheet module were inserted textually in place of the <a href="#element-include"><code>xsl:include</code></a> element that references it.<span class="definition">]</span> In other respects, however, the effect of <a href="#element-include"><code>xsl:include</code></a> is not equivalent to the effect that would be obtained by textual inclusion.</p><p><a id="err-XTSE0180"><span class="error">[ERR XTSE0180] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a stylesheet module directly or indirectly includes itself. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not intrinsically an error for a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to include the same module more than once. However, doing so can cause errors because of duplicate definitions. Such multiple inclusions are less obvious when they are indirect. For example, if stylesheet <var>B</var> includes stylesheet <var>A</var>, stylesheet <var>C</var> includes stylesheet <var>A</var>, and stylesheet <var>D</var> includes both stylesheet <var>B</var> and stylesheet <var>C</var>, then <var>A</var> will be included indirectly by <var>D</var> twice. If all of <var>B</var>, <var>C</var> and <var>D</var> are used as independent stylesheets, then the error can be avoided by separating everything in <var>B</var> other than the inclusion of <var>A</var> into a separate stylesheet <var>B′</var> and changing <var>B</var> to contain just inclusions of <var>B′</var> and <var>A</var>, similarly for <var>C</var>, and then changing <var>D</var> to include <var>A</var>, <var>B′</var>, <var>C′</var>.</p></div></div><div class="div3"><h4><a id="import"></a>3.11.3 <a href="#import" style="text-decoration: none">Stylesheet Import</a></h4><p class="element-syntax"><a id="element-import"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:import<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p><p>A stylesheet module may import another <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> using an <a href="#element-import"><code>xsl:import</code></a><a title="declaration" class="termref" href="#dt-declaration">declaration</a>. Importing a stylesheet module is the same as including it (see <a href="#include"><i>3.11.2 Stylesheet Inclusion</i></a>) except that <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> and other <a title="declaration" class="termref" href="#dt-declaration">declarations</a> in the importing module take precedence over template rules and declarations in the imported module; this is described in more detail below.</p><p>The <a href="#element-import"><code>xsl:import</code></a> declaration has a <span class="verb">required</span><code>href</code> attribute whose value is a URI reference identifying the stylesheet module to be included. This attribute is used as described in <a href="#locating-modules"><i>3.11.1 Locating Stylesheet Modules</i></a>.</p><p><a id="err-XTSE0190"><span class="error">[ERR XTSE0190] </span></a>An <a href="#element-import"><code>xsl:import</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element. </p><div class="example"><div class="exampleHeader"><a id="d8e9897"></a><a id="d8e9981"></a>Example: Using <a href="#element-import"><code>xsl:import</code></a></div><p>For example,</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:import</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">article.xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:import</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">bigfont.xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute-set</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">note-style</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-style</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">italic</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute-set</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-import-tree" title="import tree"></a>The <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a> making up a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> are treated as forming an <b>import tree</b>. In the import tree, each stylesheet level has one child for each <a href="#element-import"><code>xsl:import</code></a> declaration that it contains.<span class="definition">]</span> The ordering of the children is the <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> of the <a href="#element-import"><code>xsl:import</code></a> declarations within their stylesheet level.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-import-precedence" title="import precedence"></a>A <a title="declaration" class="termref" href="#dt-declaration">declaration</a><var>D</var> in the stylesheet is defined to have lower <b>import precedence</b> than another declaration <var>E</var> if the stylesheet level containing <var>D</var> would be visited before the stylesheet level containing <var>E</var> in a post-order traversal of the import tree (that is, a traversal of the import tree in which a stylesheet level is visited after its children). Two declarations within the same stylesheet level have the same import precedence.<span class="definition">]</span></p><p>For example, suppose</p><ul><li><p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var> and <var>C</var> in that order;</p></li><li><p>stylesheet module <var>B</var> imports stylesheet module <var>D</var>;</p></li><li><p>stylesheet module <var>C</var> imports stylesheet module <var>E</var>.</p></li></ul><p>Then the import tree has the following structure:</p><svg height="98pt" width="206pt" viewBox="0.00 0.00 206.00 98.00" preserveAspectRatio="xMidYMid meet" zoomAndPan="magnify" version="1.1"><g transform="scale(1 1) rotate(0) translate(4 94)" id="graph0" class="graph"><title>g</title><polygon fill="white" stroke="transparent" points="-4,4 -4,-94 202,-94 202,4 -4,4"></polygon><g id="node1" class="node"><title xmlns="http://www.w3.org/2000/svg">d6e10056</title><polygon fill="none" stroke="black" points="54,-63 0,-63 0,-27 54,-27 54,-63"></polygon><text text-anchor="middle" x="27" y="-41.3" font-family="Times,serif" font-size="14.00">A</text></g><g id="node2" class="node"><title xmlns="http://www.w3.org/2000/svg">d6e10057</title><polygon fill="none" stroke="black" points="126,-90 72,-90 72,-54 126,-54 126,-90"></polygon><text text-anchor="middle" x="99" y="-68.3" font-family="Times,serif" font-size="14.00">B</text></g><g id="edge3" class="edge"><title xmlns="http://www.w3.org/2000/svg">d6e10056-&gt;d6e10057</title><path fill="none" stroke="black" d="M54.07,-55.05C56.76,-56.09 59.53,-57.16 62.31,-58.23"></path><polygon fill="black" stroke="black" points="61.09,-61.51 71.68,-61.85 63.61,-54.98 61.09,-61.51"></polygon></g><g id="node4" class="node"><title xmlns="http://www.w3.org/2000/svg">d6e10059</title><polygon fill="none" stroke="black" points="126,-36 72,-36 72,0 126,0 126,-36"></polygon><text text-anchor="middle" x="99" y="-14.3" font-family="Times,serif" font-size="14.00">C</text></g><g id="edge4" class="edge"><title xmlns="http://www.w3.org/2000/svg">d6e10056-&gt;d6e10059</title><path fill="none" stroke="black" d="M54.07,-34.95C56.76,-33.91 59.53,-32.84 62.31,-31.77"></path><polygon fill="black" stroke="black" points="63.61,-35.02 71.68,-28.15 61.09,-28.49 63.61,-35.02"></polygon></g><g id="node3" class="node"><title xmlns="http://www.w3.org/2000/svg">d6e10058</title><polygon fill="none" stroke="black" points="198,-90 144,-90 144,-54 198,-54 198,-90"></polygon><text text-anchor="middle" x="171" y="-68.3" font-family="Times,serif" font-size="14.00">D</text></g><g id="edge1" class="edge"><title xmlns="http://www.w3.org/2000/svg">d6e10057-&gt;d6e10058</title><path fill="none" stroke="black" d="M126.07,-72C128.49,-72 130.98,-72 133.48,-72"></path><polygon fill="black" stroke="black" points="133.68,-75.5 143.68,-72 133.68,-68.5 133.68,-75.5"></polygon></g><g id="node5" class="node"><title xmlns="http://www.w3.org/2000/svg">d6e10060</title><polygon fill="none" stroke="black" points="198,-36 144,-36 144,0 198,0 198,-36"></polygon><text text-anchor="middle" x="171" y="-14.3" font-family="Times,serif" font-size="14.00">E</text></g><g id="edge2" class="edge"><title xmlns="http://www.w3.org/2000/svg">d6e10059-&gt;d6e10060</title><path fill="none" stroke="black" d="M126.07,-18C128.49,-18 130.98,-18 133.48,-18"></path><polygon fill="black" stroke="black" points="133.68,-21.5 143.68,-18 133.68,-14.5 133.68,-21.5"></polygon></g></g></svg><p>The order of import precedence (lowest first) is <var>D</var>, <var>B</var>, <var>E</var>, <var>C</var>, <var>A</var>.</p><p>In general, a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> with higher import precedence takes precedence over a declaration with lower import precedence. This is defined in detail for each kind of declaration.</p><p><a id="err-XTSE0210"><span class="error">[ERR XTSE0210] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a stylesheet module directly or indirectly imports itself. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The case where a stylesheet module with a particular URI is imported several times is not treated specially. The effect is exactly the same as if several stylesheet modules with different URIs but identical content were imported. This might or might not cause an error, depending on the content of the stylesheet module.</p></div></div></div><div class="div2"><h3><a id="embedded"></a>3.12 <a href="#embedded" style="text-decoration: none">Embedded Stylesheet Modules</a></h3><p>An <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a> is a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> whose containing element is not the outermost element of the containing XML document. Both <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet modules</a> and <a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module">simplified stylesheet modules</a> may be embedded in this way.</p><p>Two situations where embedded stylesheets may be useful are:</p><ul><li><p>The stylesheet may be embedded in the source document to be transformed.</p></li><li><p>The stylesheet may be embedded in an XML document that describes a sequence of processing of which the XSLT transformation forms just one part.</p></li></ul><p>The <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element <span class="verb">may</span> have an <code>id</code> attribute to facilitate reference to the stylesheet module within the containing document.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In order for such an attribute value to be used as a fragment identifier in a URI, the XDM attribute node must generally have the <code>is-id</code> property: see <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-is-id">Section 5.5 is-id Accessor </a><sup><small>DM30</small></sup>. This property will typically be set if the attribute is defined in a DTD as being of type <code>ID</code>, or if it is defined in a schema as being of type <code>xs:ID</code>. It is also necessary that the media type of the containing document should support the use of ID values as fragment identifiers. Such support is widespread in existing products, and is endorsed in respect of the media type <code>application/xml</code> by <a href="#rfc7303">[RFC7303]</a>.</p><p>An alternative, if the implementation supports it, is to use an <code>xml:id</code> attribute. XSLT allows this attribute (like other namespaced attributes) to appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>.</p></div><div class="example"><div class="exampleHeader"><a id="d8e10142"></a>Example: The <code>xml-stylesheet</code> Processing Instruction<a id="d8e10142"></a>Example: The <code>xml-stylesheet</code> Processing Instruction</div><p>The following example shows how the <code>xml-stylesheet</code> processing instruction (see <a href="#xml-stylesheet">[XML Stylesheet]</a>) can be used to allow a source document to contain its own stylesheet. The URI reference uses a fragment identifier to locate the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element:</p><div class="exampleInner"><pre class="spectrum"><span class="z">&lt;?</span><span class="pi">xml-stylesheet type="application/xslt+xml" href="#style1"</span><span class="z">?&gt;</span><span class="txt"></span><span class="z">&lt;!</span><span class="dt">DOCTYPE doc SYSTEM "doc.dtd"</span><span class="z">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">style1</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:fo</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Format</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:import</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">doc.xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="function">id</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">foo</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="z"></span><span class="atn">font-weight</span><span class="atneq">=</span><span class="z">"</span><span class="av">bold</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">xsl:stylesheet</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> ignore </span><span class="z">--&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">para</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">foo</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">para</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A stylesheet module that is embedded in the document to which it is to be applied typically needs to contain a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that specifies that <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> elements are to be ignored.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The above example uses the pseudo-attribute <code>type="application/xslt+xml"</code> in the <code>xml-stylesheet</code> processing instruction to denote an XSLT stylesheet. This is the officially registered media type for XSLT: see <a href="#xslt-media-type"><i>3.3 XSLT Media Type</i></a>. However, browsers developed before this media type was registered are more likely to accept the unofficial designation <code>type="text/xsl"</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Support for the <code>xml-stylesheet</code> processing instruction is not required for conformance with this Recommendation. Implementations are not constrained in the mechanisms they use to identify a stylesheet when a transformation is initiated: see <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.</p></div></div><div class="div2"><h3><a id="preprocessing"></a>3.13 <a href="#preprocessing" style="text-decoration: none">Stylesheet Preprocessing</a></h3><p>This specification provides <span>three</span> features that cause the raw stylesheet to be preprocessed as the first stage of static processing: </p><ul><li><p>Whitespace and commentary are stripped (see <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>).</p></li><li><p>Elements may be conditionally included or excluded by means of an <code>[xsl:]use-when</code> attribute as described in <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>.</p></li><li><p>Attributes may be conditionally computed as described in <a href="#shadow-attributes"><i>3.13.4 Shadow Attributes</i></a>.</p></li></ul><p></p><p>Note that many of the rules affecting the validity of stylesheet documents apply to a stylesheet after this preprocessing phase has been carried out.</p><div class="div3"><h4><a id="stylesheet-stripping"></a>3.13.1 <a href="#stylesheet-stripping" style="text-decoration: none">Stripping Whitespace and Commentary from the Stylesheet</a></h4><p>The tree representing the stylesheet is preprocessed as follows:</p><ol class="enumar"><li><p>All comments and processing instructions are removed.</p></li><li><p>All <a href="#element-note"><code>xsl:note</code></a> elements are removed, together with their content (see <a href="#xsl-note-elements"><i>3.13.2 The xsl:note element</i></a>).</p></li><li><p>Any text nodes that are now adjacent to each other are merged.</p></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> that satisfies both the following conditions is removed from the tree:</p><ul><li><p>The parent of the text node is not an <a href="#element-text"><code>xsl:text</code></a> element</p></li><li><p>The text node does not have an ancestor element that has an <code>xml:space</code> attribute with a value of <code>preserve</code>, unless there is a closer ancestor element having an <code>xml:space</code> attribute with a value of <code>default</code>.</p></li></ul></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose parent is one of the following elements is removed from the tree, regardless of any <code>xml:space</code> attributes:</p><blockquote><p><a href="#element-accumulator"><code>xsl:accumulator</code></a><br><a href="#element-analyze-string"><code>xsl:analyze-string</code></a><br><a href="#element-apply-imports"><code>xsl:apply-imports</code></a><br><a href="#element-apply-templates"><code>xsl:apply-templates</code></a><br><a href="#element-attribute-set"><code>xsl:attribute-set</code></a><br><a href="#element-call-template"><code>xsl:call-template</code></a><br><a href="#element-character-map"><code>xsl:character-map</code></a><br><a href="#element-choose"><code>xsl:choose</code></a><br><a href="#element-evaluate"><code>xsl:evaluate</code></a><br><a href="#element-fork"><code>xsl:fork</code></a><br><a href="#element-merge"><code>xsl:merge</code></a><br><a href="#element-merge-source"><code>xsl:merge-source</code></a><br><a href="#element-mode"><code>xsl:mode</code></a><br><a href="#element-next-iteration"><code>xsl:next-iteration</code></a><br><a href="#element-next-match"><code>xsl:next-match</code></a><br><a href="#element-override"><code>xsl:override</code></a><br><a href="#element-package"><code>xsl:package</code></a><br><a href="#element-stylesheet"><code>xsl:stylesheet</code></a><br><a href="#element-transform"><code>xsl:transform</code></a><br><a href="#element-use-package"><code>xsl:use-package</code></a></p></blockquote></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose immediate following-sibling node is an <a href="#element-param"><code>xsl:param</code></a> or <a href="#element-sort"><code>xsl:sort</code></a> or <a href="#element-context-item"><code>xsl:context-item</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> element is removed from the tree, regardless of any <code>xml:space</code> attributes.</p></li><li><p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose immediate preceding-sibling node is an <a href="#element-catch"><code>xsl:catch</code></a> element is removed from the tree, regardless of any <code>xml:space</code> attributes.</p></li></ol><p><a id="err-XTSE0260"><span class="error">[ERR XTSE0260] </span></a>Within an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> that is <span class="verb">required</span> to be empty, any content other than comments or processing instructions, including any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> preserved using the <code>xml:space="preserve"</code> attribute, is a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a> will cause whitespace text nodes in that part of the stylesheet to be copied to the result of the sequence constructor. When the result of the sequence constructor is used to form the content of an element, this can cause errors if such text nodes are followed by attribute nodes generated using <a href="#element-attribute"><code>xsl:attribute</code></a>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If an <code>xml:space</code> attribute is specified on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, it will be copied to the result tree in the same way as any other attribute.</p></div></div><div class="div3"><h4><a id="xsl-note-elements"></a>3.13.2 <a href="#xsl-note-elements" style="text-decoration: none">The </a><code>xsl:note</code><a href="#xsl-note-elements" style="text-decoration: none"> element</a></h4><p>An <a href="#element-note"><code>xsl:note</code></a> element may appear anywhere in the stylesheet, except as the outermost element.</p><p class="element-syntax"><a id="element-note"></a><code>&lt;xsl:note<br>&nbsp;&nbsp;#any#? = <var>string</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>any</var> --&gt;<br>&lt;/xsl:note&gt;</code></p><p>The element may have any attributes and any children, subject only to rules imposed by other specifications such as the XML specification. The XSLT processor discards <a href="#element-note"><code>xsl:note</code></a> elements at an early stage of processing, without performing any validation, as described in <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>.</p><p>An <a href="#element-note"><code>xsl:note</code></a> element is typically used for documentation. The format of this documentation is not prescribed here: it might be free text, or XHTML, or some custom vocabulary understood by a free-standing documentation generator.</p><p>An <a href="#element-note"><code>xsl:note</code></a> element might also be used for “commenting out” XSLT declarations or instructions.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A number of documentation processors have been produced for use with XSLT, and the general convention has been to use <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> for this purpose. This approach has its drawbacks:</p><ul><li><p>Annotations can only appear at the top level of the stylesheet (between declarations, but not within declarations). <a title="extension instruction" class="termref" href="#dt-extension-instruction">Extension instructions</a> can also potentially be used as annotations, but this abuses their intended purpose and may create an unwanted dependency on a specific processor.</p></li><li><p>Annotations require a custom namespace to be declared, typically on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, and this namespace becomes part of the static context for all expressions within the stylesheet, thus changing (if only very slightly) the semantics of the stylesheet code. This is true even if the namespace is excluded from the result tree by means of an <code>[xsl:]exclude-result-prefixes</code> attribute.</p></li></ul></div><p>Implementations <span class="verb">must not</span> interpret the contents of an <a href="#element-note"><code>xsl:note</code></a> element to modify the behavior of the stylesheet in any way, whether or not the resulting behavior remains conformant with this specification.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, <a href="#element-note"><code>xsl:note</code></a> elements must not be used to provide processor-specific performance hints. There are better mechanisms for this, such as <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> and <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>.</p></div></div><div class="div3"><h4><a id="conditional-inclusion"></a>3.13.3 <a href="#conditional-inclusion" style="text-decoration: none">Conditional Element Inclusion</a></h4><p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose value is an XPath expression that can be evaluated statically. A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or any other element within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is not in the XSLT namespace, may similarly carry an <code>xsl:use-when</code> attribute. If the attribute is present and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP40</small></sup> of the expression is false, then the element, together with all the nodes having that element as an ancestor, is effectively excluded from the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. When a node is effectively excluded from a stylesheet module the stylesheet module has the same effect as if the node were not there. Among other things this means that no static or dynamic errors will be reported in respect of the element and its contents, other than errors in the <code>use-when</code> attribute itself.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This does not apply to XML parsing or validation errors, which will be reported in the usual way. It also does not apply to attributes that are necessarily processed before <code>[xsl:]use-when</code>, examples being <code>xml:space</code> and <code>[xsl:]xpath-default-namespace</code>.</p></div><p>If the <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element itself is effectively excluded, the effect is to exclude all the children of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element, but not the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element or its attributes.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This allows all the declarations that depend on the same condition to be included in one stylesheet module, and for their inclusion or exclusion to be controlled by a single <code>use-when</code> attribute at the level of the module.</p></div><p>Conditional element exclusion happens after stripping of whitespace text nodes from the stylesheet, as described in <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>.</p><p>The XPath expression used as the value of the <code>xsl:use-when</code> attribute follows the rules for <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>, including the rules for handling errors.</p><p>The use of <code>[xsl:]use-when</code> is illustrated in the following examples.</p><div class="example"><div class="exampleHeader"><a id="d8e10451"></a><a id="d8e10535"></a>Example: Using Conditional Exclusion to Achieve Portability</div><p>This example demonstrates the use of the <code>use-when</code> attribute to achieve portability of a stylesheet across schema-aware and non-schema-aware processors.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:import-schema</span><span class="z"></span><span class="atn">schema-location</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/schema</span><span class="z">"</span><span class="z"></span><span class="atn">use-when</span><span class="atneq">=</span><span class="z">"</span><span class="function">system-property</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">xsl:is-schema-aware</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">=</span><span class="op">'</span><span class="literal">yes</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="z"></span><span class="atn">use-when</span><span class="atneq">=</span><span class="z">"</span><span class="function">system-property</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">xsl:is-schema-aware</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">=</span><span class="op">'</span><span class="literal">yes</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strict</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of these declarations is that a non-schema-aware processor ignores the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration and the first template rule, and therefore generates no errors in respect of the schema-related constructs in these declarations.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e10463"></a><a id="d8e10547"></a>Example: Including Variant Stylesheet Modules</div><p>This example includes different stylesheet modules depending on which XSLT processor is in use.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:include</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">module-A.xsl</span><span class="z">"</span><span class="z"></span><span class="atn">use-when</span><span class="atneq">=</span><span class="z">"</span><span class="function">system-property</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">xsl:vendor</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">=</span><span class="op">'</span><span class="literal">vendor-A</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:include</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">module-B.xsl</span><span class="z">"</span><span class="z"></span><span class="atn">use-when</span><span class="atneq">=</span><span class="z">"</span><span class="function">system-property</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">xsl:vendor</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">=</span><span class="op">'</span><span class="literal">vendor-B</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="shadow-attributes"></a>3.13.4 <a href="#shadow-attributes" style="text-decoration: none">Shadow Attributes</a></h4><p>When a no-namespace attribute name <var>N</var> is permitted to appear on an element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> (provided that <var>N</var> does not start with an underscore), then a value <var>V</var> can be supplied for <var>N</var> in one of two ways: </p><ul><li><p>The conventional way is for an attribute node with name <var>N</var> and value <var>V</var> to appear in the XDM representation of the element node in the stylesheet tree. </p></li><li><p>As an alternative, a shadow attribute may be supplied allowing the value <var>V</var> to be statically computed during the preprocessing phase. The shadow attribute has a name that is the same as the name <var>N</var> prefixed with an underscore, and the value of the shadow attribute is a <a title="value template" class="termref" href="#dt-value-template">value template</a> in which all expressions enclosed between curly braces must be <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>. The value <var>V</var> is the result of evaluating the value template. If a shadow attribute is present, then any attribute node with name <var>N</var> (sharing the same parent element) is ignored. </p></li></ul><p>For example, an <a href="#element-include"><code>xsl:include</code></a> element might be written:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:include</span><span class="z"></span><span class="atn">_href</span><span class="atneq">=</span><span class="z">"</span><span class="av">common</span><span class="op">{</span><span class="variable">$VERSION</span><span class="op">}</span><span class="av">.xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>allowing the stylesheet to include a specific version of a library module based on the value of a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a>.</p><p>Similarly, a <a title="mode" class="termref" href="#dt-mode">mode</a> might be declared like this:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">streamable</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="z"></span><span class="atn">required</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">_streamable</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$streamable</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">on-no-match</span><span class="atneq">=</span><span class="z">"</span><span class="av">shallow-skip</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>this allowing the streamability of the mode to be controlled using a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a> (Note: this example relies on the fact that the <code>streamable</code> attribute accepts a boolean value, which means that the values <code>true</code> and <code>false</code> are accepted as synonyms of <code>yes</code> and <code>no</code>).</p><p>This mechanism applies to all attributes in the stylesheet where the attribute name is in no namespace and the name of the parent element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. This includes attributes that have static significance such as the <code>use-when</code> attribute, the <code>version</code> attribute, and the <code>static</code> attribute on <a href="#element-variable"><code>xsl:variable</code></a>. The mechanism does not apply to shadow attributes (that is, it is not possible to invoke two stages of preprocessing by using two leading underscores). It does not apply to attributes of literal result elements, nor to attributes in a namespace such as the XML or XSLT namespace, nor to namespace declarations.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If a shadow attribute and its corresponding target attribute are both present in the stylesheet, the non-shadow attribute is ignored. This may be useful to make stylesheet code compatible across XSLT versions; an XSLT 2.0 processor operating in forwards compatible mode will ignore shadow attributes, and will require the target attribute to be valid.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The statement that the non-shadow attribute is ignored extends to error detection: it is not an error if the non-shadow attribute has an invalid value. However, this is not reflected in the schema for XSLT stylesheets, so validation using this schema may report errors in such cases.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>An attribute whose name begins with an underscore is treated specially only when it appears on an element in the XSLT namespace. On a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, it is treated in the same way as any other attribute (that is, its <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>is copied to the result tree). On an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> or <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data element</a>, as with other attributes on these elements, its meaning is entirely <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></div><div class="example"><div class="exampleHeader"><a id="d8e10566"></a><a id="d8e10652"></a>Example: Using Shadow Attributes to Parameterize XPath Default Namespace</div><p>Although it is not usually considered good practice, it sometimes happens that variants or versions of an XML vocabulary exist in which the same local names are used, but in different namespaces. There is then a requirement to write code that will process source documents in a variety of different namespaces.</p><p>It is possible to define a static stylesheet parameter containing the target namespace, for example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">NS</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">http://example.com/ns/one</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>And this can then be used to set the default namespace for XPath expressions:</p><div class="exampleInner"><pre>_xpath-default-namespace="{$NS}"</pre></div><p>However, it is not possible to put this shadow attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-package"><code>xsl:package</code></a> element of the principal stylesheet module, because at that point the variable <code>$NS</code> is not in scope. A workaround is to create a stub stylesheet module which contains nothing but the static parameter declaration and an <a href="#element-include"><code>xsl:include</code></a> of the stylesheet module containing the real logic. The static stylesheet parameter will then be in scope on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element of the included stylesheet module, and the shadow attribute <code>_xpath-default-namespace="{$NS}"</code> can therefore appear on this <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e10592"></a><a id="d8e10678"></a>Example: Using Shadow Attributes to Parameterize Selection of Elements</div><p>The following stylesheet produces a report giving information about selected employees. The predicate defining which employees are to be included in the report is supplied (as a string containing an XPath expression) in a static stylesheet parameter:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">filter</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">true()</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">local:filter</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">e</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">_select</span><span class="atneq">=</span><span class="z">"</span><span class="av">$e/(</span><span class="op">{</span><span class="variable">$filter</span><span class="op">}</span><span class="av">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">report</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">report</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">//</span><span class="qname">employee</span><span class="filter">[</span><span class="function">local:filter</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">report</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>If the supplied value of the filter parameter is, say <code>location = "UK"</code>, then the report will cover employees based in the UK.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The stylesheet function <code>local:filter</code> is used here in preference to direct use of the supplied predicate within the <code>select</code> attribute of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction because it reduces exposure to code injection attacks. It does not necessarily eliminate all such risks, however. For example, it would be possible for a caller to supply an expression that never terminates, thus creating a denial-of-service risk.</p></div></div></div></div><div class="div2"><h3><a id="built-in-types"></a>3.14 <a href="#built-in-types" style="text-decoration: none">Built-in Types</a></h3><p>Every XSLT 4.0 processor includes the following named type definitions in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>:</p><ul><li><p> All built-in types defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>, including <code>xs:anyType</code> and <code>xs:anySimpleType</code>.</p></li><li><p>The following types defined in <a href="#xpath-30">[XPath 3.0]</a>: <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and <code>xs:untypedAtomic</code>.</p></li></ul><p>XSLT 4.0 processors <span class="verb">may</span> optionally include types defined in XSD 1.1 (see <a href="#xmlschema11-1">[XML Schema 1.1 Part 1]</a>). XSD 1.1 adopts the types <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, and <code>xs:anyAtomicType</code> previously defined in XPath 2.0, and adds one new type: <code>xs:dateTimeStamp</code>. XSD 1.1 also allows implementers to define additional primitive types, and XSLT 4.0 permits such types to be supported by an XSLT processor.</p><p>A <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a> additionally supports:</p><ul><li><p>User-defined types, and element and attribute declarations, that are imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration as described in <a href="#import-schema"><i>3.15 Importing Schema Components</i></a>. These may include both simple and complex types.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The names that are imported from the XML Schema namespace do not include all the names of top-level types defined in either the Schema for Schema Documents or the Schema for Schema Documents (Datatypes). The Schema for Schema Documents, as well as defining built-in types such as <code>xs:integer</code> and <code>xs:double</code>, also defines types that are intended for use only within that schema, such as <code>xs:derivationControl</code>. A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that is designed to process XML Schema documents as its input or output may import the Schema for Schema Documents.</p></div><p>An implementation may define mechanisms that allow additional <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> to be added to the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the stylesheet. For example, the mechanisms used to define <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> (see <a href="#extension-functions"><i>25.1 Extension Functions</i></a>) may also be used to import the types used in the interface to such functions.</p><p>These <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> are the only ones that may be referenced in XPath expressions within the stylesheet, or in the <code>[xsl:]type</code> and <code>as</code> attributes of those elements that permit these attributes.</p></div><div class="div2"><h3><a id="import-schema"></a>3.15 <a href="#import-schema" style="text-decoration: none">Importing Schema Components</a></h3><div class="note"><p class="prefix"><b>Note:</b></p><p>The facilities described in this section are not available with a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a>. They require a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>, as described in <a href="#conformance"><i>28 Conformance</i></a>.</p></div><p class="element-syntax"><a id="element-import-schema"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:import-schema<br>&nbsp;&nbsp;namespace? = <var>uri</var><br>&nbsp;&nbsp;schema-location? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: xs:schema? --&gt;<br>&lt;/xsl:import-schema&gt;</code></p><p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration is used to identify <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> (that is, top-level type definitions and top-level element and attribute declarations) that need to be available statically, that is, before any source document is available. Names of such components used statically within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> must refer to an <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema component</a>, which means they must either be built-in types as defined in <a href="#built-in-types"><i>3.14 Built-in Types</i></a>, or they must be imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p><p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration identifies a namespace containing the names of the components to be imported (or indicates that components whose names are in no namespace are to be imported). The effect is that the names of top-level element and attribute declarations and type definitions from this namespace (or non-namespace) become available for use within XPath expressions in the <a title="package" class="termref" href="#dt-package">package</a>, and within other stylesheet constructs such as the <code>type</code> and <code>as</code> attributes of various <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>.</p><p>The same schema components are available in all stylesheet modules within the <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>; importing components in one stylesheet module makes them available throughout the <a title="package" class="termref" href="#dt-package">package</a>.</p><p>The schema components imported into different <a title="package" class="termref" href="#dt-package">packages</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> must be consistent. Specifically, it is not permitted to use the same name in the same XSD symbol space to refer to different schema components within different packages; and the union of the schema components imported into the packages of a stylesheet must constitute a valid schema (as well as the set of schema components imported into each package forming a valid schema in its own right).</p><p>The <code>namespace</code> and <code>schema-location</code> attributes are both optional.</p><p>If the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element contains an <code>xs:schema</code> element, then the <code>schema-location</code> attribute <span class="verb">must</span> be absent, and one of the following <span class="verb">must</span> be true:</p><ul><li><p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element and the <code>targetNamespace</code> attribute of the <code>xs:schema</code> element are both absent (indicating a no-namespace schema), or</p></li><li><p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element and the <code>targetNamespace</code> attribute of the <code>xs:schema</code> element are both present and both have the same value, or</p></li><li><p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element is absent and the <code>targetNamespace</code> attribute of the <code>xs:schema</code> element is present, in which case the target namespace is as given on the <code>xs:schema</code> element.</p></li></ul><p><a id="err-XTSE0215"><span class="error">[ERR XTSE0215] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-import-schema"><code>xsl:import-schema</code></a> element that contains an <code>xs:schema</code> element has a <code>schema-location</code> attribute, or if it has a <code>namespace</code> attribute that conflicts with the target namespace of the contained schema. </p><p>If two <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations specify the same namespace, or if both specify no namespace, then only the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used. If this leaves more than one, then all the declarations at the highest import precedence are used (which may cause conflicts, as described below).</p><p>After discarding any <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations under the above rule, the effect of the remaining <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations is defined in terms of a hypothetical document called the synthetic schema document, which is constructed as follows. The synthetic schema document defines an arbitrary target namespace that is different from any namespace actually used by the application, and it contains <code>xs:import</code> elements corresponding one-for-one with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, with the following correspondence:</p><ul><li><p>The <code>namespace</code> attribute of the <code>xs:import</code> element is copied from the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration if it is explicitly present, or is implied by the <code>targetNamespace</code> attribute of a contained <code>xs:schema</code> element, and is absent if it is absent.</p></li><li><p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element is copied from the <code>schema-location</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration if present, and is absent if it is absent. If there is a contained <code>xs:schema</code> element, the effective value of the <code>schemaLocation</code> attribute is a URI referencing a document containing a copy of the <code>xs:schema</code> element.</p></li><li><p>The base URI of the <code>xs:import</code> element is the same as the base URI of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></li></ul><p>The schema components included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> (that is, the components whose names are available for use within the stylesheet) are the top-level element and attribute declarations and type definitions that are available for reference within the synthetic schema document. See <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 4.2.3, <em>References to schema components across namespaces</em>).</p><p><a id="err-XTSE0220"><span class="error">[ERR XTSE0220] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the synthetic schema document does not satisfy the constraints described in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in Schema Construction and Structure</em>). This includes, without loss of generality, conflicts such as multiple definitions of the same name. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The synthetic schema document does not need to be constructed by a real implementation. It is purely a mechanism for defining the semantics of <a href="#element-import-schema"><code>xsl:import-schema</code></a> in terms of rules that already exist within the XML Schema specification. In particular, it implicitly defines the rules that determine whether the set of <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations are mutually consistent.</p><p>These rules do not cause names to be imported transitively. The fact that a name is available for reference within a schema document A does not of itself make the name available for reference in a stylesheet that imports the target namespace of schema document A. (See <a href="#xmlschema-1">[XML Schema Part 1]</a> section 3.15.3, Constraints on XML Representations of Schemas.) The stylesheet must import all the namespaces containing names that it actually references.</p><p>The <code>namespace</code> attribute indicates that a schema for the given namespace is required by the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This information may be enough on its own to enable an implementation to locate the required schema components. The <code>namespace</code> attribute may be omitted to indicate that a schema for names in no namespace is being imported. The zero-length string is not a valid namespace URI, and is therefore not a valid value for the <code>namespace</code> attribute.</p><p>The <code>schema-location</code> attribute is a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a> that gives a hint indicating where a schema document or other resource containing the required definitions may be found. It is likely that a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a> will be able to process a schema document found at this location.</p><p>The XML Schema specification gives implementations flexibility in how to handle multiple imports for the same namespace. Multiple imports do not cause errors if the definitions do not conflict.</p><p>A consequence of these rules is that it is not intrinsically an error if no schema document can be located for a namespace identified in an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration. This will cause an error only if it results in the stylesheet containing references to names that have not been imported.</p><p>An inline schema document (using an <code>xs:schema</code> element as a child of the <code>xsl:import-schema</code> element) has the same status as an external schema document, in the sense that it acts as a hint for a source of schema components in the relevant namespace. To ensure that the inline schema document is always used, it is advisable to use a target namespace that is unique to this schema document.</p></div><p>The use of a namespace in an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration does not by itself associate any namespace prefix with the namespace. If names from the namespace are used within the stylesheet module then a namespace declaration must be included in the stylesheet module, in the usual way.</p><div class="example"><div class="exampleHeader"><a id="d8e10987"></a><a id="d8e11073"></a>Example: An Inline Schema Document</div><p>The following example shows an inline schema document. This declares a simple type <code>local:yes-no</code>, which the stylesheet then uses in the declaration of a variable.</p><p>The example assumes the namespace declaration <code>xmlns:local="http://example.com/ns/yes-no"</code></p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:import-schema</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:schema</span><span class="z"></span><span class="atn">targetNamespace</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/ns/yes-no</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xs</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:local</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/ns/yes-no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:simpleType</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes-no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:restriction</span><span class="z"></span><span class="atn">base</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:enumeration</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:enumeration</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">xs:restriction</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">xs:simpleType</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">xs:schema</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:import-schema</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">condition</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">local:yes-no</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">yes</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">local:yes-no</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>There are two built-in functions (<a href="https://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>analyze-string</code></a><sup><small>FO30</small></sup> and <a href="#func-json-to-xml"><code>json-to-xml</code></a>) whose result is an XML structure for which a schema is defined. The namespace for these schema definitions is (in both cases) <code>http://www.w3.org/2005/xpath-functions</code>. Schema components for these namespaces are available for reference within the stylesheet if and only if an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration is present referencing this namespace. If such a declaration is present, then the schema that is imported is the schema defined in the specification of these functions: the <code>schemaLocation</code> attribute has no effect.</p></div></div><div class="div1"><h2><a id="data-model"></a>4 <a href="#data-model" style="text-decoration: none">Data Model</a></h2><p>The data model used by XSLT is the XPath 3.0 and XQuery 3.0 data model (XDM), as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>. XSLT operates on source, result and stylesheet documents using the same data model.</p><p>This section elaborates on some particular features of XDM as it is used by XSLT:</p><p>The rules in <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a> and <a href="#strip"><i>4.3.2 Stripping Whitespace from a Source Tree</i></a> make use of the concept of a whitespace text node.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-whitespace-text-node" title="whitespace text node"></a>A <b>whitespace text node</b> is a text node whose content consists entirely of whitespace characters (that is, #x09, #x0A, #x0D, or #x20).<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Features of a source XML document that are not represented in the XDM tree will have no effect on the operation of an XSLT stylesheet. Examples of such features are entity references, CDATA sections, character references, whitespace within element tags, and the choice of single or double quotes around attribute values.</p></div><div class="div2"><h3><a id="xml-versions"></a>4.1 <a href="#xml-versions" style="text-decoration: none">XML Versions</a></h3><p>The XDM data model defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a> is capable of representing either an XML 1.0 document (conforming to <a href="#REC-xml">[XML 1.0]</a> and <a href="#xml-names">[Namespaces in XML]</a>) or an XML 1.1 document (conforming to <a href="#xml11">[XML 1.1]</a> and <a href="#xml-names11">[Namespaces in XML 1.1]</a>), and it makes no distinction between the two. In principle, therefore, XSLT 4.0 can be used with either of these XML versions.</p><p>Construction of the XDM tree is outside the scope of this specification, so XSLT 4.0 places no formal requirements on an XSLT processor to accept input from either XML 1.0 documents or XML 1.1 documents or both. This specification does define a serialization capability (see <a href="#serialization"><i>27 Serialization</i></a>), though from a conformance point of view it is an optional feature. Although facilities are described for serializing the XDM tree as either XML 1.0 or XML 1.1 (and controlling the choice), there is again no formal requirement on an XSLT processor to support either or both of these XML versions as serialization targets.</p><p>Because the XDM tree is the same whether the original document was XML 1.0 or XML 1.1, the semantics of XSLT processing do not depend on the version of XML used by the original document. There is no reason in principle why all the input and output documents used in a single transformation must conform to the same version of XML.</p><p>Some of the syntactic constructs in XSLT 4.0 and XPath 3.0, for example the productions <a href="https://www.w3.org/TR/REC-xml/#NT-Char">Char</a><sup><small>XML</small></sup> and <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, are defined by reference to the XML and XML Namespaces specifications. There are slight variations between the XML 1.0 and XML 1.1 versions of these productions (and, indeed, between different editions of XML 1.0). Implementations <span class="verb">may</span> support any version; it is <span class="verb">recommended</span> that an XSLT 4.0 processor that implements the 1.1 versions <span class="verb">should</span> also provide a mode that supports the 1.0 versions. It is thus <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> which versions and editions of XML and XML Namespaces are supported by the implementation.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The specification referenced as <a href="#xml-names">[Namespaces in XML]</a> was actually published without a version number.</p></div><p>The current version of <a href="#xmlschema11-2">[XML Schema 1.1 Part 2]</a> references the XML 1.1 specifications, but the previous version (<a href="#xmlschema-2">[XML Schema Part 2]</a>) (that is, XSD 1.0) remains in widespread use, and only references XML 1.0. With processors lacking support for XSD 1.1, therefore, datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> may be constrained by the XML 1.0 rules, and not allow the full range of values permitted by XML 1.1. It is <span class="verb">recommended</span> that implementers wishing to support XML 1.1 should consult <a href="#SCHEMA-AND-XML-1.1">[XML Schema 1.0 and XML 1.1]</a> for guidance.</p></div><div class="div2"><h3><a id="xdm-versions"></a>4.2 <a href="#xdm-versions" style="text-decoration: none">XDM versions</a></h3><p>XSLT 4.0 <span class="verb">requires</span> a processor to support XDM 3.1 as defined in <a href="#xpath-datamodel-31">[XDM 3.1]</a>.</p><p>A processor <span class="verb">may</span> also provide a user option to support versions of XDM later than 3.1, in which case the way it does so is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></div><div class="div2"><h3><a id="preprocessing-source-docs"></a>4.3 <a href="#preprocessing-source-docs" style="text-decoration: none">Preprocessing Source Documents</a></h3><p>Source documents supplied as input to a transformation may be subject to preprocessing. Two kinds of preprocessing are defined: stripping of type annotations (see <a href="#stripping-annotations"><i>4.3.1 Stripping Type Annotations from a Source Tree</i></a>), and stripping of whitespace text nodes (see <a href="#strip"><i>4.3.2 Stripping Whitespace from a Source Tree</i></a>). </p><p>Stripping of type annotations happens before stripping of whitespace text nodes. </p><p>The source documents to which this applies are as follows: </p><ul><li><p>The document containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if it is a node;</p></li><li><p>Any documents containing a node present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>;</p></li><li><p>Any document containing a node that is returned by the functions <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, or <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>;</p></li><li><p>Any document read using <code>xsl:source-document</code>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>This list excludes documents passed as the values of <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> or parameters of the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a> or <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>, trees created by functions such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-parse-xml"><code>parse-xml</code></a><sup><small>FO30</small></sup>, <code>parse-xml-fragment</code>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>analyze-string</code></a><sup><small>FO30</small></sup>, or <a href="#func-json-to-xml"><code>json-to-xml</code></a>, and values returned from <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>. </p></div><p>If a node other than a document node is supplied (for example as the global context item), then the preprocessing is applied to the entire document containing that node. If several nodes within the same document are supplied (for example as nodes in the initial match selection, or as nodes returned by the <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> function), then the preprocessing is only applied to that document once. If a whitespace text node is supplied (for example as the global context item) and the rules cause this node to be stripped from its containing tree, then the behavior is as if this node had not been supplied (which may cause an error, for example if a global context item is required.) </p><p>The rules determining whether or not stripping of annotations and/or whitespace happens are defined at the level of a <a title="package" class="termref" href="#dt-package">package</a>. Declarations within a <a title="library package" class="termref" href="#dt-library-package">library package</a> only affect the handling of documents loaded using a call on the <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, or <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions or an evaluation of an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction appearing lexically within the same package. Declarations within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> also affect the processing of the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> and the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. </p><p>The semantics of the <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions are formally defined in terms of mappings from URIs to document nodes maintained within the dynamic context (see <a href="#xpath-dynamic-context"><i>5.3.4 Initializing the Dynamic Context</i></a>). The effect of the declarations that control stripping of type annotations and whitespace is therefore to modify this mapping (so it now maps the URI to a stripped document). The modification applies to the dynamic context for calls to these function appearing within a particular package; each package therefore has a different set of mappings. This means that when two calls to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function appear in different packages, specifying the same absolute URI, then in general different documents are returned. An implementation <span class="verb">may</span> return the same document for two such calls if it is able to determine that the effect of the annotation and whitespace stripping rules in both packages is the same. </p><p>The effect of dynamic calls to the <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions is defined in the same way as for other functions with dependencies on the dynamic context. As described in <a href="#additional-dynamic-context"><i>5.3.5 Additional Dynamic Context Components used by XSLT</i></a>, named function references (such as <code>doc#1</code>) and calls on <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> (for example, <code>function-lookup("doc", 1)</code>) are defined to retain the XPath static and dynamic context at the point of invocation as part of the closure of the resulting function item, and to use this preserved context when a dynamic function call is subsequently made using the function item. </p><div class="div3"><h4><a id="stripping-annotations"></a>4.3.1 <a href="#stripping-annotations" style="text-decoration: none">Stripping Type Annotations from a Source Tree</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-type-annotation" title="type annotation"></a>The term <b>type annotation</b> is used in this specification to refer to the value returned by the <code>dm:type-name</code> accessor of a node: see <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-type-name">Section 5.14 type-name Accessor </a><sup><small>DM30</small></sup>.<span class="definition">]</span></p><p>There is sometimes a requirement to write stylesheets that produce the same results whether or not the source documents have been validated against a schema. To achieve this, an option is provided to remove any <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> on element and attribute nodes in a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>, replacing them with an annotation of <code>xs:untyped</code> in the case of element nodes, and <code>xs:untypedAtomic</code> in the case of attribute nodes.</p><p>Such stripping of <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> can be requested by specifying <code>input-type-annotations="strip"</code> on the <a href="#element-package"><code>xsl:package</code></a> element. This attribute has three permitted values: <code>strip</code>, <code>preserve</code>, and <code>unspecified</code>. The default value is <code>unspecified</code>. <span>Specifying <code>unspecified</code> has the same effect as omitting the attribute [XSLT 3.0 Erratum E43, bug 30383].</span></p><p>The <code>input-type-annotations</code> attribute may also be specified on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element; if it is specified at this level then it must be consistent for all stylesheet modules within the same package.</p><p><a id="err-XTSE0265"><span class="error">[ERR XTSE0265] </span></a> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> in a <a title="package" class="termref" href="#dt-package">package</a> that specifies <code>input-type-annotations="strip"</code> and another <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that specifies <code>input-type-annotations="preserve"</code>, or if a stylesheet module specifies the value <code>strip</code> or <code>preserve</code> and the same value is not specified on the <a href="#element-package"><code>xsl:package</code></a> element of the containing package. </p><p>Type annotations are stripped from relevant source documents if at least one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies <code>input-type-annotations="strip"</code> on the <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or <a href="#element-transform"><code>xsl:transform</code></a> element [XSLT 3.0 Erratum E43, bug 30383].</p><p>When type annotations are stripped, the following changes are made to the source tree:</p><ul><li><p>The type annotation of every element node is changed to <code>xs:untyped</code></p></li><li><p>The type annotation of every attribute node is changed to <code>xs:untypedAtomic</code></p></li><li><p>The typed value of every element and attribute node is set to be the same as its string value, as an instance of <code>xs:untypedAtomic</code>.</p></li><li><p>The <code>is-nilled</code> property of every element node is set to <code>false</code>.</p></li></ul><p>The values of the <code>is-id</code> and <code>is-idrefs</code> properties are not changed.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Stripping <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> does not necessarily return the document to the state it would be in had validation not taken place. In particular, any defaulted elements and attributes that were added to the tree by the validation process will still be present, and elements and attributes validated as IDs will still be accessible using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup> function.</p></div></div><div class="div3"><h4><a id="strip"></a>4.3.2 <a href="#strip" style="text-decoration: none">Stripping Whitespace from a Source Tree</a></h4><p>A <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> supplied as input to the transformation process may contain <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> that are of no interest, and that do not need to be retained by the transformation. Conceptually, an XSLT <a title="processor" class="termref" href="#dt-processor">processor</a> makes a copy of the source tree from which unwanted <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> have been removed. This process is referred to as whitespace stripping. </p><p>The stripping process takes as input a set of element names whose child <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> are to be preserved. The way in which this set of element names is established using the <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations is described later in this section.</p><p>The stripping process that applies for a particular <a title="package" class="termref" href="#dt-package">package</a> is determined by the <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations within that package.</p><p>A <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> is preserved if either of the following apply:</p><ul><li><p>The element name of the parent of the text node is in the set of whitespace-preserving element names.</p></li><li><p>An ancestor element of the text node has an <code>xml:space</code> attribute with a value of <code>preserve</code>, and no closer ancestor element has <code>xml:space</code> with a value of <code>default</code>.</p></li></ul><p>Otherwise, the <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> is stripped.</p><p>The <code>xml:space</code> attributes are not removed from the tree.</p><p class="element-syntax"><a id="element-strip-space"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:strip-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p class="element-syntax"><a id="element-preserve-space"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:preserve-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p>The set of whitespace-preserving element names is specified by <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a><a title="declaration" class="termref" href="#dt-declaration">declarations</a>. Whether an element name is included in the set of whitespace-preserving names is determined by the best match among all the <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations: it is included if and only if there is no match or the best match is an <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element. The <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> elements each have an <code>elements</code> attribute whose value is a whitespace-separated list of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTests</a><sup><small>XP40</small></sup>; an element name matches an <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element if it matches one of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTests</a><sup><small>XP40</small></sup>. An element matches a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP40</small></sup> if and only if the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP40</small></sup> would be true for the element as an XPath node test.</p><p><a id="err-XTSE0270"><span class="error">[ERR XTSE0270] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within any <a title="package" class="termref" href="#dt-package">package</a> the same <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP40</small></sup> appears in both an <a href="#element-strip-space"><code>xsl:strip-space</code></a> and an <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declaration if both have the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. Two NameTests are considered the same if they match the same set of names (which can be determined by comparing them after expanding namespace prefixes to URIs).</p><p>Otherwise, when more than one <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element within the relevant <a title="package" class="termref" href="#dt-package">package</a> matches, the best matching element is determined by the best matching <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP40</small></sup>. The rules are similar to those for <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>:</p><ul><li><p>First, any match with lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than another match is ignored.</p></li><li><p>Next, any match that has a lower <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> than the <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> of another match is ignored.</p></li><li><p>If several matches have the same <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> (which can only happen if one of the NameTests takes the form <code>*:local</code> and the other takes the form <code>prefix:*</code>), then the declaration that appears last in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> is used.</p></li></ul><p>If an element in a source document has a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that is a simple type or a complex type with simple content, then any whitespace text nodes among its children are preserved, regardless of any <a href="#element-strip-space"><code>xsl:strip-space</code></a> declarations. The reason for this is that stripping a whitespace text node from an element with simple content could make the element invalid: for example, it could cause the <code>minLength</code> facet to be violated.</p><p>Stripping of <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> happens before stripping of whitespace text nodes, so this situation will not occur if <code>input-type-annotations="strip"</code> is specified.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In <a href="#xpath-datamodel-30">[XDM 3.0]</a>, processes are described for constructing an XDM tree from an Infoset or from a PSVI. Those processes deal with whitespace according to their own rules, and the provisions in this section apply to the resulting tree. In practice this means that elements that are defined in a DTD or a Schema to contain element-only content will have <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> stripped, regardless of the <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations in the stylesheet.</p><p>However, source trees are not necessarily constructed using those processes; indeed, they are not necessarily constructed by parsing XML documents. Nothing in the XSLT specification constrains how the source tree is constructed, or what happens to <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> during its construction. The provisions in this section relate only to whitespace text nodes that are present in the tree supplied as input to the XSLT processor. The XSLT processor cannot preserve whitespace text nodes unless they were actually present in the supplied tree.</p></div></div></div><div class="div2"><h3><a id="id-in-data-model"></a>4.4 <a href="#id-in-data-model" style="text-decoration: none">Attribute Types and DTD Validation</a></h3><p>The mapping from the Infoset to the XDM data model, described in <a href="#xpath-datamodel-30">[XDM 3.0]</a>, does not retain attribute types. This means, for example, that an attribute described in the DTD as having attribute type <code>NMTOKENS</code> will be annotated in the XDM tree as <code>xs:untypedAtomic</code> rather than <code>xs:NMTOKENS</code>, and its typed value will consist of a single <code>xs:untypedAtomic</code> value rather than a sequence of <code>xs:NMTOKEN</code> values.</p><p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the XDM tree as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is these properties, rather than any <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>, that are examined by the functions <a href="https://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup> and <a href="https://www.w3.org/TR/xpath-functions-30/#func-idref"><code>idref</code></a><sup><small>FO30</small></sup> described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p></div><div class="div2"><h3><a id="model-for-streaming"></a>4.5 <a href="#model-for-streaming" style="text-decoration: none">Data Model for Streaming</a></h3><div class="div3"><h4><a id="streamed-documents"></a>4.5.1 <a href="#streamed-documents" style="text-decoration: none">Streamed Documents</a></h4><p>The data model for nodes in a document that is being streamed is no different from the standard XDM data model, in that it contains the same objects (nodes) with the same properties and relationships. The facilities for streaming do not change the data model; instead they impose rules that limit the ability of stylesheets to navigate the data model.</p><p>A useful way to visualize streaming is to suppose that at any point in time, there is a current position in the streamed input document which may be the start or end of the document, the start or end tag of an element, or a text, comment, or processing instruction node. From this position, the stylesheet has access to the following information: </p><ul><li><p>Properties intrinsic to the node, such as its name, its base URI, its type annotation, and its <code>is-id</code> and <code>is-idref</code> properties.</p></li><li><p>The ancestors of the node (but navigation downwards from the ancestors is not permitted).</p></li><li><p>The attributes of the node, and the attributes of its ancestors. For each such attribute, all the properties of the node including its string value and typed value are available, but there are limitations that restrict navigation from the attribute node to other nodes in the document.</p></li><li><p>The in-scope namespace bindings of the node.</p></li><li><p>In the case of attributes, text nodes, comments, and processing instructions, the string value and typed value of the node.</p></li><li><p>In the case of element nodes, whether or not the element has children. This information is obtained by calling the <a href="https://www.w3.org/TR/xpath-functions-30/#func-has-children"><code>has-children</code></a><sup><small>FO30</small></sup> function. This implies that the processor performs look-ahead (limited to a single token) to determine whether the start tag is immediately followed by a matching end tag.</p></li><li><p>In the case of document nodes, details of unparsed entities in the document. This information is obtained by calling the <a href="#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a> and <a href="#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a> functions. A processor might enable this by reading the DTD as soon as the document is opened. Since comments and processing instructions that precede the DOCTYPE declaration are available as children of the document node, this also implies that a streaming processor needs sufficient memory to hold these comments and processing instructions until the start tag of the first element is encountered. Information about unparsed entities remains available for the duration of processing, in the same way as attributes of ancestor elements.</p></li></ul><p>The children and other descendants of a node are not accessible except as a by-product of changing the current position in the document. The same applies to properties of an element or document node that require examination of the node’s descendants, that is, the string value and typed value. This is enforced by means of a rule that only one expression requiring downward navigation from a node is permitted.</p><p>Information about the type of a node is in general considered a property intrinsic to the node, and is available without advancing the input stream. There is an exception for an expression of the form <code>(/) instance of document-node(element(invoice))</code>. This is not guaranteed streamable, because it requires reading ahead to check that the document node has only one element child. However, a processor that knows that the parser delivering the document stream is only capable of delivering well-formed documents may use this knowledge (along with the limited look-ahead needed to get the name of the outermost element) to make this expression streamable.</p><p>A streaming processor is not required to read any more of the source document than is needed to generate correct stylesheet output. It is not required to read the full source document merely in order to satisfy the requirement imposed by the XML Recommendation that an XML Processor must report violations of well-formedness in the input.</p><p>More detailed rules are defined in <a href="#streamability"><i>19 Streamability</i></a>.</p></div><div class="div3"><h4><a id="streaming-other-types"></a>4.5.2 <a href="#streaming-other-types" style="text-decoration: none">Other Data Structures</a></h4><p>Maps and arrays were defined in XPath 3.1.</p><p>Streaming facilities in this specification are, for the most part, relevant only to streamed processing of XML trees, and not to other structures such as sequences, maps and arrays, which will typically be held in memory unless the processor is capable of avoiding this. </p><p>Maps, however, play an important role in enabling streamed applications to be written. For example, a map can be used as the data structure maintained by an accumulator (see <a href="#accumulators"><i>18.2 Accumulators</i></a>) to remember information that has been retrieved from a streamed document, given that it is not possible to revisit the same nodes later. There is also a special streamability rule for map constructor expressions (see <a href="#maps-streaming"><i>21.4 Maps and Streaming</i></a>) that allows such an expression to make multiple downward selections in the streamed input document: for example one can write <code>map{'authors':data(author), 'editors':data(editor)}</code>, which gathers the values of these two elements, or sets of elements, from the input stream, regardless what order they appear in — even if they are interleaved.</p><p>The rules for creating maps and arrays are designed to ensure that the entries in a map, and the members of an array, cannot contain nodes from a streamed document. This is achieved by the way in which the streamability properties of the relevant expressions and functions are defined. </p><p>By contrast, sequences can and often do contain nodes from streamed documents, and a major purpose of the rules for streamability is to make this possible. </p></div></div><div class="div2"><h3><a id="limits"></a>4.6 <a href="#limits" style="text-decoration: none">Limits</a></h3><p>The XDM data model (see <a href="#xpath-datamodel-30">[XDM 3.0]</a>) leaves it to the host language to define limits. This section describes the limits that apply to XSLT.</p><p>Limits on some primitive datatypes are defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>. Other limits, listed below, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Note that this does not necessarily mean that each limit must be a simple constant: it may vary depending on environmental factors such as available resources.</p><p>The following limits are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>:</p><ol class="enumar"><li><p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (the <code>totalDigits</code> facet). This must be at least 18 digits. (Note, however, that support for the full value range of <code>xs:unsignedLong</code> requires 20 digits.) </p></li><li><p>For the types <code>xs:date</code>, <code>xs:time</code>, <code>xs:dateTime</code>, <code>xs:gYear</code>, and <code>xs:gYearMonth</code>: the range of values of the year component, which must be at least +0001 to +9999; and the maximum number of fractional second digits, which must be at least 3.</p></li><li><p>For the <code>xs:duration</code> type: the maximum absolute values of the years, months, days, hours, minutes, and seconds components. </p></li><li><p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value, expressed as an integer number of months.</p></li><li><p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value, expressed as a decimal number of seconds.</p></li><li><p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>, <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>, <code>xs:NOTATION</code>, and types derived from them: the maximum length of the value. </p></li><li><p>For sequences, the maximum number of items in a sequence.</p></li></ol></div><div class="div2"><h3><a id="d-o-e-in-data-model"></a>4.7 <a href="#d-o-e-in-data-model" style="text-decoration: none">Disable Output Escaping</a></h3><p>For backwards compatibility reasons, XSLT 4.0 continues to support the <code>disable-output-escaping</code> feature introduced in XSLT 1.0. This is an optional feature and implementations are not <span class="verb">required</span> to support it. A new facility, that of named <a title="character map" class="termref" href="#dt-character-map">character maps</a> (see <a href="#character-maps"><i>27.1 Character Maps</i></a>) was introduced in XSLT 2.0. It provides similar capabilities to <code>disable-output-escaping</code>, but without distorting the data model.</p><p>If an <a title="implementation" class="termref" href="#dt-implementation">implementation</a> supports the <code>disable-output-escaping</code> attribute of <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a>, (see <a href="#disable-output-escaping"><i>27.2 Disabling Output Escaping</i></a>), then the data model for trees constructed by the <a title="processor" class="termref" href="#dt-processor">processor</a> is augmented with a boolean value representing the value of this property. This boolean value, however, can be set only within a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> that is being passed to the serializer.</p><p>Conceptually, each character in a text node on such a result tree has a boolean property indicating whether the serializer is to disable the normal rules for escaping of special characters (for example, outputting of <code>&amp;</code> as <code>&amp;amp;</code>) in respect of this character.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, the nodes in a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> will often be streamed directly from the XSLT processor to the serializer. In such an implementation, <code>disable-output-escaping</code> can be viewed not so much a property stored with nodes in the tree, but rather as additional information passed across the interface between the XSLT processor and the serializer.</p></div></div></div><div class="div1"><h2><a id="constructs"></a>5 <a href="#constructs" style="text-decoration: none">Features of the XSLT Language</a></h2><div class="div2"><h3><a id="names"></a>5.1 <a href="#names" style="text-decoration: none">Names</a></h3><div class="div3"><h4><a id="qname"></a>5.1.1 <a href="#qname" style="text-decoration: none">Qualified Names</a></h4><p>Many constructs appearing in a stylesheet, for example <a title="named template" class="termref" href="#dt-named-template">named templates</a>, <a title="mode" class="termref" href="#dt-mode">modes</a>, and <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a>, are named using a qualified name: this consists of a local name and an optional namespace URI.</p><p>In most cases where such names are written in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, the syntax for expressing the name is given by the production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP40</small></sup> in the XPath specification. In practice, this means that three forms are permitted:</p><ul><li><p>A simple <code>NCName</code> appearing on its own (without any prefix). This represents the local name of the object. The interpretation of unprefixed names is described below.</p></li><li><p>A <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> written in the form <code>NCName ":" NCName</code> where the first part is a namespace prefix and the second part is the local name. The namespace part of the object’s name is then derived from the prefix by examining the in-scope namespace bindings of the element node in the stylesheet where the name appears.</p></li><li><p>A <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-URIQualifiedName">URIQualifiedName</a><sup><small>XP40</small></sup> in the form <code>"Q{" URI? "}" NCName</code> where the two parts of the name, that is the namespace part and the local part, both appear explicitly. If the URI part is omitted (for example <code>Q{}local</code>), the resulting expanded QName is a QName whose namespace part is absent.</p></li></ul><p>The rules for the use of these constructs generally permit leading and trailing whitespace, which is ignored.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are a few places where the third form, a URIQualifiedName, is not permitted. These include the <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-attribute"><code>xsl:attribute</code></a> (which have a separate <code>namespace</code> attribute for the purpose), and constructs defined by other specifications. For example, names appearing within an embedded <code>xs:schema</code> element must follow the XSD rules.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-expanded-qname" title="expanded QName"></a>An <b>expanded QName</b> is a value in the value space of the <code>xs:QName</code> datatype as defined in the XDM data model (see <a href="#xpath-datamodel-30">[XDM 3.0]</a>): that is, a triple containing namespace prefix (optional), namespace URI (optional), and local name. Two expanded QNames are equal if the namespace URIs are the same (or both absent) and the local names are the same. The prefix plays no part in the comparison, but is used only if the expanded QName needs to be converted back to a string.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-eqname" title="EQName"></a>An <b>EQName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is in the form defined by the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP40</small></sup> production in the XPath specification.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-lexical-qname" title="lexical QName"></a>A <b>lexical QName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is within the lexical space of the <code>xs:QName</code> datatype as defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local name optionally preceded by a namespace prefix and a colon.<span class="definition">]</span></p><p>Note that every <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, but the converse is not true.</p><p>The following rules are used when interpreting a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>:</p><ol class="enumar"><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-defining-element" title="defining element"></a>A string in the form of a lexical QName may occur as the value of an attribute node in a stylesheet module, or within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in an attribute or text node within a stylesheet module, or as the result of evaluating an XPath expression contained in such a node. The element containing this attribute or text node is referred to as the <b>defining element</b> of the lexical QName.<span class="definition">]</span></p></li><li><p>If the lexical QName has a prefix, then the prefix is expanded into a URI reference using the namespace declarations in effect on its <a title="defining element" class="termref" href="#dt-defining-element">defining element</a>. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> consisting of the local part of the name and the possibly null URI reference is used as the name of the object. The default namespace of the defining element (see <a href="https://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2 Element Nodes </a><sup><small>DM30</small></sup>) is <em>not</em> used for unprefixed names.</p><p><a id="err-XTSE0280"><span class="error">[ERR XTSE0280] </span></a>In the case of a prefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> used as the value (or as part of the value) of an attribute in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, or appearing within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> in the stylesheet, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="defining element" class="termref" href="#dt-defining-element">defining element</a> has no namespace node whose name matches the prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>. </p><p><a id="err-XTDE0290"><span class="error">[ERR XTDE0290] </span></a>Where the result of evaluating an XPath expression (or an attribute value template) is required to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, or if it is permitted to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> and the actual value takes the form of a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then unless otherwise specified it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value has a prefix and the <a title="defining element" class="termref" href="#dt-defining-element">defining element</a> has no namespace node whose name matches that prefix. This error <span class="verb">may</span> be signaled as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the expression can be determined statically. </p></li><li><p>If the lexical QName has no prefix, then:</p><ol class="enumla"><li><p>In the case of an unprefixed QName used as a <code>NameTest</code> within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> (see <a href="#expressions"><i>5.2 Expressions</i></a>), and in certain other contexts, the namespace to be used in expanding the QName may be specified by means of the <code>[xsl:]xpath-default-namespace</code> attribute, as specified in <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>.</p></li><li><p>If the name is in one of the following categories, then the default namespace of the <a title="defining element" class="termref" href="#dt-defining-element">defining element</a> is used:</p><ol class="enumlr"><li><p>Where a QName is used to define the name of an element being constructed. This applies both to cases where the name is known statically (that is, the name of a literal result element) and to cases where it is computed dynamically (the value of the <code>name</code> attribute of the <a href="#element-element"><code>xsl:element</code></a> instruction).</p></li><li><p>The default namespace is used when expanding the first argument of the function <a href="#func-element-available"><code>element-available</code></a>.</p></li><li><p>The default namespace applies to any unqualified element names appearing in the <code>cdata-section-elements</code> or <code>suppress-indentation</code> attributes of <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-result-document"><code>xsl:result-document</code></a></p></li></ol></li><li><p>In all other cases, a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with no prefix represents an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> in no namespace (that is, an <code>xs:QName</code> value in which both the prefix and the namespace URI are absent).</p></li></ol></li></ol></div><div class="div3"><h4><a id="unprefixed-qnames"></a>5.1.2 <a href="#unprefixed-qnames" style="text-decoration: none">Unprefixed Lexical QNames in Expressions and Patterns</a></h4><div class="div4"><h5><a id="unprefixed-element-names"></a>5.1.2.1 <a href="#unprefixed-element-names" style="text-decoration: none">Unprefixed Element Names</a></h5><p>The attribute <code>[xsl:]default-element-namespace</code> (see <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>) may be used on an element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to define the namespace that will be used for an unprefixed element name within an XPath expression, and in certain other contexts listed below.</p><p>The attribute <code>[xsl:]xpath-default-namespace</code> (which is retained for backwards compatibility reasons) also has the same effect, but also affects unprefixed type names.</p><p>The value of the attribute, in each case, is the namespace URI to be used.</p><p>For any element <code>$E</code> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there is an effective value for the default element namespace, which is the value of the XPath expression:</p><div class="exampleInner"><pre>string(($E/ancestor-or-self::node()/ (self::xsl:*/@default-element-namespace otherwise @xsl:default-element-namespace otherwise self::xsl:*/@xpath-default-namespace otherwise @xsl:xpath-default-namespace))[last()]).</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>That is, the default element namespace is the value of the <code>[xsl:]default-element-namespace</code> or <code>[xsl:]xpath-default-namespace</code> attribute on that element or on the innermost containing element that specifies such an attribute, or a zero-length string if no containing element specifies such an attribute; and if both attributes are present on the same element, then <code>[xsl:]default-element-namespace</code> wins.</p></div><p>For any element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, the effective value of the default element namespace determines the value of the <em>default namespace for element names</em> in the static context of any XPath expression contained in an attribute or text node of that element (including XPath expressions in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>). The effect of this is specified in <a href="#xpath-40">[XPath 4.0]</a>; in summary, it determines the namespace used for any unprefixed element name appearing in a path expression or in the <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> production.</p><p>The effective value of this attribute similarly applies to any of the following constructs appearing within its scope:</p><ul><li><p>any unprefixed element name used in a <a title="pattern" class="termref" href="#dt-pattern">pattern</a></p></li><li><p>any unprefixed element name used in the <code>elements</code> attribute of the <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> instructions</p></li><li><p>any unprefixed element name used in the <code>as</code> attribute of an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a></p></li></ul><p>The <code>[xsl:]xpath-default-namespace</code> attribute <span class="verb">must</span> be in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> if and only if its parent element is <em>not</em> in the XSLT namespace.</p><p>If the effective value of the attribute is a zero-length string, which will be the case if it is explicitly set to a zero-length string or if it is not specified at all, then an unprefixed element name or type name refers to a name that is in no namespace. The default namespace of the parent element (see <a href="https://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2 Element Nodes </a><sup><small>DM30</small></sup>) is <em>not</em> used.</p></div><div class="div4"><h5><a id="unprefixed-type-names"></a>5.1.2.2 <a href="#unprefixed-type-names" style="text-decoration: none">Unprefixed Type Names</a></h5><p>The attribute <code>[xsl:]default-type-namespace</code> (see <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>) may be used on an element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to define the namespace that will be used for an unprefixed type name within an XPath expression, and in certain other contexts listed below.</p><p>The attribute <code>[xsl:]xpath-default-namespace</code> (which is retained for backwards compatibility reasons) also has the same effect, but also affects unprefixed element names.</p><p>The value of the attribute, in each case, is the namespace URI to be used.</p><p>For any element <code>$E</code> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there is an effective value for the default type namespace, which is the value of the XPath expression:</p><div class="exampleInner"><pre>string(($E/ancestor-or-self::node()/ (self::xsl:*/@default-type-namespace otherwise @xsl:default-type-namespace otherwise self::xsl:*/@xpath-default-namespace otherwise @xsl:xpath-default-namespace))[last()]).</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>That is, the default type namespace is the value of the <code>[xsl:]default-type-namespace</code> or <code>[xsl:]xpath-default-namespace</code> attribute on that element or on the innermost containing element that specifies such an attribute, or a zero-length string if no containing element specifies such an attribute; and if both attributes are present on the same element, then <code>[xsl:]default-type-namespace</code> wins.</p></div><p><span style="display: none;" class="delete_version">For any element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, the effective value of the default type namespace determines the value of the <em>default namespace for type names</em> in the static context of any XPath expression contained in an attribute or text node of that element (including XPath expressions in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>). The effect of this is specified in <a href="#xpath-40">[XPath 4.0]</a>; in summary, it determines the namespace used for any unprefixed element name appearing in a path expression or in the <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> production.</span><span style="display: none;" class="add_version">For any element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the default type namespace determines the value of the <em>default namespace for type names</em> in the static context of any XPath expression contained in an attribute or text node of that element (including XPath expressions in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>). The effect of this is specified in <a href="#xpath-40">[XPath 4.0]</a>; in summary, it determines the namespace used for any unprefixed element name appearing in a path expression or in the <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> production.</span><span class="modify_version">For any element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the default type namespace determines the value of the <em>default namespace for type names</em> in the static context of any XPath expression contained in an attribute or text node of that element (including XPath expressions in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>). The effect of this is specified in <a href="#xpath-40">[XPath 4.0]</a>; in summary, it determines the namespace used for any unprefixed element name appearing in a path expression or in the <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> production.</span></p><p>The <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of this attribute similarly applies to any of the following constructs appearing within its scope:</p><ul><li><p>any unprefixed type name used in a <a title="pattern" class="termref" href="#dt-pattern">pattern</a></p></li><li><p>any unprefixed type name used in the <code>as</code> or <code>type</code> attribute of an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a></p></li><li><p>any unprefixed type name used in the <code>xsl:type</code> attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. </p></li></ul><p><span style="display: none;" class="delete_version">If the effective value of the attribute is a zero-length string, which will be the case if it is explicitly set to a zero-length string or if it is not specified at all, then an unprefixed element name or type name refers to a name that is in no namespace. The default namespace of the parent element (see <a href="https://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2 Element Nodes </a><sup><small>DM30</small></sup>) is <em>not</em> used.</span><span style="display: none;" class="add_version">If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute is a zero-length string, which will be the case if it is explicitly set to a zero-length string or if it is not specified at all, then an unprefixed element name or type name refers to a name that is in no namespace. The default namespace of the parent element (see <a href="https://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2 Element Nodes </a><sup><small>DM30</small></sup>) is <em>not</em> used.</span><span class="modify_version">If the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the attribute is a zero-length string, which will be the case if it is explicitly set to a zero-length string or if it is not specified at all, then an unprefixed element name or type name refers to a name that is in no namespace. The default namespace of the parent element (see <a href="https://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2 Element Nodes </a><sup><small>DM30</small></sup>) is <em>not</em> used.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In a stylesheet that does not import any schema, all type names used are likely to be in the namespace <code>http://www.w3.org/2001/XMLSchema</code>, which is traditionally bound to the prefix <code>xs</code>. In such a stylesheet, it makes sense to declare (on the outermost <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element) the attribute <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code>. With this declaration in place, variables and parameters can use type declarations such as <code>as="integer"</code> rather than <code>as="xs:integer"</code>, thus eliminating the need to declare this namespace.</p><p>Note however that the default namespace for types does not apply to the names of constructor functions. In a function call such as <code>decimal(@price)</code> the rules for unprefixed function names, not type names, apply.</p><p>In a stylesheet that imports a no-namespace schema, setting the default type namespace to <code>http://www.w3.org/2001/XMLSchema</code> is still possible; but in this case user-defined types in no namespace can only be referenced using the notation <code>Q{}my-type</code>.</p></div></div><div class="div4"><h5><a id="unprefixed-function-names"></a>5.1.2.3 <a href="#unprefixed-function-names" style="text-decoration: none">Unprefixed Function Names</a></h5><p>The interpretation of unprefixed function names is described in <a href="#resolving-function-names"><i>5.3.2 Resolving Function Names</i></a>.</p></div><div class="div4"><h5><a id="other-unprefixed-names"></a>5.1.2.4 <a href="#other-unprefixed-names" style="text-decoration: none">Other Unprefixed Names</a></h5><p>For other unprefixed names, for example variable names, template names, mode names, or strings that are interpreted as <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QNames</a> during stylesheet evaluation, such as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a> or the string supplied as the first argument to the <a href="#func-key"><code>key</code></a> function, any unprefixed lexical QName is taken as being a no-namespace name.</p></div></div><div class="div3"><h4><a id="reserved-namespaces"></a>5.1.3 <a href="#reserved-namespaces" style="text-decoration: none">Reserved Namespaces</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-reserved-namespace" title="reserved namespace"></a>The XSLT namespace, together with certain other namespaces recognized by an XSLT processor, are classified as <b>reserved namespaces</b> and <span class="verb">must</span> be used only as specified in this and related specifications.<span class="definition">]</span> The reserved namespaces are those listed below.</p><ul><li><p>The <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, described in <a href="#xslt-namespace"><i>3.1 XSLT Namespace</i></a>, is reserved.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-function-namespace" title="standard function namespace"></a>The <b>standard function namespace</b><code>http://www.w3.org/2005/xpath-functions</code> is used for functions in the function library defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> and for standard functions defined in this specification.<span class="definition">]</span></p></li><li><p> The namespace <code>http://www.w3.org/2005/xpath-functions/math</code> is used for mathematical functions in the function library defined in <a href="#xpath-functions-30">[Functions and Operators 3.0]</a>. </p></li><li><p> The namespace <code>http://www.w3.org/2005/xpath-functions/map</code> is used for functions defined in this specification relating to the manipulation of maps. </p></li><li><p> The namespace <code>http://www.w3.org/2005/xpath-functions/array</code> is reserved for use as described in <a href="#xpath-functions-31">[Functions and Operators 3.1]</a>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="xml-namespace" title="XML namespace"></a>The <b>XML namespace</b>, defined in <a href="#xml-names">[Namespaces in XML]</a> as <code>http://www.w3.org/XML/1998/namespace</code>, is used for attributes such as <code>xml:lang</code>, <code>xml:space</code>, and <code>xml:id</code>.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-namespace" title="schema namespace"></a>The <b>schema namespace</b><code>http://www.w3.org/2001/XMLSchema</code> is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a><span class="definition">]</span>. In a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> this namespace may be used to refer to built-in schema datatypes and to the constructor functions associated with those datatypes.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-instance-namespace" title="schema instance namespace"></a>The <b>schema instance namespace</b><code>http://www.w3.org/2001/XMLSchema-instance</code> is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a><span class="definition">]</span>. Attributes in this namespace, if they appear in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, are treated by the XSLT processor in the same way as any other attributes.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-error-namespace" title="standard error namespace"></a>The <b>standard error namespace</b><code>http://www.w3.org/2005/xqt-errors</code> is used for error codes defined in this specification and related specifications. It is also used for the names of certain predefined variables accessible within the scope of an <a href="#element-catch"><code>xsl:catch</code></a> element.<span class="definition">]</span></p></li><li><p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is reserved for use as described in <a href="#xml-names">[Namespaces in XML]</a>. No element or attribute node can have a name in this namespace, and although the prefix <code>xmlns</code> is implicitly bound to this namespace, no namespace node will ever define this binding.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>With the exception of the XML namespace, any of the above namespaces that are used in a stylesheet must be explicitly declared with a namespace declaration. Although conventional prefixes are used for these namespaces in this specification, any prefix may be used in a user stylesheet.</p></div><p>Reserved namespaces may be used without restriction to refer to the names of elements and attributes in source documents and result documents. As far as the XSLT processor is concerned, reserved namespaces other than the XSLT namespace may be used without restriction in the names of <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a> and <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>, and in the names of attributes of literal result elements or of <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>: but other processors <span class="verb">may</span> impose restrictions or attach special meaning to them. Reserved namespaces <span class="verb">must not</span> be used, however, in the names of stylesheet-defined objects such as <a title="variable" class="termref" href="#dt-variable">variables</a> and <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, nor in the names of <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>.</p><p>It is not an error to use a reserved namespace in the name of an <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attribute</a>: attributes such as <code>xml:space</code> and <code>xsi:type</code> fall into this category. XSLT processors <span class="verb">must not</span> reject such attributes, and <span class="verb">must not</span> attach any meaning to them other than any meaning defined by the relevant specification.</p><p><a id="err-XTSE0080"><span class="error">[ERR XTSE0080] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, a <a title="decimal format" class="termref" href="#dt-decimal-format">decimal-format</a>, a <a title="variable" class="termref" href="#dt-variable">variable</a> or <a title="parameter" class="termref" href="#dt-parameter">parameter</a>, a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>, an <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>, or a <a title="character map" class="termref" href="#dt-character-map">character map</a><span>; except that the name <code>xsl:initial-template</code> is permitted as a template name.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The name <code>xsl:original</code> is used within <a href="#element-override"><code>xsl:override</code></a> to refer to a <a title="component" class="termref" href="#dt-component">component</a> that is being overridden. Although the name <code>xsl:original</code> is used to refer to the component, the component has its own name, and no component ever has the name <code>xsl:original</code>. </p></div></div></div><div class="div2"><h3><a id="expressions"></a>5.2 <a href="#expressions" style="text-decoration: none">Expressions</a></h3><p>XSLT uses the expression language defined by <span>XPath 3.0</span><a href="#xpath-30">[XPath 3.0]</a>. Expressions are used in XSLT for a variety of purposes including:</p><ul><li><p>selecting nodes for processing;</p></li><li><p>specifying conditions for different ways of processing a node;</p></li><li><p>generating text to be inserted in a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p></li></ul><p><span class="definition">[Definition:&nbsp;</span><a id="dt-expression" title="expression"></a>Within this specification, the term <b>XPath expression</b>, or simply <b>expression</b>, means a string that matches the production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP40</small></sup> defined in <a href="#xpath-30">[XPath 3.0]</a>.<span class="definition">]</span></p><p>An XPath expression may occur as the value of certain attributes on XSLT-defined elements, and also within curly brackets in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>.</p><p>Except where <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is enabled (see <a href="#forwards"><i>3.10 Forwards Compatible Processing</i></a>), it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of such an attribute, or the text between curly brackets in an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> or <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a>, does not match the XPath production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP40</small></sup>, or if it fails to satisfy other static constraints defined in the XPath specification, for example that all variable references <span class="verb">must</span> refer to <a title="variable" class="termref" href="#dt-variable">variables</a> that are in scope. Error codes are defined in <a href="#xpath-30">[XPath 3.0]</a>.</p><p>The transformation fails with a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> is evaluated and raises a dynamic error. Error codes are defined in <a href="#xpath-30">[XPath 3.0]</a>.</p><p>The transformation fails with a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> raises a type error, or if the result of evaluating the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> is evaluated and raises a type error, or if the XPath processor signals a type error during static analysis of an <a title="expression" class="termref" href="#dt-expression">expression</a>. Error codes are defined in <a href="#xpath-30">[XPath 3.0]</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-required-type" title="required type"></a>The context within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> appears may specify the <b>required type</b> of the expression. The required type indicates the type of the value that the expression is expected to return.<span class="definition">]</span> If no required type is specified, the expression may return any value: in effect, the required type is then <code>item()*</code>. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-coercion-rules" title="coercion rules"></a> When used in this specification without further qualification, the term <b>coercion rules</b> means the coercion rules defined in <a href="#xpath-40">[XPath 4.0]</a>, applied with XPath 1.0 compatibility mode set to false.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In earlier versions of this specification, these were referred to as the <b>function conversion rules.</b></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p> These are the rules defined in <a href="#xpath-40">[XPath 4.0]</a> for converting the supplied argument of a function call to the required type of that argument, as defined in the function signature. The same rules are used in XSLT for converting the value of a variable to the declared type of the variable, or the result of evaluating a function or template body to the declared type of the function or template. They are also used when parameters are supplied to a template using <a href="#element-with-param"><code>xsl:with-param</code></a>. In all such cases, the rules that apply are the XPath 4.0 rules without XPath 1.0 compatibility mode. The rules with XPath 1.0 compatibility mode set to true are used only for XPath function calls, and for the operands of certain XPath operators. </p></div><p>This specification also invokes the XPath 3.0 <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert the result of evaluating an XSLT <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> to a required type (for example, the sequence constructor enclosed in an <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-template"><code>xsl:template</code></a>, or <a href="#element-function"><code>xsl:function</code></a> element).</p><p>Any <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> or <a title="type error" class="termref" href="#dt-type-error">type error</a> that occurs when applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert a value to a required type results in the transformation failing, in the same way as if the error had occurred while evaluating an expression.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Note the distinction between the two kinds of error that may occur. Attempting to convert an integer to a date is a type error, because such a conversion is never possible. Type errors can be reported statically if they can be detected statically, whether or not the construct in question is ever evaluated. Attempting to convert the <span><code>xs:untypedAtomic</code></span> value <code>2003-02-29</code> to a date is a dynamic error rather than a type error, because the problem is with this particular value, not with its type. Dynamic errors are reported only if the instructions or expressions that cause them are actually evaluated. <span>[XSLT 3.0 Erratum E21, bug 30236]</span></p></div><p>The XPath specification states that the host language must specify whether the XPath processor normalizes all line breaks on input, before parsing, and if it does so, whether it uses the rules of [XML 1.0] or [XML 1.1]. In the case of XSLT, all handling of line breaks is the responsibility of the XML parser (which may support either XML 1.0 or XML 1.1); the XSLT and XPath processors perform no further changes.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Most XPath expressions in a stylesheet appear within XML attributes. They are therefore subject to XML line-ending normalization (for example, a CRLF sequence is normalized to LF) and also to XML attribute-value normalization, which replaces tabs and newlines by spaces. XPath expressions appearing in text value templates, however (see <a href="#text-value-templates"><i>5.7.2 Text Value Templates</i></a>) are subject to line-ending normalization but not attribute-value normalization. In both cases, normalization of whitespace can be prevented by using character references such as <code>&amp;#x9;</code>.</p></div></div><div class="div2"><h3><a id="static-and-dynamic-context"></a>5.3 <a href="#static-and-dynamic-context" style="text-decoration: none">The Static and Dynamic Context</a></h3><p>XPath defines the concept of an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-expression-context">expression context</a><sup><small>XP40</small></sup> which contains all the information that can affect the result of evaluating an <a title="expression" class="termref" href="#dt-expression">expression</a>. The expression context has two parts, the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP40</small></sup>, and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-context">dynamic context</a><sup><small>XP40</small></sup>. The components that make up the expression context are defined in the XPath specification (see <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#context">Section 2.2 Expression Context</a><sup><small>XP40</small></sup>). This section describes the way in which these components are initialized when an XPath expression is contained within an XSLT stylesheet.</p><p> This section does not apply to <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a> (whose context is defined in <a href="#static-expression"><i>9.7 Static Expressions</i></a>), nor to XPath expressions evaluated using <a href="#element-evaluate"><code>xsl:evaluate</code></a> (whose context is defined in <a href="#evaluate-dynamic-context"><i>10.4.2 Dynamic context for the target expression</i></a>). [XSLT 3.0 Erratum E24, bug 30241] </p><p>As well as providing values for the static and dynamic context components defined in the XPath specification, XSLT defines additional context components of its own. These context components are used by XSLT instructions (for example, <a href="#element-next-match"><code>xsl:next-match</code></a> and <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>), and also by the functions in the extended function library described in this specification.</p><p>The following four sections describe:</p><blockquote><p><a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a><br><a href="#additional-static-context"><i>5.3.3 Additional Static Context Components used by XSLT</i></a><br><a href="#xpath-dynamic-context"><i>5.3.4 Initializing the Dynamic Context</i></a><br><a href="#additional-dynamic-context"><i>5.3.5 Additional Dynamic Context Components used by XSLT</i></a></p></blockquote><div class="div3"><h4><a id="static-context"></a>5.3.1 <a href="#static-context" style="text-decoration: none">Initializing the Static Context</a></h4><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP40</small></sup> of an XPath expression appearing in an XSLT stylesheet is initialized as follows. In these rules, the term <b>containing element</b> means the element within the stylesheet that is the parent of the attribute or text node whose value contains the XPath expression in question, and the term <b>enclosing element</b> means the containing element or any of its ancestors.</p><ul><li><p><a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to true if and only if the containing element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a> (see <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>).</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-namespaces">statically known namespaces</a><sup><small>XP40</small></sup> are the namespace declarations that are in scope for the containing element.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-def-element-ns">default element namespace</a><sup><small>XP40</small></sup> is determined as described in <a href="#unprefixed-element-names"><i>5.1.2.1 Unprefixed Element Names</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-def-type-ns">default type namespace</a><sup><small>XP40</small></sup> is determined as described in <a href="#unprefixed-type-names"><i>5.1.2.2 Unprefixed Type Names</i></a>..</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-function-namespace">default function namespace</a><sup><small>XP40</small></sup> is <code>http://www.w3.org/2005/xpath-functions</code> (and cannot be changed). The XSLT 4.0 specification refines the XPath 4.0 rules for resolving function names as described in <a href="#resolving-function-names"><i>5.3.2 Resolving Function Names</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP40</small></sup> for the XPath expression are the same as the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and are as specified in <a href="#built-in-types"><i>3.14 Built-in Types</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-variables">in-scope variables</a><sup><small>XP40</small></sup> are defined by the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding elements</a> that are in scope for the containing element (see <a href="#variables-and-parameters"><i>9 Variables and Parameters</i></a>).</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-item-static-type">context item static type</a><sup><small>XP40</small></sup> may be determined by an XSLT processor that performs static type inferencing, using rules that are outside the scope of this specification; if no static type inferencing is done, then the context item static type for every XPath expression is <code>item()</code>. Note that some limited static type inferencing is required in the case of a processor that performs streamability analysis: see <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known function definitions</a><sup><small>XP40</small></sup> are:</p><ul><li><p>The functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in namespaces <code>http://www.w3.org/2005/xpath-functions</code> and <code>http://www.w3.org/2005/xpath-functions/math</code>;</p></li><li><p>The functions defined in this specification in namespaces <code>http://www.w3.org/2005/xpath-functions</code> and <code>http://www.w3.org/2005/xpath-functions/map</code>;</p></li><li><p>Constructor functions for all the simple types in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP40</small></sup>, including both built-in types and user-defined types;</p></li><li><p>The <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> defined in the containing <a title="package" class="termref" href="#dt-package">package</a>;</p></li><li><p>Stylesheet functions defined in used packages, subject to visibility: see <a href="#package-dependencies"><i>3.5.2 Dependencies between Packages</i></a>;</p></li><li><p>any <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> bound using <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanisms (see <a href="#extension"><i>25 Extensibility and Fallback</i></a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> includes both vendor-supplied and user-written extension functions.</p></div></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>It follows from the above that a conformant XSLT processor must implement the entire library of functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> as well as those defined in this specification.</p></div></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-collations">statically known collations</a><sup><small>XP40</small></sup> are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, except that they <span class="verb">must</span> always include (a) the Unicode codepoint collation, defined in <a href="https://qt4cg.org/specifications/xpath-functions-40/#string-compare">Section 5.3 Comparison of strings</a><sup><small>FO40</small></sup>, and (b) the family of UCA collations described in <a href="#uca-collations"><i>13.4 The Unicode Collation Algorithm</i></a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-def-collation">default collation</a><sup><small>XP40</small></sup> is defined by the value of the <code>[xsl:]default-collation</code> attribute on the innermost enclosing element that has such an attribute. For details, see <a href="#default-collation-attribute"><i>3.7.1 The default-collation Attribute</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-default-collation" title="default collation"></a>In this specification the term <b>default collation</b> means the collation that is used by XPath operators such as <code>eq</code> and <code>lt</code> appearing in XPath expressions within the stylesheet.<span class="definition">]</span></p><p>This collation is also used by default when comparing strings in the evaluation of the <a href="#element-key"><code>xsl:key</code></a> and <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> elements. This <span class="verb">may</span> also (but need not necessarily) be the same as the default collation used for <a href="#element-sort"><code>xsl:sort</code></a> elements within the stylesheet. Collations used by <a href="#element-sort"><code>xsl:sort</code></a> are described in <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>.</p></li><li><p><b>Static base URI</b>: In a conventional interpreted environment, the static base URI of an expression in the stylesheet is the base URI of the containing element in the stylesheet. The concept of the base URI of a node is defined in <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2 base-uri Accessor </a><sup><small>DM30</small></sup>.</p><p>When stylesheets are executed in an environment where no source code is present (for example, because the code of the stylesheet has been compiled and is distributed as executable object code), it is <span class="verb">recommended</span> (subject to operational constraints such as security) that the static base URI used during stylesheet evaluation should be the location from which the stylesheet was loaded for execution (its “deployed location”). This means, for example, that when the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="#func-document"><code>document</code></a> functions are called with a relative URI, the required document is by default located relative to the deployed location of the stylesheet. </p><p>Whether or not the stylesheet is executed directly from source code, it is possible that no static base URI is available, for example because the code was supplied as an anonymous input stream, or because security policies are set to prevent executable code discovering the location from which it was loaded. If the static base URI is not known, the <a href="https://www.w3.org/TR/xpath-functions-30/#func-static-base-uri"><code>static-base-uri</code></a><sup><small>FO30</small></sup> function returns an empty sequence, and other operations that depend on the static base URI may fail with a dynamic error.</p></li><li><p>The set of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-docs">statically known documents</a><sup><small>XP40</small></sup> is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. </p></li><li><p>The set of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-collections">statically known collections</a><sup><small>XP40</small></sup> is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. </p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-default-collection">statically known default collection type</a><sup><small>XP40</small></sup> is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. </p></li><li><p>The set of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically known decimal formats</a><sup><small>XP40</small></sup> is the set of decimal formats defined by <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in the stylesheet. </p></li></ul></div><div class="div3"><h4><a id="resolving-function-names"></a>5.3.2 <a href="#resolving-function-names" style="text-decoration: none">Resolving Function Names</a></h4><p>This section defines how function names appearing in XPath expressions and patterns are resolved. It refines the rules given in the XPath 4.0 specification, which rely simply on looking up a function name and arity in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP40</small></sup>. The refinements are necessary to handle function overriding.</p><p>The rules depend on whether or not the stylesheet module contains an <a href="#element-function-library"><code>xsl:function-library</code></a> declaration: the following two sections describe these two cases.</p><p>The name <code>xsl:original</code> is treated specially, as described in <a href="#refer-to-overridden"><i>3.5.3.4 Referring to Overridden Components</i></a>.</p><div class="div4"><h5><a id="resolving-function-names-without-function-library"></a>5.3.2.1 <a href="#resolving-function-names-without-function-library" style="text-decoration: none">When no </a><a href="#element-function-library"><code>xsl:function-library</code></a><a href="#resolving-function-names-without-function-library" style="text-decoration: none"> is Declared</a></h5><p>In the absence of an <a href="#element-function-library"><code>xsl:function-library</code></a> declaration in the containing module:</p><ol class="enumar"><li><p>A lexical QName with no prefix is treated as the local name of a function in the namespace <code>http://www.w3.org/2005/xpath-functions</code>.</p></li><li><p>A lexical QName with a prefix is resolved by reference to the in-scope namespaces of the <b>containing element</b>.</p></li></ol></div><div class="div4"><h5><a id="resolving-function-names-with-function-library"></a>5.3.2.2 <a href="#resolving-function-names-with-function-library" style="text-decoration: none">When an </a><a href="#element-function-library"><code>xsl:function-library</code></a><a href="#resolving-function-names-with-function-library" style="text-decoration: none"> is Declared</a></h5><p>A stylesheet module may contain at most one <a href="#element-function-library"><code>xsl:function-library</code></a> declaration. The <a href="#element-function-library"><code>xsl:function-library</code></a> declaration affects the resolution of all function names used in expressions and patterns within that stylesheet module; it has no effect outside the containing module.</p><p class="element-syntax"><a id="element-function-library"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:function-library<br>&nbsp;&nbsp;namespace? = <var>uri</var><br>&nbsp;&nbsp;schema-location? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-function-namespace">xsl:function-namespace</a>* --&gt;<br>&lt;/xsl:function-library&gt;</code></p><p class="element-syntax"><a id="element-function-namespace"></a><code>&lt;xsl:function-namespace<br>&nbsp;&nbsp;<b>uri</b> = <var>uri</var><br>&nbsp;&nbsp;prefix? = <var>ncname</var><br>&nbsp;&nbsp;exclude? = <var>ncnames</var>&nbsp;/&gt;</code></p><p>Within the <a href="#element-function-library"><code>xsl:function-library</code></a> declaration, each <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> element defines a namespace that (typically) contains a number of functions, whose names are in that namespace.</p><p>It is a static error [TBA] if there is more than one <a href="#element-function-library"><code>xsl:function-library</code></a> declaration within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>.</p><p>It is a static error [TBA] if two <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> elements within an <a href="#element-function-library"><code>xsl:function-library</code></a> declaration have the same value for the <code>uri</code> attribute.</p><p>It is a static error [TBA] if two <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> elements within an <a href="#element-function-library"><code>xsl:function-library</code></a> declaration have the same value for the <code>prefix</code> attribute.</p><p>An unprefixed function name (together with the required arity) is resolved as follows:</p><ol class="enumar"><li><p>If exactly one of the <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> elements contains a function name with the required local name and arity, and does not exclude that local name by listing it in the <code>exclude</code> attribute, then that function is chosen.</p></li><li><p>Otherwise (if none of the <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> elements identifies such a function, or if more than one does so), the name is unresolved and a static error is reported.</p></li></ol><p>A prefixed function name (together with the required arity) is resolved as follows:</p><ol class="enumar"><li><p>If the namespace prefix used in the lexical QName matches the value of the <code>prefix</code> attribute of one of the <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> elements, then the local name is expanded using that namespace URI.</p></li><li><p>Otherwise (if there is no matching <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> element), the name is resolved as if the <a href="#element-function-library"><code>xsl:function-library</code></a> element were not present: see <a href="#resolving-function-names-without-function-library"><i>5.3.2.1 When no xsl:function-library is Declared</i></a>.</p></li></ol><p>A function name used in the <code>name</code> attribute of an <a href="#element-function"><code>xsl:function</code></a> declaration must be prefixed, and is expanded using the rules above.</p><div class="example"><div class="exampleHeader"><a id="d8e13238"></a>Example: Example <code>xsl:function-library</code><a id="d8e13238"></a>Example: Example <code>xsl:function-library</code></div><p>The following example shows a function library that makes all the standard function namespaces available:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function-library</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">fn</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">math</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions/math</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">map</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions/map</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">array</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions/array</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function-library</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Within a stylesheet module containing this declaration, functions from all these namespaces can be referred to be local name alone, provided the local name and arity (in combination) are unique. So it is possible to use <code>name()</code> to refer to a function in the <code>fn</code> namespace, <code>sqrt($x)</code> to refer to a function in the <code>math</code> namespace, and <code>integer($x)</code> to refer to a function in the <code>xs</code> namespace. However, the function call <code>boolean($x)</code> would be an error, because the reference is ambiguous: it could mean <code>fn:boolean($x)</code> or <code>xs:boolean($x)</code>. To disambiguate the call, it is necessary to use the namespace prefix.</p><p>It is not necessary, however, for the stylesheet to contain an XML namespace declaration that binds the prefix; the binding in the <a href="#element-function-namespace"><code>xsl:function-namespace</code></a> element suffices.</p><p>An <a href="#element-function-library"><code>xsl:function-library</code></a> element may include user-defined or vendor-defined function namespaces as well as system-defined namespaces.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e13181"></a><a id="d8e13274"></a>Example: Excluding Selected Names</div><p>The following example modifies the above function library to exclude some functions that otherwise cause conflicts:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function-library</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">fn</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">math</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions/math</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">map</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions/map</span><span class="z">"</span><span class="z"></span><span class="atn">exclude</span><span class="atneq">=</span><span class="z">"</span><span class="av">remove</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">array</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2005/xpath-functions/array</span><span class="z">"</span><span class="z"></span><span class="atn">exclude</span><span class="atneq">=</span><span class="z">"</span><span class="av">get put</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function-namespace</span><span class="z"></span><span class="atn">prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs</span><span class="z">"</span><span class="z"></span><span class="atn">uri</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">exclude</span><span class="atneq">=</span><span class="z">"</span><span class="av">boolean</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function-library</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>With the above declaration, it becomes possible to use the function call <code>remove($x, $n)</code> to refer unambiguously to the <code>fn:remove</code> function, because the entry for the <code>map</code> namespace explicitly excludes <code>map:remove</code>, which would otherwise cause an ambiguity. Similarly, <code>boolean($x)</code> unambiguously refers to <code>fn:boolean</code>, and <code>get($m, $k)</code> unambiguously refers to <code>map:get</code>.</p><p>It would also be possible to write a stylesheet function <code>my:get</code> which calls <code>map:get</code> or <code>array:get</code> as appropriate:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">my:get</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">target</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">key</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$target</span><span class="whitespace"></span><span class="type-op">instance of</span><span class="whitespace"></span><span class="node-type">map</span><span class="parenthesis">(</span><span class="quantifier">*</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">then</span><span class="atneq">=</span><span class="z">"</span><span class="av">map:get($target, $key)</span><span class="z">"</span><span class="z"></span><span class="atn">else</span><span class="atneq">=</span><span class="z">"</span><span class="av">array:get($target, $key)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>If the function library includes the <code>my</code> namespace, and if <code>map:get</code> and <code>array:get</code> are excluded, then an unprefixed call on <code>get()</code> becomes possible. A smart optimizer might even be able to decide at compile time which underlying function to call, if the type of the first argument is known.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This construct has several motivating purposes:</p><ul><li><p>Firstly, it improves code readability by reducing the need to qualify function names with a namespace prefix when the local name is unambiguous. The expression <code>sin($x)+cos($y)</code> is easier to read than <code>math:sin($x)+math:cos($y)</code>.</p></li><li><p>Secondly, it reduces the need to declare namespaces (using <code>xmlns:prefix="uri"</code> declarations) that are needed only for the purpose of qualifying function names. This is useful because a proliferation of such namespace declarations carries unwanted overheads. Even if the namespaces are designated as <b>excluded namespaces</b> (see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>) they still become part of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-namespaces">in-scope namespaces</a><sup><small>XP40</small></sup> in the static context of every XPath expression, which need to be carried around at run-time in a compiled stylesheet because they can be referenced at execution time (for example in a call of <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-available"><code>function-available</code></a><sup><small>FO30</small></sup>)</p><p>Namespace bindings established using an <a href="#element-function-library"><code>xsl:function-library</code></a> declaration impose less overhead because they are used only when binding function names, and they are never needed at evaluation time.</p></li><li><p>Finally, stylesheet authors may consider that documenting the dependencies of a stylesheet module makes the code more maintainable.</p></li></ul></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules take into account that new functions may be added to a namespace over time. Adding a new function to one of the namespaces may introduce a conflict, but this conflict will always result in a static error, it will never result in the wrong function being called. The conflict can always be resolved by excluding the function that caused the conflict, thus limiting the scope of the changes needed to handle this eventuality.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It is probably good practice for the <a href="#element-function-library"><code>xsl:function-library</code></a> declaration to appear near the start of a module, along with any <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> declarations, but this is not a formal requirement. The declaration can appear anywhere in the module.</p><p>Consider using XInclude, or DTD-defined entities, if you want to share an <a href="#element-function-library"><code>xsl:function-library</code></a> declaration between multiple modules.</p></div></div></div><div class="div3"><h4><a id="additional-static-context"></a>5.3.3 <a href="#additional-static-context" style="text-decoration: none">Additional Static Context Components used by XSLT</a></h4><p>Some of the components of the XPath static context are used also by <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>. For example, the <a href="#element-sort"><code>xsl:sort</code></a> element makes use of the collations defined in the static context, and attributes such as <code>type</code> and <code>as</code> may reference types defined in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>.</p><p>Many top-level declarations in a stylesheet, and attributes on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, affect the behavior of instructions within the stylesheet. Each of these constructs is described in its appropriate place in this specification.</p><p>A number of these constructs are of particular significance because they are used by functions defined in XSLT, which are added to the library of functions available for use in XPath expressions within the stylesheet. These are:</p><ul><li><p>The set of named keys, used by the <a href="#func-key"><code>key</code></a> function</p></li><li><p>The values of system properties, used by the <a href="#func-system-property"><code>system-property</code></a> function</p></li><li><p>The set of available instructions, used by the <a href="#func-element-available"><code>element-available</code></a> function</p></li></ul><p>A dynamic function call clears the first of these components: this means that a dynamic call to the <a href="#func-key"><code>key</code></a> function will always raise a dynamic error (the key name is unknown). The values of system properties and the set of available instructions, by contrast, reflect the capabilities and configuration of the processor rather than values specific to the stylesheet code itself; the result of a dynamic call to <a href="#func-system-property"><code>system-property</code></a> or <a href="#func-element-available"><code>element-available</code></a> will reflect the information available to the processor at evaluation time.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If these functions are called within a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>, the results will reflect the capabilities and configuration of the processor used to perform static analysis, while if they are called elsewhere, the results should reflect the capabilities and configuration of the processor used to perform dynamic evaluation, which might give a different result. These calls should not be pre-evaluated at compile time unless it is known that this will give the same result.</p></div></div><div class="div3"><h4><a id="xpath-dynamic-context"></a>5.3.4 <a href="#xpath-dynamic-context" style="text-decoration: none">Initializing the Dynamic Context</a></h4><p>For convenience, the dynamic context is described in two parts: the <a title="focus" class="termref" href="#dt-focus">focus</a>, which represents the place in the source document that is currently being processed, and a collection of additional context variables.</p><p>A number of functions specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> are defined to be <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO40</small></sup>, meaning that if they are called twice during the same <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO40</small></sup>, with the same arguments, then they return the same results (see <a href="https://qt4cg.org/specifications/xpath-functions-40/#terminology">Section 1.8 Terminology</a><sup><small>FO40</small></sup>). In XSLT, the execution of a stylesheet defines the execution scope. This means, for example, that if the function <a href="https://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>current-dateTime</code></a><sup><small>FO30</small></sup> is called repeatedly during a transformation, it produces the same result each time. By implication, the components of the dynamic context on which these functions depend are also stable for the duration of the transformation. Specifically, the following components defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#eval_context">Section 2.2.2 Dynamic Context</a><sup><small>XP40</small></sup> must be stable: <em>function implementations</em>, <em>current dateTime</em>, <em>implicit timezone</em>, <em>available documents</em>, <em>available collections</em>, and <em>default collection</em>. The values of global variables and stylesheet parameters are also stable for the duration of a transformation. The focus is <em>not</em> stable; the additional dynamic context components defined in <a href="#additional-dynamic-context"><i>5.3.5 Additional Dynamic Context Components used by XSLT</i></a> are also <em>not</em> stable.</p><p>As specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>, implementations may provide user options that relax the requirement for the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> and <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions (and therefore, by implication, the <a href="#func-document"><code>document</code></a> function) to return stable results. By default, however, the functions must be stable. The manner in which such user options are provided, if at all, is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>XPath expressions contained in <code>[xsl:]use-when</code> attributes are not considered to be evaluated “during the transformation” as defined above. For details see <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-absent" title="absent"></a>A component of the context that has no value is said to be <b>absent</b>.<span class="definition">]</span> This is a distinguishable state, and is not the same as having the empty sequence as its value.</p><div class="div4"><h5><a id="focus"></a>5.3.4.1 <a href="#focus" style="text-decoration: none">Maintaining Position: the Focus</a></h5><p><span class="definition">[Definition:&nbsp;</span><a id="dt-focus" title="focus"></a>When a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is evaluated, the <a title="processor" class="termref" href="#dt-processor">processor</a> keeps track of which items are being processed by means of a set of implicit variables referred to collectively as the <b>focus</b>.<span class="definition">]</span> More specifically, the focus consists of the following three values:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-item" title="context item"></a>The <b>context item</b> is the item currently being processed. An item (see <a href="#xpath-datamodel-30">[XDM 3.0]</a>) is either an atomic value (such as an integer, date, or string), a node, or a function item. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; each item in such a sequence becomes the context item while that item is being processed.<span class="definition">]</span> The context item is returned by the XPath <a title="expression" class="termref" href="#dt-expression">expression</a><code>.</code> (dot).</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-position" title="context position"></a>The <b>context position</b> is the position of the context item within the sequence of items currently being processed. It changes whenever the context item changes. When an instruction such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process a sequence of items, the first item in the sequence is processed with a context position of 1, the second item with a context position of 2, and so on.<span class="definition">]</span> The context position is returned by the XPath <a title="expression" class="termref" href="#dt-expression">expression</a><code>position()</code>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-size" title="context size"></a>The <b>context size</b> is the number of items in the sequence of items currently being processed. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; during the processing of each one of those items, the context size is set to the count of the number of items in the sequence (or equivalently, the position of the last item in the sequence).<span class="definition">]</span> The context size is returned by the XPath <a title="expression" class="termref" href="#dt-expression">expression</a><code>last()</code>.</p></li></ul><p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-node" title="context node"></a>If the <a title="context item" class="termref" href="#dt-context-item">context item</a> is a node (as distinct from an atomic value such as an integer), then it is also referred to as the <b>context node</b>. The context node is not an independent variable, it changes whenever the context item changes. When the context item is an atomic value or a function item, there is no context node.<span class="definition">]</span> The context node is returned by the XPath <a title="expression" class="termref" href="#dt-expression">expression</a><code>self::node()</code>, and it is used as the starting node for all relative path expressions.</p><p>Where the containing element of an XPath expression is an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> or a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, the initial context item, context position, and context size for the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> are the same as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, <a title="context position" class="termref" href="#dt-context-position">context position</a>, and <a title="context size" class="termref" href="#dt-context-size">context size</a> for the evaluation of the containing instruction or literal result element.</p><p>The context item for evaluating global variables <span>declared</span> in the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> is set to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> supplied when the transformation is invoked (see <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>). <span>For global variables declared in a </span><a title="library package" class="termref" href="#dt-library-package">library package</a>, the context item is <a title="absent" class="termref" href="#dt-absent">absent</a>. <span>[XSLT 3.0 Erratum E7, bug 30179].</span></p><p>For an XPath expression contained in a <a title="value template" class="termref" href="#dt-value-template">value template</a>, the initial context item, context position, and context size for the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> are the same as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, <a title="context position" class="termref" href="#dt-context-position">context position</a>, and <a title="context size" class="termref" href="#dt-context-size">context size</a> for the evaluation of the containing <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>In other cases (for example, where the containing element is <a href="#element-sort"><code>xsl:sort</code></a>, <a href="#element-with-param"><code>xsl:with-param</code></a>, or <a href="#element-key"><code>xsl:key</code></a>), the rules are given in the specification of the containing element.</p><p>The <a href="#func-current"><code>current</code></a> function can be used within any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> to select the item that was supplied as the context item to the XPath expression by the XSLT processor. Unlike <code>.</code> (dot) this is unaffected by changes to the context item that occur within the XPath expression. The <a href="#func-current"><code>current</code></a> function is described in <a href="#func-current"><i>20.4.1 fn:current</i></a>.</p><p>On completion of an instruction that changes the <a title="focus" class="termref" href="#dt-focus">focus</a> (such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-for-each"><code>xsl:for-each</code></a>), the focus reverts to its previous value.</p><p>When a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> is called, the focus within the body of the function is initially <a title="absent" class="termref" href="#dt-absent">absent</a>.</p><p>When the focus is <a title="absent" class="termref" href="#dt-absent">absent</a>, evaluation of any <a title="expression" class="termref" href="#dt-expression">expression</a> that references the context item, context position, or context size results in a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup></p><p>The description above gives an outline of the way the <a title="focus" class="termref" href="#dt-focus">focus</a> works. Detailed rules for the effect of each instruction are given separately with the description of that instruction. In the absence of specific rules, an instruction uses the same focus as its parent instruction. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-singleton-focus" title="singleton focus"></a>A <b>singleton focus</b> based on an item <var>J</var> has the <a title="context item" class="termref" href="#dt-context-item">context item</a> (and therefore the <a title="context node" class="termref" href="#dt-context-node">context node</a>, if <var>J</var> is a node) set to <var>J</var>, and the <a title="context position" class="termref" href="#dt-context-position">context position</a> and <a title="context size" class="termref" href="#dt-context-size">context size</a> both set to 1 (one).<span class="definition">]</span></p></div><div class="div4"><h5><a id="evaluation-context"></a>5.3.4.2 <a href="#evaluation-context" style="text-decoration: none">Other Components of the XPath Dynamic Context</a></h5><p>The previous section explained how the <a title="focus" class="termref" href="#dt-focus">focus</a> for an XPath expression appearing in an XSLT stylesheet is initialized. This section explains how the other components of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-context">dynamic context</a><sup><small>XP40</small></sup> of an XPath expression are initialized.</p><ul><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-variable-values">dynamic variables</a><sup><small>XP40</small></sup> are the current values of the in-scope <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding elements</a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamically-known-function-definitions">dynamically known function definitions</a><sup><small>XP40</small></sup> (representing the functions accessible using <a href="#func-function-available"><code>function-available</code></a> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>) include all the functions available in the static context, and may also include an additional <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of functions that are available dynamically but not statically. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This set therefore includes some functions that are not available for dynamic calling using <a href="#element-evaluate"><code>xsl:evaluate</code></a>, for example <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> whose visibility is private, and XSLT-defined functions such as <a href="#func-current"><code>current</code></a> and <a href="#func-key"><code>key</code></a>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The rule that all functions present in the static context must always be present in the dynamic context is a consistency constraint. The effect of violating a consistency constraint is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>: it does not necessarily lead to an error. For example, if the version of a used package that is available at evaluation time does not include all public user-defined functions that were available in the version that was used at analysis time, then a processor <span class="verb">may</span> recover by signaling an error only if the function is actually called. Conversely, if the evaluation-time version of the package includes additional public functions, these <span class="verb">may</span> be included in the dynamic context even though they were absent from the static context. Dynamic calling of functions using <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> may therefore be an effective strategy for coping with variations between versions of a library package on which a stylesheet depends.</p></div></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-docs">available documents</a><sup><small>XP40</small></sup> are defined as part of the XPath 3.0 dynamic context to support the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function, but this component is also referenced by the similar XSLT <a href="#func-document"><code>document</code></a> function: see <a href="#func-document"><i>20.1 fn:document</i></a>. This variable defines a mapping between URIs passed to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="#func-document"><code>document</code></a> function and the document nodes that are returned.</p><p>The mapping from URIs to document nodes is affected by <a href="#element-strip-space"><code>xsl:strip-space</code></a> declarations and by the <code>input-type-annotations</code> attribute, and may therefore vary from one package to another.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Defining this as part of the evaluation context is a formal way of specifying that the way in which URIs get turned into document nodes is outside the control of the language specification, and depends entirely on the run-time environment in which the transformation takes place.</p></div><p>The XSLT-defined <a href="#func-document"><code>document</code></a> function allows the use of URI references containing fragment identifiers. The interpretation of a fragment identifier depends on the media type of the resource representation. Therefore, the information supplied in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-docs">available documents</a><sup><small>XP40</small></sup> for XSLT processing must provide not only a mapping from URIs to document nodes as required by XPath, but also a mapping from URIs to media types.</p></li><li><p>All other aspects of the dynamic context (for example, the current date and time, the implicit timezone, the default language, calendar, and place, the available documents, text resources, and collections, and the default collection) are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, and do not change in the course of a single transformation, except to the extent that they <span class="verb">may</span> be different from one <a title="package" class="termref" href="#dt-package">package</a> to another.</p></li></ul></div></div><div class="div3"><h4><a id="additional-dynamic-context"></a>5.3.5 <a href="#additional-dynamic-context" style="text-decoration: none">Additional Dynamic Context Components used by XSLT</a></h4><p>In addition to the values that make up the <a title="focus" class="termref" href="#dt-focus">focus</a>, an XSLT processor maintains a number of other dynamic context components that reflect aspects of the evaluation context. These components are fully described in the sections of the specification that maintain and use them. They are:</p><ul><li><p>The <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>, which is the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> most recently invoked by an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction: see <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>; </p></li><li><p>The <a title="current mode" class="termref" href="#dt-current-mode">current mode</a>, which is the <a title="mode" class="termref" href="#dt-mode">mode</a> set by the most recent call of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> (for a full definition see <a href="#modes"><i>6.7 Modes</i></a>);</p></li><li><p>The <a title="current group" class="termref" href="#dt-current-group">current group</a> and <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a>, which provide information about the collection of items currently being processed by an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction: see <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a> and <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a>;</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In XSLT 3.0 the initial value of these two properties is “absent”, which means that any reference to their values causes a dynamic error. Previously, the initial value was an empty sequence. </p></div></li><li><p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>, which provide information about the collection of items currently being processed by an <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p></li><li><p>The <a title="current captured substrings" class="termref" href="#dt-current-captured-substrings">current captured substrings</a>: this is a sequence of strings, which is maintained when a string is matched against a regular expression using the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction, and which is accessible using the <a href="#func-regex-group"><code>regex-group</code></a> function: see <a href="#func-regex-group"><i>17.2 fn:regex-group</i></a>.</p></li><li><p>The <a title="output state" class="termref" href="#dt-output-state">output state</a>: this is a flag whose two possible values are <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> and <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>. The initial setting when the stylesheet is invoked by executing a template is <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>, and it is switched to <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a> by instructions such as <a href="#element-variable"><code>xsl:variable</code></a>. For more details, see <a href="#result-document-restrictions"><i>26.2 Restrictions on the use of xsl:result-document</i></a>.</p></li><li><p>The <a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a>: this is the URI associated with the result tree to which instructions are currently writing. The current output URI is initially the same as the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>. During the evaluation of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, the current output URI is set to the absolute URI identified by the <code>href</code> attribute of that instruction.</p></li></ul><p>The following non-normative table summarizes the initial state of each of the components in the evaluation context, and the instructions which cause the state of the component to change.</p><table class="data"><caption>Components of the Dynamic Evaluation Context</caption><thead><tr><th style="text-align:left; vertical-align:top">Component</th><th style="text-align:left; vertical-align:top">Initial Setting</th><th style="text-align:left; vertical-align:top">Set by</th><th style="text-align:left; vertical-align:top">Cleared by</th></tr></thead><tbody><tr><td style="vertical-align:top; text-align:left"><a title="focus" class="termref" href="#dt-focus">focus</a></td><td style="vertical-align:top; text-align:left">See <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.</td><td style="vertical-align:top; text-align:left"><a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, evaluation of <a title="pattern" class="termref" href="#dt-pattern">patterns</a></td><td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a></td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a></td><td style="vertical-align:top; text-align:left">If apply-templates invocation is used (see <a href="#invoking-initial-mode"><i>2.3.3 Apply-Templates Invocation</i></a>), then for each item in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is initially set to the template rule chosen for processing that item. Otherwise, <a title="absent" class="termref" href="#dt-absent">absent</a>. </td><td style="vertical-align:top; text-align:left"><a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, <a href="#element-next-match"><code>xsl:next-match</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>. </td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current mode" class="termref" href="#dt-current-mode">current mode</a></td><td style="vertical-align:top; text-align:left">the initial <a title="mode" class="termref" href="#dt-mode">mode</a></td><td style="vertical-align:top; text-align:left"><a href="#element-apply-templates"><code>xsl:apply-templates</code></a></td><td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>. Also cleared while evaluating global variables and stylesheet parameters, <a title="pattern" class="termref" href="#dt-pattern">patterns</a>, and the sequence constructor contained in <a href="#element-key"><code>xsl:key</code></a> or <a href="#element-sort"><code>xsl:sort</code></a>. Clearing the current mode causes the current mode to be set to the default (unnamed) mode.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current group" class="termref" href="#dt-current-group">current group</a></td><td style="vertical-align:top; text-align:left">absent</td><td style="vertical-align:top; text-align:left"><a href="#element-for-each-group"><code>xsl:for-each-group</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a></td><td style="vertical-align:top; text-align:left">absent</td><td style="vertical-align:top; text-align:left"><a href="#element-for-each-group"><code>xsl:for-each-group</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a></td><td style="vertical-align:top; text-align:left">absent</td><td style="vertical-align:top; text-align:left"><a href="#element-merge"><code>xsl:merge</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-merge-group"><i>15.6.1 fn:current-merge-group</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a></td><td style="vertical-align:top; text-align:left"><span>absent</span></td><td style="vertical-align:top; text-align:left"><a href="#element-merge"><code>xsl:merge</code></a></td><td style="vertical-align:top; text-align:left">See <a href="#func-current-merge-key"><i>15.6.2 fn:current-merge-key</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current captured substrings" class="termref" href="#dt-current-captured-substrings">current captured substrings</a></td><td style="vertical-align:top; text-align:left">empty sequence</td><td style="vertical-align:top; text-align:left"><a href="#element-matching-substring"><code>xsl:matching-substring</code></a></td><td style="vertical-align:top; text-align:left"><a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>; Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, dynamic function calls, evaluation of global variables, stylesheet parameters, and <a title="pattern" class="termref" href="#dt-pattern">patterns</a></td></tr><tr><td style="vertical-align:top; text-align:left"><a title="output state" class="termref" href="#dt-output-state">output state</a></td><td style="vertical-align:top; text-align:left"><a title="final output state" class="termref" href="#dt-final-output-state">final output state</a></td><td style="vertical-align:top; text-align:left">Set to <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a> by instructions such as <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, etc., and by calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a></td><td style="vertical-align:top; text-align:left">None</td></tr><tr><td style="vertical-align:top; text-align:left"><a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a></td><td style="vertical-align:top; text-align:left"><a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a></td><td style="vertical-align:top; text-align:left"><a href="#element-result-document"><code>xsl:result-document</code></a></td><td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, dynamic function calls, evaluation of <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>, <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and <a title="pattern" class="termref" href="#dt-pattern">patterns</a>.</td></tr></tbody></table><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-setting" title="initial setting"></a>The <b>initial setting</b> of a component of the dynamic context is used when evaluating <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, when evaluating the <code>use</code> and <code>match</code> attributes of <a href="#element-key"><code>xsl:key</code></a>, and when evaluating the <code>initial-value</code> of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> expressions or contained sequence constructors of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a><span class="definition">]</span>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-non-contextual-function-call" title="non-contextual function call"></a>The term <b>non-contextual function call</b> is used to refer to function calls that do not pass the dynamic context to the called function. This includes all calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> and all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-function-invocation">dynamic function invocations</a><sup><small>XP40</small></sup>, (that is calls to function items as permitted by XPath 3.0). It excludes calls to some functions in the namespace <code>http://www.w3.org/2005/xpath-functions</code>, in particular those that explicitly depend on the context, such as the <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-regex-group"><code>regex-group</code></a> functions. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances, calls to <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are non-contextual.<span class="definition">]</span></p><p>Named function references (such as <code>position#0</code>) and calls on <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> (for example, <code>function-lookup("position", 0)</code>) are defined to retain the XPath static and dynamic context at the point of invocation as part of the closure of the resulting function item, and to use this preserved context when a dynamic function call is subsequently made using the function item. This rule does not extend to the XSLT extensions to the dynamic context defined in this section. If a dynamic function call is made that depends on the XSLT part of the dynamic context (for example, <code>regex-group#1(2)</code>), then the relevant components of the context are cleared as described in the table above. </p></div></div><div class="div2"><h3><a id="patterns"></a>5.4 <a href="#patterns" style="text-decoration: none">Patterns</a></h3><p>In XSLT 4.0, patterns can match any kind of item: atomic values and function items as well as nodes.</p><p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> identifies the items to which it applies by means of a pattern. As well as being used in template rules, patterns are used for numbering (see <a href="#number"><i>12 Numbering</i></a>), for grouping (see <a href="#grouping"><i>14 Grouping</i></a>), and for declaring <a title="key" class="termref" href="#dt-key">keys</a> (see <a href="#key"><i>20.2 Keys</i></a>).</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-pattern" title="pattern"></a>A <b>pattern</b> specifies a set of conditions on an item. An item that satisfies the conditions matches the pattern; an item that does not satisfy the conditions does not match the pattern.<span class="definition">]</span></p><p>There are three kinds of pattern: <a title="predicate pattern" class="termref" href="#dt-predicate-pattern">predicate patterns</a>, <a title="type pattern" class="termref" href="#dt-type-pattern">type patterns</a>, and <a title="node pattern" class="termref" href="#dt-node-pattern">node patterns</a>:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-predicate-pattern" title="predicate pattern"></a>A <b>predicate pattern</b> is written as <code>.</code> (dot) followed by zero or more predicates in square brackets, and it matches any item for which each of the predicates evaluates to <code>true</code>.<span class="definition">]</span></p><p>A predicate pattern <code>.[P1][P2]...</code> can be regarded as an abbreviation for the type pattern <code>type(item())[P1][P2]...</code>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-type-pattern" title="type pattern"></a>A <b>type pattern</b> can be written as <code>type(T)</code> (where <var>T</var> is an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP40</small></sup> followed by zero or more predicates in square brackets, and it matches any item of type <var>T</var> which each of the predicates evaluates to <code>true</code>.<span class="definition">]</span></p><p>For convenience, if <var>T</var> takes the form <code>record(F1, F2, ...)</code>, then the pattern can be abbrevated.</p><p>The detailed semantics are given in <a href="#pattern-semantics"><i>5.4.2.4 The Meaning of a Node Pattern</i></a>. This construct can be used to match items of any kind (nodes, atomic values, and function items). For example, the pattern <code>.[starts-with(., '$')]</code> matches any string that starts with the character "$", or a node whose atomized value starts with "$". This example shows a predicate pattern with a single predicate, but the grammar allows any number of predicates (zero or more).</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-node-pattern" title="node pattern"></a>A <b>node pattern</b> uses a subset of the syntax for path expressions, and is defined to match a node if the corresponding path expression would select the node. Node patterns may also be formed by combining other patterns using union, intersection, and difference operators.<span class="definition">]</span></p><p>The syntax for node patterns (<code>UnionExprP</code> in the grammar: see <a href="#pattern-syntax"><i>5.4.2 Syntax of Patterns</i></a>) is a subset of the syntax for <a title="expression" class="termref" href="#dt-expression">expressions</a>. Node patterns are used only for matching nodes; an item other than a node will never match a node pattern. As explained in detail below, a node matches a node pattern if the node can be selected by deriving an equivalent expression, and evaluating this expression with respect to some possible context.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The specification uses the phrases <em>an item matches a pattern</em> and <em>a pattern matches an item</em> interchangeably. They are equivalent: an item matches a pattern if and only if the pattern matches the item.</p></div><div class="div3"><h4><a id="pattern-examples"></a>5.4.1 <a href="#pattern-examples" style="text-decoration: none">Examples of Patterns</a></h4><div class="example"><div class="exampleHeader"><a id="pattern-examples-1"></a>Example: Patterns</div><p>Here are some examples of patterns:</p><ul><li><p><em>Predicate Patterns:</em></p><ol class="enumar"><li><p><code>.</code> matches any item.</p></li><li><p><code>.[. castable as xs:date]</code> matches any item that can be successfully cast to <code>xs:date</code>: for example, an <code>xs:date</code> or <code>xs:dateTime</code> value, or a string in the lexical form of a date, or a node whose typed value is an <code>xs:date</code> or a string in the form of a date.</p></li><li><p><code>.[string() =&gt; matches('^[0-9]$')]</code> matches any item whose string value is a sequence of digits.</p></li><li><p><code>.[. castable as xs:date][xs:date(.) le current-date()]</code> matches any item that is castable to <code>xs:date</code> provided that the result of casting the value to <code>xs:date</code> is a date in the past.</p></li></ol></li><li><p><em>Type Patterns</em></p><ol class="enumar"><li><p><code>type(item())</code> matches any item.</p></li><li><p><code>type(node())</code> matches any node. (Note the distinction from the pattern <code>node()</code>.)</p></li><li><p><code>type(xs:date)</code> matches any atomic value of type <code>xs:date</code> (or a type derived by restriction from <code>xs:date</code>).</p></li><li><p><code>type(xs:date)[. gt current-date()]</code> matches any date in the future.</p></li><li><p><code>type(xs:string)[starts-with(., 'e')]</code> matches any <code>xs:string</code> value that starts with the letter 'e'. Note there is no type conversion; the pattern will not match an <code>xs:untypedAtomic</code> or <code>xs:anyURI</code> value, nor will it match any node.</p></li><li><p><code>type(function(*))</code> matches any function item.</p></li><li><p><code>type(function($x as xs:integer) as xs:boolean)[.(42)]</code> matches any function that accepts an <code>xs:integer</code> argument and returns a boolean result, provided that the result of calling the function with the argument value <code>42</code> is true.</p></li><li><p><code>union(xs:date, xs:dateTime, xs:time)</code> matches any atomic value that is an instance of <code>xs:date</code>, <code>xs:dateTime</code>, or <code>xs:time</code>.</p></li><li><p><code>enum("red", "green", "blue")</code> matches any one of the three strings <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p></li><li><p><code>record(first, last, *)[?location = 'UK']</code> matches any map whose keys include the strings <code>"first"</code> and <code>"last"</code>, and that also has an entry with key <code>"location"</code> whose value is <code>"UK"</code>.</p></li><li><p><code>record(longitude, latitude)</code> matches any map with two entries whose keys are the strings <code>"longitude"</code> and <code>"latitude"</code>.</p></li><li><p><code>array(xs:integer)[array:size(.) eq 4]</code> matches any array of four integers.</p></li><li><p><code>array(record(first, last, *))</code> matches any array of maps where each map contains entries with keys <code>"first"</code> and <code>"last"</code>. (Note that this includes the empty array).</p></li><li><p><code>array(record(first, last, *))[array:size(.) gt 0]</code> matches any non-empty array of maps where each map contains entries with keys <code>"first"</code> and <code>"last"</code>. </p></li><li><p><code>type(complex)</code> matches any value that is an instance of the item type declared in an <a href="#element-item-type"><code>xsl:item-type</code></a> declaration with name <code>"complex"</code></p></li><li><p><code>type(complex)[?i eq 0]</code> matches any value that is an instance of the item type declared in an <a href="#element-item-type"><code>xsl:item-type</code></a> declaration with name <code>"complex"</code> and that is a map with an entry having key "i" and value zero.</p></li></ol></li><li><p><em>Node Patterns</em></p><ol class="enumar"><li><p><code>*</code> matches any element.</p></li><li><p><code>para</code> matches any <code>para</code> element.</p></li><li><p><code>chapter|appendix</code> matches any <code>chapter</code> element and any <code>appendix</code> element.</p></li><li><p><code>child::(chapter|appendix)</code> matches any <code>chapter</code> element and any <code>appendix</code> element. Note that although the <code>child</code> axis is explicitly written, an element can match even though it has no parent.</p></li><li><p><code>olist/entry</code> matches any <code>entry</code> element with an <code>olist</code> parent.</p></li><li><p><code>appendix//para</code> matches any <code>para</code> element with an <code>appendix</code> ancestor element.</p></li><li><p><code>appendix/descendant::(para|table)</code> matches any <code>para</code> or <code>table</code>element with an <code>appendix</code> ancestor element.</p></li><li><p><code>schema-element(us:address)</code> matches any element that is annotated as an instance of the type defined by the schema element declaration <code>us:address</code>, and whose name is either <code>us:address</code> or the name of another element in its substitution group. </p></li><li><p><code>attribute(*, xs:date)</code> matches any attribute annotated as being of type <code>xs:date</code>.</p></li><li><p><code>/</code> matches a document node.</p></li><li><p><code>document-node()</code> matches a document node.</p></li><li><p><code>document-node(schema-element(my:invoice))</code> matches the document node of a document whose document element is named <code>my:invoice</code> and matches the type defined by the global element declaration <code>my:invoice</code>.</p></li><li><p><code>text()</code> matches any text node.</p></li><li><p><code>namespace-node()</code> matches any namespace node.</p></li><li><p><code>node()</code> matches any node other than an attribute node, namespace node, or document node.</p></li><li><p><code>id("W33")</code> matches the element with unique ID <code>W33</code>. </p></li><li><p><code>para[1]</code> matches any <code>para</code> element that is the first <code>para</code> child element of its parent. It also matches a parentless <code>para</code> element.</p></li><li><p><code>//para</code> matches any <code>para</code> element in a tree that is rooted at a document node.</p></li><li><p><code>bullet[position() mod 2 = 0]</code> matches any <code>bullet</code> element that is an even-numbered <code>bullet</code> child of its parent.</p></li><li><p><code>div[@class="appendix"]//p</code> matches any <code>p</code> element with a <code>div</code> ancestor element that has a <code>class</code> attribute with value <code>appendix</code>. </p></li><li><p><code>@class</code> matches any <code>class</code> attribute (<em>not</em> any element that has a <code>class</code> attribute).</p></li><li><p><code>@(class|type|kind)</code> matches any attribute named <code>class</code> or <code>type</code> or <code>kind</code>.</p></li><li><p><code>@*</code> matches any attribute node.</p></li><li><p><code>$xyz</code> matches any node that is present in the value of the variable <code>$xyz</code>.</p></li><li><p><code>$xyz//*</code> matches any element that is a descendant of a node that is present in the value of the variable <code>$xyz</code>.</p></li><li><p><code>doc('product.xml')//*</code> matches any element within the document whose document URI is 'product.xml'.</p></li></ol></li></ul></div></div><div class="div3"><h4><a id="pattern-syntax"></a>5.4.2 <a href="#pattern-syntax" style="text-decoration: none">Syntax of Patterns</a></h4><p><a id="err-XTSE0340"><span class="error">[ERR XTSE0340] </span></a>Where an attribute is defined to contain a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the pattern does not match the production <a href="#doc-xslt40-patterns-Pattern40">Pattern40</a>.</p><p>The grammar for patterns uses the notation defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#EBNFNotation">Section A.1.1 Notation</a><sup><small>XP40</small></sup>. </p><p>The lexical rules for patterns are the same as the lexical rules for XPath expressions, as defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#lexical-structure">Section A.2 Lexical structure</a><sup><small>XP40</small></sup>. Comments are permitted between tokens, using the syntax <code>(: ... :)</code>. All other provisions of the XPath grammar apply where relevant, for example the rules for whitespace handling and extra-grammatical constraints.</p><a id="Patterns-scrap"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-Pattern40"></a>[1]&nbsp;&nbsp;&nbsp;</td><td><code>Pattern40</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-PredicatePattern">PredicatePattern</a> | <a href="#doc-xslt40-patterns-TypePattern">TypePattern</a> | <a href="#doc-xslt40-patterns-NodePattern">NodePattern</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-PredicatePattern"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code>PredicatePattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"." <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-TypePattern"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code>TypePattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xslt40-patterns-WrappedItemTest">WrappedItemTest</a> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyItemTest">AnyItemTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionTest">FunctionTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MapTest">MapTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrayTest">ArrayTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RecordTest">RecordTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LocalUnionType">LocalUnionType</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnumerationType">EnumerationType</a><sup><small>XP40</small></sup>) <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-NodePattern"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code>NodePattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-UnionExprP">UnionExprP</a></code></td><td></td></tr></tbody></table><p>Patterns fall into three groups:</p><ul><li><p>A <code>PredicatePattern</code> matches items according to conditions that the item must satisfy: for example <code>.[. castable as xs:integer]</code> matches any value (it might be an atomic value, a node, or an array) that is castable as an integer.</p></li><li><p>A <code>TypePattern</code> matches items according to their type. For example <code>type(xs:integer)</code> matches an atomic value that is an instance of <code>xs:integer</code>, while <code>record(longitude, latitude)</code> matches a map that has exactly two entries, with keys <code>"longitude"</code> and <code>"latitude"</code></p></li><li><p>A <code>NodePattern</code> matches nodes in a tree, typically by specifying a path that can be used to locate the nodes: for example <code>order</code> matches an element node named <code>order</code>, while <code>billing-address/city</code> matches an element named <code>city</code> whose parent node is an element named <code>billing-address</code>.</p></li></ul><p>The following sections define the rules for each of these groups.</p><div class="div4"><h5><a id="predicate-patterns"></a>5.4.2.1 <a href="#predicate-patterns" style="text-decoration: none">Predicate Patterns</a></h5><a id="PredicatePatterns-scrap"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14438.doc-xslt40-patterns-PredicatePattern"></a><a id="noid_d4e14531.doc-xslt40-patterns-PredicatePattern"></a>[2]&nbsp;&nbsp;&nbsp;</td><td><code>PredicatePattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"." <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-PredicateList"></a>[86]&nbsp;&nbsp;&nbsp;</td><td><code>PredicateList</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP40</small></sup>*</code></td><td></td></tr></tbody></table><p>A <a href="#doc-xslt40-patterns-PredicatePattern">PredicatePattern</a><var>PP</var> matches an item <var>J</var> if and only if the XPath expression taking the same form as <var>PP</var> returns a non-empty sequence when evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>J</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The pattern <code>.</code>, which is a <code>PredicatePattern</code> with an empty <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup>, matches every item.</p><p>A predicate with the numeric value 1 (one) always matches, and a predicate with any other numeric value never matches. Numeric predicates in a <code>PredicatePattern</code> are therefore not useful, but are defined this way in the interests of consistency with XPath.</p></div><p>For example, the pattern <code>.[contains(., "XSLT")]</code> matches any item whose typed value contains <code>"XSLT"</code> as a substring. It matches values such as the string "XSLT Transformations", the <code>xs:anyURI</code> value <code>http://www.w3.org/TR/XSLT</code>, the attribute node <code>class="XSD XSLT XPath"</code>, and the singleton array <code>["XSLT 4.0"]</code>.</p></div><div class="div4"><h5><a id="type-patterns"></a>5.4.2.2 <a href="#type-patterns" style="text-decoration: none">Type Patterns</a></h5><a id="TypePatterns-scrap"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14489.doc-xslt40-patterns-TypePattern"></a><a id="noid_d4e14582.doc-xslt40-patterns-TypePattern"></a>[3]&nbsp;&nbsp;&nbsp;</td><td><code>TypePattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xslt40-patterns-WrappedItemTest">WrappedItemTest</a> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyItemTest">AnyItemTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionTest">FunctionTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MapTest">MapTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrayTest">ArrayTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RecordTest">RecordTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LocalUnionType">LocalUnionType</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnumerationType">EnumerationType</a><sup><small>XP40</small></sup>) <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-WrappedItemTest"></a>[4]&nbsp;&nbsp;&nbsp;</td><td><code>WrappedItemTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"type" "(" <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP40</small></sup> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-AnyItemTest"></a>[108]&nbsp;&nbsp;&nbsp;</td><td><code>AnyItemTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"item" "(" ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-FunctionTest"></a>[127]&nbsp;&nbsp;&nbsp;</td><td><code>FunctionTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyFunctionTest">AnyFunctionTest</a><sup><small>XP40</small></sup><br>| <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedFunctionTest">TypedFunctionTest</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-MapTest"></a>[130]&nbsp;&nbsp;&nbsp;</td><td><code>MapTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyMapTest">AnyMapTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedMapTest">TypedMapTest</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-ArrayTest"></a>[140]&nbsp;&nbsp;&nbsp;</td><td><code>ArrayTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyArrayTest">AnyArrayTest</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedArrayTest">TypedArrayTest</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-RecordTest"></a>[133]&nbsp;&nbsp;&nbsp;</td><td><code>RecordTest</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"record" "(" <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FieldDeclaration">FieldDeclaration</a><sup><small>XP40</small></sup> ("," <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FieldDeclaration">FieldDeclaration</a><sup><small>XP40</small></sup>)* <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExtensibleFlag">ExtensibleFlag</a><sup><small>XP40</small></sup>? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-FieldDeclaration"></a>[134]&nbsp;&nbsp;&nbsp;</td><td><code>FieldDeclaration</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FieldName">FieldName</a><sup><small>XP40</small></sup> "?"? ("as" (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SelfReference">SelfReference</a><sup><small>XP40</small></sup>))?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-FieldName"></a>[135]&nbsp;&nbsp;&nbsp;</td><td><code>FieldName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-ExtensibleFlag"></a>[137]&nbsp;&nbsp;&nbsp;</td><td><code>ExtensibleFlag</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"," "*"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-EnumerationType"></a>[139]&nbsp;&nbsp;&nbsp;</td><td><code>EnumerationType</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"enum" "(" <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP40</small></sup> ("," <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP40</small></sup>)* ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14502.doc-xslt40-patterns-PredicateList"></a><a id="noid_d4e14595.doc-xslt40-patterns-PredicateList"></a>[86]&nbsp;&nbsp;&nbsp;</td><td><code>PredicateList</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP40</small></sup>*</code></td><td></td></tr></tbody></table><p>A type pattern tests whether an item matches a given item type, optionally qualified with one or more predicates that the value must also satisfy.</p><p>The general-purpose construct <code>type(ItemType)</code> allows any <code>ItemType</code> to be used in a pattern. Where syntactic constraints permit, many <code>ItemTypes</code> can also be used directly: for example <code>type(item())</code> can be abbreviated as <code>item()</code>.</p><p>For example:</p><ul><li><p><code>type(integer)</code> matches any instance of <code>xs:integer</code></p></li><li><p><code>type(integer)[. gt 0]</code> matches any positive integer.</p></li><li><p><code>union(string, untypedAtomic)[matches(., '[0-9]+')]</code> matches any instance of <code>xs:string</code> or <code>xs:untypedAtomic</code> that contains a sequence of decimal digits.</p></li><li><p><code>type(node())</code> matches any node. (This is not the same as the pattern <code>node()</code>, which for historical reasons only matches element, text, comment, and processing instruction nodes).</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The above examples assume the declaration <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code>.</p></div><p>More formally, an item <var>$J</var> matches a pattern <code>type(T)[P1][P2][P3]</code> if the XPath expression <code>$J instance of T and exists($J[P1][P2]P3])</code> is true.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As with predicate patterns, numeric predicates are allowed, but serve no useful purpose.</p></div><p>A pattern written as <code>record(A, B, C)</code> is an abbreviation for <code>type(record(A, B, C))</code> (retaining any predicates). For example, the pattern <code>record(first, last, *)[?first eq "Sharon"]</code> matches any map having entries with the string-valued keys <code>"first"</code> and <code>"last"</code>, where the entry for the key <code>"first"</code> is equal to the string <code>"Sharon"</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The item type in a pattern can be any <code>ItemType</code>, but patterns that match nodes can usually be expressed more economically as a <code>NodeTest</code>: for example <code>match="type(element(PERSON))"</code> has the same meaning as <code>match="element(PERSON)"</code>, which in turn is usually abbreviated to <code>match="PERSON"</code>.</p><p>Although <code>match="type(element(PERSON))"</code> matches exactly the same items as <code>match="PERSON"</code>, the priority relative to other template rules (in the absence of an explicit <code>priority</code> attribute) may be different.</p></div></div><div class="div4"><h5><a id="node-patterns"></a>5.4.2.3 <a href="#node-patterns" style="text-decoration: none">Node Patterns</a></h5><a id="NodePatterns-scrap"></a><table class="scrap"><tbody><tr style="vertical-align:baseline;"><td><a id="noid_d4e14598.doc-xslt40-patterns-NodePattern"></a><a id="noid_d4e14691.doc-xslt40-patterns-NodePattern"></a>[5]&nbsp;&nbsp;&nbsp;</td><td><code>NodePattern</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-UnionExprP">UnionExprP</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-UnionExprP"></a>[6]&nbsp;&nbsp;&nbsp;</td><td><code>UnionExprP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-IntersectExceptExprP">IntersectExceptExprP</a> (("union" | "|") <a href="#doc-xslt40-patterns-IntersectExceptExprP">IntersectExceptExprP</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-IntersectExceptExprP"></a>[7]&nbsp;&nbsp;&nbsp;</td><td><code>IntersectExceptExprP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> (("intersect" | "except") <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-PathExprP"></a>[8]&nbsp;&nbsp;&nbsp;</td><td><code>PathExprP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-RootedPath">RootedPath</a><br>| ("/" <a href="#doc-xslt40-patterns-RelativePathExprP">RelativePathExprP</a>?)<br>| ("//" <a href="#doc-xslt40-patterns-RelativePathExprP">RelativePathExprP</a>)<br>| <a href="#doc-xslt40-patterns-RelativePathExprP">RelativePathExprP</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-RootedPath"></a>[9]&nbsp;&nbsp;&nbsp;</td><td><code>RootedPath</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP40</small></sup> | <a href="#doc-xslt40-patterns-FunctionCallP">FunctionCallP</a>) <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup> (("/" | "//") <a href="#doc-xslt40-patterns-RelativePathExprP">RelativePathExprP</a>)?</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-FunctionCallP"></a>[10]&nbsp;&nbsp;&nbsp;</td><td><code>FunctionCallP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-OuterFunctionName">OuterFunctionName</a><a href="#doc-xslt40-patterns-ArgumentListP">ArgumentListP</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-OuterFunctionName"></a>[11]&nbsp;&nbsp;&nbsp;</td><td><code>OuterFunctionName</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"doc" | "id" | "element-with-id" | "key" | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-URIQualifiedName">URIQualifiedName</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-ArgumentListP"></a>[12]&nbsp;&nbsp;&nbsp;</td><td><code>ArgumentListP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" (<a href="#doc-xslt40-patterns-ArgumentP">ArgumentP</a> ("," <a href="#doc-xslt40-patterns-ArgumentP">ArgumentP</a>)*)? ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-ArgumentP"></a>[13]&nbsp;&nbsp;&nbsp;</td><td><code>ArgumentP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP40</small></sup> | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Literal">Literal</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-RelativePathExprP"></a>[14]&nbsp;&nbsp;&nbsp;</td><td><code>RelativePathExprP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-StepExprP">StepExprP</a> (("/" | "//") <a href="#doc-xslt40-patterns-StepExprP">StepExprP</a>)*</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-StepExprP"></a>[15]&nbsp;&nbsp;&nbsp;</td><td><code>StepExprP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-PostfixExprP">PostfixExprP</a> | <a href="#doc-xslt40-patterns-AxisStepP">AxisStepP</a></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-PostfixExprP"></a>[16]&nbsp;&nbsp;&nbsp;</td><td><code>PostfixExprP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-ParenthesizedExprP">ParenthesizedExprP</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-ParenthesizedExprP"></a>[17]&nbsp;&nbsp;&nbsp;</td><td><code>ParenthesizedExprP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>"(" <a href="#doc-xslt40-patterns-UnionExprP">UnionExprP</a> ")"</code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-AxisStepP"></a>[18]&nbsp;&nbsp;&nbsp;</td><td><code>AxisStepP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code><a href="#doc-xslt40-patterns-ForwardStepP">ForwardStepP</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-ForwardStepP"></a>[19]&nbsp;&nbsp;&nbsp;</td><td><code>ForwardStepP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>(<a href="#doc-xslt40-patterns-ForwardAxisP">ForwardAxisP</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeTest">NodeTest</a><sup><small>XP40</small></sup>) | <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AbbrevForwardStep">AbbrevForwardStep</a><sup><small>XP40</small></sup></code></td><td></td></tr></tbody><tbody><tr style="vertical-align:baseline;"><td><a id="doc-xslt40-patterns-ForwardAxisP"></a>[20]&nbsp;&nbsp;&nbsp;</td><td><code>ForwardAxisP</code></td><td>&nbsp;&nbsp;&nbsp;::=&nbsp;&nbsp;&nbsp;</td><td><code>("child" "::")<br>| ("descendant" "::")<br>| ("attribute" "::")<br>| ("self" "::")<br>| ("descendant-or-self" "::")<br>| ("namespace" "::")</code></td><td></td></tr></tbody></table><p>Node Patterns are used to match XDM nodes.</p><p>The names of these constructs are chosen to align with the XPath 3.0 grammar. Constructs whose names are suffixed with <code>P</code> are restricted forms of the corresponding XPath 3.0 construct without the suffix. Constructs labeled with the suffix “XP40” are defined in <a href="#xpath-40">[XPath 4.0]</a>.</p><p>In a <a href="#doc-xslt40-patterns-FunctionCallP">FunctionCallP</a>, the <code>EQName</code> used for the function name must have local part <code>doc</code>, <code>id</code>, <code>element-with-id</code>, <code>key</code>, or <code>root</code>, and must use the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a> either explicitly or implicitly.</p><p>In the case of a call to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup> function, the argument list must be empty: that is, only the zero-arity form of the function is allowed.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As with XPath expressions, the pattern <code>/ union /*</code> can be parsed in two different ways, and the chosen interpretation is to treat <code>union</code> as an element name rather than as an operator. The other interpretation can be achieved by writing <code>(/) union (/*)</code></p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>A peculiarity of this grammar is that <code>doc('a.xml')/(id('abc'))</code> is a valid pattern, while <code>doc('a.xml')/id('abc')</code> is not: the <code>/</code> operator must be followed either by a parenthesized expression, or by an axis step.</p></div></div><div class="div4"><h5><a id="pattern-semantics"></a>5.4.2.4 <a href="#pattern-semantics" style="text-decoration: none">The Meaning of a Node Pattern</a></h5><p>The meaning of a node pattern is defined formally as follows, where “if” is to be read as “if and only if”.</p><p>The pattern is converted to an <a title="expression" class="termref" href="#dt-expression">expression</a>, called the <b>equivalent expression</b>. The equivalent expression to a <a href="#doc-xslt40-patterns-Pattern40">Pattern</a> is the XPath expression that takes the same lexical form as the <code>Pattern</code> as written, with the following adjustment:</p><ul><li><p>If any <code>PathExprP</code> in the <code>Pattern</code> is a <code>RelativePathExprP</code>, then the first <code>StepExprP</code><var>PS</var> of this <code>RelativePathExprP</code> is adjusted to allow it to match a parentless element, attribute, or namespace node. The adjustment depends on the axis used in this step, whether it appears explicitly or implicitly (according to the rules of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#abbrev">Section 4.6.5 Abbreviated Syntax</a><sup><small>XP40</small></sup>), and is made as follows:</p><ol class="enumar"><li><p>If the <code>NodeTest</code> in <var>PS</var> is <code>document-node()</code> (optionally with arguments), and if no explicit axis is specified, then the axis in step <var>PS</var> is taken as <code>self</code> rather than <code>child</code>.</p></li><li><p>If <var>PS</var> uses the child axis (explicitly or implicitly), and if the <code>NodeTest</code> in <var>PS</var> is not <code>document-node()</code> (optionally with arguments), then the axis in step <var>PS</var> is replaced by <code>child-or-top</code>, which is defined as follows. If the context node is a parentless element, comment, processing-instruction, or text node then the <code>child-or-top</code> axis selects the context node; otherwise it selects the children of the context node. It is a forwards axis whose principal node kind is element.</p></li><li><p>If <var>PS</var> uses the attribute axis (explicitly or implicitly), then the axis in step <var>PS</var> is replaced by <code>attribute-or-top</code>, which is defined as follows. If the context node is an attribute node with no parent, then the <code>attribute-or-top</code> axis selects the context node; otherwise it selects the attributes of the context node. It is a forwards axis whose principal node kind is attribute.</p></li><li><p>If <var>PS</var> uses the namespace axis (explicitly or implicitly), then the axis in step <var>PS</var> is replaced by <code>namespace-or-top</code>, which is defined as follows. If the context node is a namespace node with no parent, then the <code>namespace-or-top</code> axis selects the context node; otherwise it selects the namespace nodes of the context node. It is a forwards axis whose principal node kind is namespace.</p></li></ol><p>The axes <code>child-or-top</code>, <code>attribute-or-top</code>, and <code>namespace-or-top</code> are introduced only for definitional purposes. They cannot be used explicitly in a user-written pattern or expression.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The purpose of this adjustment is to ensure that a pattern such as <code>person</code> matches any element named <code>person</code>, even if it has no parent; and similarly, that the pattern <code>@width</code> matches any attribute named <code>width</code>, even a parentless attribute. The rule also ensures that a pattern using a <code>NodeTest</code> of the form <code>document-node(...)</code> matches a document node. The pattern <code>node()</code> will match any element, text node, comment, or processing instruction, whether or not it has a parent. For backwards compatibility reasons, the pattern <code>node()</code>, when used without an explicit axis, does not match document nodes, attribute nodes, or namespace nodes. The rules are also phrased to ensure that positional patterns of the form <code>para[1]</code> continue to count nodes relative to their parent, if they have one. To match any node at all, XSLT 4.0 allows the pattern <code>.[. instance of node()]</code> to be used.</p></div></li></ul><p>The meaning of the pattern is then defined in terms of the semantics of the equivalent expression, denoted below as <code>EE</code>.</p><p>Specifically, an item <var>N</var> matches a pattern <var>P</var> if the following applies, where <code>EE</code> is the <b>equivalent expression</b> to <var>P</var>:</p><ol class="enumar"><li><p><var>N</var> is a node, and the result of evaluating the expression <code>root(.)//(EE)</code> with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>N</var> is a sequence that includes the node <var>N</var></p></li></ol><p>If a pattern appears in an attribute of an element that is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a> (see <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>), then the semantics of the pattern are defined on the basis that the equivalent XPath expression is evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to true.</p><div class="example"><div class="exampleHeader"><a id="d8e15364"></a><a id="d8e15457"></a>Example: The Semantics of Node Patterns</div><p>The <a title="node pattern" class="termref" href="#dt-node-pattern">node pattern</a><code>p</code> matches any <code>p</code> element, because a <code>p</code> element will always be present in the result of evaluating the <a title="expression" class="termref" href="#dt-expression">expression</a><code>root(.)//(child-or-top::p)</code>. Similarly, <code>/</code> matches a document node, and only a document node, because the result of the <a title="expression" class="termref" href="#dt-expression">expression</a><code>root(.)//(/)</code> returns the root node of the tree containing the context node if and only if it is a document node.</p><p>The <a title="node pattern" class="termref" href="#dt-node-pattern">node pattern</a><code>node()</code> matches all nodes selected by the expression <code>root(.)//(child-or-top::node())</code>, that is, all element, text, comment, and processing instruction nodes, whether or not they have a parent. It does not match attribute or namespace nodes because the expression does not select nodes using the attribute or namespace axes. It does not match document nodes because for backwards compatibility reasons the <code>child-or-top</code> axis does not match a document node.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The pattern <code>type(node())</code> matches all nodes.</p></div><p>The <a title="node pattern" class="termref" href="#dt-node-pattern">node pattern</a><code>$V</code> matches all nodes selected by the expression <code>root(.)//($V)</code>, that is, all nodes in the value of $V (which will typically be a global variable, though when the pattern is used in contexts such as the <a href="#element-number"><code>xsl:number</code></a> or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instructions, it can also be a local variable).</p><p>The <a title="node pattern" class="termref" href="#dt-node-pattern">node pattern</a><code>doc('product.xml')//product</code> matches all nodes selected by the expression <code>root(.)//(doc('product.xml')//product)</code>, that is, all <code>product</code> elements in the document whose URI is <code>product.xml</code>.</p><p>The <a title="node pattern" class="termref" href="#dt-node-pattern">node pattern</a><code>root(.)/self::E</code> matches an <code>E</code> element that is the root of a tree (that is, an <code>E</code> element with no parent node).</p></div><p>Although the semantics of <a title="node pattern" class="termref" href="#dt-node-pattern">node patterns</a> are specified formally in terms of expression evaluation, it is possible to understand pattern matching using a different model. A <a title="node pattern" class="termref" href="#dt-node-pattern">node pattern</a> such as <code>book/chapter/section</code> can be examined from right to left. A node will only match this pattern if it is a <code>section</code> element; and then, only if its parent is a <code>chapter</code>; and then, only if the parent of that <code>chapter</code> is a <code>book</code>. When the pattern uses the <code>//</code> operator, one can still read it from right to left, but this time testing the ancestors of a node rather than its parent. For example <code>appendix//section</code> matches every <code>section</code> element that has an ancestor <code>appendix</code> element.</p><p>The formal definition, however, is useful for understanding the meaning of a pattern such as <code>para[1]</code>. This matches any node selected by the expression <code>root(.)//(child-or-top::para[1])</code>: that is, any <code>para</code> element that is the first <code>para</code> child of its parent, or a <code>para</code> element that has no parent.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An implementation, of course, may use any algorithm it wishes for evaluating patterns, so long as the result corresponds with the formal definition above. An implementation that followed the formal definition by evaluating the equivalent expression and then testing the membership of a specific node in the result would probably be very inefficient.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Patterns using the <code>intersect</code> and <code>except</code> operators do not always have the intuitive meaning: in particular, it is not always the case that a node matches <code>A except B</code> if it matches <code>A</code> but does not match <code>B</code>.</p><p>For example, consider the pattern <code>para except appendix//para</code>. This expands to <code>root(.)/descendant-or-self::node()/(child::para except child::appendix//para)</code>. Since for a given parent node, the results of <code>child::para</code> and <code>child::appendix</code> are disjoint, the right-hand operand of <code>except</code> has no effect.</p><p>The effect of matching all paragraphs except those within an appendix can be achieved using the pattern <code>para except //appendix//para</code>; alternatively, use <code>para[not(ancestor::appendix)]</code>.</p><p>Simpler patterns such as <code>@* except @code</code> generally have the expected effect; the complications arise mainly when non-trivial relative paths are used.</p></div></div></div><div class="div3"><h4><a id="pattern-errors"></a>5.4.3 <a href="#pattern-errors" style="text-decoration: none">Errors in Patterns</a></h4><p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> or <a title="type error" class="termref" href="#dt-type-error">type error</a> that occurs during the evaluation of a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> against a particular item has the effect that the item being tested is treated as not matching the pattern. The error does not cause the transformation to fail, and cannot be caught by a try/catch expression surrounding the instruction that causes the pattern to be evaluated.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The reason for this provision is that it is difficult for the stylesheet author to predict which predicates in a pattern will actually be evaluated. In the case of match patterns in template rules, it is not even possible to predict which patterns will be evaluated against a particular node.</p><p>There is a risk that ignoring errors in this way may make programming mistakes harder to debug. Implementations may mitigate this by providing warnings or other diagnostics when evaluation of a pattern triggers an error condition.</p><p>Static errors in patterns, including dynamic and type errors that are signaled statically as permitted by the specification, are reported in the normal way and cause the transformation to fail.</p></div><p>The requirement to detect and report a <a title="circularity" class="termref" href="#dt-circularity">circularity</a> as a dynamic error overrides this rule.</p></div></div><div class="div2"><h3><a id="named-item-types"></a>5.5 <a href="#named-item-types" style="text-decoration: none">Defining Named Item Types</a></h3><p class="element-syntax"><a id="element-item-type"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:item-type<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;visibility? = "private" | "final"&nbsp;/&gt;</code></p><p>An <a href="#element-item-type"><code>xsl:item-type</code></a> declaration associates a name with an item type, and allows the type to be referenced by name throughout the stylesheet package.</p><div class="example"><p>The following example declares a named item type for complex numbers, and uses it in a variable declaration and two function declarations.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:item-type</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">cx:complex</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">record(r as xs:double, i as xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">i</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">cx:complex</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">cx:number</span><span class="parenthesis">(</span><span class="numeric">0</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">cx:number</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">cx:complex</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">r</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">i</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="op">'</span><span class="property">r</span><span class="op">'</span><span class="op">:</span><span class="variable">$r</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="property">i</span><span class="op">'</span><span class="op">:</span><span class="variable">$i</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">cx:add</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">cx:complex</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">x</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">cx:complex</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">y</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">cx:complex</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">cx:number</span><span class="parenthesis">(</span><span class="variable">$x</span><span class="op">?</span><span class="qname">r</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="variable">$y</span><span class="op">?</span><span class="qname">r</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$x</span><span class="op">?</span><span class="qname">i</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="variable">$y</span><span class="op">?</span><span class="qname">i</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>Using named item types makes the stylesheet more readable, and improves potential for change: a change to the way complex numbers are implemented in this example is less likely to affect users of the function library. However, named item types do not provide true encapsulation or information hiding; users of the function library can still treat complex numbers as raw maps if they wish.</p><p>The <a href="#element-item-type"><code>xsl:item-type</code></a> declaration adds an entry to the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-type-alias">type alias</a><sup><small>XP40</small></sup> component of the static context for XPath expressions, and also becomes available for use wherever XSLT allows an <code>ItemType</code> to appear.</p><p>The scope of a named item type is the <a title="package" class="termref" href="#dt-package">package</a> in which it is declared. If it is declared with <code>visibility="final"</code> then it also becomes available for use in using packages. Named item types cannot be overridden in a using package, so the only permitted values for <code>visibility</code> are <code>private</code> and <code>final</code>.</p><p>The name of the item type is the expanded name formed by resolving the <code>name</code> attribute. A lexical QName with no prefix is treated as a no-namespace name.</p><p>If two <a href="#element-item-type"><code>xsl:item-type</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> have the same name, then the one with higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used. </p><p><a id="err-XTSE9ZZZ"><span class="error">[ERR XTSE9ZZZ] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package contains two <a href="#element-item-type"><code>xsl:item-type</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same item type with higher import precedence.</p><p>TODO: add named item types to xsl:accept and xsl:expose. Clarify that when a function or variable is exported to a different package, its declared type/signature uses the expanded form of any named item type; there's no requirement for the using package to know the named item types. But it becomes easier to use the exposed variables and functions if the names of the types are exposed too.</p></div><div class="div2"><h3><a id="defining-decimal-format"></a>5.6 <a href="#defining-decimal-format" style="text-decoration: none">Defining a Decimal Format</a></h3><p>The definition of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function is now in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. What remains here is the definition of the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration, which provides the context for this function when used in an XSLT stylesheet.</p><p class="element-syntax"><a id="element-decimal-format"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:decimal-format<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;decimal-separator? = <var>char</var><br>&nbsp;&nbsp;grouping-separator? = <var>char</var><br>&nbsp;&nbsp;infinity? = <var>string</var><br>&nbsp;&nbsp;minus-sign? = <var>char</var><br>&nbsp;&nbsp;exponent-separator? = <var>char</var><br>&nbsp;&nbsp;NaN? = <var>string</var><br>&nbsp;&nbsp;percent? = <var>char</var><br>&nbsp;&nbsp;per-mille? = <var>char</var><br>&nbsp;&nbsp;zero-digit? = <var>char</var><br>&nbsp;&nbsp;digit? = <var>char</var><br>&nbsp;&nbsp;pattern-separator? = <var>char</var>&nbsp;/&gt;</code></p><p>The <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> element sets the <b>statically known decimal formats</b> component of the static context for XPath expressions, which controls the interpretation of a <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> used by the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-picture-string" title="picture string"></a>The <b>picture string</b> is the string supplied as the second argument of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function, previously defined in this specification, is now defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. </p></div><p>A <a title="package" class="termref" href="#dt-package">package</a> may contain multiple <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations and may include or import <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> that also contain <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations. The name of an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration is the value of its <code>name</code> attribute, if any.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-decimal-format" title="decimal format"></a>All the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in a package that share the same name are grouped into a named <b>decimal format</b>; those that have no name are grouped into a single unnamed decimal format.<span class="definition">]</span></p><p> The attributes of the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration define the value of the corresponding property in the relevant decimal format in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically known decimal formats</a><sup><small>XP40</small></sup> component of the static context for all XPath expressions in the package. The attribute names used in the XSLT 4.0 syntax are the same as the property names used in the definition of the static context. </p><p>The scope of an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> name is the package in which it is declared; the name is available for use only in calls to <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> that appear within the same package.</p><p>If a <a title="package" class="termref" href="#dt-package">package</a> does not contain a declaration of the unnamed decimal format, a declaration equivalent to an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> element with no attributes is implied.</p><p>The attributes of the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration establish values for a number of variables used as input to the algorithm followed by the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function. An outline of the purpose of each attribute is given below; however, the definitive explanations are given as part of the specification of <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup>.</p><p>For any named <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a>, the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of each attribute is taken from an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration that has that name, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p>For any unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a>, the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of each attribute is taken from an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration that is unnamed, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p><a id="err-XTSE1290"><span class="error">[ERR XTSE1290] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a named or unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a> contains two conflicting values for the same attribute in different <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same attribute with higher import precedence. </p><p>The following attributes control the interpretation of characters in the <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> supplied to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function, and also specify characters that may appear in the result of formatting the number. In each case the value <span class="verb">must</span> be a single character <span class="error">[see <a href="#err-XTSE0020">ERR XTSE0020</a>]</span>.</p><ul><li><p><code>decimal-separator</code> specifies the character used to separate the integer part from the fractional part of the formatted number; the default value is the period character (<code>.</code>)</p></li><li><p><code>grouping-separator</code> specifies the character typically used as a thousands separator; the default value is the comma character (<code>,</code>)</p></li><li><p><code>percent</code> specifies the character used to indicate that the number is represented as a per-hundred fraction; the default value is the percent character (<code>%</code>)</p></li><li><p><code>per-mille</code> specifies the character used to indicate that the number is represented as a per-thousand fraction; the default value is the Unicode per-mille character (#x2030)</p></li><li><p><code>zero-digit</code> specifies the character used to represent the digit zero; the default value is the Western digit zero (<code>0</code>). This character <span class="verb">must</span> be a digit (category <code>Nd</code> in the Unicode property database), and it <span class="verb">must</span> have the numeric value zero. This attribute implicitly defines the Unicode character that is used to represent each of the values 0 to 9 in the final result string: Unicode is organized so that each set of decimal digits forms a contiguous block of characters in numerical sequence.</p></li></ul><p><a id="err-XTSE1295"><span class="error">[ERR XTSE1295] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the character specified in the <code>zero-digit</code> attribute is not a digit or is a digit that does not have the numeric value zero. </p><p>The following attributes control the interpretation of characters in the <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> supplied to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function. In each case the value <span class="verb">must</span> be a single character <span class="error">[see <a href="#err-XTSE0020">ERR XTSE0020</a>]</span>.</p><ul><li><p><code>digit</code> specifies the character used in the <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> as a place-holder for an optional digit; the default value is the number sign character (<code>#</code>)</p></li><li><p><code>pattern-separator</code> specifies the character used to separate positive and negative sub-pictures in a <a title="picture string" class="termref" href="#dt-picture-string">picture string</a>; the default value is the semi-colon character (<code>;</code>)</p></li></ul><p>The following attributes specify characters or strings that may appear in the result of formatting the number:</p><ul><li><p><code>infinity</code> specifies the string used to represent the <code>xs:double</code> value <code>INF</code>; the default value is the string <code>Infinity</code></p></li><li><p><code>NaN</code> specifies the string used to represent the <code>xs:double</code> value <code>NaN</code> (not-a-number); the default value is the string <code>NaN</code></p></li><li><p><code>minus-sign</code> specifies the character used to signal a negative number; the default value is the hyphen-minus character (<code>-</code>, #x2D). The value <span class="verb">must</span> be a single character.</p></li></ul><p><a id="err-XTSE1300"><span class="error">[ERR XTSE1300] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if, for any named or unnamed decimal format, the variables representing characters used in a <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> do not each have distinct values. These variables are <var>decimal-separator-sign</var>, <var>grouping-sign</var>, <var>percent-sign</var>, <var>per-mille-sign</var>, <var>digit-zero-sign</var>, <var>digit-sign</var>, and <var>pattern-separator-sign</var>. </p><p>Every (named or unnamed) decimal format defined in a <a title="stylesheet" class="termref" href="#dt-stylesheet">package</a> is added to the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically known decimal formats</a><sup><small>XP40</small></sup> in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP40</small></sup> of every expression in the <a title="package" class="termref" href="#dt-package">package</a>, excluding expressions appearing in <code>[xsl:]use-when</code> attributes.</p></div><div class="div2"><h3><a id="value-templates"></a>5.7 <a href="#value-templates" style="text-decoration: none">Value Templates</a></h3><p>The string value of an attribute or text node in the stylesheet may in particular circumstances contain embedded expressions enclosed between curly brackets. Attributes and text nodes that use (or are permitted to use) this mechanism are referred to respectively as <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-value-template" title="value template"></a>Collectively, attribute value templates and text value templates are referred to as <b>value templates</b>.<span class="definition">]</span></p><p>A value template is a string consisting of an alternating sequence of fixed parts and variable parts:</p><ul><li><p>A variable part consists of an optional XPath <a title="expression" class="termref" href="#dt-expression">expression</a> enclosed in curly brackets (<code>{}</code>): more specifically, a string conforming to the XPath production <code>Expr?</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An expression within a variable part may contain an unescaped curly bracket within a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP40</small></sup> or within a comment.</p><p>Currently no XPath expression starts with an opening curly bracket, so the use of <code>{{</code> creates no ambiguity. If an enclosed expression ends with a closing curly bracket, no whitespace is required between this and the closing delimiter.</p><p>The fact that the expression is optional means that the string contained between the curly brackets may be zero-length, may comprise whitespace only, or may contain XPath comments. The effective value in this case is a zero-length string, which is equivalent to omitting the variable part entirely, together with its curly-bracket delimiters. </p></div></li><li><p>A fixed part may contain any characters, except that a left curly bracket <span class="verb">must</span> be written as <code>{{</code> and a right curly bracket <span class="verb">must</span> be written as <code>}}</code>. </p></li></ul><p><a id="err-XTSE0350"><span class="error">[ERR XTSE0350] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped left curly bracket appears in a fixed part of a value template without a matching right curly bracket. </p><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the string contained between matching curly brackets in a value template does not match the XPath production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr?</a><sup><small>XP40</small></sup>, or if it contains other XPath static errors. The error is signaled using the appropriate XPath error code.</p><p><a id="err-XTSE0370"><span class="error">[ERR XTSE0370] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped right curly bracket occurs in a fixed part of a value template. </p><p><span style="display: none;" class="add_version">The result of evaluating a value template is referred to as its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>. The effective value is the string obtained by concatenating the expansions of the fixed and variable parts:</span><span class="modify_version"><span class="deltaxml-old" style="background:#FF5555">[Definition:&nbsp;</span><a id="dt-effective-value" title="effective value"></a>The result of evaluating a value template is referred to as its <span class="deltaxml-old" style="background:#FF5555">effective value</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a>.<span class="deltaxml-old" style="background:#FF5555">]</span> The effective value is the string obtained by concatenating the expansions of the fixed and variable parts:</span></p><ul><li><p>The expansion of a fixed part is obtained by replacing any double curly brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly bracket.</p></li><li><p>The expansion of a variable part is as follows:</p><ul><li><p>If an expression is present, the result of evaluating the enclosed XPath <a title="expression" class="termref" href="#dt-expression">expression</a> and converting the resulting value to a string. This conversion is done using the rules given in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p></li><li><p>If the expression is omitted, a zero-length string.</p></li></ul></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>This process can generate dynamic errors, for example if the sequence contains an element with a complex content type (which cannot be atomized).</p></div><p>In the case of an attribute value template, the effective value becomes the string value of the new attribute node. In the case of a text value template, the effective value becomes the string value of the new text node.</p><div class="div3"><h4><a id="attribute-value-templates"></a>5.7.1 <a href="#attribute-value-templates" style="text-decoration: none">Attribute Value Templates</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-attribute-value-template" title="attribute value template"></a>In an attribute that is designated as an <b>attribute value template</b>, such as an attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a> can be used by surrounding the expression with curly brackets (<code>{}</code>), following the general rules for <a title="value template" class="termref" href="#dt-value-template">value templates</a><span class="definition">]</span>.</p><p>Curly brackets are not treated specially in an attribute value in an XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> unless the attribute is specifically designated as one that permits an attribute value template; in an element syntax summary, the value of such attributes is surrounded by curly brackets.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Not all attributes are designated as attribute value templates. Attributes whose value is an <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, attributes of <a title="declaration" class="termref" href="#dt-declaration">declaration</a> elements and attributes that refer to named XSLT objects are generally not designated as attribute value templates (an exception is the <code>format</code> attribute of <a href="#element-result-document"><code>xsl:result-document</code></a>). Namespace declarations are not XDM attribute nodes and are therefore never treated as attribute value templates.</p></div><p>If the element containing the attribute is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then the rules for converting the value of the expression to a string (given in <a href="#value-templates"><i>5.7 Value Templates</i></a>) are modified as follows. After <a title="atomize" class="termref" href="#dt-atomization">atomizing</a> the result of the expression, all items other than the first item in the resulting sequence are discarded, and the effective value is obtained by converting the first item in the sequence to a string. If the atomized sequence is empty, the result is a zero-length string.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The above rule applies to attribute value templates but not to text value templates, since the latter were not available in XSLT 1.0.</p></div><div class="example"><div class="exampleHeader"><a id="d8e16099"></a><a id="d8e16193"></a>Example: Attribute Value Templates</div><p>The following example creates an <code>img</code> result element from a <code>photograph</code> element in the source; the value of the <code>src</code> and <code>width</code> attributes are computed using XPath expressions enclosed in attribute value templates:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">image-dir</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">/images</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">photograph</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">img</span><span class="z"></span><span class="atn">src</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$image-dir</span><span class="op">}</span><span class="av">/</span><span class="op">{</span><span class="qname">href</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">width</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="qname">size</span><span class="step">/</span><span class="axis">@</span><span class="qname">width</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>With this source</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">photograph</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">href</span><span class="scx">&gt;</span><span class="txt">headquarters.jpg</span><span class="ez">&lt;/</span><span class="cl">href</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">size</span><span class="z"></span><span class="atn">width</span><span class="atneq">=</span><span class="z">"</span><span class="av">300</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">photograph</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>the result would be</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">img</span><span class="z"></span><span class="atn">src</span><span class="atneq">=</span><span class="z">"</span><span class="av">/images/headquarters.jpg</span><span class="z">"</span><span class="z"></span><span class="atn">width</span><span class="atneq">=</span><span class="z">"</span><span class="av">300</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e16119"></a><a id="d8e16213"></a>Example: Producing a Space-Separated List</div><p>The following example shows how the values in a sequence are output as a space-separated list. The following literal result element:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">temperature</span><span class="z"></span><span class="atn">readings</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="numeric">10.32</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">5.50</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">8.31</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>produces the output node:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">temperature</span><span class="z"></span><span class="atn">readings</span><span class="atneq">=</span><span class="z">"</span><span class="av">10.32 5.5 8.31</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>Curly brackets are <em>not</em> recognized recursively inside expressions.</p><div class="example"><div class="exampleHeader"><a id="d8e16131"></a><a id="d8e16225"></a>Example: Curly Brackets cannot be Nested</div><p>For example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">a</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">#</span><span class="op">{</span><span class="function">id</span><span class="parenthesis">(</span><span class="op">{</span><span class="axis">@</span><span class="qname">ref</span><span class="op">}</span><span class="parenthesis">)</span><span class="step">/</span><span class="qname">title</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>is <em>not</em> allowed. Instead, use simply:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">a</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">#</span><span class="op">{</span><span class="function">id</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">ref</span><span class="parenthesis">)</span><span class="step">/</span><span class="qname">title</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="text-value-templates"></a>5.7.2 <a href="#text-value-templates" style="text-decoration: none">Text Value Templates</a></h4><p>The <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attribute</a><code>[xsl:]expand-text</code> may appear on any element in the stylesheet, and determines whether descendant text nodes of that element are treated as text value templates. A text node in the stylesheet is treated as a text value template if (a) it is part of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> or a child of an <a href="#element-text"><code>xsl:text</code></a> instruction, (b) there is an ancestor element with an <code>[xsl:]expand-text</code> attribute, and (c) on the innermost ancestor element that has such an attribute, the value of the attribute is <code>yes</code>. The attribute is boolean and <span class="verb">must</span> therefore take one of the values <code>yes</code> (synonyms <code>true</code> or <code>1</code>) or <code>no</code> (synonyms <code>false</code> or <code>0</code>). </p><p><span style="display: none;" class="delete_version">This section describes how text nodes are processed when the effective value is <code>yes</code>. Such text nodes are referred to as text value templates.</span><span style="display: none;" class="add_version">This section describes how text nodes are processed when the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>yes</code>. Such text nodes are referred to as text value templates.</span><span class="modify_version">This section describes how text nodes are processed when the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>is <code>yes</code>. Such text nodes are referred to as text value templates.</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-text-value-template" title="text value template"></a>In a text node that is designated as a <b>text value template</b>, <a title="expression" class="termref" href="#dt-expression">expressions</a> can be used by surrounding each expression with curly brackets (<code>{}</code>).<span class="definition">]</span></p><p>The rules for text value templates are given in <a href="#value-templates"><i>5.7 Value Templates</i></a>. A text node whose value is a text value template results in the construction of a text node in the result of the containing sequence constructor or <a href="#element-text"><code>xsl:text</code></a> instruction. The string value of that text node is obtained by computing the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the value template.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The result of evaluating a text value template is a (possibly zero-length) text node. This text node becomes part of the result of the containing sequence constructor or <a href="#element-text"><code>xsl:text</code></a> instruction, and is thereafter handled exactly as if the value had appeared explicitly as a text node in the stylesheet.</p><p>The way in which the effective value is computed does not depend on any <code>separator</code> attribute on a containing <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-attribute"><code>xsl:attribute</code></a> instruction. The <code>separator</code> attribute only affects how the text node is combined with adjacent items in the result of the containing sequence constructor.</p><p>Fixed parts consisting entirely of whitespace are significant and are handled in the same way as any other fixed part. This is different from the default treatment of “boundary space” in XQuery.</p></div><div class="example"><div class="exampleHeader"><a id="d8e16213"></a><a id="d8e16311"></a>Example: Using a text value template to construct message output</div><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">id</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">A123</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">step</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">5</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Processing id=</span><span class="op">{</span><span class="variable">$id</span><span class="op">}</span><span class="txt">, step=</span><span class="op">{</span><span class="variable">$step</span><span class="op">}</span><span class="ez">&lt;/</span><span class="clxsl">xsl:message</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This will typically output the message text <code>Processing id=A123, step=5</code>.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e16221"></a><a id="d8e16319"></a>Example: Using a text value template to define the result of a function</div><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:sum</span><span class="z">"</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">x</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">y</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="op">{</span><span class="variable">$x</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="variable">$y</span><span class="op">}</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Note that although this is a very readable way of expressing the computation performed by the function, the semantics are somewhat complex, and this could mean that execution is inefficient. The function computes the value of <code>$x + $y</code> as an integer, and then constructs a text node containing the string representation of this integer (preceded and followed by whitespace). Because the declared result type of the function is <code>xs:integer</code>, this text node is then atomized, giving an <code>xs:untypedAtomic</code> value, and the <code>xs:untypedAtomic</code> value is then cast to an <code>xs:integer</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The main motivations for adding text value templates to the XSLT language are firstly, to make it easier to construct parameterized text in contexts such as <a href="#element-value-of"><code>xsl:value-of</code></a> and <a href="#element-message"><code>xsl:message</code></a>, and secondly, to allow use of complex multi-line XPath expressions where maintaining correct indentation is important for readability. The fact that XML processors are required to normalize whitespace in attribute values means that writing such expressions within a <code>select</code> attribute is not ideal.</p><p>The facility is only present if enabled using the <code>[xsl:]expand-text</code> attribute. This is partly for backwards compatibility, and partly to avoid creating difficulties when constructing content that is rich in curly brackets, for example JavaScript code or CSS style sheets.</p></div></div></div><div class="div2"><h3><a id="sequence-constructors"></a>5.8 <a href="#sequence-constructors" style="text-decoration: none">Sequence Constructors</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-constructor" title="sequence constructor"></a>A <b>sequence constructor</b> is a sequence of zero or more sibling nodes in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be evaluated to return a sequence of nodes, atomic values, and function items. The way that the resulting sequence is used depends on the containing instruction.<span class="definition">]</span></p><p>Many <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>, and also <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, are defined to take a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as their content.</p><p>Four kinds of nodes may be encountered in a sequence constructor:</p><ol class="enumar"><li><p> A <em>Text node</em> appearing in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (if it has not been removed in the process of whitespace stripping: see <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>) is processed as follows:</p><ol class="enumla"><li><p><span style="display: none;" class="delete_version">if the effective value of the standard attribute <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence of this attribute, the text node in the stylesheet is copied to create a new parentless text node in the result of the sequence constructor.</span><span style="display: none;" class="add_version">if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the standard attribute <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence of this attribute, the text node in the stylesheet is copied to create a new parentless text node in the result of the sequence constructor.</span><span class="modify_version">if the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the standard attribute <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence of this attribute, the text node in the stylesheet is copied to create a new parentless text node in the result of the sequence constructor.</span></p></li><li><p><span style="display: none;" class="delete_version">Otherwise (the effective value of <code>[xsl:]expand-text</code> is <code>yes</code>), the text node in the stylesheet is processed as described in <a href="#text-value-templates"><i>5.7.2 Text Value Templates</i></a>.</span><span style="display: none;" class="add_version">Otherwise (the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of <code>[xsl:]expand-text</code> is <code>yes</code>), the text node in the stylesheet is processed as described in <a href="#text-value-templates"><i>5.7.2 Text Value Templates</i></a>.</span><span class="modify_version">Otherwise (the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of <code>[xsl:]expand-text</code> is <code>yes</code>), the text node in the stylesheet is processed as described in <a href="#text-value-templates"><i>5.7.2 Text Value Templates</i></a>.</span></p></li></ol></li><li><p> A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> is evaluated to create a new parentless element node, having the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as the literal result element: see <a href="#literal-result-element"><i>11.1 Literal Result Elements</i></a>. </p></li><li><p>An XSLT <a title="instruction" class="termref" href="#dt-instruction">instruction</a> produces a sequence of zero, one, or more items as its result. For most XSLT instructions, these items are nodes, but some instructions (such as <a href="#element-sequence"><code>xsl:sequence</code></a> and <a href="#element-copy-of"><code>xsl:copy-of</code></a>) can also produce atomic values or function items. Several instructions, such as <a href="#element-element"><code>xsl:element</code></a>, return a newly constructed parentless node (which may have its own attributes, namespaces, children, and other descendants). Other instructions, such as <a href="#element-if"><code>xsl:if</code></a>, pass on the items produced by their own nested sequence constructors. The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction may return atomic values, function items, or existing nodes.</p></li><li><p> An <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a>) also produces a sequence of items as its result.</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-immediate-result" title="immediate result"></a>The result of evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the sequence of items formed by concatenating the results of evaluating each of the nodes in the sequence constructor, retaining order. This is referred to as the <b>immediate result</b> of the sequence constructor.<span class="definition">]</span></p><p>However:</p><ul><li><p>For the effect of the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction, see <a href="#fallback"><i>25.2.3 Fallback</i></a>.</p></li><li><p>For the effect of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions, see <a href="#conditional-content-construction"><i>8.5 Conditional Content Construction</i></a>.</p></li></ul><p>The way that <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is used depends on the containing element in the stylesheet, and is specified in the rules for that element. It is typically one of the following:</p><ul><li><p>The <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> may be bound to a <a title="variable" class="termref" href="#dt-variable">variable</a> or delivered as the result of a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>. In this case the <code>as</code> attribute of the containing <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-function"><code>xsl:function</code></a> element may be used to declare its required type, and the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> is then converted to the required type by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><ul><li><p>In the absence of an <code>as</code> attribute, the result of a function is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the sequence constructor; but the value of a variable (for backwards compatibility reasons) is a document node whose content is formed by applying the rules in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a> to the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a>. </p></li><li><p>The coercion rules do not merge adjacent text nodes or insert separators between adjacent items. This means it is often inappropriate to use <a href="#element-value-of"><code>xsl:value-of</code></a> in the body of <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-function"><code>xsl:function</code></a>, especially when the intent is to return an atomic result. The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is designed for this purpose, and is usually a better choice. </p></li><li><p>The result of a function, or the value of a variable, may contain nodes (such as elements, attributes, and text nodes) that are not attached to any parent node in a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. The semantics of XPath expressions when applied to parentless nodes are well-defined; however, such expressions should be used with care. For example, the expression <code>/</code> causes a type error if the root of the tree containing the context node is not a document node. </p></li><li><p>Parentless attribute nodes require particular care because they have no namespace nodes associated with them. A parentless attribute node is not permitted to contain namespace-sensitive content (for example, a QName or an XPath expression) because there is no information enabling the prefix to be resolved to a namespace URI. Parentless attributes can be useful in an application (for example, they provide an alternative to the use of attribute sets: see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>) but they need to be handled with care.</p></li></ul></div></li><li><p>The sequence may be returned as the result of the containing element. This happens, for example, when the element containing the sequence constructor is <a href="#element-break"><code>xsl:break</code></a>, <a href="#element-catch"><code>xsl:catch</code></a>, <a href="#element-fallback"><code>xsl:fallback</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-fork"><code>xsl:fork</code></a>, <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a>, <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>, <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>, <a href="#element-on-completion"><code>xsl:on-completion</code></a>, <a href="#element-otherwise"><code>xsl:otherwise</code></a>, <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-try"><code>xsl:try</code></a>, or <a href="#element-when"><code>xsl:when</code></a>. </p></li><li><p>The sequence may be used to construct the content of a new element or document node. This happens when the sequence constructor appears as the content of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or of one of the instructions <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-assert"><code>xsl:assert</code></a>, or <a href="#element-message"><code>xsl:message</code></a>. It also happens when the sequence constructor is contained in one of the elements <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, or <a href="#element-with-param"><code>xsl:with-param</code></a>, when this instruction has no <code>as</code> attribute. For details, see <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>.</p></li><li><p>The sequence may be used to construct the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an attribute node, text node, namespace node, comment node, or processing instruction node. This happens when the sequence constructor is contained in one of the elements <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-value-of"><code>xsl:value-of</code></a>, <a href="#element-namespace"><code>xsl:namespace</code></a>, <a href="#element-comment"><code>xsl:comment</code></a>, or <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>. For details, see <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p></li></ul><div class="div3"><h4><a id="constructing-complex-content"></a>5.8.1 <a href="#constructing-complex-content" style="text-decoration: none">Constructing Complex Content</a></h4><p>Many instructions, for example <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, create a new parent node, and evaluate a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the content of the instruction to create the attributes, namespaces, and children of the new parent node. The <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the sequence constructor is processed to create the content of the new parent node as described in this section.</p><p>When constructing the content of an element, the <code>inherit-namespaces</code> attribute of the <a href="#element-element"><code>xsl:element</code></a> or <a href="#element-copy"><code>xsl:copy</code></a> instruction, or the <code>xsl:inherit-namespaces</code> property of the literal result element, determines whether namespace nodes are to be inherited. The effect of this attribute is described in the rules that follow.</p><p>The <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is processed as follows (applying the rules in the order they are listed):</p><ol class="enumar"><li><p>The containing instruction may generate attribute nodes and/or namespace nodes, as specified in the rules for the individual instruction. For example, these nodes may be produced by expanding an <code>[xsl:]use-attribute-sets</code> attribute, or by expanding the attributes of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. Any such nodes are prepended to the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p></li><li><p>Any array item in the sequence (see <a href="#arrays"><i>22 Arrays</i></a>) is replaced by its members, recursively. This is equivalent to applying the <a href="https://www.w3.org/TR/xpath-functions-30/#func-array-flatten"><code>array:flatten</code></a><sup><small>FO40</small></sup> function defined in <a href="#xpath-functions-31">[Functions and Operators 3.1]</a>.</p></li><li><p>Any atomic value in the sequence is cast to a string.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to <code>xs:string</code> always succeeds, because these values retain a prefix for this purpose. However, there is no guarantee that the prefix used will always be meaningful in the context where the resulting string is used.</p></div></li><li><p>Any consecutive sequence of strings in the sequence is converted to a single text node, whose <a title="string value" class="termref" href="#dt-string-value">string value</a> contains the content of each of the strings in turn, with a single space (#x20) used as a separator between successive strings.</p></li><li><p>Any document node within the sequence is replaced by a sequence containing each of its children, in document order.</p></li><li><p>Zero-length text nodes within the sequence are removed.</p></li><li><p>Adjacent text nodes within the sequence are merged into a single text node.</p></li><li><p>Invalid items in the sequence are detected as follows.</p><p><a id="err-XTDE0410"><span class="error">[ERR XTDE0410] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence used to construct the content of an element node contains a namespace node or attribute node that is preceded in the sequence by a node that is neither a namespace node nor an attribute node. </p><p><a id="err-XTDE0420"><span class="error">[ERR XTDE0420] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence used to construct the content of a document node contains a namespace node or attribute node. </p><p><a id="err-XTDE0430"><span class="error">[ERR XTDE0430] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence contains two or more namespace nodes having the same name but different <a title="string value" class="termref" href="#dt-string-value">string values</a> (that is, namespace nodes that map the same prefix to different namespace URIs). </p><p><a id="err-XTDE0440"><span class="error">[ERR XTDE0440] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence contains a namespace node with no name and the element node being constructed has a null namespace URI (that is, it is an error to define a default namespace when the element is in no namespace). </p><p><a id="err-XTDE0450"><span class="error">[ERR XTDE0450] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result sequence contains a function item. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The error code reflects the fact that this error was at one time classified as a dynamic error rather than a type error. [XSLT 3.0 Erratum E17, bug 30223].</p></div></li><li><p>If the sequence contains two or more namespace nodes with the same name (or no name) and the same <a title="string value" class="termref" href="#dt-string-value">string value</a> (that is, two namespace nodes mapping the same prefix to the same namespace URI), then all but one of the duplicate nodes are discarded.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Since the order of namespace nodes is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, it is not significant which of the duplicates is retained.</p></div></li><li><p>If an attribute <var>A</var> in the sequence has the same name as another attribute <var>B</var> that appears later in the sequence, then attribute <var>A</var> is discarded from the sequence. Before discarding attribute <var>A</var>, the processor <span class="verb">may</span> signal any <a title="type error" class="termref" href="#dt-type-error">type errors</a> that would be signaled if attribute <var>B</var> were not present. </p></li><li><p>Each node in the resulting sequence is attached as a namespace, attribute, or child of the newly constructed element or document node. Conceptually this involves making a deep copy of the node; in practice, however, copying the node will only be necessary if the existing node can be referenced independently of the parent to which it is being attached. When copying an element or processing instruction node, its base URI property is changed to be the same as that of its new parent, unless it has an <code>xml:base</code> attribute (see <a href="#xmlbase">[XML Base]</a>) that overrides this. If the copied element has an <code>xml:base</code> attribute, its base URI is the value of that attribute, resolved (if it is relative) against the base URI of the new parent node.</p><p>Except for the handling of base URI, the copying of a node follows the rules of the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with attributes <code>copy-namespaces="yes" copy-accumulators="no" validation="preserve"</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This has the consequence that the type annotation and the values of the <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties are retained. However, if the node under construction (the new parent of the node being copied) uses a validation mode other than <code>preserve</code>, this will be transient: the values will be recomputed when the new parent node is validated.</p></div></li><li><p>If the newly constructed node is an element node, then namespace fixup is applied to this node, as described in <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>.</p></li><li><p>If the newly constructed node is an element node, and if namespaces are inherited, then each namespace node of the newly constructed element (including any produced as a result of the namespace fixup process) is copied to each descendant element of the newly constructed element, unless that element or an intermediate element already has a namespace node with the same name (or absence of a name) or that descendant element or an intermediate element is in no namespace and the namespace node has no name.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d8e16715"></a><a id="d8e16817"></a>Example: A Sequence Constructor for Complex Content</div><p>Consider the following stylesheet fragment:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">valign</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">top</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">description</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This fragment consists of a literal result element <code>td</code>, containing a sequence constructor that consists of two instructions: <a href="#element-attribute"><code>xsl:attribute</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a>. The sequence constructor is evaluated to produce a sequence of two nodes: a parentless attribute node, and a parentless text node. The <code>td</code> instruction causes a <code>td</code> element to be created; the new attribute therefore becomes an attribute of the new <code>td</code> element, while the text node created by the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction becomes a child of the <code>td</code> element (unless it is zero-length, in which case it is discarded).</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e16739"></a><a id="d8e16841"></a>Example: Space Separators in Element Content</div><p>Consider the following stylesheet fragment:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">e</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">5</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">e</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">f</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">5</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">f</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This produces the output (when indented):</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">e</span><span class="scx">&gt;</span><span class="txt">1 2 3 4 5</span><span class="ez">&lt;/</span><span class="cl">e</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">f</span><span class="scx">&gt;</span><span class="txt">12345</span><span class="ez">&lt;/</span><span class="cl">f</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The difference between the two cases is that for the <code>e</code> element, the sequence constructor generates a sequence of five atomic values, which are therefore separated by spaces. For the <code>f</code> element, the content is a sequence of five text nodes, which are concatenated without space separation.</p><p>It is important to be aware of the distinction between <a href="#element-sequence"><code>xsl:sequence</code></a>, which returns the value of its <code>select</code> expression unchanged, and <a href="#element-value-of"><code>xsl:value-of</code></a>, which constructs a text node.</p></div></div><div class="div3"><h4><a id="constructing-simple-content"></a>5.8.2 <a href="#constructing-simple-content" style="text-decoration: none">Constructing Simple Content</a></h4><p>The instructions <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-comment"><code>xsl:comment</code></a>, <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, <a href="#element-namespace"><code>xsl:namespace</code></a>, and <a href="#element-value-of"><code>xsl:value-of</code></a> all create nodes that cannot have children. Specifically, the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction creates an attribute node, <a href="#element-comment"><code>xsl:comment</code></a> creates a comment node, <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> creates a processing instruction node, <a href="#element-namespace"><code>xsl:namespace</code></a> creates a namespace node, and <a href="#element-value-of"><code>xsl:value-of</code></a> creates a text node. The string value of the new node is constructed using either the <code>select</code> attribute of the instruction, or the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the instruction. The <code>select</code> attribute allows the content to be specified by means of an XPath expression, while the sequence constructor allows it to be specified by means of a sequence of XSLT instructions. The <code>select</code> attribute or sequence constructor is evaluated to produce a result sequence, and the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the new node is derived from this result sequence according to the rules below.</p><p>These rules are also used to compute the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of a <a title="value template" class="termref" href="#dt-value-template">value template</a>. In this case the sequence being processed is the result of evaluating an XPath expression enclosed between curly brackets, and the separator is a single space character.</p><ol class="enumar"><li><p>Zero-length text nodes in the sequence are discarded.</p></li><li><p>Adjacent text nodes in the sequence are merged into a single text node.</p></li><li><p>The sequence is <a title="atomize" class="termref" href="#dt-atomization">atomized</a> (which may cause a dynamic error).</p></li><li><p>Every value in the atomized sequence is cast to a string.</p></li><li><p>The strings within the resulting sequence are concatenated, with a (possibly zero-length) separator inserted between successive strings. The default separator depends on the containing instruction; except where otherwise specified, it is a single space.</p><p>In the case of <a href="#element-attribute"><code>xsl:attribute</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a>, the default separator is a single space when the <code>select</code> attribute is used, or a zero-length string otherwise; a different separator can be specified using the <code>separator</code> attribute of the instruction.</p><p>In the case of <a href="#element-comment"><code>xsl:comment</code></a>, <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, and <a href="#element-namespace"><code>xsl:namespace</code></a>, and when expanding a <a title="value template" class="termref" href="#dt-value-template">value template</a>, the default separator cannot be changed.</p></li><li><p>In the case of <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, any leading spaces in the resulting string are removed.</p></li><li><p>The resulting string forms the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the new attribute, namespace, comment, processing-instruction, or text node.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d8e16855"></a><a id="d8e16957"></a>Example: Space Separators in Attribute Content</div><p>Consider the following stylesheet fragment:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">e</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">5</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">f</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">5</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">g</span><span class="z">"</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="op">{</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">5</span><span class="op">}</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This produces the output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">doc</span><span class="z"></span><span class="atn">e</span><span class="atneq">=</span><span class="z">"</span><span class="av">1 2 3 4 5</span><span class="z">"</span><span class="z"></span><span class="atn">f</span><span class="atneq">=</span><span class="z">"</span><span class="av">12345</span><span class="z">"</span><span class="z"></span><span class="atn">g</span><span class="atneq">=</span><span class="z">"</span><span class="av">1 2 3 4 5</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The difference between the three cases is as follows. For the <code>e</code> attribute, the sequence constructor generates a sequence of five atomic values, which are therefore separated by spaces. For the <code>f</code> attribute, the content is supplied as a sequence of five text nodes, which are concatenated without space separation. For the <code>g</code> attribute, the <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a> constructs a text node using the rules for constructing simple content, which insert space separators between atomic values; the text node is then atomized to form the value of the attribute.</p><p>Specifying <code>separator=""</code> on the first <a href="#element-attribute"><code>xsl:attribute</code></a> instruction would cause the attribute value to be <code>e="12345"</code>. A <code>separator</code> attribute on the second <a href="#element-attribute"><code>xsl:attribute</code></a> instruction would have no effect, since the separator only affects the way adjacent atomic values are handled: separators are never inserted between adjacent text nodes. A <code>separator</code> on the third <a href="#element-attribute"><code>xsl:attribute</code></a> instruction would also have no effect, because text value templates are evaluated without regard to the containing instruction.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If an attribute value template contains a sequence of fixed and variable parts, no additional whitespace is inserted between the expansions of the fixed and variable parts. For example, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute <code>a="chapters{4 to 6}"</code> is <code>a="chapters4 5 6"</code>.</p></div></div><div class="div3"><h4><a id="namespace-fixup"></a>5.8.3 <a href="#namespace-fixup" style="text-decoration: none">Namespace Fixup</a></h4><p>In a tree supplied to or constructed by an XSLT processor, the constraints relating to namespace nodes that are specified in <a href="#xpath-datamodel-30">[XDM 3.0]</a><span class="verb">must</span> be satisfied. For example:</p><ul><li><p>If an element node has an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with a non-null namespace URI, then that element node <span class="verb">must</span> have at least one namespace node whose <a title="string value" class="termref" href="#dt-string-value">string value</a> is the same as that namespace URI.</p></li><li><p>If an element node has an attribute node whose <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has a non-null namespace URI, then the element <span class="verb">must</span> have at least one namespace node whose <a title="string value" class="termref" href="#dt-string-value">string value</a> is the same as that namespace URI and whose name is non-empty.</p></li><li><p>Every element <span class="verb">must</span> have a namespace node whose <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has local-part <code>xml</code> and whose <a title="string value" class="termref" href="#dt-string-value">string value</a> is <code>http://www.w3.org/XML/1998/namespace</code>. The namespace prefix <code>xml</code><span class="verb">must</span> not be associated with any other namespace URI, and the namespace URI <code>http://www.w3.org/XML/1998/namespace</code><span class="verb">must</span> not be associated with any other prefix.</p></li><li><p>A namespace node <span class="verb">must not</span> have the name <code>xmlns</code> or the string value <code>http://www.w3.org/2000/xmlns/</code>.</p></li></ul><p><span class="definition">[Definition:&nbsp;</span><a id="dt-namespace-fixup" title="namespace fixup"></a>The rules for the individual XSLT instructions that construct a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> (see <a href="#creating-new-nodes"><i>11 Creating Nodes and Sequences</i></a>) prescribe some of the situations in which namespace nodes are written to the tree. These rules, however, are not sufficient to ensure that the prescribed constraints are always satisfied. The XSLT processor <span class="verb">must</span> therefore add additional namespace nodes to satisfy these constraints. This process is referred to as <b>namespace fixup</b>.<span class="definition">]</span></p><p>The actual namespace nodes that are added to the tree by the namespace fixup process are <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, provided firstly, that at the end of the process the above constraints <span class="verb">must</span> all be satisfied, and secondly, that a namespace node <span class="verb">must not</span> be added to the tree unless the namespace node is necessary either to satisfy these constraints, or to enable the tree to be serialized using the original namespace prefixes from the source document or <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.</p><p>Namespace fixup <span class="verb">must not</span> result in an element having multiple namespace nodes with the same name.</p><p>Namespace fixup <span class="verb">may</span>, if necessary to resolve conflicts, change the namespace prefix contained in the QName value that holds the name of an element or attribute node. This includes the option to add or remove a prefix. However, namespace fixup <span class="verb">must not</span> change the prefix component contained in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code> that forms the typed value of an element or attribute node.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Namespace fixup is not used to create namespace declarations for <code>xs:QName</code> or <code>xs:NOTATION</code> values appearing in the content of an element or attribute.</p><p>Where values acquire such types as the result of validation, namespace fixup does not come into play, because namespace fixup happens before validation: in this situation, it is the user’s responsibility to ensure that the element being validated has the required namespace nodes to enable validation to succeed.</p><p>Where existing elements are copied along with their existing <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> (<code>validation="preserve"</code>) the rules require that existing namespace nodes are also copied, so that any namespace-sensitive values remain valid.</p><p>Where existing attributes are copied along with their existing type annotations, the rules of the XDM data model require that a parentless attribute node cannot contain a namespace-sensitive typed value; this means that it is an error to copy an attribute using <code>validation="preserve"</code> if it contains namespace-sensitive content.</p></div><p>Namespace fixup is applied to every element that is constructed using a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or one of the instructions <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, or <a href="#element-copy-of"><code>xsl:copy-of</code></a>. An implementation is not <span class="verb">required</span> to perform namespace fixup for elements in any source document, that is, for a document in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, documents loaded using the <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> function, documents supplied as the value of a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, or documents returned by an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A source document (an input document, a document returned by the <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions, a document returned by an extension function or extension instruction, or a document supplied as a stylesheet parameter) is required to satisfy the constraints described in <a href="#xpath-datamodel-30">[XDM 3.0]</a>, including the constraints imposed by the namespace fixup process. The effect of supplying a pseudo-document that does not meet these constraints is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></div><p>In an Infoset (see <a href="#xml-infoset">[XML Information Set]</a>) created from a document conforming to <a href="#xml-names">[Namespaces in XML]</a>, it will always be true that if a parent element has an in-scope namespace with a non-empty namespace prefix, then its child elements will also have an in-scope namespace with the same namespace prefix, though possibly with a different namespace URI. This constraint is removed in <a href="#xml-names11">[Namespaces in XML 1.1]</a>. XSLT 4.0 supports the creation of result trees that do not satisfy this constraint: the namespace fixup process does not add a namespace node to an element merely because its parent node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> has such a namespace node. However, the process of constructing the children of a new element, which is described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>, does cause the namespaces of a parent element to be inherited by its children unless this is prevented using <code>[xsl:]inherit-namespaces="no"</code> on the instruction that creates the parent element.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This has implications on serialization, defined in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>. It means that it is possible to create <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> that cannot be faithfully serialized as XML 1.0 documents. When such a result tree is serialized as XML 1.0, namespace declarations written for the parent element will be inherited by its child elements as if the corresponding namespace nodes were present on the child element, except in the case of the default namespace, which can be undeclared using the construct <code>xmlns=""</code>. When the same result tree is serialized as XML 1.1, however, it is possible to undeclare any namespace on the child element (for example, <code>xmlns:foo=""</code>) to prevent this inheritance taking place.</p></div></div></div><div class="div2"><h3><a id="uri-references"></a>5.9 <a href="#uri-references" style="text-decoration: none">URI References</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-uri-reference" title="URI Reference"></a>Within this specification, the term <b>URI Reference</b>, unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.<span class="definition">]</span> Note that this is a wider definition than that in <a href="#RFC3986">[RFC3986]</a>: in particular, it is designed to accommodate Internationalized Resource Identifiers (IRIs) as described in <a href="#RFC3987">[RFC3987]</a>, and thus allows the use of non-ASCII characters without escaping.</p><p>URI References are used in XSLT with three main roles:</p><ul><li><p>As namespace URIs</p></li><li><p>As collation URIs</p></li><li><p>As identifiers for resources such as stylesheet modules; these resources are typically accessible using a protocol such as HTTP. Examples of such identifiers are the URIs used in the <code>href</code> attributes of <a href="#element-import"><code>xsl:import</code></a>, <a href="#element-include"><code>xsl:include</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a>.</p></li></ul><p>The rules for namespace URIs are given in <a href="#xml-names">[Namespaces in XML]</a> and <a href="#xml-names11">[Namespaces in XML 1.1]</a>. Those specifications deprecate the use of relative URI references as namespace URIs.</p><p>The rules for collation URIs are given in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p><p>URI references used to identify external resources must conform to the same rules as the locator attribute (<code>href</code>) defined in section 5.4 of <a href="#xlink">[XLink]</a>. If the URI reference is relative, then it is resolved (unless otherwise specified) against the base URI of the containing element node, according to the rules of <a href="#RFC3986">[RFC3986]</a>, after first escaping all characters that need to be escaped to make it a valid RFC3986 URI reference. (But a relative URI reference in the <code>href</code> attribute of <a href="#element-result-document"><code>xsl:result-document</code></a> is resolved against the <a title="base output URI" class="termref" href="#dt-base-output-uri">Base Output URI</a>.)</p><p>Other URI references appearing in an XSLT stylesheet document, for example the system identifiers of external entities or the value of the <code>xml:base</code> attribute, must follow the rules in their respective specifications.</p><p>The base URI of an element node in the stylesheet is determined as defined in <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2 base-uri Accessor </a><sup><small>DM30</small></sup>. Some implementations may allow the output of the static analysis phase of stylesheet processing (a “compiled stylesheet”) to be evaluated in a different location from that where static analysis took place. Furthermore, stylesheet authors may in such cases wish to avoid exposing the location of resources that are private to the development environment. If the base URI of an element in the stylesheet is defined by an absolute URI appearing in an <code>xml:base</code> attribute within the stylesheet, this value <span class="verb">must</span> be used as the static base URI. In other cases where processing depends on the static base URI of a stylesheet module, implementations <span class="verb">may</span> use different values for the static base URI during static analysis and during dynamic evaluation (for example, an implementation <span class="verb">may</span> use different base URIs for resolving <a href="#element-import"><code>xsl:import</code></a> module references and for resolving a relative reference used as an argument to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function). In such cases an implementation <span class="verb">must</span> document how the static base URI is computed for each situation in which it is required. </p></div></div><div class="div1"><h2><a id="rules"></a>6 <a href="#rules" style="text-decoration: none">Template Rules</a></h2><p>Template rules define the processing that can be applied to items that match a particular <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p><div class="div2"><h3><a id="defining-templates"></a>6.1 <a href="#defining-templates" style="text-decoration: none">Defining Templates</a></h3><p class="element-syntax"><a id="element-template"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:template<br>&nbsp;&nbsp;match? = <var>pattern</var><br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;priority? = <var>decimal</var><br>&nbsp;&nbsp;mode? = <var>tokens</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-context-item">xsl:context-item</a>?, <a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:template&gt;</code></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-template" title="template"></a>An <a href="#element-template"><code>xsl:template</code></a> declaration defines a <b>template</b>, which contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>; this sequence constructor is evaluated to determine the result of the template. A template can serve either as a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, invoked by matching items against a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, or as a <a title="named template" class="termref" href="#dt-named-template">named template</a>, invoked explicitly by name. It is also possible for the same template to serve in both capacities.<span class="definition">]</span></p><p><a id="err-XTSE0500"><span class="error">[ERR XTSE0500] </span></a>An <a href="#element-template"><code>xsl:template</code></a> element <span class="verb">must</span> have either a <code>match</code> attribute or a <code>name</code> attribute, or both. An <a href="#element-template"><code>xsl:template</code></a> element that has no <code>match</code> attribute <span class="verb">must</span> have no <code>mode</code> attribute and no <code>priority</code> attribute. An <a href="#element-template"><code>xsl:template</code></a> element that has no <code>name</code> attribute <span class="verb">must</span> have no <code>visibility</code> attribute. </p><p>If an <a href="#element-template"><code>xsl:template</code></a> element has a <code>match</code> attribute, then it is a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>. If it has a <code>name</code> attribute, then it is a <a title="named template" class="termref" href="#dt-named-template">named template</a>.</p><p>A <a title="template" class="termref" href="#dt-template">template</a> may be invoked in a number of ways, depending on whether it is a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, a <a title="named template" class="termref" href="#dt-named-template">named template</a>, or both. The result of invoking the template is the result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the <a href="#element-template"><code>xsl:template</code></a> element (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>).</p><p>For details of the optional <a href="#element-context-item"><code>xsl:context-item</code></a> child element, see <a href="#declaring-context-item"><i>10.1.4 Declaring the Context Item for a Template</i></a>.</p><p>If an <code>as</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element is present, the <code>as</code> attribute defines the required type of the result. The result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is then converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If no <code>as</code> attribute is specified, the default value is <code>item()*</code>, which permits any value. No conversion then takes place.</p><p><a id="err-XTTE0505"><span class="error">[ERR XTTE0505] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> cannot be converted to the required type. </p><p>If the <code>visibility</code> attribute is present with the value <code>abstract</code> then (a) the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> defining the template body <span class="verb">must</span> be empty: that is, the only permitted children are <a href="#element-context-item"><code>xsl:context-item</code></a> and <a href="#element-param"><code>xsl:param</code></a>, and (b) there <span class="verb">must</span> be no <code>match</code> attribute.</p><p>If the parent of the <a href="#element-template"><code>xsl:template</code></a> element is an <a href="#element-override"><code>xsl:override</code></a> element, then either or both of the following conditions must be true:</p><ol class="enumar"><li><p>There is a <code>name</code> attribute, and the <a title="package" class="termref" href="#dt-package">package</a> identified by the containing <a href="#element-use-package"><code>xsl:use-package</code></a> element contains among its <a title="component" class="termref" href="#dt-component">components</a> a <a title="named template" class="termref" href="#dt-named-template">named template</a> whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> is the same as that of this named template, and which has a <a title="compatible" class="termref" href="#dt-compatible">compatible</a> signature.</p></li><li><p>Both the following conditions are true:</p><ol class="enumla"><li><p>There is a <code>match</code> attribute.</p></li><li><p>The value of the <code>mode</code> attribute, or in its absence the string <code>#default</code>, is a whitespace-separated sequence of tokens in which each token satisfies one of the following conditions:</p><ol class="enumlr"><li><p>The token is an EQName representing the name of a mode that is exposed, with visibility equal to <code>public</code>, by the package identified by the containing <a href="#element-use-package"><code>xsl:use-package</code></a> element.</p></li><li><p>The token is <code>#default</code>, and there is an ancestor-or-self element with a <code>default-mode</code> attribute whose value is an EQName representing the name of a mode that is exposed, with visibility equal to <code>public</code>, by the package identified by the containing <a href="#element-use-package"><code>xsl:use-package</code></a> element.</p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The token <code>#unnamed</code> is not allowed because the unnamed mode never has public visibility. The token <code>#all</code> is not allowed because its intended meaning would not be obvious. </p></div></li></ol></div><div class="div2"><h3><a id="defining-template-rules"></a>6.2 <a href="#defining-template-rules" style="text-decoration: none">Defining Template Rules</a></h3><p>This section describes <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>. <a title="named template" class="termref" href="#dt-named-template">Named templates</a> are described in <a href="#named-templates"><i>10.1 Named Templates</i></a>.</p><p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is specified using the <a href="#element-template"><code>xsl:template</code></a> element with a <code>match</code> attribute. The <code>match</code> attribute is a <a href="#doc-xslt40-patterns-Pattern40">Pattern</a> that identifies the items to which the rule applies. The result of applying the template rule is the result of evaluating the sequence constructor contained in the <a href="#element-template"><code>xsl:template</code></a> element, with the matching item used as the <a title="context item" class="termref" href="#dt-context-item">context item</a>.</p><div class="example"><div class="exampleHeader"><a id="d8e17464"></a><a id="d8e17566"></a>Example: A Simple Template Rule</div><p>For example, an XML document might contain:</p><div class="exampleInner"><pre>This is an &lt;emph&gt;important&lt;/emph&gt; point.</pre></div><p>The following <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> matches <code>emph</code> elements and produces a <code>fo:wrapper</code> element with a <code>font-weight</code> property of <code>bold</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">emph</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:wrapper</span><span class="z"></span><span class="atn">font-weight</span><span class="atneq">=</span><span class="z">"</span><span class="av">bold</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:fo</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Format</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:wrapper</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is evaluated when an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that matches the pattern specified in the <code>match</code> attribute. The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is described in the next section. If several template rules match a selected item, only one of them is evaluated, as described in <a href="#conflict"><i>6.5 Conflict Resolution for Template Rules</i></a>.</p></div><div class="div2"><h3><a id="applying-templates"></a>6.3 <a href="#applying-templates" style="text-decoration: none">Applying Template Rules</a></h3><p class="element-syntax"><a id="element-apply-templates"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:apply-templates<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;mode? = <var>token</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br>&lt;/xsl:apply-templates&gt;</code></p><p>The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction takes as input a sequence of items (typically nodes in a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>), and produces as output a sequence of items; these will often be nodes to be added to a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p><p>If the instruction has one or more <a href="#element-sort"><code>xsl:sort</code></a> children, then the input sequence is sorted as described in <a href="#sorting"><i>13 Sorting</i></a>. The result of this sort is referred to below as the <b>sorted sequence</b>; if there are no <a href="#element-sort"><code>xsl:sort</code></a> elements, then the sorted sequence is the same as the input sequence.</p><p>Each item in the input sequence is processed by finding a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> whose <a title="pattern" class="termref" href="#dt-pattern">pattern</a> matches that item. If there is more than one such template rule, the best among them is chosen, using rules described in <a href="#conflict"><i>6.5 Conflict Resolution for Template Rules</i></a>. If there is no template rule whose pattern matches the item, a built-in template rule is used (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>). The chosen template rule is evaluated. The rule that matches the <var>N</var>th item in the sorted sequence is evaluated with that item as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, with <var>N</var> as the <a title="context position" class="termref" href="#dt-context-position">context position</a>, and with the length of the sorted sequence as the <a title="context size" class="termref" href="#dt-context-size">context size</a>. Each template rule that is evaluated produces a sequence of items as its result. The resulting sequences (one for each item in the sorted sequence) are then concatenated, to form a single sequence. They are concatenated retaining the order of the items in the sorted sequence. The final concatenated sequence forms the result of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. </p><div class="example"><div class="exampleHeader"><a id="d8e17561"></a><a id="d8e17663"></a>Example: Applying Template Rules</div><p>Suppose the source document is as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">message</span><span class="scx">&gt;</span><span class="txt">Proceed </span><span class="es">&lt;</span><span class="en">emph</span><span class="scx">&gt;</span><span class="txt">at once</span><span class="ez">&lt;/</span><span class="cl">emph</span><span class="ec">&gt;</span><span class="txt"> to the exit!</span><span class="ez">&lt;/</span><span class="cl">message</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This can be processed using the two template rules shown below.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">message</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">child::</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">emph</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">b</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">child::</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">b</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>There is no template rule for the document node; the built-in template rule for this node will cause the <code>message</code> element to be processed. The template rule for the <code>message</code> element causes a <code>p</code> element to be written to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>; the contents of this <code>p</code> element are constructed as the result of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. This instruction selects the three child nodes of the <code>message</code> element (a text node containing the value <code>Proceed </code>, an <code>emph</code> element node, and a text node containing the value <code> to the exit!</code>). The two text nodes are processed using the built-in template rule for text nodes, which returns a copy of the text node. The <code>emph</code> element is processed using the explicit template rule that specifies <code>match="emph"</code>.</p><p>When the <code>emph</code> element is processed, this template rule constructs a <code>b</code> element. The contents of the <code>b</code> element are constructed by means of another <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, which in this case selects a single node (the text node containing the value <code>at once</code>). This is again processed using the built-in template rule for text nodes, which returns a copy of the text node.</p><p>The final result of the <code>match="message"</code> template rule thus consists of a <code>p</code> element node with three children: a text node containing the value <code>Proceed </code>, a <code>b</code> element that is the parent of a text node containing the value <code>at once</code>, and a text node containing the value <code> to the exit!</code>. This <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> might be serialized as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Proceed </span><span class="es">&lt;</span><span class="en">b</span><span class="scx">&gt;</span><span class="txt">at once</span><span class="ez">&lt;/</span><span class="cl">b</span><span class="ec">&gt;</span><span class="txt"> to the exit!</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>The default value of the <code>select</code> attribute is <code>child::node()</code>, which causes all the children of the context node to be processed.</p><p><a id="err-XTTE0510"><span class="error">[ERR XTTE0510] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>select</code> attribute is evaluated when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. </p><p>A <code>select</code> attribute can be used to process items selected by an expression instead of processing all children. The value of the <code>select</code> attribute is an <a title="expression" class="termref" href="#dt-expression">expression</a>. </p><div class="example"><div class="exampleHeader"><a id="d8e17661"></a><a id="d8e17763"></a>Example: Applying Templates to Selected Nodes</div><p>The following example processes all of the <code>given-name</code> children of the <code>author</code> elements that are children of <code>author-group</code>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">author-group</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:wrapper</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">author</span><span class="step">/</span><span class="qname">given-name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:wrapper</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e17673"></a><a id="d8e17775"></a>Example: Applying Templates to Nodes that are not Descendants</div><p>It is also possible to process elements that are not descendants of the context node. This example assumes that a <code>department</code> element has <code>group</code> children and <code>employee</code> descendants. It finds an employee’s department and then processes the <code>group</code> children of the <code>department</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">employee</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"> Employee </span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> belongs to group </span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">ancestor::</span><span class="qname">department</span><span class="step">/</span><span class="qname">group</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e17690"></a><a id="d8e17792"></a>Example: Matching Nodes by Schema-Defined Types</div><p>It is possible to write template rules that are matched according to the schema-defined type of an element or attribute. The following example applies different formatting to the children of an element depending on their type:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="step">/</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">3</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">name</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-match</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="step">/</span><span class="node-type">element</span><span class="parenthesis">(</span><span class="op">*</span><span class="op">,</span><span class="whitespace"></span><span class="qname">xs:decimal</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">|</span><span class="whitespace"></span><span class="qname">product</span><span class="step">/</span><span class="node-type">element</span><span class="parenthesis">(</span><span class="op">*</span><span class="op">,</span><span class="whitespace"></span><span class="qname">xs:double</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">format-number</span><span class="parenthesis">(</span><span class="function">xs:double</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">#,###0.00</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="step">/</span><span class="node-type">element</span><span class="parenthesis">(</span><span class="op">*</span><span class="op">,</span><span class="whitespace"></span><span class="qname">xs:date</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">format-date</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">[Mn] [D], [Y]</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="step">/</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">1.5</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The <a href="#element-next-match"><code>xsl:next-match</code></a> instruction is described in <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e17701"></a><a id="d8e17803"></a>Example: Re-ordering Elements in the Result Tree</div><p>Multiple <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements can be used within a single template to do simple reordering. The following example creates two HTML tables. The first table is filled with domestic sales while the second table is filled with foreign sales.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">sales</span><span class="step">/</span><span class="qname">domestic</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">sales</span><span class="step">/</span><span class="qname">foreign</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e17709"></a><a id="d8e17811"></a>Example: Processing Recursive Structures</div><p>It is possible for there to be two matching descendants where one is a descendant of the other. This case is not treated specially: both descendants will be processed as usual.</p><p> For example, given a source document</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">div</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">div</span><span class="scx">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">div</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">div</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>the rule</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">doc</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="step">//</span><span class="qname">div</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>will process both the outer <code>div</code> and inner <code>div</code> elements.</p><p>This means that if the template rule for the <code>div</code> element processes its own children, then these grandchildren will be processed more than once, which is probably not what is required. The solution is to process one level at a time in a recursive descent, by using <code>select="div"</code> in place of <code>select=".//div"</code></p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e17732"></a><a id="d8e17834"></a>Example: Applying Templates to Atomic Values</div><p>This example reads a non-XML text file and processes it line-by-line, applying different template rules based on the content of each line:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">main</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">unparsed-text-lines</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">input.txt</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="type">type</span><span class="parenthesis">(</span><span class="qname">xs:string</span><span class="parenthesis">)</span><span class="filter">[</span><span class="function">starts-with</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">==</span><span class="op">'</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h2</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">replace</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">==</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">h2</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="type">type</span><span class="parenthesis">(</span><span class="qname">xs:string</span><span class="parenthesis">)</span><span class="filter">[</span><span class="function">starts-with</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">::</span><span class="op">'</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="z"></span><span class="atn">class</span><span class="atneq">=</span><span class="z">"</span><span class="av">indent</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">replace</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">::</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="type">type</span><span class="parenthesis">(</span><span class="qname">xs:string</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="z"></span><span class="atn">class</span><span class="atneq">=</span><span class="z">"</span><span class="av">body</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e17737"></a><a id="d8e17839"></a>Example: Applying Templates to JSON Documents</div><p>This example reads a JSON data file and formats it as XHTML.</p><p>It takes the following JSON data as input:</p><div class="exampleInner"><pre>[ { "Title": "Computer Architecture", "Authors": ["Enid Blyton"] "Category": "Computers", "Price": 42.60 }, { "Title": "How to Win Elections", "Authors": ["Donald Trump", "Boris Johnson"], "Category": "Politics", "Price": 56.00 }, { "Title": "How to Explore Outer Space with Binoculars", "Authors: ["Bruce Betts", "Erica Colon"] "Category": "Science", "Price": 10.40 } ]</pre></div><p>The following template rules are used. The settings <code>expand-text="yes"</code> and <code>default-type-namespace="http://www.w3.org/2001/XMLSchema"</code> are assumed:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:item-type</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">book</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">record(Title, Authors, Category, *)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">xsl:initial-template</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">parse-json</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">input.json</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="function">array</span><span class="parenthesis">(</span><span class="qname">book</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h1</span><span class="scx">&gt;</span><span class="txt">Christmas Book Selection</span><span class="ez">&lt;/</span><span class="cl">h1</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">thead</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Title</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Authors</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Category</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Price</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">thead</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tbody</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tbody</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="type">type</span><span class="parenthesis">(</span><span class="qname">book</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">{?Title}</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">{?Authors?* =&gt; string-join(", ")}</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">{?Category}</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">${?Price}</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is most commonly used to process nodes that are descendants of the context node. Such use of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> cannot result in non-terminating processing loops. However, when <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used to process elements that are not descendants of the context node, the possibility arises of non-terminating loops. For example,</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">foo</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Implementations may be able to detect such loops in some cases, but the possibility exists that a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> may enter a non-terminating loop that an implementation is unable to detect. This may present a denial of service security risk.</p></div></div><div class="div2"><h3><a id="apply-templates-separator"></a>6.4 <a href="#apply-templates-separator" style="text-decoration: none">The </a><code>separator</code><a href="#apply-templates-separator" style="text-decoration: none"> attribute</a></h3><p>If the <code>separator</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is present, then its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted sequence other than the last.</p><p>For example, if the <code>ARTICLE</code> element has a number of element children named <code>AUTHOR</code>, the following code will produce a sorted, comma-separated list of authors:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">ARTICLE</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">article</span><span class="scx">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">Author(s): </span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">AUTHOR</span><span class="z">"</span><span class="z"></span><span class="atn">separator</span><span class="atneq">=</span><span class="z">"</span><span class="av">, </span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">LAST-NAME</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">FIRST-NAME</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:apply-templates</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">article</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">AUTHOR</span><span class="z">"</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="op">{</span><span class="qname">FIRST-NAME</span><span class="op">}</span><span class="txt"></span><span class="op">{</span><span class="qname">LAST-NAME</span><span class="op">}</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The node identity of any text nodes that are inserted is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Specifically, it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p><p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a> and <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>.)</p></div><div class="div2"><h3><a id="conflict"></a>6.5 <a href="#conflict" style="text-decoration: none">Conflict Resolution for Template Rules</a></h3><p>It is possible for a selected item to match more than one <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> with a given <a title="mode" class="termref" href="#dt-mode">mode</a><var>M</var>. When this happens, only one template rule is evaluated for the item. The template rule to be used is determined as follows:</p><ol class="enumar"><li><p>First, only the matching template rule or rules with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> are considered. Other matching template rules with lower precedence are eliminated from consideration.</p></li><li><p>Next, of the remaining matching rules, only those with the highest priority are considered. Other matching template rules with lower priority are eliminated from consideration.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-priority" title="priority"></a>The <b>priority</b> of a template rule is specified by the <code>priority</code> attribute on the <a href="#element-template"><code>xsl:template</code></a> declaration. If no priority is specified explicitly for a template rule, its <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> is used, as defined in <a href="#default-priority"><i>6.6 Default Priority for Template Rules</i></a>.<span class="definition">]</span></p><p><a id="err-XTSE0530"><span class="error">[ERR XTSE0530] </span></a>The value of the <code>priority</code> attribute <span class="verb">must</span> conform to the rules for the <code>xs:decimal</code> type defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>. Negative values are permitted. </p></li><li><p>Next, if each of the remaining matching rules has a match pattern in the form of a <a href="#doc-xslt40-patterns-TypePattern">TypePattern</a>, then this set of rules (call it <var>R</var>) is examined as follows: </p><ol class="enumla"><li><p>A <a href="#doc-xslt40-patterns-TypePattern">TypePattern</a> comprises an <code>ItemType</code> and a possibly empty set of predicates.</p></li><li><p>Any rule in <var>R</var> whose <code>ItemType</code> is a strict supertype of the <code>ItemType</code> of another rule in <var>R</var> is discarded. A type <var>T</var> is a strict supertype of another type <var>U</var> if <var>U</var> is a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-subtype">subtype</a><sup><small>XP40</small></sup> of <var>T</var> and <var>T</var> is not a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-subtype">subtype</a><sup><small>XP40</small></sup> of <var>U</var>. </p></li><li><p>If there is a rule <var>P</var> in <var>R</var> whose <code>ItemType</code> is the same type as the <code>ItemType</code> of another rule <var>Q</var> in <var>R</var>, and if <var>Q</var> has one or more predicates while <var>P</var> has none, then <var>P</var> is discarded. A type <var>T</var> is the same type as another type <var>U</var> if <var>T</var> is a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-subtype">subtype</a><sup><small>XP40</small></sup> of <var>U</var> and <var>U</var> is a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-subtype">subtype</a><sup><small>XP40</small></sup> of <var>T</var>. </p></li><li><p>If this process leaves a single rule, then that rule is chosen.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, this means that the pattern <code>type(xs:integer)</code> is chosen in preference to <code>type(xs:decimal)</code> which in turn is chosen in preference to <code>type(item())</code>; it also means that <code>type(xs:integer)[. gt 0]</code> is chosen in preference to <code>type(xs:integer)</code>.</p><p>Similarly, the pattern <code>record(longitude, latitude, altitude)</code> will be chosen in preference to the pattern <code>record(longitude, latitude, *)</code></p></div></li><li><p>If this leaves more than one matching template rule, then:</p><ol class="enumla"><li><p>If the <a title="mode" class="termref" href="#dt-mode">mode</a><var>M</var> has an <a href="#element-mode"><code>xsl:mode</code></a> declaration, and the attribute value <code>on-multiple-match="fail"</code> is specified in the mode declaration, a dynamic error is signaled. The error is treated as occurring in the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, and can be recovered by wrapping that instruction in an <a href="#element-try"><code>xsl:try</code></a> instruction.</p><p><a id="err-XTDE0540"><span class="error">[ERR XTDE0540] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the conflict resolution algorithm for template rules leaves more than one matching template rule when the declaration of the relevant <a title="mode" class="termref" href="#dt-mode">mode</a> has an <code>on-multiple-match</code> attribute with the value <code>fail</code>.</p></li><li><p>Otherwise, of the matching template rules that remain, the one that occurs last in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> is used.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This was a recoverable error in XSLT 2.0, meaning that it was implementation-defined whether the error was signaled, or whether the ambiguity was resolved by taking the last matching rule in declaration order. In XSLT 3.0 this situation is not an error unless the attribute value <code>on-multiple-match="fail"</code> is specified in the mode declaration. It is also possible to request warnings when this condition arises, by means of the attribute <code>warning-on-multiple-match="yes"</code>. </p></div></li></ol></div><div class="div2"><h3><a id="default-priority"></a>6.6 <a href="#default-priority" style="text-decoration: none">Default Priority for Template Rules</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-default-priority" title="default priority"></a>If no <code>priority</code> attribute is specified on an <a href="#element-template"><code>xsl:template</code></a> element, a <b>default priority</b> is computed, based on the syntax of the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> supplied in the <code>match</code> attribute.<span class="definition">]</span> The rules are as follows. </p><ol class="enumar"><li><p>If the top-level pattern is a <a href="#doc-xslt40-patterns-ParenthesizedExprP">ParenthesizedExprP</a> then the outer parentheses are effectively stripped; these rules are applied recursively to the <a href="#doc-xslt40-patterns-UnionExprP">UnionExprP</a> contained in the <a href="#doc-xslt40-patterns-ParenthesizedExprP">ParenthesizedExprP</a>.</p></li><li><p>If the top-level pattern is a <a href="#doc-xslt40-patterns-UnionExprP">UnionExprP</a> consisting of multiple alternatives separated by <code>|</code> or <code>union</code>, then the template rule is treated equivalently to a set of template rules, one for each alternative. For example, a rule with <code>match="a|b"</code> is treated as if there were one rule with <code>match="a"</code> and another with <code>match="b"</code>. These template rules are adjacent to each other in declaration order, and the declaration order within this set of template rules (which affects the result of <a href="#element-next-match"><code>xsl:next-match</code></a> if the alternatives have the same default priority) is the order of alternatives in the <a href="#doc-xslt40-patterns-UnionExprP">UnionExprP</a>.</p><p>Similarly, if the top-level pattern takes the form of a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#UnionNodeTest">UnionNodeTest</a><sup><small>XP40</small></sup> preceded by an axis name or abbreviation, it is treated equivalently to a set of template rules, one for each alternative. For example, a rule with <code>match="@(a|b)"</code> is treated as if there were one rule with <code>match="@a"</code> and another with <code>match="@b"</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The splitting of a template rule into multiple rules occurs only if there is no explicit <code>priority</code> attribute.</p></div></li><li><p>If the top-level pattern is an <a href="#doc-xslt40-patterns-IntersectExceptExprP">IntersectExceptExprP</a> containing two or more <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> operands separated by <code>intersect</code> or <code>except</code> operators, then the priority of the pattern is that of the first <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a>. </p></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-PredicatePattern">PredicatePattern</a> then its priority is 1 (one), unless the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PredicateList">PredicateList</a><sup><small>XP40</small></sup> is empty, in which case the priority is −1 (minus one).</p></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> taking the form <code>/</code>, then the priority is −0.5 (minus 0.5).</p></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> taking the form of an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> optionally preceded by a <a href="#doc-xslt40-patterns-ForwardAxisP">ForwardAxisP</a> or has the form <code>processing-instruction(</code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP40</small></sup><code>)</code> or <code>processing-instruction(</code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup><code>)</code> optionally preceded by a <a href="#doc-xslt40-patterns-ForwardAxisP">ForwardAxisP</a>, then the priority is 0 (zero).</p></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> taking the form of an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP40</small></sup> or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AttributeTest">AttributeTest</a><sup><small>XP40</small></sup>, optionally preceded by a <a href="#doc-xslt40-patterns-ForwardAxisP">ForwardAxisP</a>, then the priority is as shown in the table below. In this table, the symbols <var>E</var>, <var>A</var>, and <var>T</var> represent an arbitrary element name, attribute name, and type name respectively, while the symbol <code>*</code> represents itself. The presence or absence of the symbol <code>?</code> following a type name does not affect the priority.</p><table class="data"><caption>Default Priority of Patterns</caption><thead><tr><th style="text-align:left; vertical-align:top">Format</th><th style="text-align:left; vertical-align:top">Priority</th><th style="text-align:left; vertical-align:top">Notes</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top"><code>element()</code></td><td style="text-align:left; vertical-align:top">−0.5</td><td style="text-align:left; vertical-align:top">(equivalent to <code>*</code>)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>element(*)</code></td><td style="text-align:left; vertical-align:top">−0.5</td><td style="text-align:left; vertical-align:top">(equivalent to <code>*</code>)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>attribute()</code></td><td style="text-align:left; vertical-align:top">−0.5</td><td style="text-align:left; vertical-align:top">(equivalent to <code>@*</code>)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>attribute(*)</code></td><td style="text-align:left; vertical-align:top">−0.5</td><td style="text-align:left; vertical-align:top">(equivalent to <code>@*</code>)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>element(<var>E</var>)</code></td><td style="text-align:left; vertical-align:top">0</td><td style="text-align:left; vertical-align:top">(equivalent to E)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>element(*,<var>T</var>)</code></td><td style="text-align:left; vertical-align:top">0</td><td style="text-align:left; vertical-align:top">(matches by type only)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>attribute(<var>A</var>)</code></td><td style="text-align:left; vertical-align:top">0</td><td style="text-align:left; vertical-align:top">(equivalent to <code>@A</code>)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>attribute(*,<var>T</var>)</code></td><td style="text-align:left; vertical-align:top">0</td><td style="text-align:left; vertical-align:top">(matches by type only)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>element(<var>E</var>,<var>T</var>)</code></td><td style="text-align:left; vertical-align:top">0.25</td><td style="text-align:left; vertical-align:top">(matches by name and type)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>schema-element(<var>E</var>)</code></td><td style="text-align:left; vertical-align:top">0.25</td><td style="text-align:left; vertical-align:top">(matches by substitution group and type)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>attribute(<var>A</var>,<var>T</var>)</code></td><td style="text-align:left; vertical-align:top">0.25</td><td style="text-align:left; vertical-align:top">(matches by name and type)</td></tr><tr><td style="text-align:left; vertical-align:top"><code>schema-attribute(<var>A</var>)</code></td><td style="text-align:left; vertical-align:top">0.25</td><td style="text-align:left; vertical-align:top">(matches by name and type)</td></tr></tbody></table></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> taking the form of a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-DocumentTest">DocumentTest</a><sup><small>XP40</small></sup>, then if it includes no <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP40</small></sup> or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP40</small></sup> the priority is −0.5. If it does include an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP40</small></sup> or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP40</small></sup>, then the priority is the same as the priority of that <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP40</small></sup> or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP40</small></sup>, computed according to the table above.</p></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> taking the form of an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup><code>:*</code><span>, <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-BracedURILiteral">BracedURILiteral</a><sup><small>XP40</small></sup>*,</span> or <code>*:</code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, optionally preceded by a <a href="#doc-xslt40-patterns-ForwardAxisP">ForwardAxisP</a>, then the priority is −0.25. <span>[XSLT 3.0 Erratum E37, bug 30375].</span></p></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-PathExprP">PathExprP</a> taking the form of any other <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeTest">NodeTest</a><sup><small>XP40</small></sup>, optionally preceded by a <a href="#doc-xslt40-patterns-ForwardAxisP">ForwardAxisP</a>, then the priority is −0.5.</p></li><li><p>If the pattern is a <a href="#doc-xslt40-patterns-TypePattern">TypePattern</a>, then the priority is 0 (zero).</p></li><li><p>In all other cases, the priority is +0.5.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>In many cases this means that highly selective patterns have higher priority than less selective patterns. The most common kind of pattern (a pattern that tests for a node of a particular kind, with a particular <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> or a particular type) has priority 0. The next less specific kind of pattern (a pattern that tests for a node of a particular kind and an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with a particular namespace URI) has priority −0.25. Patterns less specific than this (patterns that just test for nodes of a given kind) have priority −0.5. Patterns that specify both the name and the required type have a priority of +0.25, putting them above patterns that only specify the name <em>or</em> the type. Patterns more specific than this, for example patterns that include predicates or that specify the ancestry of the required node, have priority 0.5.</p><p>However, it is not invariably true that a more selective pattern has higher priority than a less selective pattern. For example, the priority of the pattern <code>node()[self::*]</code> is higher than that of the pattern <code>salary</code>. Similarly, the patterns <code>attribute(*, xs:decimal)</code> and <code>attribute(*, xs:short)</code> have the same priority, despite the fact that the latter pattern matches a subset of the nodes matched by the former. Therefore, to achieve clarity in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> it is good practice to allocate explicit priorities.</p></div></div><div class="div2"><h3><a id="modes"></a>6.7 <a href="#modes" style="text-decoration: none">Modes</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-mode" title="mode"></a> A <b>mode</b> is a set of template rules; when the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects a set of items for processing, it identifies the rules to be used for processing those items by nominating a mode, explicitly or implicitly.<span class="definition">]</span> Modes allow a node in a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> (for example) to be processed multiple times, each time producing a different result. They also allow different sets of <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> to be active when processing different trees, for example when processing documents loaded using the <a href="#func-document"><code>document</code></a> function (see <a href="#func-document"><i>20.1 fn:document</i></a>). </p><p>Modes are identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>; in addition to any named modes, there is always one unnamed mode available. Whether a mode is named or unnamed, its properties <span class="verb">may</span> be defined in an <a href="#element-mode"><code>xsl:mode</code></a> declaration. If a mode name is used (for example in an <a href="#element-template"><code>xsl:template</code></a> declaration or an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction) and no declaration of that mode appears in the stylesheet, the mode is implicitly declared with default properties.</p><div class="div3"><h4><a id="declaring-modes"></a>6.7.1 <a href="#declaring-modes" style="text-decoration: none">Declaring Modes</a></h4><p class="element-syntax"><a id="element-mode"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:mode<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var><br>&nbsp;&nbsp;on-no-match? = "deep-copy" | "shallow-copy" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail"<br>&nbsp;&nbsp;on-multiple-match? = "use-last" | "fail"<br>&nbsp;&nbsp;warning-on-no-match? = <var>boolean</var><br>&nbsp;&nbsp;warning-on-multiple-match? = <var>boolean</var><br>&nbsp;&nbsp;typed? = <var>boolean</var> | "strict" | "lax" | "unspecified"<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a>*) --&gt;<br>&lt;/xsl:mode&gt;</code></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-unnamed-mode" title="unnamed mode"></a>The <b>unnamed mode</b> is the default mode used when no <code>mode</code> attribute is specified on an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction or <a href="#element-template"><code>xsl:template</code></a> declaration, unless a different default mode has been specified using the <code>[xsl:]default-mode</code> attribute of a containing element.<span class="definition">]</span></p><p>Every <a title="mode" class="termref" href="#dt-mode">mode</a> other than the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> is identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p><p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> may contain multiple <a href="#element-mode"><code>xsl:mode</code></a> declarations and may include or import <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> that also contain <a href="#element-mode"><code>xsl:mode</code></a> declarations. The name of an <a href="#element-mode"><code>xsl:mode</code></a> declaration is the value of its <code>name</code> attribute, if any.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-mode-definition" title="mode definition"></a>All the <a href="#element-mode"><code>xsl:mode</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>mode definition</b>; those that have no name are grouped into a single unnamed mode definition.<span class="definition">]</span></p><p>The <code>declared-modes</code> attribute of the <a href="#element-package"><code>xsl:package</code></a> element determines whether implicit mode declarations are allowed, as described in <a href="#requiring-explicit-modes"><i>3.5.4.1 Requiring Explicit Mode Declarations</i></a>. If the package allows implicit mode declarations, then if a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> does not contain a declaration of the unnamed mode, a declaration is implied equivalent to an <a href="#element-mode"><code>xsl:mode</code></a> element with no attributes. Similarly, if there is a mode that is named in an <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element, or in the <code>[xsl:]default-mode</code> attribute of a containing element, and the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> does not contain a declaration of that mode, then a declaration is implied comprising an <a href="#element-mode"><code>xsl:mode</code></a> element with a <code>name</code> attribute equal to that mode name, plus the attribute <code>visibility="private"</code>. </p><p>The attributes of the <a href="#element-mode"><code>xsl:mode</code></a> declaration establish values for a number of properties of a mode. The allowed values and meanings of the attributes are given in the following table.</p><table class="data"><caption>Attributes of the <code>xsl:mode</code> Element</caption><thead><tr><th style="text-align:left; vertical-align:top">Attribute</th><th style="text-align:left; vertical-align:top">Values</th><th style="text-align:left; vertical-align:top">Meaning</th></tr></thead><tbody><tr><td style="vertical-align:top; text-align:left">name</td><td style="vertical-align:top; text-align:left">An <a title="EQName" class="termref" href="#dt-eqname">EQName</a></td><td style="vertical-align:top; text-align:left">Specifies the name of the mode. If omitted, this <a href="#element-mode"><code>xsl:mode</code></a> declaration provides properties of the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a></td></tr><tr><td style="vertical-align:top; text-align:left">as</td><td style="vertical-align:top; text-align:left">A <code>SequenceType</code></td><td style="vertical-align:top; text-align:left">Declares the type of value returned by all template rules in this mode. If any template rules in this mode declare their return type using an <code>as</code> attribute on <a href="#element-template"><code>xsl:template</code></a>, the values must be consistent.</td></tr><tr><td style="vertical-align:top; text-align:left">streamable</td><td style="vertical-align:top; text-align:left"><code>yes</code> or <code>no</code> (default <code>no</code>)</td><td style="vertical-align:top; text-align:left">Determines whether template rules in this mode are to be capable of being processed using <a title="streaming" class="termref" href="#dt-streaming">streaming</a>. If the value <code>yes</code> is specified, then the body of any <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that uses this mode <span class="verb">must</span> conform to the rules for streamable templates given in <a href="#streamable-templates"><i>6.7.6 Streamable Templates</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left">use-accumulators</td><td style="vertical-align:top; text-align:left">List of accumulator names, or <code>#all</code> (default is an empty list)</td><td style="vertical-align:top; text-align:left">Relevant only when this mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> of the transformation, determines which accumulators are applicable to documents containing nodes in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. For further details see <a href="#applicability-of-accumulators"><i>18.2.2 Applicability of Accumulators</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left">on-no-match</td><td style="vertical-align:top; text-align:left">One of <code>deep-copy</code>, <code>shallow-copy</code>, <code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code> or <code>fail</code> (default <code>text-only-copy</code>)</td><td style="vertical-align:top; text-align:left">Determines selection of the built-in <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> that are used to process an item when an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that does not match any user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For details, see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left">on-multiple-match</td><td style="vertical-align:top; text-align:left">One of <code>fail</code> or <code>use-last</code> (default <code>use-last</code>)</td><td style="vertical-align:top; text-align:left">Defines the action to be taken when <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used in this mode and more than one user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is available to process an item, each having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a>. The value <code>fail</code> indicates that it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if more than one template rule matches an item. The value <code>use-last</code> indicates that the situation is not to be treated as an error (the last template in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> is the one that is used). </td></tr><tr><td style="vertical-align:top; text-align:left">warning-on-no-match</td><td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a></td><td style="vertical-align:top; text-align:left">Requests the <a title="processor" class="termref" href="#dt-processor">processor</a> to output (or not to output) a warning message in the case where an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that matches no user-written template rule. The form and destination of such warnings is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The processor <span class="verb">may</span> ignore this attribute, for example if the environment provides no suitable means of communicating with the user. </td></tr><tr><td style="vertical-align:top; text-align:left">warning-on-multiple-match</td><td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a></td><td style="vertical-align:top; text-align:left">Requests the <a title="processor" class="termref" href="#dt-processor">processor</a> to output a warning message in the case where an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that matches multiple template rules having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a>. The form and destination of such warnings is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The processor <span class="verb">may</span> ignore this attribute, for example if the environment provides no suitable means of communicating with the user.</td></tr><tr><td style="vertical-align:top; text-align:left">typed</td><td style="vertical-align:top; text-align:left">One of <code>yes</code>, <code>no</code>, <code>strict</code>, <code>lax</code>, or <code>unspecified</code>. The default is <code>unspecified</code>.</td><td style="vertical-align:top; text-align:left">See <a href="#xsl-mode-typed"><i>6.7.3 Declaring the Type of Nodes Processed by a Mode</i></a>.</td></tr><tr><td style="vertical-align:top; text-align:left">visibility</td><td style="vertical-align:top; text-align:left">One of <code>public</code>, <code>private</code>, or <code>final</code>. The default is <code>private</code>.</td><td style="vertical-align:top; text-align:left">See <a href="#visibility"><i>3.5.3.1 Visibility of Components</i></a>. If the mode is unnamed, that is, if the <code>name</code> attribute is absent, then the <code>visibility</code> attribute if present <span class="verb">must</span> have the value <code>private</code>. <table class="ednote" caption="Editorial note"><tbody><tr><td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td><td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td></tr><tr style="text-align: left; vertical-align: top;"><td colspan="2">See issue 270.</td></tr></tbody></table></td></tr></tbody></table><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streamable-mode" title="streamable mode"></a>A <b>streamable mode</b> is a <a title="mode" class="termref" href="#dt-mode">mode</a> that is declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration with the attribute <code>streamable="yes"</code>.<span class="definition">]</span></p><p><span style="display: none;" class="delete_version">For any named <a title="mode" class="termref" href="#dt-mode">mode</a>, the effective value of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has a matching name in its <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</span><span style="display: none;" class="add_version">For any named <a title="mode" class="termref" href="#dt-mode">mode</a>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has a matching name in its <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</span><span class="modify_version">For any named <a title="mode" class="termref" href="#dt-mode">mode</a>, the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has a matching name in its <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</span></p><p><span style="display: none;" class="delete_version">For the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, the effective value of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has no <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</span><span style="display: none;" class="add_version">For the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has no <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</span><span class="modify_version">For the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has no <code>name</code> attribute, and that specifies an explicit value for the required attribute. If there is no such declaration, the default value of the attribute is used. If there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</span></p><p><a id="err-XTSE0545"><span class="error">[ERR XTSE0545] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if for any named or unnamed <a title="mode" class="termref" href="#dt-mode">mode</a>, a package explicitly specifies two conflicting values for the same attribute in different <a href="#element-mode"><code>xsl:mode</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same attribute with higher import precedence. The attributes in question are the attributes other than <code>name</code> on the <a href="#element-mode"><code>xsl:mode</code></a> element. </p></div><div class="div3"><h4><a id="using-modes"></a>6.7.2 <a href="#using-modes" style="text-decoration: none">Using Modes</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-applicable" title="applicable"></a>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is <b>applicable</b> to one or more modes. The modes to which it is applicable are defined by the <code>mode</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element. If the attribute is omitted, then the template rule is applicable to the default mode specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing element that has such an attribute, which in turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. If the <code>mode</code> attribute is present, then its value <span class="verb">must</span> be a non-empty whitespace-separated list of tokens, each of which defines a mode to which the template rule is applicable.<span class="definition">]</span></p><p>Each token in the <code>mode</code> attribute <span class="verb">must</span> be one of the following:</p><ul><li><p>An <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> to define the name of the mode</p></li><li><p>The token <code>#default</code>, to indicate that the template rule is applicable to the default mode that would apply if the <code>mode</code> attribute were absent </p></li><li><p>The token <code>#unnamed</code>, to indicate that the template rule is applicable to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a></p></li><li><p>The token <code>#all</code>, to indicate that the template rule is applicable to all modes <span>other than <a title="enclosing mode" class="termref" href="#dt-enclosing-mode">enclosing modes</a></span> (specifically, to the unnamed mode and to every mode that is named explicitly or implicitly in an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction anywhere in the stylesheet).</p><p>More specifically, when a template rule specifies <code>mode="#all"</code> this makes the template rule <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to:</p><ul><li><p>The unnamed mode.</p></li><li><p>Every mode, other than an <a title="enclosing mode" class="termref" href="#dt-enclosing-mode">enclosing mode</a>, that is declared using an <a href="#element-mode"><code>xsl:mode</code></a> declaration within the containing <a title="package" class="termref" href="#dt-package">package</a>.</p></li><li><p>Every mode that is implicitly declared within the containing <a title="package" class="termref" href="#dt-package">package</a> by virtue of being referenced in an <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element.</p></li></ul><p>The value <code>mode="#all"</code> cannot be used on a template rule declared within an <a href="#element-override"><code>xsl:override</code></a><span>or <a href="#element-mode"><code>xsl:mode</code></a></span> element.</p></li></ul><p></p><p><a id="err-XTSE0550"><span class="error">[ERR XTSE0550] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of modes is empty, if the same token is included more than once in the list, if the list contains an invalid token, or if the token <code>#all</code> appears together with any other value. </p><p><a id="err-XTSE3440"><span class="error">[ERR XTSE3440] </span></a>In the case of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> (that is, an <a href="#element-template"><code>xsl:template</code></a> element having a <code>match</code> attribute) appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of modes in the <code>mode</code> attribute contains <code>#all</code> or <code>#unnamed</code>, or if it contains <code>#default</code> and the default mode is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, or if the <code>mode</code> attribute is omitted when the default mode is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. </p><p>The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element also has an optional <code>mode</code> attribute. The value of this attribute <span class="verb">must</span> be one of the following:</p><ul><li><p>an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> to define the name of a mode</p></li><li><p>the token <code>#default</code>, to indicate that the default mode for the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> is to be used</p></li><li><p>the token <code>#unnamed</code>, to indicate that the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> is to be used</p></li><li><p>the token <code>#current</code>, to indicate that the <a title="current mode" class="termref" href="#dt-current-mode">current mode</a> is to be used</p></li></ul><p>If the attribute is omitted, the default mode for the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> is used.</p><p>When searching for a template rule to process each item selected by the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, only those template rules that are applicable to the selected mode are considered.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-mode" title="current mode"></a>At any point in the processing of a stylesheet, there is a <b>current mode</b>. When the transformation is initiated, the current mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is evaluated, the current mode becomes the mode selected by this instruction.<span class="definition">]</span> When a <a title="non-contextual function call" class="termref" href="#dt-non-contextual-function-call">non-contextual function call</a> is made, the current mode is set to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. While evaluating global variables and parameters, and the sequence constructor contained in <a href="#element-key"><code>xsl:key</code></a> or <a href="#element-sort"><code>xsl:sort</code></a>, the current mode is set to the unnamed mode. No other instruction changes the current mode. The current mode while evaluating an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is the same as the current mode of the caller. On completion of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, or on return from a stylesheet function call, the current mode reverts to its previous value. The current mode is used when an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction uses the syntax <code>mode="#current"</code>; it is also used by the <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a> instructions (see <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>).</p></div><div class="div3"><h4><a id="xsl-mode-typed"></a>6.7.3 <a href="#xsl-mode-typed" style="text-decoration: none">Declaring the Type of Nodes Processed by a Mode</a></h4><p>Typically the template rules in a particular <a title="mode" class="termref" href="#dt-mode">mode</a> will be designed to process a specific kind of input document. The <code>typed</code> attribute of <a href="#element-mode"><code>xsl:mode</code></a> gives the stylesheet author the opportunity to provide information about this document to the processor. This information may enable the processor to improve diagnostics or to optimize performance.</p><p>The <code>typed</code> attribute of <a href="#element-mode"><code>xsl:mode</code></a> informs the processor whether the nodes to be processed by template rules in this mode are to be typed or untyped. </p><ul><li><p>If the value <code>yes</code> is specified (synonyms <code>true</code> or <code>1</code>), then all nodes processed in this mode must be typed. A dynamic error occurs if <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> in this mode selects an element or attribute node whose <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> is <code>xs:untyped</code> or <code>xs:untypedAtomic</code>. </p></li><li><p>If the value <code>no</code> is specified (synonyms <code>false</code> or <code>0</code>), then all nodes processed in this mode must be untyped. A dynamic error occurs if <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> in this mode selects an element or attribute whose <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> is anything other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code>. </p></li><li><p>The value <code>strict</code> is equivalent to <code>yes</code>, with the additional provision that in the match pattern of any template rule that is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to this mode, any <code>NameTest</code> used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of a <code>RelativePathExprP</code> is interpreted as follows:</p><ul><li><p>If the <code>NameTest</code> is an <code>EQName</code><var>E</var>, and the principal node kind of the axis of this step is <code>Element</code>, then:</p><ul><li><p>It is a static error if the in-scope schema declarations do not include a global element declaration for element name <var>E</var></p></li><li><p>When matching templates in this mode, the element name <var>E</var> appearing in this step is interpreted as <code>schema-element(E)</code>. (Informally, this means that it will only match an element if it has been validated against this element declaration). </p></li></ul></li><li><p>Otherwise (the <code>NameTest</code> is a wildcard or the principal node kind is <code>Attribute</code> or <code>Namespace</code>), the template matching proceeds as if the <code>typed</code> attribute were absent. </p></li></ul></li><li><p>The value <code>lax</code> is equivalent to <code>yes</code>, with the additional provision that in the match pattern of any template rule that is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to this mode, any <code>NameTest</code> used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of a <code>RelativePathExprP</code> is interpreted as follows:</p><ul><li><p>If the <code>NameTest</code> is an <code>EQName</code><var>E</var>, and the principal node kind of the axis of this step is <code>Element</code>, and the in-scope schema declarations include a global element declaration for element name <var>E</var>, then:</p><ul><li><p>When matching templates in this mode, the element name <var>E</var> appearing in this step is interpreted as <code>schema-element(E)</code>. (Informally, this means that it will only match an element if it has been validated against this element declaration). </p></li></ul></li><li><p>Otherwise (the <code>NameTest</code> is a wildcard, or the principal node kind is <code>Attribute</code> or <code>Namespace</code>, or there is no element declaration for <var>E</var>), the template matching proceeds as if the <code>typed</code> attribute were absent. </p></li></ul></li></ul><p><a id="err-XTTE3100"><span class="error">[ERR XTTE3100] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in a particular <code>mode</code> selects an element or attribute whose type is <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the <code>typed</code> attribute of that mode specifies the value <code>yes</code>, <code>strict</code>, or <code>lax</code>. </p><p><a id="err-XTSE3105"><span class="error">[ERR XTSE3105] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a template rule applicable to a mode that is defined with <code>typed="strict"</code> uses a match pattern that contains a <code>RelativePathExprP</code> whose first <code>StepExprP</code> is an <code>AxisStepP</code> whose <code>ForwardStepP</code> uses an axis whose principal node kind is <code>Element</code> and whose <code>NodeTest</code> is an <code>EQName</code> that does not correspond to the name of any global element declaration in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>. </p><p><a id="err-XTTE3110"><span class="error">[ERR XTTE3110] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in a particular <code>mode</code> selects an element or attribute whose type is anything other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the <code>typed</code> attribute of that mode specifies the value <code>no</code>. </p></div><div class="div3"><h4><a id="mode-result-type"></a>6.7.4 <a href="#mode-result-type" style="text-decoration: none">Declaring the result type of a mode</a></h4><p>Traditionally, template rules have most commonly been used to construct XDM nodes, and the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction has been used to add nodes to a result tree. However, it is also possible to use template rules to produce other kinds of value, for example strings, booleans, or maps. For the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction to be useful, it will generally be the case that all template rules in a mode produce the same kind of value: for example, if one rule delivers a boolean, then the other rules will also deliver a boolean.</p><p>XSLT 4.0 therefore allows the result type of the template rules in a mode to be declared using the <code>as</code> attribute on the <a href="#element-mode"><code>xsl:mode</code></a> declaration. If this is absent, it defaults to <code>item()*</code>. The presence of an <code>as</code> attribute on a mode provides useful documentation and consistency checking, and enables the XSLT processor to infer a static type for an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, which can be useful for optimization.</p><p>If a template rule <var>R</var> is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to a mode <var>M</var>, and <var>M</var> is declared with an <code>as</code> attribute whose value is the <code>SequenceType</code><var>T</var>, then:</p><ul><li><p>If <code>R</code> has an <code>as</code> attribute, the <code>SequenceType</code><var>S</var> declared by <var>R</var> must be a subtype of <var>T</var>, according to the relationship <code>subtype(S, T)</code> defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-seqtype-subtype">Section 3.7.1 Subtypes of Sequence Types</a><sup><small>XP40</small></sup>.</p></li><li><p>If <code>R</code> has no <code>as</code> attribute, then it is treated as if it had an <code>as</code> attribute set to <var>T</var>. If <code>R</code> is applicable to more than one mode, then the implicit <code>SequenceType</code> inferred for any one of these modes must be consistent with the <code>SequenceType</code> declared on all the other modes to which <code>R</code> is applicable: for example, if <var>is</var> applicable to modes <var>M<sub>1</sub></var> and <var>M<sub>2</sub></var>, and if <var>M<sub>1</sub></var> declares a result type of <code>element(A)</code>, then a static error occurs if <code>element(A)</code> is not a subtype of the (explicit or implicit) result type for mode <var>M<sub>2</sub></var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice this means that if a template rule is applicable to more than one mode (including the case <code>mode="#all"</code>), then either (a) all those modes should have the same declared result type, or (b) the template rule should declare an explicit result type that is compatible with each one of the relevant modes.</p></div><p>TODO: define the error code.</p></li></ul></div><div class="div3"><h4><a id="enclosing-modes"></a>6.7.5 <a href="#enclosing-modes" style="text-decoration: none">Enclosing Modes</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-enclosing-mode" title="enclosing mode"></a>A mode declared by an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has one or more contained <a href="#element-template"><code>xsl:template</code></a> declarations is referred to as an <b>enclosing mode</b>.<span class="definition">]</span></p><p>An enclosing mode ensures that all the template rules for a mode are together in one place, which makes it easier for someone reading the stylesheet to establish what is going to happen when an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in that mode is evaluated.</p><p>An enclosing mode <span class="verb">must</span> satisfy the following rules:</p><ol class="enumar"><li><p>The mode must have a name.</p></li><li><p>Every contained <a href="#element-template"><code>xsl:template</code></a> element must have a <code>match</code> attribute and no <code>name</code> attribute.</p></li><li><p>Every contained <a href="#element-template"><code>xsl:template</code></a> element must have no <code>mode</code> attribute: the template is implicitly <a title="applicable" class="termref" href="#dt-applicable">applicable</a> only to the containing mode.</p></li><li><p>An <a href="#element-mode"><code>xsl:mode</code></a> declaration with one or more <a href="#element-template"><code>xsl:template</code></a> children effectively has a <code>default-mode</code> attribute whose value is the mode's name; it must not have a <code>default-mode</code> attribute with any other value.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions within the template rules of the enclosing mode default to using the enclosing mode.</p></div></li><li><p>No <a href="#element-template"><code>xsl:template</code></a> that is in the same <span><a title="package" class="termref" href="#dt-package">package</a></span> as the containing mode, but not declared within the containing mode, may be <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to the containing mode.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Template rules in an enclosing mode may, however, be overridden within an <a href="#element-override"><code>xsl:override</code></a> element in a using <a title="package" class="termref" href="#dt-package">package</a>.</p></div></li><li><p>There must be no other <a href="#element-mode"><code>xsl:mode</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a> having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></li></ol><p>These rules give rise to the following error conditions:</p><p><a id="err-XTSE4005"><span class="error">[ERR XTSE4005] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration with one or more <a href="#element-template"><code>xsl:template</code></a> children has no <code>name</code> attribute.</p><p><a id="err-XTSE4010"><span class="error">[ERR XTSE4010] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration has a child <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute, with a <code>mode</code> attribute, or with no <code>match</code> attribute.</p><p><a id="err-XTSE4015"><span class="error">[ERR XTSE4015] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code> attribute whose value differs from its <code>name</code> attribute, or if any of those child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code> attribute that differs from the <code>name</code> attribute of the <a href="#element-mode"><code>xsl:mode</code></a> declaration.</p><p><a id="err-XTSE4020"><span class="error">[ERR XTSE4020] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains both (a) an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) an <a href="#element-template"><code>xsl:template</code></a> declaration that is not one of those children but that references the <a href="#element-mode"><code>xsl:mode</code></a> declaration in its <code>name</code> attribute.</p><p><a id="err-XTSE4025"><span class="error">[ERR XTSE4025] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains (a) an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) a second <a href="#element-mode"><code>xsl:mode</code></a> declaration having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p><div class="example"><div class="exampleHeader"><a id="d8e19675"></a><a id="d8e19781"></a>Example: An Enclosing Mode</div><p>The following mode might be used for formatting of numbers appearing in text:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">numbers-in-text</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">final</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="type">type</span><span class="parenthesis">(</span><span class="qname">xs:integer</span><span class="parenthesis">)</span><span class="filter">[</span><span class="context">.</span><span class="whitespace"></span><span class="op">gt</span><span class="whitespace"></span><span class="numeric">0</span><span class="whitespace"></span><span class="op">and</span><span class="whitespace"></span><span class="context">.</span><span class="whitespace"></span><span class="op">lt</span><span class="whitespace"></span><span class="numeric">21</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">w</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="type">type</span><span class="parenthesis">(</span><span class="qname">xs:integer</span><span class="parenthesis">)</span><span class="filter">[</span><span class="context">.</span><span class="whitespace"></span><span class="op">lt</span><span class="whitespace"></span><span class="numeric">10000</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="type">type</span><span class="parenthesis">(</span><span class="qname">xs:integer</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="z"></span><span class="atn">grouping-separator</span><span class="atneq">=</span><span class="z">"</span><span class="av">,</span><span class="z">"</span><span class="z"></span><span class="atn">grouping-size</span><span class="atneq">=</span><span class="z">"</span><span class="av">3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:mode</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="streamable-templates"></a>6.7.6 <a href="#streamable-templates" style="text-decoration: none">Streamable Templates</a></h4><p>A template rule that is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to a mode <var>M</var> is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> if and only if all the following conditions are satisfied:</p><ol class="enumar"><li><p>Mode <var>M</var> is declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration that specifies <code>streamable="yes"</code>.</p></li><li><p>The <a title="pattern" class="termref" href="#dt-pattern">pattern</a> defined in the <code>match</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element is a <a title="motionless" class="termref" href="#dt-motionless">motionless</a> pattern as defined in <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a>.</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-template"><code>xsl:template</code></a> element is either <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture</a> of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-template"><code>xsl:template</code></a> element, with respect to the <a title="U-type" class="termref" href="#dt-utype">U-type</a> that corresponds to the declared return type of the template (defaulting to <code>item()*</code>), is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that either (a) the sequence constructor is grounded as written (that is, it does not return streamed nodes), or (b) it effectively becomes grounded because the declared result type of the template is atomic, leading to implicit atomization of the result.</p></div></li><li><p>Every <a title="expression" class="termref" href="#dt-expression">expression</a> and contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> in a contained <a href="#element-param"><code>xsl:param</code></a> element (the construct that provides the default value of the parameter) is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol><p>Specifying <code>streamable="yes"</code> on an <a href="#element-mode"><code>xsl:mode</code></a> declaration declares an intent that every template rule <span>to which that mode is <a title="applicable" class="termref" href="#dt-applicable">applicable</a></span> (explicitly or implicitly, including by specifying <code>#all</code>), should be streamable, either because it is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, or because it takes advantage of streamability extensions offered by a particular processor. The consequences of declaring the mode to be streamable when there is such a template rule that is not guaranteed streamable depend on the conformance level of the processor, and are explained in <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>.</p><p>Processing of a document using streamable templates may be initiated using code such as the following, where <code>S</code> is a mode declared with <code>streamable="yes"</code>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">bigdoc.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">S</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Alternatively, streamed processing may be initiated by invoking the transformation with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> declared as streamable, while supplying the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> (in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way) as a streamed document.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Invoking a streamable template using the construct <code>&lt;xsl:apply-templates select="doc('bigdoc.xml')"/&gt;</code> does not ensure streamed processing. As always, processors may use streamed processing if they are able to do so, but when the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="#func-document"><code>document</code></a> functions are used, processors are obliged to ensure that the results are deterministic, which may be difficult to reconcile with streaming (if the same document is read twice, the results must be identical). The use of <a href="#element-source-document"><code>xsl:source-document</code></a> with <code>streamable="yes"</code> does not offer the same guarantees of determinism.</p></div><p>For an example of processing a collection of documents by use of the function <a href="https://www.w3.org/TR/xpath-functions-30/#func-uri-collection"><code>uri-collection</code></a><sup><small>FO30</small></sup> in conjunction with <a href="#element-source-document"><code>xsl:source-document</code></a>, see <a href="#stream-examples"><i>18.1.2 Examples of xsl:source-document</i></a>.</p></div></div><div class="div2"><h3><a id="built-in-rule"></a>6.8 <a href="#built-in-rule" style="text-decoration: none">Built-in Template Rules</a></h3><p>When an item is selected by <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and there is no user-specified <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be used to process that item, then a built-in template rule is evaluated instead. </p><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> have lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than all other template rules. Thus, the stylesheet author can override a built-in template rule by including an explicit template rule.</p><p>There are six sets of built-in template rules available. The set that is chosen is a property of the <a title="mode" class="termref" href="#dt-mode">mode</a> selected by the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. This property is set using the <code>on-no-match</code> attribute of the <a href="#element-mode"><code>xsl:mode</code></a> declaration, which takes one of the six values <code>deep-copy</code>, <code>shallow-copy</code>, <code>deep-skip</code>, <code>shallow-skip</code>, <code>text-only-copy</code>, or <code>fail</code>, the default being <code>text-only-copy</code>. The effect of these six sets of built-in template rules is explained in the following subsections.</p><div class="div3"><h4><a id="built-in-templates-text-only-copy"></a>6.8.1 <a href="#built-in-templates-text-only-copy" style="text-decoration: none">Built-in Templates: Text-only Copy</a></h4><p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies <code>on-no-match="text-only-copy"</code> is that the textual content of the source document is retained while losing the markup, except where explicit template rules dictate otherwise. When an element is encountered for which there is no explicit <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, the processing continues with the children of that element. Text nodes are copied to the output.</p><p>The built-in rule for document nodes and element nodes is equivalent to calling <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with no <code>select</code> attribute, and with the <code>mode</code> attribute set to <code>#current</code>. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>This is equivalent to the following in the case where there are no parameters:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">document-node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">|</span><span class="node-type">element</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">#current</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for text and attribute nodes returns a text node containing the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the context node. It is effectively:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">text</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">|</span><span class="axis">@</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This text node may have a string value that is zero-length.</p></div><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for atomic values returns a text node containing the value. It is effectively:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="filter">[</span><span class="context">.</span><span class="whitespace"></span><span class="type-op">instance of</span><span class="whitespace"></span><span class="type-name">xs:anyAtomicType</span><span class="filter">]</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This text node may have a string value that is zero-length.</p></div><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for processing instructions, comments, and namespace nodes does nothing (it returns the empty sequence).</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">processing-instruction</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">|</span><span class="node-type">comment</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">|</span><span class="node-type">namespace-node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for functions (including maps) does nothing (it returns the empty sequence).</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="filter">[</span><span class="context">.</span><span class="whitespace"></span><span class="type-op">instance of</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="quantifier">*</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for arrays (see <a href="#arrays"><i>22 Arrays</i></a>) is to apply templates to the members of the array. It is equivalent to invoking <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with the <code>select</code> attribute set to <code>?*</code> (which selects the members of the array), and with the <code>mode</code> attribute set to <code>#current</code>. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>This is equivalent to the following in the case where there are no parameters:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="filter">[</span><span class="context">.</span><span class="whitespace"></span><span class="type-op">instance of</span><span class="whitespace"></span><span class="node-type">array</span><span class="parenthesis">(</span><span class="quantifier">*</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">#current</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The following example illustrates the use of built-in template rules when there are parameters.</p><div class="example"><div class="exampleHeader"><a id="d8e19952"></a><a id="d8e20058"></a>Example: Using a Built-In Template Rule</div><p>Suppose the stylesheet contains the following instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">title</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">init</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">10</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:apply-templates</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>If there is no explicit template rule that matches the <code>title</code> element, then the following implicit rule is used:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">title</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">init</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">#current</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">init</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$init</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:apply-templates</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="built-in-templates-deep-copy"></a>6.8.2 <a href="#built-in-templates-deep-copy" style="text-decoration: none">Built-in Templates: Deep Copy</a></h4><p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies <code>on-no-match="deep-copy"</code> is that an unmatched element in the source tree is copied unchanged to the output, together with its entire subtree. Other unmatched items are also copied unchanged. The subtree is copied unconditionally, without attempting to match nodes in the subtree against template rules.</p><p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic values, and functions, including maps and arrays) are processed using a template rule that is equivalent to the following:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">preserve</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="div3"><h4><a id="built-in-templates-shallow-copy"></a>6.8.3 <a href="#built-in-templates-shallow-copy" style="text-decoration: none">Built-in Templates: Shallow Copy</a></h4><p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies <code>on-no-match="shallow-copy"</code> is that the source tree is copied unchanged to the output, except for nodes where different processing is specified using an explicit <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>.</p><p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic values, and functions, including maps and arrays) are processed using a template rule that is equivalent to the following, except that all parameters supplied in <a href="#element-with-param"><code>xsl:with-param</code></a> elements are passed on implicitly to the called templates:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">preserve</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:copy</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This rule is often referred to as the <em>identity template</em>, though it should be noted that it does not preserve node identity.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This rule differs from the traditional identity template rule by using two <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions, one to process the attributes and one to process the children. The only observable difference from the traditional <code>select="node() | @*"</code> is that with two separate instructions, the value of <code>position()</code> in the called templates forms one sequence starting at 1 for the attributes, and a new sequence starting at 1 for the children.</p></div><div class="example"><div class="exampleHeader"><a id="d8e20011"></a><a id="d8e20117"></a>Example: Modified Identity Transformation</div><p>The following stylesheet transforms an input document by deleting all elements named <code>note</code>, together with their attributes and descendants:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">on-no-match</span><span class="atneq">=</span><span class="z">"</span><span class="av">shallow-copy</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">true</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">note</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> no action </span><span class="z">--&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="built-in-templates-deep-skip"></a>6.8.4 <a href="#built-in-templates-deep-skip" style="text-decoration: none">Built-in Templates: Deep Skip</a></h4><p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies <code>on-no-match="deep-skip"</code> is that where no explicit template rule is specified for an element, that element and all its descendants are ignored, and are not copied to the result tree.</p><p>The effect of choosing <code>on-no-match="deep-skip"</code> is as follows:</p><ul><li><p>The built-in rule for document nodes is equivalent to calling <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with no <code>select</code> attribute, and with the <code>mode</code> attribute set to <code>#current</code>. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>In the case where there are no parameters, this is equivalent to the following rule:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">document-node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">#current</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></li><li><p>The built-in rule for all items other than document nodes (that is, for all other kinds of node, as well as atomic values and functions, including maps and and arrays) is to do nothing, that is, to return an empty sequence (without applying templates to any children or ancestors).</p><p>This is equivalent to the following rule:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></li></ul></div><div class="div3"><h4><a id="built-in-templates-shallow-skip"></a>6.8.5 <a href="#built-in-templates-shallow-skip" style="text-decoration: none">Built-in Templates: Shallow Skip</a></h4><p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies <code>on-no-match="shallow-skip"</code> is to drop both the textual content and the markup from the result document, except where there is an explicit user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that dictates otherwise.</p><p>The built-in rule for document nodes and element nodes applies templates (in the current mode) first to the node’s attributes and then to its children. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions.</p><p>In the case where there are no parameters, this is equivalent to the following rule:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">document-node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">|</span><span class="node-type">element</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">#current</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">#current</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The built-in template rule for all other kinds of node, and for atomic values and functions (including maps, but not arrays) is empty: that is, when the item is matched, the built-in template rule returns an empty sequence.</p><p>This is equivalent to the following rule:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for arrays (see <a href="#arrays"><i>22 Arrays</i></a>) is to apply templates to the members of the array. It is equivalent to invoking <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with the <code>select</code> attribute set to <code>?*</code> (which selects the members of the array), and with the <code>mode</code> attribute set to <code>#current</code>. If the built-in rule was invoked with parameters, those parameters are passed on in the implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p>This is equivalent to the following in the case where there are no parameters:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="filter">[</span><span class="context">.</span><span class="whitespace"></span><span class="type-op">instance of</span><span class="whitespace"></span><span class="node-type">array</span><span class="parenthesis">(</span><span class="quantifier">*</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">#current</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="div3"><h4><a id="built-in-templates-fail"></a>6.8.6 <a href="#built-in-templates-fail" style="text-decoration: none">Built-in Templates: Fail</a></h4><p>The effect of choosing <code>on-no-match="fail"</code> for a <a title="mode" class="termref" href="#dt-mode">mode</a> is that every item selected in an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction must be matched by an explicit user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>.</p><p>The built-in template rule is effectively: </p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">M</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="z"></span><span class="atn">terminate</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">error-code</span><span class="atneq">=</span><span class="z">"</span><span class="av">err:XTDE0555</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>with an <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> message body.</p><p><a id="err-XTDE0555"><span class="error">[ERR XTDE0555] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is used to process <span>an item</span> using a mode whose declaration specifies <code>on-no-match="fail"</code> when there is no <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> whose match pattern matches that <span>item</span>. </p></div></div><div class="div2"><h3><a id="apply-imports"></a>6.9 <a href="#apply-imports" style="text-decoration: none">Overriding Template Rules</a></h3><p class="element-syntax"><a id="element-apply-imports"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:apply-imports&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:apply-imports&gt;</code></p><p class="element-syntax"><a id="element-next-match"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:next-match&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:next-match&gt;</code></p><p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that is being used to override another template rule (see <a href="#conflict"><i>6.5 Conflict Resolution for Template Rules</i></a>) can use the <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction to invoke the overridden template rule. The <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction only considers template rules in imported stylesheet modules; the <a href="#element-next-match"><code>xsl:next-match</code></a> instruction considers all other template rules of lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and/or priority, and also declarations of the same precedence and priority that appear earlier in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>. Both instructions will invoke the built-in template rule for the context item (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>) if no other template rule is found.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-template-rule" title="current template rule"></a>At any point in the processing of a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there may be a <b>current template rule</b>. Whenever a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is chosen as a result of evaluating <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>, the template rule becomes the current template rule for the evaluation of the rule’s sequence constructor.<span class="definition">]</span></p><p> The <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is cleared (becomes <a title="absent" class="termref" href="#dt-absent">absent</a>) by any instruction that evaluates an operand with changed focus. It is therefore cleared when evaluating <a title="instruction" class="termref" href="#dt-instruction">instructions</a> contained within: </p><ul><li><p><a href="#element-for-each"><code>xsl:for-each</code></a></p></li><li><p><a href="#element-for-each-group"><code>xsl:for-each-group</code></a></p></li><li><p><a href="#element-analyze-string"><code>xsl:analyze-string</code></a></p></li><li><p><a href="#element-iterate"><code>xsl:iterate</code></a></p></li><li><p><a href="#element-source-document"><code>xsl:source-document</code></a></p></li><li><p><a href="#element-merge"><code>xsl:merge</code></a></p></li><li><p><a href="#element-sort"><code>xsl:sort</code></a></p></li><li><p><a href="#element-key"><code>xsl:key</code></a></p></li><li><p><a href="#element-copy"><code>xsl:copy</code></a> if and only if there is a <code>select</code> attribute</p></li><li><p>A global <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a></p></li><li><p><a href="#element-function"><code>xsl:function</code></a></p></li><li><p><a href="#element-template"><code>xsl:template</code></a> if and only if the called template specifies <code>&lt;xsl:context-item use="absent"/&gt;</code></p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>The current template rule is not affected by invoking named attribute sets (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), or named templates (see <a href="#named-templates"><i>10.1 Named Templates</i></a>) unless <code>&lt;xsl:context-item use="absent"/&gt;</code> is specified. While evaluating a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or the default value of a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>) the current template rule is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></div><p>These rules ensure that when <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is called, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is the same as when the current template rule was invoked.</p><p> Both <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a> search for a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that matches the <a title="context item" class="termref" href="#dt-context-item">context item</a>, and that is applicable to the <a title="current mode" class="termref" href="#dt-current-mode">current mode</a> (see <a href="#modes"><i>6.7 Modes</i></a>). In choosing a template rule, they use the usual criteria such as the priority and <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> of the template rules, but they consider as candidates only a subset of the template rules in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This subset differs between the two instructions:</p><ul><li><p>The <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction considers as candidates only those template rules contained in <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a> that are descendants in the <a title="import tree" class="termref" href="#dt-import-tree">import tree</a> of the <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> that contains the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is <em>not</em> the same as saying that the search considers all template rules whose import precedence is lower than that of the current template rule.</p></div><p><a id="err-XTSE3460"><span class="error">[ERR XTSE3460] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element appears in a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within an <a href="#element-override"><code>xsl:override</code></a> element. (To invoke the template rule that is being overridden, <a href="#element-next-match"><code>xsl:next-match</code></a> should therefore be used.)</p></li><li><p>The <a href="#element-next-match"><code>xsl:next-match</code></a> instruction considers as candidates all those template rules that come after the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> in the ordering of template rules implied by the conflict resolution rules given in <a href="#conflict"><i>6.5 Conflict Resolution for Template Rules</i></a>. That is, it considers all template rules with lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>, plus the template rules that are at the same import precedence that have lower priority than the current template rule, plus the template rules with the same import precedence and priority that occur before the current template rule in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As explained in <a href="#conflict"><i>6.5 Conflict Resolution for Template Rules</i></a>, a template rule with no <code>priority</code> attribute, whose match pattern contains multiple alternatives separated by <code>|</code>, is treated equivalently to a set of template rules, one for each alternative. This means that where the same item matches more than one alternative, it is possible for an <a href="#element-next-match"><code>xsl:next-match</code></a> instruction to cause the current template rule to be invoked recursively. This situation does not occur when the template rule has an explicit priority.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Because a template rule declared as a child of <a href="#element-override"><code>xsl:override</code></a> has higher precedence than any template rule declared in the used package (see <a href="#modes-and-packages"><i>3.5.4 Overriding Template Rules from a Used Package</i></a>), the effect of <a href="#element-next-match"><code>xsl:next-match</code></a> within such a template rule is to consider as candidates first any other template rules for the same mode within the same <a href="#element-use-package"><code>xsl:use-package</code></a> element (taking into account explicit and implicit priority, and document order, in the usual way), and then all template rules in the used package.</p></div></li></ul><p>If a matching template rule <var>R</var> is found, then the result of the <a href="#element-next-match"><code>xsl:next-match</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction is the result of invoking <var>R</var>, with the values of parameters being set using the child <a href="#element-with-param"><code>xsl:with-param</code></a> elements as described in <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>. The template rule <var>R</var> is evaluated with the same <a title="focus" class="termref" href="#dt-focus">focus</a> as the <a href="#element-next-match"><code>xsl:next-match</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction. The <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> changes to be <var>R</var>. The <a title="current mode" class="termref" href="#dt-current-mode">current mode</a> does not change. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the case where the current template rule <var>T</var> is declared within an <a href="#element-override"><code>xsl:override</code></a> element in a using package <var>P</var>, while the selected rule <var>R</var> is declared within a different package <var>Q</var>, and where the current mode is <var>M<sub>P</sub></var> (mode <var>M</var> in package <var>P</var>), the effect is that the current mode for evaluation of <var>R</var> remains <var>M<sub>P</sub></var> rather than reverting to its corresponding mode <var>M<sub>Q</sub></var> (mode <var>M</var> in package <var>Q</var>). If <var>R</var> contains an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction that uses <code>mode="#current"</code>, then the set of template rules considered by this instruction will therefore include any overriding template rules declared in <var>P</var> as well as the original rules declared in <var>Q</var>. </p></div><p>If no matching template rule is found that satisfies these criteria, the built-in template rule for the context item is used (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>).</p><p>An <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction may use <a href="#element-with-param"><code>xsl:with-param</code></a> child elements to pass parameters to the chosen <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> (see <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>). It also passes on any <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> as described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>.</p><p><a id="err-XTDE0560"><span class="error">[ERR XTDE0560] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is evaluated when the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>. </p><div class="example"><div class="exampleHeader"><a id="d8e20506"></a><a id="d8e20612"></a>Example: Using <a href="#element-apply-imports"><code>xsl:apply-imports</code></a></div><p>For example, suppose the stylesheet <code>doc.xsl</code> contains a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for <code>example</code> elements:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">example</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">pre</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">pre</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Another stylesheet could import <code>doc.xsl</code> and modify the treatment of <code>example</code> elements as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:import</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">doc.xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">example</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">div</span><span class="z"></span><span class="atn">style</span><span class="atneq">=</span><span class="z">"</span><span class="av">border: solid red</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-imports</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">div</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The combined effect would be to transform an <code>example</code> into an element of the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">div</span><span class="z"></span><span class="atn">style</span><span class="atneq">=</span><span class="z">"</span><span class="av">border: solid red</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">pre</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">pre</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">div</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>An <a href="#element-fallback"><code>xsl:fallback</code></a> instruction appearing as a child of an <a href="#element-next-match"><code>xsl:next-match</code></a> instruction is ignored by an XSLT 2.0 or 3.0 processor, but can be used to define fallback behavior when the stylesheet is processed by an XSLT 1.0 processor with forwards compatible behavior.</p></div><div class="div2"><h3><a id="parameters-to-template-rules"></a>6.10 <a href="#parameters-to-template-rules" style="text-decoration: none">Passing Parameters to Template Rules</a></h3><p>A template rule may have parameters. The parameters are declared in the body of the template using <a href="#element-param"><code>xsl:param</code></a> elements, as described in <a href="#parameters"><i>9.2 Parameters</i></a>.</p><p>Values for these parameters may be supplied in the calling <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction by means of <a href="#element-with-param"><code>xsl:with-param</code></a> elements appearing as children of the calling instruction. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> represented by the <code>name</code> attribute of the <a href="#element-with-param"><code>xsl:with-param</code></a> element must match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> represented by the <code>name</code> attribute of the corresponding <a href="#element-param"><code>xsl:param</code></a> element. </p><p>It is not an error for these instructions to supply a parameter that does not match any parameter declared in the template rule that is invoked; unneeded parameter values are simply ignored.</p><p>A parameter may be declared as a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> by specifying <code>tunnel="yes"</code> in the <a href="#element-param"><code>xsl:param</code></a> declaration; in this case the caller must supply the value as a tunnel parameter by specifying <code>tunnel="yes"</code> in the corresponding <a href="#element-with-param"><code>xsl:with-param</code></a> element. Tunnel parameters differ from ordinary template parameters in that they are passed transparently through multiple template invocations. They are fully described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>.</p></div></div><div class="div1"><h2><a id="repetition"></a>7 <a href="#repetition" style="text-decoration: none">Repetition</a></h2><p>XSLT offers two constructs for processing each <span>entry in a collection</span>: <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-iterate"><code>xsl:iterate</code></a>.</p><p>Both instructions can be used to process the items in a sequence, the elements in an array, or the entries in a map. Arrays and maps are processed by reducing them to a sequence of items, so in what follows, the terms <b>item</b> and <b>sequence</b> are used generically.</p><p>The main difference between the two constructs is that with <a href="#element-for-each"><code>xsl:for-each</code></a>, the processing applied to each item in the sequence is independent of the processing applied to any other item; this means that the items may be processed in any order or in parallel, though the order of the output sequence is well defined and corresponds to the order of the input (sorted if so requested). By contrast, with <a href="#element-iterate"><code>xsl:iterate</code></a>, the processing is explicitly sequential: while one item is being processed, values may be computed which are then available for use while the next item is being processed. This makes <a href="#element-iterate"><code>xsl:iterate</code></a> suitable for tasks such as creating a running total over a sequence of financial transactions.</p><p>A further difference is that <a href="#element-for-each"><code>xsl:for-each</code></a> permits sorting of the input sequence, while <a href="#element-iterate"><code>xsl:iterate</code></a> does not.</p><div class="div2"><h3><a id="for-each"></a>7.1 <a href="#for-each" style="text-decoration: none">The </a><code>xsl:for-each</code><a href="#for-each" style="text-decoration: none"> instruction</a></h3><p class="element-syntax"><a id="element-for-each"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each&gt;</code></p><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction processes each in a sequence of items, evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> within the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction once for each item in that sequence.</p><p> The <code>select</code> attribute is <span class="verb">required</span>; it contains an <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a sequence, called the input sequence. If there is an <a href="#element-sort"><code>xsl:sort</code></a> element present (see <a href="#sorting"><i>13 Sorting</i></a>) the input sequence is sorted to produce a sorted sequence. Otherwise, the sorted sequence is the same as the input sequence.</p><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is evaluated once for each item in the sorted sequence, with the <a title="focus" class="termref" href="#dt-focus">focus</a> set as follows:</p><ul><li><p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the item being processed. </p></li><li><p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of this item in the sorted sequence.</p></li><li><p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is the size of the sorted sequence (which is the same as the size of the input sequence).</p></li></ul><p> For each item in the input sequence, evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> produces a sequence of items (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>). These output sequences are concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence, then the result of evaluating the sequence constructor with <var>Q</var> as the context item is concatenated after the result of evaluating the sequence constructor with <var>P</var> as the context item. The result of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is the concatenated sequence of items.</p><div class="example"><div class="exampleHeader"><a id="d8e20741"></a><a id="d8e20847"></a>Example: Using <a href="#element-for-each"><code>xsl:for-each</code></a> to process a sequence</div><p>For example, given an XML document with this structure</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">customers</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">customer</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">name</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">name</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">order</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">order</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">order</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">order</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">customer</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">customer</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">name</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">name</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">order</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">order</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">order</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">order</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">customer</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">customers</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>the following would create an HTML document containing a table with a row for each <code>customer</code> element</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">html</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">Customers</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tbody</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">customers</span><span class="step">/</span><span class="qname">customer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">order</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tbody</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">html</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e20756"></a><a id="d8e20862"></a>Example: Using <a href="#element-for-each"><code>xsl:for-each</code></a> to process an array</div><p>Consider a JSON document of the form:</p><div class="exampleInner"><pre>[ { "city": "London", "latitude": 51.5099, "longitude": -0.1181 }, { "city": "Paris", "latitude": 48.8647, "longitude": 2.3488 }, { "city": "Berlin", "latitude": 52.5200, "longitude": 13.4049 } ]</pre></div><p>The following code processes this array to produce an XML representation of the same information. The cities are sorted by name:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">json-doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">input.json</span><span class="op">'</span><span class="parenthesis">)</span><span class="quantifier">?</span><span class="op">*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="qname">city</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">number</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="op">?</span><span class="qname">city</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">latitude</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="op">?</span><span class="qname">latitude</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">longitude</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="op">?</span><span class="qname">longitude</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>In this example it is possible to use the expression <code>$array?*</code> to convert an array to a sequence. This works because the members of the array are all single items. In the more general case (a member of the array might be an empty sequence, corresponding to the JSON value <code>null</code>, or it might be a sequence containing several items), the function <code>array:members</code> can be used to deliver the contents of the array as a sequence of <em>parcels</em>, and the contents of each parcel can be extracted (as a sequence) using the <a href="#func-unparcel"><code>unparcel</code></a> function.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e20779"></a><a id="d8e20885"></a>Example: Using <a href="#element-for-each"><code>xsl:for-each</code></a> to process a map</div><p>Consider a JSON document of the form:</p><div class="exampleInner"><pre>{ "London": {"latitude": 51.5099, "longitude": -0.1181 }, "Paris": {"latitude": 48.8647, "longitude": 2.3488 }, "Berlin": {"latitude": 52.5200, "longitude": 13.4049 } }</pre></div><p>The following code processes this map to produce an XML representation of the same information. The cities are sorted by name:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">map:key-value-pairs</span><span class="parenthesis">(</span><span class="function">json-doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">input.json</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="qname">key</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">number</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="op">?</span><span class="qname">key</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">latitude</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="op">?</span><span class="qname">value</span><span class="op">?</span><span class="qname">latitude</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">longitude</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="op">?</span><span class="qname">value</span><span class="op">?</span><span class="qname">longitude</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>In this example the map is decomposed to a sequence of key-value pairs, each represented as a map with two entries, <code>"key"</code> and <code>"value"</code>, which can be accessed using the lookup expressions <code>?key</code> and <code>?value</code>.</p></div><div class="div3"><h4><a id="for-each-separator"></a>7.1.1 <a href="#for-each-separator" style="text-decoration: none">The </a><code>separator</code><a href="#for-each-separator" style="text-decoration: none"> attribute</a></h4><p>If the <code>separator</code> attribute is present, then its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted sequence other than the last.</p><p>For example, the following instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">6</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">3</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">9</span><span class="z">"</span><span class="z"></span><span class="atn">separator</span><span class="atneq">=</span><span class="z">"</span><span class="av">|</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="context">.</span><span class="op">+</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>produces a sequence comprising, in order: the integer 3, the integer 4, a text node with string value <code>"|"</code>, the integer 6, the integer 7, another text node with string value <code>"|"</code>, the integer 9, and the integer 10.</p><p>The node identity of any text nodes that are inserted is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Specifically, it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p><p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a> and <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>.)</p></div></div><div class="div2"><h3><a id="iterate"></a>7.2 <a href="#iterate" style="text-decoration: none">The </a><code>xsl:iterate</code><a href="#iterate" style="text-decoration: none"> Instruction</a></h3><p>The <code>xsl:iterate</code> instruction processes the items in a sequence in order; unlike <code>xsl:for-each</code>, the result of processing one item can affect the way that subsequent items are processed.</p><p>As with <code>xsl:for-each</code>, the instruction is extended in XSLT 4.0 to allow maps and arrays to be processed.</p><p class="element-syntax"><a id="element-iterate"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:iterate<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <a href="#element-on-completion">xsl:on-completion</a>?, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:iterate&gt;</code></p><p class="element-syntax"><a id="element-next-iteration"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:next-iteration&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a>*) --&gt;<br>&lt;/xsl:next-iteration&gt;</code></p><p class="element-syntax"><a id="element-break"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:break<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:break&gt;</code></p><p class="element-syntax"><a id="element-on-completion"></a><code>&lt;xsl:on-completion<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-completion&gt;</code></p><p>The <code>select</code> attribute contains an <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a sequence, called the input sequence.</p><p>The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is evaluated once for each item in the input sequence, in order, or until the loop exits by evaluating an <a href="#element-break"><code>xsl:break</code></a> instruction, whichever is earlier. Within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the body of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is set to each item from the value of the <code>select</code> expression in turn; the <a title="context position" class="termref" href="#dt-context-position">context position</a> reflects the position of this item in the input sequence, and the <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of items in the input sequence (which may be greater than the number of iterations, if the loop exits prematurely using <a href="#element-break"><code>xsl:break</code></a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If <a href="#element-iterate"><code>xsl:iterate</code></a> is used in conjunction with <a href="#element-source-document"><code>xsl:source-document</code></a> to achieve streaming, calls on the function <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> will be disallowed. </p></div><p>The <a href="#element-break"><code>xsl:break</code></a> and <a href="#element-on-completion"><code>xsl:on-completion</code></a> elements may have either a <code>select</code> attribute or a non-empty contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> but not both. The effect of the element in both cases is obtained by evaluating the <code>select</code> expression if present or the contained sequence constructor otherwise; if neither is present, the value is an empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-on-completion"><code>xsl:on-completion</code></a> element appears before other children of <a href="#element-iterate"><code>xsl:iterate</code></a> to ensure that variables declared in the sequence constructor are not in scope within <a href="#element-on-completion"><code>xsl:on-completion</code></a>, since such variables do not have a defined value within <a href="#element-on-completion"><code>xsl:on-completion</code></a> especially in the case where the value of the <code>select</code> attribute is an empty sequence.</p></div><p>The effect of <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> is to cause the iteration to continue by processing the next item in the input sequence, potentially with different values for the iteration parameters. The effect of <a href="#element-break"><code>xsl:break</code></a> is to cause the iteration to finish, whether or not all the items in the input sequence have been processed. In both cases the affected iteration is the one controlled by the innermost ancestor <a href="#element-iterate"><code>xsl:iterate</code></a> element.</p><p>The instructions <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> and <a href="#element-break"><code>xsl:break</code></a> are allowed only as descendants of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, and only in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-tail-position" title="tail position"></a>An <a title="instruction" class="termref" href="#dt-instruction">instruction</a><var>J</var> is in a <b>tail position</b> within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a><var>SC</var> if it satisfies one of the following conditions:</p><ul><li><p><var>J</var> is the last instruction in <var>SC</var>, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-if"><code>xsl:if</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch of an <a href="#element-choose"><code>xsl:choose</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var> (that is, it is immediately followed by an <a href="#element-catch"><code>xsl:catch</code></a> element, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> elements).</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-catch"><code>xsl:catch</code></a> element within an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li></ul><p>]</p><p><a id="err-XTSE3120"><span class="error">[ERR XTSE3120] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element appears other than in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. </p><p><a id="err-XTSE3125"><span class="error">[ERR XTSE3125] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> is present and the instruction has children. </p><p><a id="err-XTSE3130"><span class="error">[ERR XTSE3130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>name</code> attribute of an <a href="#element-with-param"><code>xsl:with-param</code></a> child of an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element does not match the <code>name</code> attribute of an <a href="#element-param"><code>xsl:param</code></a> child of the innermost containing <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. </p><p>Parameter names in <a href="#element-with-param"><code>xsl:with-param</code></a> must be unique: <span class="error">[see <a href="#err-XTSE0670">ERR XTSE0670</a>]</span>.</p><p>The result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the concatenation of the sequences that result from the repeated evaluation of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, followed by the sequence that results from evaluating the <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> element if any.</p><p>Any <a href="#element-param"><code>xsl:param</code></a> element that appears as a child of <a href="#element-iterate"><code>xsl:iterate</code></a> declares a parameter whose value may vary from one iteration to the next. The initial value of the parameter is the value obtained according to the rules given in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. The dynamic context for evaluating the initial value of an <a href="#element-param"><code>xsl:param</code></a> element is the same as the dynamic context for evaluating the <code>select</code> expression of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction (the context item is thus <em>not</em> the first item in the input sequence).</p><p>On the first iteration a parameter always takes its initial value (which may depend on variables or other aspects of the dynamic context). Subsequently:</p><ul><li><p>If an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction is evaluated, then parameter values for processing the next item in the input sequence can be set in the <a href="#element-with-param"><code>xsl:with-param</code></a> children of that instruction; in the absence of an <a href="#element-with-param"><code>xsl:with-param</code></a> element that names a particular parameter, that parameter will retain its value from the previous iteration.</p></li><li><p>If an <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, no further items in the input sequence are processed.</p></li><li><p>If neither an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> nor an <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, then the next item in the input sequence is processed using parameter values that are unchanged from the previous iteration.</p></li></ul><p>The <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction contributes nothing to the result sequence (technically, it returns an empty sequence). The instruction supplies parameter values for the next iteration, which are evaluated according to the rules given in <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>; if there are no further items in the input sequence then it supplies parameter values for use while evaluating the body of the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element if any.</p><p>The <a href="#element-break"><code>xsl:break</code></a> instruction indicates that the iteration should terminate without processing any remaining items from the input sequence. The <code>select</code> expression or contained sequence constructor is evaluated using the same context item, position, and size as the <a href="#element-break"><code>xsl:break</code></a> instruction itself, and the result is appended to the result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction as a whole.</p><p>If neither an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> nor an <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, the next item in the input sequence is processed with parameter values unchanged from the previous iteration; if there are no further items in the input sequence, the iteration terminates.</p><p>The optional <a href="#element-on-completion"><code>xsl:on-completion</code></a> element (which is not technically an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> and is not technically part of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>) is evaluated when the input sequence is exhausted. It is not evaluated if the evaluation is terminated using <a href="#element-break"><code>xsl:break</code></a>. During evaluation of its <code>select</code> expression or sequence constructor the context item, position, and size are <a title="absent" class="termref" href="#dt-absent">absent</a> (that is, any reference to these values is an error). However, the values of the parameters to <a href="#element-iterate"><code>xsl:iterate</code></a> are available, and take the values supplied by the <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction evaluated while processing the last item in the sequence.</p><p>If the input sequence is empty, then the result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the result of evaluating the <code>select</code> attribute or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, using the initial values of the <a href="#element-param"><code>xsl:param</code></a> elements. If there is no <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, the result is an empty sequence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Conceptually, <a href="#element-iterate"><code>xsl:iterate</code></a> behaves like a tail-recursive function. The <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction then represents the recursive call, supplying the tail of the input sequence as an implicit parameter. There are two main reasons for providing the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. One is that many XSLT users find writing recursive functions to be a difficult skill, and this construct promises to be easier to learn. The other is that recursive function calls are difficult for an optimizer to analyze. Because <a href="#element-iterate"><code>xsl:iterate</code></a> is more constrained than a general-purpose head-tail recursive function, it should be more amenable to optimization. In particular, when the instruction is used in conjunction with <a href="#element-source-document"><code>xsl:source-document</code></a>, it is designed to make it easy for the implementation to use streaming techniques, processing the nodes in an input document sequentially as they are read, without building the entire document tree in memory.</p></div><p>The examples below use <a href="#element-iterate"><code>xsl:iterate</code></a> in conjunction with the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction. This is not the only way of using <a href="#element-iterate"><code>xsl:iterate</code></a>, but it illustrates the way in which the two features can be combined to achieve streaming of a large input document.</p><div class="example"><div class="exampleHeader"><a id="d8e21290"></a><a id="d8e21396"></a>Example: Using <a href="#element-iterate"><code>xsl:iterate</code></a> to Compute Cumulative Totals</div><p>Suppose that the input XML document has this structure</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">transactions</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-01</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">12.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-01</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">8.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-02</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">-2.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-02</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">5.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">transactions</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>and that the requirement is to transform this to:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">account</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-01</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">12.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-01</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">20.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-02</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">18.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2008-09-02</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">23.00</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">account</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This can be achieved using the following code, which is designed to process the transaction file using streaming:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">account</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">balance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0.00</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:decimal</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">newBalance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$balance</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">xs:decimal</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="axis">@</span><span class="qname">date</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">format-number</span><span class="parenthesis">(</span><span class="variable">$newBalance</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">0.00</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">balance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$newBalance</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">account</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The following example modifies this by only outputting the information for the first day’s transactions:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">account</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">balance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0.00</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:decimal</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">prevDate</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:date?</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">newBalance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$balance</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">xs:decimal</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">thisDate</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:date</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">date</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="variable">$prevDate</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">or</span><span class="whitespace"></span><span class="variable">$thisDate</span><span class="whitespace"></span><span class="op">eq</span><span class="whitespace"></span><span class="variable">$prevDate</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$thisDate</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">format-number</span><span class="parenthesis">(</span><span class="variable">$newBalance</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">0.00</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">balance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$newBalance</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">prevDate</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$thisDate</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:break</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">account</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The following code outputs the balance only at the end of each day, together with the final balance:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">account</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">balance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0.00</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:decimal</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">prevDate</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:date?</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-completion</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$prevDate</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">format-number</span><span class="parenthesis">(</span><span class="variable">$balance</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">0.00</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-completion</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">newBalance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$balance</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">xs:decimal</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">thisDate</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:date</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">date</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">exists</span><span class="parenthesis">(</span><span class="variable">$prevDate</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">and</span><span class="whitespace"></span><span class="variable">$thisDate</span><span class="whitespace"></span><span class="op">ne</span><span class="whitespace"></span><span class="variable">$prevDate</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">balance</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$prevDate</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">format-number</span><span class="parenthesis">(</span><span class="variable">$balance</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">0.00</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">balance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$newBalance</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">prevDate</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$thisDate</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">account</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>If the sequence of transactions is empty, this code outputs a single element: <code>&lt;balance date="" value="0.00"/&gt;</code>.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e21315"></a><a id="d8e21421"></a>Example: Collecting Multiple Values in a Single Pass</div><p>Problem: Given a sequence of <code>employee</code> elements, find the employees having the highest and lowest salary, while processing each employee only once.</p><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">si-iterate-035.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">employees</span><span class="step">/</span><span class="qname">employee</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">highest</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">lowest</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-completion</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">highest-paid-employees</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$highest</span><span class="step">/</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">highest-paid-employees</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">lowest-paid-employees</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$lowest</span><span class="step">/</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">lowest-paid-employees</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-completion</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">this</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">is-new-highest</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="variable">$highest</span><span class="filter">[</span><span class="axis">@</span><span class="qname">salary</span><span class="whitespace"></span><span class="op">ge</span><span class="whitespace"></span><span class="function">current</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">salary</span><span class="filter">]</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">is-equal-highest</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">exists</span><span class="parenthesis">(</span><span class="variable">$highest</span><span class="filter">[</span><span class="axis">@</span><span class="qname">salary</span><span class="whitespace"></span><span class="op">eq</span><span class="whitespace"></span><span class="function">current</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">salary</span><span class="filter">]</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">is-new-lowest</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="variable">$lowest</span><span class="filter">[</span><span class="axis">@</span><span class="qname">salary</span><span class="whitespace"></span><span class="op">le</span><span class="whitespace"></span><span class="function">current</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">salary</span><span class="filter">]</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">is-equal-lowest</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">exists</span><span class="parenthesis">(</span><span class="variable">$lowest</span><span class="filter">[</span><span class="axis">@</span><span class="qname">salary</span><span class="whitespace"></span><span class="op">eq</span><span class="whitespace"></span><span class="function">current</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">salary</span><span class="filter">]</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">new-highest-set</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)*</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$is-new-highest</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="variable">$this</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$is-equal-highest</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$highest</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$this</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="variable">$highest</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">new-lowest-set</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)*</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$is-new-lowest</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="variable">$this</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$is-equal-lowest</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$lowest</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$this</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="variable">$lowest</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">highest</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$new-highest-set</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">lowest</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$new-lowest-set</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>If the input sequence is empty, this code outputs an empty <code>highest-paid-employees</code> element and an empty <code>lowest-paid-employees</code> element.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e21330"></a><a id="d8e21436"></a>Example: Processing the Last Item in a Sequence Specially</div><p>When streaming, it is not possible to determine whether the item being processed is the last in a sequence without reading ahead. The <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> function therefore cannot be used in <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> code. The <a href="#element-iterate"><code>xsl:iterate</code></a> instruction provides a solution to this problem.</p><p>Problem: render the last paragraph in a section in some special way, for example by using bold face. (The actual rendition is achieved by processing the paragraph with mode <code>last-para</code>.)</p><p>The solution uses <a href="#element-iterate"><code>xsl:iterate</code></a> together with the <a href="#func-copy-of"><code>copy-of</code></a> function to maintain a one-element look-ahead by explicit coding:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">section</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">streaming</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">para</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">prev</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(para)?</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-completion</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$prev</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">last-para</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-completion</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$prev</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$prev</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">prev</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e21458"></a>Example: Processing an array using <code>xsl:iterate</code><a id="d8e21458"></a>Example: Processing an array using <code>xsl:iterate</code></div><p>Consider the following JSON document representing transactions in a bank account:</p><div class="exampleInner"><pre>[ {"date":"2008-09-01", credit:12.00}, {"date":"2008-09-01", credit:8.00}, {"date":"2008-09-02", debit:2.00}, {"date":"2008-09-02", credit:12.00} ]</pre></div><p>The following code converts this to an XML representation that includes a running balance:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">array</span><span class="atneq">=</span><span class="z">"</span><span class="av">json-doc('account.json')</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">balance</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:decimal</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">delta</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="qname">value</span><span class="op">?</span><span class="op">credit</span><span class="whitespace"></span><span class="qname">otherwise</span><span class="whitespace"></span><span class="op">-</span><span class="op">?</span><span class="qname">value</span><span class="op">?</span><span class="qname">debit</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">entry</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="op">?</span><span class="qname">value</span><span class="op">?</span><span class="qname">date</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">amount</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$delta</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">balance</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$balance</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="variable">$delta</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">balance</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$balance</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="variable">$delta</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div1"><h2><a id="conditionals"></a>8 <a href="#conditionals" style="text-decoration: none">Conditional Processing</a></h2><p>There are several instructions in XSLT that support conditional processing: <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-choose"><code>xsl:choose</code></a><span>, and <a href="#element-switch"><code>xsl:switch</code></a></span>. The <a href="#element-if"><code>xsl:if</code></a> instruction provides simple <span>if-then-else</span> conditionality; the <a href="#element-choose"><code>xsl:choose</code></a> instruction supports selection of one choice when there are several possibilities, <span>and <a href="#element-switch"><code>xsl:switch</code></a> allows a branch to be selected based on the value of a given expression.</span></p><p>XSLT 3.0 also supports <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a> which define conditional processing to handle <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>XSLT offers a number of ways of expressing conditional logic.</p><p>XSLT 1.0 offered the <a href="#element-if"><code>xsl:if</code></a> instruction for cases where output was to be produced only if a condition was true, with <a href="#element-choose"><code>xsl:choose</code></a> available for multi-way branches where different output was to be produced under different input conditions. In addition, of course, XSLT 1.0 also offered the option of rule-based processing using templates and match patterns.</p><p>XSLT 2.0 added the XPath conditional expression providing two-way branches for use at a finer-grained level where <a href="#element-choose"><code>xsl:choose</code></a> could be excessively verbose: it allowed constructs such as <code>&lt;xsl:value-of select="if ($x) then 'red' else 'green'/&gt;</code> to be reduced from eight lines of code to one.</p><p>XSLT 4.0 introduces the <code>then</code> and <code>else</code> attributes for <a href="#element-if"><code>xsl:if</code></a>, which are particularly useful in contexts such as the body of an <a href="#element-function"><code>xsl:function</code></a> declaration where the alternative results are conveniently evaluated using XPath expressions rather than XSLT instructions: for example a recursive function might have as its body the instruction <code>&lt;xsl:if test="empty($seq)" then="1" else="head($seq) * my:f(tail($seq))"/&gt;</code>. The <code>select</code> attribute of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> is introduced for similar reasons: XSLT instructions are most useful when contructing node trees, whereas XPath expressions are more convenient when computing atomic values. Again, the main contribution of these enhancements is to reduce visual clutter, making the code more concise and more easily readable.</p><p>The <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced in XSLT 4.0 as an alternative to <a href="#element-choose"><code>xsl:choose</code></a> for the common use case where the conditions test for multiple different values of some common expression. By avoiding repetition of the common expression whose value is being tested, the logic becomes self-explanatory both to the human reader of the code and to an optimizing compiler, making it easier to generate efficient branching code.</p><p>Further conditional constructs are also under development for XPath 4.0. [TODO: elaborate on this when complete.]</p></div><div class="div2"><h3><a id="xsl-if"></a>8.1 <a href="#xsl-if" style="text-decoration: none">Conditional Processing with </a><a href="#element-if"><code>xsl:if</code></a><a href="#xsl-if" style="text-decoration: none"></a></h3><p class="element-syntax"><a id="element-if"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:if<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;then? = <var>expression</var><br>&nbsp;&nbsp;else? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:if&gt;</code></p><p>The <a href="#element-if"><code>xsl:if</code></a> element has a mandatory <code>test</code> attribute, whose value is an <a title="expression" class="termref" href="#dt-expression">expression</a>. The content is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>If the <a href="#element-if"><code>xsl:if</code></a> element has a <code>then</code> attribute, then it <span class="verb">must</span> have no children. That is, the <code>then</code> attribute and the contained sequence constructor are mutually exclusive.</p><p>The result of the <a href="#element-if"><code>xsl:if</code></a> instruction depends on the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP40</small></sup> of the expression in the <code>test</code> attribute. The rules for determining the effective boolean value of an expression are given in <a href="#xpath-40">[XPath 4.0]</a>: they are the same as the rules used for XPath conditional expressions.</p><p>If the effective boolean value of the <a title="expression" class="termref" href="#dt-expression">expression</a> is true, then:</p><ul><li><p>If there is a <code>then</code> attribute, the expression in the <code>then</code> attribute is evaluated, and the resulting value is returned as the result of the <a href="#element-if"><code>xsl:if</code></a> instruction.</p></li><li><p>If there is a non-empty sequence constructor, it is evaluated and the resulting value is returned as the result of the <a href="#element-if"><code>xsl:if</code></a> instruction.</p></li><li><p>Otherwise, the result of the <a href="#element-if"><code>xsl:if</code></a> instruction is an empty sequence.</p></li></ul><p>If the effective boolean value of the <code>test</code><a title="expression" class="termref" href="#dt-expression">expression</a> is false, then:</p><ul><li><p>If there is an <code>else</code> attribute, the expression in the <code>else</code> attribute is evaluated, and the resulting value is returned as the result of the <a href="#element-if"><code>xsl:if</code></a> instruction.</p></li><li><p>Otherwise, the result of the <a href="#element-if"><code>xsl:if</code></a> instruction is an empty sequence.</p></li></ul><p>If the <code>test</code> expression has no effective boolean value (for example, if it is a sequence of several integers, or a map), then a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs. (See <a href="https://www.w3.org/TR/xpath-functions/#ERRFORG0006" title="FORG0006"><span class="error">[ERR FORG0006] </span></a><sup><small>FO</small></sup>.)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The semantics of the <a href="#element-if"><code>xsl:if</code></a> instruction are essentially equivalent to the semantics of the conditional expression in XPath: the construct <code>&lt;xsl:if test="C" then="X" else="Y"/&gt;</code> can equivalently be written <code>&lt;xsl:sequence select="if (C) then X else Y"/&gt;</code>. The same effect can also be achieved by writing <code>&lt;xsl:choose&gt;&lt;xsl:when test="C" select="X"/&gt;&lt;xsl:otherwise select="Y"/&gt;&lt;/xsl:choose&gt;.</code> The choice of which of these constructs to use is a largely matter of personal style. </p></div><div class="example"><div class="exampleHeader"><a id="d8e21549"></a><a id="d8e21655"></a>Example: Using <a href="#element-if"><code>xsl:if</code></a> to insert separators</div><p>In the following example, the names in a group of names are formatted as a comma separated list:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">namelist</span><span class="step">/</span><span class="qname">name</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">not</span><span class="parenthesis">(</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">=</span><span class="function">last</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">, </span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This adds a comma after every item except the last. This can also be expressed as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">namelist</span><span class="step">/</span><span class="qname">name</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">not</span><span class="parenthesis">(</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">=</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">, </span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>which inserts a comma before every item except the first. (This formulation might be more efficient, since determining whether an item is the last may involve look-ahead.)</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e21563"></a><a id="d8e21669"></a>Example: Using <a href="#element-if"><code>xsl:if</code></a> as the body of a function</div><p>The following example shows the use of <a href="#element-if"><code>xsl:if</code></a> to deliver the result of a recursive function:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:product</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">in</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="variable">$in</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">then</span><span class="atneq">=</span><span class="z">"</span><span class="av">1e0</span><span class="z">"</span><span class="z"></span><span class="atn">else</span><span class="atneq">=</span><span class="z">"</span><span class="av">head($in) * f:product(tail($in))</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="xsl-choose"></a>8.2 <a href="#xsl-choose" style="text-decoration: none">Conditional Processing with </a><a href="#element-choose"><code>xsl:choose</code></a><a href="#xsl-choose" style="text-decoration: none"></a></h3><p class="element-syntax"><a id="element-choose"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:choose&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br>&lt;/xsl:choose&gt;</code></p><p class="element-syntax"><a id="element-when"></a><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p class="element-syntax"><a id="element-otherwise"></a><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p>The <a href="#element-choose"><code>xsl:choose</code></a> element selects one among a number of possible alternatives. It consists of a sequence of one or more <a href="#element-when"><code>xsl:when</code></a> elements followed by an optional <a href="#element-otherwise"><code>xsl:otherwise</code></a> element. Each <a href="#element-when"><code>xsl:when</code></a> element has <span>an</span> attribute, <code>test</code>, which specifies an <a title="expression" class="termref" href="#dt-expression">expression</a> used as a condition.</p><p>The effective value of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the effective value is an empty sequence.</p><p>When an <a href="#element-choose"><code>xsl:choose</code></a> element is processed, each of the <a href="#element-when"><code>xsl:when</code></a> elements is tested in turn (that is, in the order that the elements appear in the stylesheet), until one of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied. If none of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied, then the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is considered, as described below.</p><p>An <a href="#element-when"><code>xsl:when</code></a> element is satisfied if the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP40</small></sup> of the <a title="expression" class="termref" href="#dt-expression">expression</a> in its <code>test</code> attribute is <code>true</code>. The rules for determining the effective boolean value of an expression are given in <a href="#xpath-30">[XPath 3.0]</a>: they are the same as the rules used for XPath conditional expressions.</p><p>The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-choose"><code>xsl:choose</code></a> instruction is an empty sequence.</p><p><span>The <code>select</code> expressions and sequence constructors of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> instructions after the selected one are not evaluated.</span> The <code>test</code> expressions for <a href="#element-when"><code>xsl:when</code></a> instructions after the selected one are not evaluated.</p><div class="example"><div class="exampleHeader"><a id="d8e21708"></a><a id="d8e21814"></a>Example: Using <a href="#element-choose"><code>xsl:choose</code></a> for formatting a numbered list </div><p>The following example enumerates items in an ordered list using arabic numerals, letters, or roman numerals depending on the depth to which the ordered lists are nested.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">orderedlist</span><span class="step">/</span><span class="qname">listitem</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:list-item</span><span class="z"></span><span class="atn">indent-start</span><span class="atneq">=</span><span class="z">'</span><span class="av">2pi</span><span class="z">'</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:list-item-label</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">level</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="axis">ancestor::</span><span class="qname">orderedlist</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">mod</span><span class="whitespace"></span><span class="numeric">3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">'</span><span class="variable">$level</span><span class="op">=</span><span class="numeric">1</span><span class="z">'</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">i</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">'</span><span class="variable">$level</span><span class="op">=</span><span class="numeric">2</span><span class="z">'</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">a</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">. </span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:list-item-label</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:list-item-body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:list-item-body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:list-item</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e21823"></a>Example: Using the <code>select</code> attribute of  and <a id="d8e21823"></a>Example: Using the <code>select</code> attribute of  and </div><p>The following example is equivalent to the one above:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">orderedlist</span><span class="step">/</span><span class="qname">listitem</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:list-item</span><span class="z"></span><span class="atn">indent-start</span><span class="atneq">=</span><span class="z">'</span><span class="av">2pi</span><span class="z">'</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:list-item-label</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">level</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="axis">ancestor::</span><span class="qname">orderedlist</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">mod</span><span class="whitespace"></span><span class="numeric">3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">format</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">'</span><span class="variable">$level</span><span class="op">=</span><span class="numeric">1</span><span class="z">'</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">i</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">'</span><span class="variable">$level</span><span class="op">=</span><span class="numeric">2</span><span class="z">'</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">a</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">1</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$format</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">. </span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:list-item-label</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:list-item-body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:list-item-body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:list-item</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="xsl-switch"></a>8.3 <a href="#xsl-switch" style="text-decoration: none">Conditional Processing with </a><a href="#element-switch"><code>xsl:switch</code></a><a href="#xsl-switch" style="text-decoration: none"></a></h3><p class="element-syntax"><a id="element-switch"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:switch<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:switch&gt;</code></p><p class="element-syntax"><a id="element-when"></a><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p class="element-syntax"><a id="element-otherwise"></a><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p>The <a href="#element-switch"><code>xsl:switch</code></a> element selects one among a number of possible alternatives. The <code>select</code> attribute of the <a href="#element-switch"><code>xsl:switch</code></a> element is evaluated to obtain an atomic value, which is compared with the values given by the <code>test</code> attributes of the <a href="#element-when"><code>xsl:when</code></a> elements, in turn.</p><p>The content of the <a href="#element-switch"><code>xsl:switch</code></a> element consists of a sequence of one or more <a href="#element-when"><code>xsl:when</code></a> elements followed by an optional <a href="#element-otherwise"><code>xsl:otherwise</code></a> element. Each <a href="#element-when"><code>xsl:when</code></a> element has <span>an</span> attribute, <code>test</code>, which contains an <a title="expression" class="termref" href="#dt-expression">expression</a>.</p><p>The result of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch may be supplied using either a <code>select</code> attribute or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the result is an empty sequence.</p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children are ignored by an XSLT 4.0 processor, but can be used to define the recovery action to be taken by a processor for an earlier version of XSLT when operating with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>.</p><p>An <a href="#element-switch"><code>xsl:switch</code></a> element is processed as follows:</p><ul><li><p>The <code>select</code> expression of the <a href="#element-switch"><code>xsl:switch</code></a> element is evaluated.</p></li><li><p>The result of the evaluation is converted to a single atomic value by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>; a type error occurs if this conversion is not possible. This value is referred to below as the <b>selector</b>.</p></li><li><p>Each of the <a href="#element-when"><code>xsl:when</code></a> elements is tested in turn (that is, in the order that the elements appear in the stylesheet), until one of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied. If none of the <a href="#element-when"><code>xsl:when</code></a> elements is satisfied, then the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is considered, as described below.</p><p>An <a href="#element-when"><code>xsl:when</code></a> element is tested by first evaluating its <code>test</code> expression and converting the result to a sequence of atomic values by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, and then comparing this sequence of atomic values with the <code>selector</code> value. The comparison is performed using the rules of the XPath <code>=</code> operator, using the default collation that is in scope for the <a href="#element-switch"><code>xsl:switch</code></a> instruction.</p><p>An <a href="#element-when"><code>xsl:when</code></a> element is satisfied if the result of this comparison is <code>true</code>.</p></li><li><p>The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that is satisfied is evaluated, and the resulting sequence <span>(that is, the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as appropriate)</span> is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated, and the resulting sequence is returned as the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of the <a href="#element-switch"><code>xsl:switch</code></a> instruction is an empty sequence.</p></li><li><p>The <code>select expressions</code> and sequence constructors of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> instructions after the selected one are not evaluated. The <code>test</code> expressions for <a href="#element-when"><code>xsl:when</code></a> instructions after the selected one are not evaluated.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no requirement that the values of <code>select</code> expressions should be literals, nor that the values should be distinct.</p></div><div class="example"><div class="exampleHeader"><a id="d8e21908"></a><a id="d8e22014"></a>Example: Using <a href="#element-switch"><code>xsl:switch</code></a> as a lookup table</div><p>The following example shows a simple function to convert a month number to a month name:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:month-name</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">month-number</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:switch</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$month-number</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">January</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">2</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">February</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">3</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">March</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">4</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">April</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">5</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">May</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">6</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">June</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">7</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">July</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">8</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">August</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">9</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">September</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">10</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">October</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">11</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">November</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">12</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">December</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">error</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">Unknown month</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:switch</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e21916"></a><a id="d8e22022"></a>Example: Using <a href="#element-switch"><code>xsl:switch</code></a> to return the number of days in the month</div><p>This function returns the number of days in a month, returning an empty sequence if the supplied month is invalid.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:days-in-month</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer?</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">month-number</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">leap-year</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:switch</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$month-number</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">3</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">5</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">7</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">8</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">10</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">12</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">31</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">4</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">6</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">9</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">11</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">30</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$leap-year</span><span class="z">"</span><span class="z"></span><span class="atn">then</span><span class="atneq">=</span><span class="z">"</span><span class="av">29</span><span class="z">"</span><span class="z"></span><span class="atn">else</span><span class="atneq">=</span><span class="z">"</span><span class="av">28</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:switch</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="try-catch"></a>8.4 <a href="#try-catch" style="text-decoration: none">Try/Catch</a></h3><p>The <a href="#element-try"><code>xsl:try</code></a> instruction can be used to trap dynamic errors occurring within the expression it wraps; the recovery action if such errors occur is defined using a child <a href="#element-catch"><code>xsl:catch</code></a> element.</p><p class="element-syntax"><a id="element-try"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:try<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;rollback-output? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>sequence-constructor</var>, <a href="#element-catch">xsl:catch</a>, (<a href="#element-catch">xsl:catch</a> | <a href="#element-fallback">xsl:fallback</a>)*) --&gt;<br>&lt;/xsl:try&gt;</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because a sequence constructor may contain an <a href="#element-fallback"><code>xsl:fallback</code></a> element, the effect of this content model is that an <a href="#element-fallback"><code>xsl:fallback</code></a> instruction may appear as a child of <a href="#element-try"><code>xsl:try</code></a> in any position.</p></div><p class="element-syntax"><a id="element-catch"></a><code>&lt;xsl:catch<br>&nbsp;&nbsp;errors? = <var>tokens</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:catch&gt;</code></p><p>An <a href="#element-try"><code>xsl:try</code></a> instruction evaluates either the expression contained in its <code>select</code> attribute, or its contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and returns the result of that evaluation if it succeeds without error. If a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during the evaluation, the processor evaluates the first <a href="#element-catch"><code>xsl:catch</code></a> child element applicable to the error, and returns that result instead.</p><p>If the <a href="#element-try"><code>xsl:try</code></a> element has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a>. That is, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive. If neither is present, the result of the <a href="#element-try"><code>xsl:try</code></a> is an empty sequence (no dynamic error can occur in this case).</p><p>The <code>rollback-output</code> attribute is described in <a href="#recovery"><i>8.4.1 Recovery of Result Trees</i></a>. The default value is <code>yes</code>.</p><p><a id="err-XTSE3140"><span class="error">[ERR XTSE3140] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-try"><code>xsl:try</code></a> element is present and the element has children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> elements. </p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children of the <a href="#element-try"><code>xsl:try</code></a> element are ignored by an XSLT 3.0 processor, but can be used to define the recovery action taken by an XSLT 1.0 or XSLT 2.0 processor operating with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>.</p><p>The <a href="#element-catch"><code>xsl:catch</code></a> element has an optional <code>errors</code> attribute, which lists the error conditions that the <a href="#element-catch"><code>xsl:catch</code></a> element is designed to intercept. The default value is <code>errors="*"</code>, which catches all errors. The value is a whitespace-separated list of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTests</a><sup><small>XP40</small></sup>; an <a href="#element-catch"><code>xsl:catch</code></a> element catches an error condition if this list includes a <code>NameTest</code> that matches the error code associated with that error condition.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Error codes are QNames. Those defined in this specification and in related specifications are all in the <a title="standard error namespace" class="termref" href="#dt-standard-error-namespace">standard error namespace</a>, and may therefore be caught using an <a href="#element-catch"><code>xsl:catch</code></a> element such as <code>&lt;xsl:catch errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix <code>err</code> is bound to this namespace. Errors defined by implementers, and errors raised by an explicit call of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup> function or by use of the <a href="#element-message"><code>xsl:message</code></a> or <a href="#element-assert"><code>xsl:assert</code></a> instruction, may use error codes in other namespaces.</p></div><p>If more than one <a href="#element-catch"><code>xsl:catch</code></a> element matches an error, the error is processed using the first one that matches, in document order. If no <a href="#element-catch"><code>xsl:catch</code></a> matches the error, then the error is not caught (that is, evaluation of the <a href="#element-try"><code>xsl:try</code></a> element fails with the dynamic error).</p><p>An <a href="#element-catch"><code>xsl:catch</code></a> element may have either a <code>select</code> attribute, or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p><a id="err-XTSE3150"><span class="error">[ERR XTSE3150] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-catch"><code>xsl:catch</code></a> element is present unless the element has empty content. </p><p>The result of evaluating the <a href="#element-catch"><code>xsl:catch</code></a> element is the result of evaluating the XPath expression in its <code>select</code> attribute or the result of evaluating the contained sequence constructor; if neither is present, the result is an empty sequence. This result is delivered as the result of the <a href="#element-try"><code>xsl:try</code></a> instruction.</p><p>If a dynamic error occurs during the evaluation of <a href="#element-catch"><code>xsl:catch</code></a>, it causes the containing <a href="#element-try"><code>xsl:try</code></a> to fail with this error. The error is not caught by other sibling <a href="#element-catch"><code>xsl:catch</code></a> elements within the same <a href="#element-try"><code>xsl:try</code></a> instruction, but it may be caught by an <a href="#element-try"><code>xsl:try</code></a> instruction at an outer level, or by an <a href="#element-try"><code>xsl:try</code></a> instruction nested within the <a href="#element-catch"><code>xsl:catch</code></a>. </p><p>Within the <code>select</code> expression, or within the sequence constructor contained by the <a href="#element-catch"><code>xsl:catch</code></a> element, a number of variables are implicitly declared, giving information about the error that occurred. These are lexically scoped to the <a href="#element-catch"><code>xsl:catch</code></a> element. These variables are all in the <a title="standard error namespace" class="termref" href="#dt-standard-error-namespace">standard error namespace</a>, and they are initialized as described in the following table:</p><table class="data"><caption>Variables Available within <code>xsl:catch</code></caption><thead><tr><th style="text-align:left; vertical-align:top">Variable</th><th style="text-align:left; vertical-align:top">Type</th><th style="text-align:left; vertical-align:top">Value</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">err:code</td><td style="text-align:left; vertical-align:top">xs:QName</td><td style="text-align:left; vertical-align:top">The error code</td></tr><tr><td style="text-align:left; vertical-align:top">err:description</td><td style="text-align:left; vertical-align:top">xs:string?</td><td style="text-align:left; vertical-align:top">A description of the error condition; an empty sequence if no description is available (for example, if the <a href="https://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup> function was called with one argument).</td></tr><tr><td style="text-align:left; vertical-align:top">err:value</td><td style="text-align:left; vertical-align:top">item()*</td><td style="text-align:left; vertical-align:top">Value associated with the error. For an error raised by calling the <a href="https://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup> function, this is the value of the third argument (if supplied). For an error raised by evaluating <a href="#element-message"><code>xsl:message</code></a> with <code>terminate="yes"</code>, or a failing <a href="#element-assert"><code>xsl:assert</code></a>, this is the document node at the root of the tree containing the XML message body.</td></tr><tr><td style="text-align:left; vertical-align:top">err:module</td><td style="text-align:left; vertical-align:top">xs:string?</td><td style="text-align:left; vertical-align:top">The URI (or system ID) of the stylesheet module containing the instruction where the error occurred; an empty sequence if the information is not available.</td></tr><tr><td style="text-align:left; vertical-align:top">err:line-number</td><td style="text-align:left; vertical-align:top">xs:integer?</td><td style="text-align:left; vertical-align:top">The line number within the stylesheet module of the instruction where the error occurred; an empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</td></tr><tr><td style="text-align:left; vertical-align:top">err:column-number</td><td style="text-align:left; vertical-align:top">xs:integer?</td><td style="text-align:left; vertical-align:top">The column number within the stylesheet module of the instruction where the error occurred; an empty sequence if the information is not available. The value <span class="verb">may</span> be approximate.</td></tr></tbody></table><p>Variables declared within the sequence constructor of the <a href="#element-try"><code>xsl:try</code></a> element (and not within an <a href="#element-catch"><code>xsl:catch</code></a>) are not visible within the <a href="#element-catch"><code>xsl:catch</code></a> element.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within an <a href="#element-catch"><code>xsl:catch</code></a> it is possible to re-throw the error using the function call <code>error($err:code, $err:description, $err:value)</code>.</p></div><p>The following additional rules apply to the catching of errors:</p><ol class="enumar"><li><p>All dynamic errors occurring during the evaluation of the <a href="#element-try"><code>xsl:try</code></a> sequence constructor or <code>select</code> expression are caught (provided they match one of the <a href="#element-catch"><code>xsl:catch</code></a> elements). </p><div class="note"><p class="prefix"><b>Note:</b></p><ul><li><p>This includes errors occurring in functions or templates invoked in the course of this evaluation, unless already caught by a nested <a href="#element-try"><code>xsl:try</code></a>.</p></li><li><p>It also includes (for example) errors caused by calling the <a href="https://www.w3.org/TR/xpath-functions-30/#func-error"><code>error</code></a><sup><small>FO30</small></sup> function, or the <a href="#element-message"><code>xsl:message</code></a> instruction with <code>terminate="yes"</code>, or the <a href="#element-assert"><code>xsl:assert</code></a> instruction, or the <code>xs:error</code> constructor function. </p></li><li><p>It does not include errors that occur while evaluating references to variables whose declaration and initialization is outside the <a href="#element-try"><code>xsl:try</code></a>.</p></li></ul></div></li><li><p>The existence of an <a href="#element-try"><code>xsl:try</code></a> instruction does not affect the obligation of the processor to signal certain errors as static errors, or its right to choose whether to signal some errors (such as <a title="type error" class="termref" href="#dt-type-error">type errors</a>) statically or dynamically. Static errors are never caught.</p></li><li><p>Some fatal errors arising in the processing environment, such as running out of memory, may cause termination of the transformation despite the presence of an <a href="#element-try"><code>xsl:try</code></a> instruction. This is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p></li><li><p>If the sequence constructor or <code>select</code> expression of the <a href="#element-try"><code>xsl:try</code></a> causes execution of <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-message"><code>xsl:message</code></a>, or <a href="#element-assert"><code>xsl:assert</code></a> instructions and fails with a dynamic error that is caught, it is implementation-dependent whether these instructions have any externally visible effect. The processor is <span class="verb">not required</span> to roll back any changes made by these instructions. The same applies to any side effects caused by extension functions or extension instructions.</p></li><li><p>A serialization error that occurs during the serialization of a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> produced using <a href="#element-result-document"><code>xsl:result-document</code></a> is treated as a dynamic error in the evaluation of the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, and may be caught (for example by an <a href="#element-try"><code>xsl:try</code></a> instruction that contains the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction). A serialization error that occurs while serializing the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> is treated as occurring after the transformation has finished, and cannot be caught. </p></li><li><p>A validation error is treated as occurring in the instruction that requested validation. For example, if the stylesheet is producing XHTML output and requests validation of the entire result document by means of the attribute <code>validation="strict"</code> on the instruction that creates the outermost <code>html</code> element, then a validation failure can be caught only at that level. Although the validation error might be detected, for example, while writing a <code>p</code> element at a location where no <code>p</code> element is allowed, it is not treated as an error in the instruction that writes the <code>p</code> element and cannot be caught at that level.</p></li><li><p>A type error may be caught if the processor raises it dynamically; this does not affect the processor’s right to raise the error statically if it chooses.</p><p>The following rules are provided to define which expression is considered to fail when a type error occurs, and therefore where the error can be caught. The general principle is that where the semantics of a construct <var>C</var> place requirements on the type of some subexpression, a type error is an error in the evaluation of <var>C</var>, not in the evaluation of the subexpression.</p><p>For example, consider the following construct:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">v</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$foo</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The expected type of the result of the sequence constructor is <code>xs:integer</code>; if the value of variable <code>$foo</code> turns out to be a string, then a type error will occur. It is not possible to catch this by writing:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">v</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:try</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$foo</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:catch</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="clxsl">xsl:catch</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:try</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This fails to catch the error because the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is deemed to evaluate successfully; the failure only occurs when the result of this instruction is bound to the variable.</p><p>A similar rule applies to functions: if the body of a function computes a result which does not conform to the required type of the function result, it is not possible to catch this error within the function body itself; it can only be caught by the caller of the function. Similarly, if an expression used to compute an argument to a function returns a value of the wrong type for the function signature, this is not considered an error in this expression, but an error in evaluating the function call as a whole.</p><p>A consequence of these rules is that when a type error occurs while initializing a global variable (because the initializer returns a value of the wrong type, given the declared type of the variable), then this error cannot be caught.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because processors are permitted to report type errors during static analysis, it is unwise to attempt to recover from type errors dynamically. The best strategy is generally to prevent their occurrence. For example, rather than writing <code>$p + 1</code> where <code>$p</code> is a parameter of unknown type, and then catching the type error that occurs if <code>$p</code> is not numeric, it is better first to test whether <code>$p</code> is numeric, perhaps by means of an expression such as <code>$p instance of my:numeric</code>, where <code>my:numeric</code> is a union type with <code>xs:double</code>, <code>xs:float</code>, and <code>xs:decimal</code> as its member types.</p></div></li><li><p>The fact that the application tries to catch errors does not prevent the processor from organizing the evaluation in such a way as to prevent errors occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an “early exit”, rather than examining every item in the sequence just to see if it triggers a divide-by-zero error.</p></li><li><p>Except as specified above, the optimizer must not rearrange the evaluation (at compile time or at run time) so that expressions written to be subject to the try/catch are evaluated outside its scope, or expressions written to be external to the try/catch are evaluated within its scope. This does not prevent expressions being rearranged, but any expression that is so rearranged must carry its try/catch context with it.</p></li></ol><div class="div3"><h4><a id="recovery"></a>8.4.1 <a href="#recovery" style="text-decoration: none">Recovery of Result Trees</a></h4><p>The XSLT language is designed so that a processor that chooses to execute instructions in document order will always append nodes to the result tree in document order, and never needs to update a result tree in situ. As a result, it is normal practice for XSLT processors to stream the result tree directly to its final destination (for example, a serializer) without ever holding the tree in memory. This applies whether or not the processor is streamable, and whether or not source documents are streamed.</p><p>The language specification states (see <a href="#errors"><i>2.14 Error Handling</i></a>) that when a transformation terminates with a dynamic error, the state of persistent resources affected by the transformation (for example, serialized result documents) is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, so processors are not required to take any special steps to recover such resources to their pre-transformation state; at the same time, there is no guarantee that secondary result documents produced before the failure occurs will be in a usable state.</p><p>The situation becomes more complicated when dynamic errors occur while writing to a result tree, and the dynamic error is caught by an <a href="#element-try"><code>xsl:try</code></a>/<a href="#element-catch"><code>xsl:catch</code></a> instruction. The semantics of these instructions requires that when an error occurring during the evaluation of <a href="#element-try"><code>xsl:try</code></a> is caught, the result of the <a href="#element-try"><code>xsl:try</code></a> instruction is the result of the relevant <a href="#element-catch"><code>xsl:catch</code></a>. To achieve this, any output written to the result tree during the execution of <a href="#element-try"><code>xsl:try</code></a> until the point where the error occurs must effectively be undone. There are two basic strategies for achieving this: either the updates are not committed to persistent storage until the <a href="#element-try"><code>xsl:try</code></a> instruction is completed, or the updates are written in such a way that they can be rolled back in the event of a failure.</p><p>Both these strategies are potentially expensive, and both have an adverse effect on streaming, in that they affect the amount of memory needed to transform large amounts of data. XSLT 3.0 therefore provides an option to relax the requirement to recover result trees when failures occur in the course of evaluating an <a href="#element-try"><code>xsl:try</code></a> instruction. This option is invoked by specifying <code>rollback-output="no"</code> on the <a href="#element-try"><code>xsl:try</code></a> instruction.</p><p>The default value of the attribute is <code>rollback-output="yes"</code>.</p><p>The effect of specifying <code>rollback-output="no"</code> on <a href="#element-try"><code>xsl:try</code></a> is as follows: if a dynamic error occurs in the course of evaluating the <a href="#element-try"><code>xsl:try</code></a> instruction, and if the failing construct is evaluated in <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> while writing to some result document, then it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether an attempt to catch this error using <a href="#element-catch"><code>xsl:catch</code></a> will be successful. If the attempt is successful, then the <a href="#element-try"><code>xsl:try</code></a> instruction succeeds, delivering the result of evaluating the <a href="#element-catch"><code>xsl:catch</code></a> clause, and the transformation proceeds as normal. If the attempt is unsuccessful (typically, because non-recoverable updates have already been made to the result tree), then the <a href="#element-try"><code>xsl:try</code></a> instruction as a whole fails with a dynamic error. The state of this result document will then be undefined, but the transformation can ignore the failure and continue to produce other result documents, for example by wrapping the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction in an <a href="#element-try"><code>xsl:try</code></a> instruction that catches the relevant error.</p><p><a id="err-XTDE3530"><span class="error">[ERR XTDE3530] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-try"><code>xsl:try</code></a> instruction is unable to recover the state of a final result tree because recovery has been disabled by use of the attribute <code>rollback-output="no"</code>. </p><p>For example, consider the following:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">out.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:try</span><span class="z"></span><span class="atn">rollback-output</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">in.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:catch</span><span class="z"></span><span class="atn">errors</span><span class="atneq">=</span><span class="z">"</span><span class="av">*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">error</span><span class="z"></span><span class="atn">code</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$err:code</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">message</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$err:description</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">file</span><span class="atneq">=</span><span class="z">"</span><span class="av">in.xml</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:catch</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:try</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The most likely failure to occur here is a failure to read the streamed input file <code>in.xml</code>. In the common case where this failure is detected immediately, for example if the file does not exist or the network connection is down, no output will have been written to the result document, and the attempt to catch the error is likely to be successful. If however a failure is detected after several megabytes of data have been copied to <code>out.xml</code>, for example an XML well-formedness error in the input file, or a network failure that occurs while reading the file, recovery of the output file may be impossible. In this situation the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction will fail with a dynamic error. It is possible to catch this error, but the state of the file <code>out.xml</code> will be unpredictable.</p><p>Note that adding an <a href="#element-try"><code>xsl:try</code></a> instruction as a child of <a href="#element-source-document"><code>xsl:source-document</code></a> does not help. Any error reading the input file (such as a well-formedness error) is an error in the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction and can only be caught at that level.</p><p>When <code>rollback-output="no"</code> is specified, it is still possible to ensure recovery of errors happens predictably by evaluating the potentially failing code in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>: typically, within an <a href="#element-variable"><code>xsl:variable</code></a>. In effect the variable acts as an explicit buffer for temporary results, which is only copied to the final output if evaluation succeeds.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An application might wish to ensure that when a fatal error occurs while reading an input stream, data written to persistent storage up to the point of failure is available after the transformation terminates. Setting <code>rollback-output="no"</code> does not guarantee this, but a processor might choose to interpret this as the intent.</p></div><p>Changing the attribute to <code>rollback-output="yes"</code> makes the stylesheet more robust and able to handle error conditions predictably, but the cost may be substantial; for example it may be necessary to buffer the whole of the result document in memory.</p></div><div class="div3"><h4><a id="try-catch-examples"></a>8.4.2 <a href="#try-catch-examples" style="text-decoration: none">Try/Catch Examples</a></h4><div class="example"><div class="exampleHeader"><a id="d8e22483"></a><a id="d8e22589"></a>Example: Catching a Divide-by-Zero Error</div><p>The following example divides an employee’s salary by the number of years they have served, catching the divide-by-zero error if the latter is zero.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:try</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">salary</span><span class="whitespace"></span><span class="op">div</span><span class="whitespace"></span><span class="qname">length-of-service</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:catch</span><span class="z"></span><span class="atn">errors</span><span class="atneq">=</span><span class="z">"</span><span class="av">err:FOAR0001</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:try</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e22488"></a><a id="d8e22594"></a>Example: Catching an Error during Result-tree Validation</div><p>The following example generates a result tree and performs schema validation, outputting a warning message and serializing the invalid tree if validation fails.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">out.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">result</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:call-template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tcall">construct-output</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:try</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$result</span><span class="z">"</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strict</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:catch</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="scx">&gt;</span><span class="txt">Warning: validation of result document failed: Error code: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$err:code</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> Reason: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$err:description</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:message</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$result</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:catch</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:try</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The reason that the result tree is constructed in a variable in this example is so that the unvalidated tree is available to be used within the <a href="#element-catch"><code>xsl:catch</code></a> element. An alternative approach would be to repeat the logic for constructing the tree:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:try</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">out.xml</span><span class="z">"</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strict</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:call-template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tcall">construct-output</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:catch</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="scx">&gt;</span><span class="txt">Warning: validation of result document failed: Error code: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$err:code</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> Reason: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$err:description</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:message</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:call-template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tcall">construct-output</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:catch</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:try</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div2"><h3><a id="conditional-content-construction"></a>8.5 <a href="#conditional-content-construction" style="text-decoration: none">Conditional Content Construction</a></h3><p>The facilities described in this section are designed to make it easier to generate result trees conditionally depending on what is found in the input, without violating the rules for streamability. These facilities are available whether or not streaming is in use, but they are introduced to the language specifically to make streaming easier.</p><p>The facilities are introduced first by example:</p><div class="example"><div class="exampleHeader"><a id="d8e22503"></a><a id="d8e22609"></a>Example: Generating a Wrapper Element for a non-Empty Sequence</div><p>The following example generates an <code>events</code> element if and only if there are one or more <code>event</code> elements. The code could be written like this:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">exists</span><span class="parenthesis">(</span><span class="qname">event</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">events</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">event</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>However, the above code would not be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, because it processes the child <code>event</code> elements more than once. To make it streamable, it can be rewritten as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:where-populated</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">events</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">event</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:where-populated</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction, as explained later, is to avoid outputting the <code>events</code> element if it would have no children. A streaming implementation will typically hold the start tag of the <code>events</code> element in a buffer, to be sent to the output destination only if and when a child node is generated.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e22529"></a><a id="d8e22635"></a>Example: Generating a Header and Footer only if there is Content</div><p>The following example generates an <code>h3</code> element and a summary paragraph only if a list of items is non-empty. The code could be written like this:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">exists</span><span class="parenthesis">(</span><span class="qname">item-for-sale</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h1</span><span class="scx">&gt;</span><span class="txt">Items for Sale</span><span class="ez">&lt;/</span><span class="cl">h1</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">item-for-sale</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">exists</span><span class="parenthesis">(</span><span class="qname">item-for-sale</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Total value: {accumulator-before('total-value')}</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>However, the above code would not be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, because it processes the child <code>item-for-sale</code> elements more than once. To make it streamable, it can be rewritten as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-non-empty</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h1</span><span class="scx">&gt;</span><span class="txt">Items for Sale</span><span class="ez">&lt;/</span><span class="cl">h1</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-non-empty</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">item-for-sale</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-non-empty</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Total value: {accumulator-before('total-value')}</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-non-empty</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sequence</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction, as explained later, is to output the enclosed content only if the containing sequence constructor also generates “ordinary” content, that is, if there is content generated by instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e22553"></a><a id="d8e22659"></a>Example: Generating Substitute Text when there is no Content</div><p>The following example generates a summary paragraph only if a list of items is empty. The code could be written like this:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">item-for-sale</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="qname">item-for-sale</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">There are no items for sale.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>However, the above code would not be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, because it processes the child <code>item-for-sale</code> elements more than once (the fact that the list is empty is irrelevant, because streamability is determined statically). To make the code streamable, it can be rewritten as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">item-for-sale</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-empty</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">There are no items for sale.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-empty</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sequence</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, as explained later, is to output the enclosed content only if the containing sequence constructor generates no “ordinary” content, that is, if there is no content generated by instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In some cases, similar effects can be achieved by using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-has-children"><code>has-children</code></a><sup><small>FO30</small></sup> function, which tests whether an element has child nodes without consuming the children. However, use of <a href="https://www.w3.org/TR/xpath-functions-30/#func-has-children"><code>has-children</code></a><sup><small>FO30</small></sup> has the drawback that the function is unselective: it cannot be used to test whether there are any children of relevance to the application. In particular, it returns true if an element contains comments or whitespace text nodes that the application might consider to be insignificant.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>There are no special streamability rules for the three instructions <a href="#element-where-populated"><code>xsl:where-populated</code></a>, <a href="#element-on-empty"><code>xsl:on-empty</code></a>, or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>. The <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. In many cases the <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions will generate content that does not depend on the source document, and they will therefore be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, but this is not required.</p></div><div class="div3"><h4><a id="where-populated"></a>8.5.1 <a href="#where-populated" style="text-decoration: none">The </a><code>xsl:where-populated</code><a href="#where-populated" style="text-decoration: none"> instruction</a></h4><p class="element-syntax"><a id="element-where-populated"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:where-populated&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:where-populated&gt;</code></p><p>The <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction encloses a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The result of the instruction is established as follows:</p><ol class="enumar"><li><p>The sequence constructor is evaluated in the usual way (taking into account any <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions) to produce a result <var>$R</var>.</p></li><li><p>The result of the instruction is the value of the expression <code>$R[not(deemed-empty(.))]</code> where the function <code>deemed-empty($item as item())</code> returns true if and only if <code>$item</code> is one of the following:</p><ul><li><p>A document or element node that has no children.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If an element has attributes or namespaces, these do not prevent the element being deemed empty.</p><p>If a document or element node has children, the node is not deemed empty, even if the children are empty. For example, a document node created using an <a href="#element-variable"><code>xsl:variable</code></a> instruction in the form <code>&lt;xsl:variable name="temp"&gt;&lt;a/&gt;&lt;/xsl:variable&gt;</code> is not deemed empty, even though the contained &lt;a/&gt; element is empty.</p></div></li><li><p>A node, other than a document or element node, whose string value is zero-length.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A whitespace-only text node is not deemed empty.</p></div></li><li><p>An atomic value such that the result of casting the atomic value to a string is zero-length.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This can happen only when the atomic value is of type <code>xs:string</code>, <code>xs:anyURI</code>, <code>xs:untypedAtomic</code>, <code>xs:hexBinary</code>, or <code>xs:base64Binary</code>.</p></div></li><li><p>A map whose size (number of key/value pairs) is zero.</p></li><li><p>An array (see <a href="#arrays"><i>22 Arrays</i></a>) where the result of flattening the array using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-array-flatten"><code>array:flatten</code></a><sup><small>FO40</small></sup> function is either an empty sequence, or a sequence in which every item is deemed empty (applying these rules recursively).</p></li></ul></li></ol><div class="example"><div class="exampleHeader"><a id="d8e22674"></a><a id="d8e22780"></a>Example: Generating an HTML list</div><p>The following example generates an HTML unnumbered list, if and only if the list is non-empty. Note that the presence of the <code>class</code> attribute does not make the list non-empty. The code is written to be streamable.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:where-populated</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">ul</span><span class="z"></span><span class="atn">class</span><span class="atneq">=</span><span class="z">"</span><span class="av">my-list</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">source-item</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">ul</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:where-populated</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="on-empty"></a>8.5.2 <a href="#on-empty" style="text-decoration: none">The </a><code>xsl:on-empty</code><a href="#on-empty" style="text-decoration: none"> instruction</a></h4><p class="element-syntax"><a id="element-on-empty"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:on-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-empty&gt;</code></p><p>The <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction has the same content model as <a href="#element-sequence"><code>xsl:sequence</code></a>, and when it is evaluated, the same rules apply. In particular, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p><p>When an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction appears in a sequence constructor, then:</p><ol class="enumar"><li><p>It must be the only <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction in the sequence constructor, and</p></li><li><p>It must not be followed in the sequence constructor by any other <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, other than <a href="#element-fallback"><code>xsl:fallback</code></a>, or by a significant text node (that is, a text node that has not been discarded under the provisions of <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>), or by a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. It may, however, be followed by non-instructions such as <a href="#element-catch"><code>xsl:catch</code></a> where appropriate.</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-vacuous" title="vacuous"></a>An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic value which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-array-flatten"><code>array:flatten</code></a><sup><small>FO40</small></sup> function produces either an empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.<span class="definition">]</span></p><p>An <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered only if every preceding sibling instruction, text node, and literal result element in the same <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> returns either an empty sequence, or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items. </p><p>If an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered, then the result of the containing <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the result of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that the (vacuous) results produced by other instructions in the sequence constructor are discarded. This is relevant mainly when the result of the sequence constructor is used for something other than constructing a node: for example if it forms the result of a function, or the value of a variable, and the function or variable specifies a required type.</p><p>When streaming, it may be necessary to buffer vacuous items in the result sequence until it is known whether the result will contain items that are non-vacuous. In many common situations, however — in particular, when the sequence constructor is being used to create the content of a node — vacuous items can be discarded immediately because they do not affect the content of the node being constructed. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In nearly all cases, the rules for <a href="#element-on-empty"><code>xsl:on-empty</code></a> are aligned with the rules for constructing complex content. If the sequence constructor within a literal result element or an <a href="#element-element"><code>xsl:element</code></a> instruction includes an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, then the content of the element will be the value delivered by the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction if and only if the content would otherwise be empty.</p><p>There is one minor exception to this rule: if the sequence constructor delivers multiple zero-length strings, then in the absence of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction the new element would contain whitespace, made up of the separators between these zero-length strings; but <a href="#element-on-empty"><code>xsl:on-empty</code></a> takes no account of these separators.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Attribute and namespace nodes created by the sequence constructor are significant; the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction will not be triggered if such nodes are present. If this is not the desired effect, it is possible to partition the sequence constructor to change the scope of <a href="#element-on-empty"><code>xsl:on-empty</code></a>, for example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">ol</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">class</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">numbered-list</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">xyz</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-empty</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">The list is empty</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sequence</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">ol</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Where the sequence constructor is a child of an instruction with an <code>[xsl:]use-attribute-sets</code> attribute, any attribute nodes created by expanding the referenced attribute set(s) are not part of the result of the sequence constructor and therefore play no role in determining whether an <a href="#element-on-empty"><code>xsl:on-empty</code></a> or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is triggered. Equally, when the sequence constructor is a child of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, attribute nodes generated by expanding the attributes of the literal result element are not taken into account.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> is the only instruction in a sequence constructor then it is always evaluated.</p><p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> appear in the same sequence constructor, then the rules ensure that only one of them will be evaluated.</p></div></div><div class="div3"><h4><a id="on-non-empty"></a>8.5.3 <a href="#on-non-empty" style="text-decoration: none">The </a><a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a><a href="#on-non-empty" style="text-decoration: none"> instruction</a></h4><p class="element-syntax"><a id="element-on-non-empty"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:on-non-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-non-empty&gt;</code></p><p>The <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction has the same content model as <a href="#element-sequence"><code>xsl:sequence</code></a>, and when it is evaluated, the same rules apply. In particular, the <code>select</code> attribute and the contained sequence constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p><p>An <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is evaluated only if there is at least one sibling node in the same <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, excluding <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions, whose evaluation yields a sequence containing an item that is not <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a>. If this condition applies, then all <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions in the containing sequence constructor are evaluated, and their results are included in the result of the containing sequence constructor in their proper positions. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is typically used to generate headers or footers appearing before or after a list of items, where the header or footer is to be omitted if there are no items in the list. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Unlike <a href="#element-on-empty"><code>xsl:on-empty</code></a>, the <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction can appear anywhere in a sequence constructor, and can appear more than once.</p></div></div><div class="div3"><h4><a id="evaluating-on-empty"></a>8.5.4 <a href="#evaluating-on-empty" style="text-decoration: none">Evaluating </a><a href="#element-on-empty"><code>xsl:on-empty</code></a><a href="#evaluating-on-empty" style="text-decoration: none"> and </a><a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a><a href="#evaluating-on-empty" style="text-decoration: none"> Instructions</a></h4><p>The following non-normative algorithm explains one possible strategy for streamed evaluation of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> containing <a href="#element-on-empty"><code>xsl:on-empty</code></a> and/or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p><p>The algorithm makes use of the following mutable variables:</p><ul><li><p><var>L</var> : a list of instructions awaiting evaluation. Initially empty.</p></li><li><p><var>R</var> : a list of items to act as the result of the evaluation. Initially empty.</p></li><li><p><var>F</var> : a boolean flag, initially false, to indicate whether any <a title="vacuous" class="termref" href="#dt-vacuous">non-vacuous</a> items have been written to <var>R</var> by <b>ordinary instructions</b>. The term <b>ordinary instruction</b> means any node in the sequence constructor other than an <a href="#element-on-empty"><code>xsl:on-empty</code></a> or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction.</p></li></ul><p>The algorithm is as follows:</p><ol class="enumar"><li><p>The nodes in the sequence constructor are evaluated in document order.</p></li><li><p>When an <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is encountered, then:</p><ol class="enumla"><li><p>If <var>F</var> is true, the instruction is evaluated and the result is appended to <var>R</var>.</p></li><li><p>Otherwise, the instruction is appended to <var>L</var>.</p></li></ol></li><li><p>When an <b>ordinary instruction</b> is evaluated:</p><ol class="enumla"><li><p>The results of the evaluation are appended to <var>R</var>, in order.</p></li><li><p>When a <a title="vacuous" class="termref" href="#dt-vacuous">non-vacuous</a> item is about to be appended to <var>R</var>, and <var>F</var> is false, then before appending the item to <var>R</var>, the following actions are taken:</p><ol class="enumlr"><li><p>Any <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions in <var>L</var> are evaluated, in order, and their results are appended to <var>R</var>.</p></li><li><p><var>F</var> is set to true.</p></li></ol></li></ol></li><li><p>When an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is encountered, then:</p><ol class="enumla"><li><p>If <var>F</var> is true, the instruction is ignored.</p></li><li><p>Otherwise, the existing contents of <var>R</var> are discarded, the instruction is evaluated, and its results are appended to <var>R</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The need to discard items from <var>R</var> arises only when all the items in <var>R</var> are <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a>. Streaming implementations may therefore need a limited amount of buffering to retain insignificant items until it is known whether they will be needed. However, in many common cases an optimized implementation will be able to discard <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items such as empty text nodes immediately, because when a node is being constructed using the rules in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a> or <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>, such items have no effect on the final outcome.</p></div><p>Otherwise, the instruction is evaluated and its results are appended to <var>R</var>.</p></li></ol></li><li><p>The result of the sequence constructor is the list of items in <var>R</var>.</p></li></ol></div><div class="div3"><h4><a id="where-populated-example"></a>8.5.5 <a href="#where-populated-example" style="text-decoration: none">A More Complex Example</a></h4><p>This example shows how the three instructions <a href="#element-where-populated"><code>xsl:where-populated</code></a>, <a href="#element-on-empty"><code>xsl:on-empty</code></a>, and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> may be combined.</p><div class="example"><div class="exampleHeader"><a id="d8e23015"></a><a id="d8e23121"></a>Example: Generating a Table only if there is Content</div><p>The following example generates a table containing the names and ages of a set of students; if there are no students, it substitutes a paragraph explaining this.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">div</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">students</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:where-populated</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-non-empty</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">thead</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Name</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Age</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">thead</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-non-empty</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:where-populated</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tbody</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">student</span><span class="step">/</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">age</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tbody</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:where-populated</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:where-populated</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-empty</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">There are no students</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-empty</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">div</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Explanation:</p><ul><li><p>The <a href="#element-where-populated"><code>xsl:where-populated</code></a> around the <code>table</code> element ensures that if there is no <code>thead</code> and no <code>tbody</code>, then there will be no <code>table</code>. </p></li><li><p>The <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> surrounding the <code>thead</code> element ensures that the <code>thead</code> element is not output unless the <code>tbody</code> element is output. </p></li><li><p>The <a href="#element-where-populated"><code>xsl:where-populated</code></a> around the <code>tbody</code> element ensures that the <code>tbody</code> element is not output unless there is at least one table row (<code>tr</code>). </p></li><li><p>The <a href="#element-on-empty"><code>xsl:on-empty</code></a> around the <code>p</code> element ensures that if no <code>table</code> is output, then the paragraph <code>There are no students</code> is output instead. </p></li></ul></div></div></div></div><div class="div1"><h2><a id="variables-and-parameters"></a>9 <a href="#variables-and-parameters" style="text-decoration: none">Variables and Parameters</a></h2><p><span class="definition">[Definition:&nbsp;</span><a id="dt-variable-binding-element" title="variable-binding element"></a>The two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to as <b>variable-binding elements</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-variable" title="variable"></a>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-parameter" title="parameter"></a>The <a href="#element-param"><code>xsl:param</code></a> element declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that its value can be set by the caller.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-value" title="value"></a>A variable is a binding between a name and a value. The <b>value</b> of a variable is any sequence (of nodes, atomic values, and/or function items), as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>.<span class="definition">]</span></p><div class="div2"><h3><a id="variables"></a>9.1 <a href="#variables" style="text-decoration: none">Variables</a></h3><p class="element-syntax"><a id="element-variable"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:variable<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;static? = <var>boolean</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:variable&gt;</code></p><p>The <a href="#element-variable"><code>xsl:variable</code></a> element has a <span class="verb">required</span><code>name</code> attribute, which specifies the name of the variable. The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p><p>The <a href="#element-variable"><code>xsl:variable</code></a> element has an optional <code>as</code> attribute, which specifies the <a title="required type" class="termref" href="#dt-required-type">required type</a> of the variable. The value of the <code>as</code> attribute is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-supplied-value" title="supplied value"></a>The value of the variable is computed using the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. This value is referred to as the <b>supplied value</b> of the variable.<span class="definition">]</span> If the <a href="#element-variable"><code>xsl:variable</code></a> element has a <code>select</code> attribute, then the sequence constructor <span class="verb">must</span> be empty.</p><p>If the <code>as</code> attribute is specified, then the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is converted to the required type, using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p><a id="err-XTTE0570"><span class="error">[ERR XTTE0570] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a variable cannot be converted to the required type. </p><p>If the <code>as</code> attribute is omitted, the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is used directly, and no conversion takes place.</p><p>For the effect of the <code>static</code> attribute, see <a href="#static-params"><i>9.6 Static Variables and Parameters</i></a>.</p><p>The <code>visibility</code> attribute <span class="verb">must not</span> be specified for a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>: that is, it is allowed only when the parent element is <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, <a href="#element-package"><code>xsl:package</code></a> or <a href="#element-override"><code>xsl:override</code></a>.</p><p>If the <code>visibility</code> attribute is present with the value <code>abstract</code> then the <code>select</code> attribute <span class="verb">must</span> be absent and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a><span class="verb">must</span> be empty. In this situation there is no <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>, and therefore the constraint that the supplied value is consistent with the required type does not apply.</p></div><div class="div2"><h3><a id="parameters"></a>9.2 <a href="#parameters" style="text-decoration: none">Parameters</a></h3><p class="element-syntax"><a id="element-param"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;required? = <var>boolean</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var><br>&nbsp;&nbsp;static? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:param&gt;</code></p><p>The <a href="#element-param"><code>xsl:param</code></a> element may be used:</p><ul><li><p>As a child of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-package"><code>xsl:package</code></a>, to define a parameter to the transformation. <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">Stylesheet parameters</a> are set by the calling application: see <a href="#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>. </p></li><li><p>As a child of <a href="#element-template"><code>xsl:template</code></a> to define a parameter to a template, which may be supplied when the template is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>. <a title="template parameter" class="termref" href="#dt-template-parameter">Template parameters</a> are set by means of an <a href="#element-with-param"><code>xsl:with-param</code></a> child element of the invoking instruction, as described in <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>.</p></li><li><p>As a child of <a href="#element-function"><code>xsl:function</code></a> to define a parameter to a stylesheet function, which may be supplied when the function is called from an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>. <a title="function parameter" class="termref" href="#dt-function-parameter">Function parameters</a> are set <span>either positionally or by keyword</span> by means of the argument list in an XPath function call. </p></li><li><p>As a child of <a href="#element-iterate"><code>xsl:iterate</code></a> to define a parameter that can vary from one iteration to the next. Iteration parameters always take their default values for the first iteration, and in subsequent iterations are set using an <a href="#element-with-param"><code>xsl:with-param</code></a> child of the <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction.</p></li></ul><p>The attributes applicable to <a href="#element-param"><code>xsl:param</code></a> depend on its parent element in the stylesheet, as defined by the following table:</p><table class="data"><caption>Attributes of the <code>xsl:param</code> Element</caption><thead><tr><th style="text-align:left; vertical-align:top">Parent Element</th><th style="text-align:left; vertical-align:top">name</th><th style="text-align:left; vertical-align:top">select</th><th style="text-align:left; vertical-align:top">as</th><th style="text-align:left; vertical-align:top">required</th><th style="text-align:left; vertical-align:top">tunnel</th><th style="text-align:left; vertical-align:top">static</th></tr></thead><tbody><tr><th style="text-align:left; vertical-align:top"><a href="#element-package"><code>xsl:package</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-stylesheet"><code>xsl:stylesheet</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-template"><code>xsl:template</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top">yes|<b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-function"><code>xsl:function</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top"><b>yes</b>|no</td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td></tr><tr><th style="text-align:left; vertical-align:top"><a href="#element-iterate"><code>xsl:iterate</code></a></th><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">mandatory</td><td style="text-align:left; vertical-align:top">optional</td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td><td style="text-align:left; vertical-align:top"><b>no</b></td></tr></tbody></table><p>In the table, the entries for the <code>name</code>, <code>select</code>, and <code>as</code> attributes indicate whether the attribute must appear, is optional, or must be absent; the entries for the <code>required</code>, <code>tunnel</code>, and <code>static</code> attributes indicate the values that are permitted if the attribute is present, with the default value shown in bold. (The value <code>yes</code> can also be written <code>true</code> or <code>1</code>, while <code>no</code> can also be written <code>false</code> or <code>0</code>.)</p><p>The <code>name</code> attribute is mandatory: it specifies the name of the parameter. The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p><p><a id="err-XTSE0580"><span class="error">[ERR XTSE0580] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the values of the <code>name</code> attribute of two sibling <a href="#element-param"><code>xsl:param</code></a> elements represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>. </p><p>If the <a href="#element-param"><code>xsl:param</code></a> element has a <code>select</code> attribute, then the sequence constructor <span class="verb">must</span> be empty.</p><p>The <code>static</code> attribute can take the value <code>yes</code> only on <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and is explained in <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Local variables may <a title="shadows" class="termref" href="#dt-shadows">shadow</a> template parameters and function parameters: see <a href="#scope-of-variables"><i>9.9 Scope of Variables</i></a>.</p></div><p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The default is <code>no</code>; the value <code>yes</code> may be specified only for <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>. Tunnel parameters are described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a></p><div class="div3"><h4><a id="parameter-type"></a>9.2.1 <a href="#parameter-type" style="text-decoration: none">The Required Type of a Parameter</a></h4><p>The <a href="#element-param"><code>xsl:param</code></a> element has an optional <code>as</code> attribute, which specifies the <a title="required type" class="termref" href="#dt-required-type">required type</a> of the parameter. The value of the <code>as</code> attribute is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>. If the <code>as</code> attribute is omitted, then the required type is <code>item()*</code>.</p><p>The <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the parameter is the value supplied by the caller. If no value was supplied by the caller, and if the parameter is not mandatory, then the default value is used as the supplied value as described in <a href="#default-values-of-parameters"><i>9.2.2 Default Values of Parameters</i></a>.</p><p>The <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the parameter is converted to the <a title="required type" class="termref" href="#dt-required-type">required type</a> using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p><a id="err-XTTE0590"><span class="error">[ERR XTTE0590] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the conversion of the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a parameter, or of the context item, does not match the <a title="required type" class="termref" href="#dt-required-type">required type</a>, after applying any permitted conversions. [XSLT 3.0 Erratum E22, bug 30238]. </p></div><div class="div3"><h4><a id="default-values-of-parameters"></a>9.2.2 <a href="#default-values-of-parameters" style="text-decoration: none">Default Values of Parameters</a></h4><p>The optional <code>required</code> attribute of <a href="#element-param"><code>xsl:param</code></a> may be used to indicate whether a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a><span>, or <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a></span> is mandatory or optional. The only value permitted for a parameter to <a href="#element-iterate"><code>xsl:iterate</code></a> is <code>no</code> (these are always initialized to a default value).</p><p>The default value for a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a> is <code>required="yes"</code>; in all other cases it is <code>required="no"</code>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-explicitly-mandatory" title="explicitly mandatory"></a>A parameter is <b>explicitly mandatory</b> if it is a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a><span>with no <code>required</code> attribute</span>, or if the <code>required</code> attribute is present and has the value <code>yes</code>.<span class="definition">]</span> If a parameter is explicitly mandatory, then the <a href="#element-param"><code>xsl:param</code></a> element <span class="verb">must</span> be empty and <span class="verb">must not</span> have a <code>select</code> attribute.</p><p>The static context for evaluating the default value depends on where the relevant expression appears in the stylesheet, in the usual way. Note however that for <a href="#element-param"><code>xsl:param</code></a> elements defining <a title="function parameter" class="termref" href="#dt-function-parameter">function parameters</a>, the static context does not include variables bound in preceding-sibling <a href="#element-param"><code>xsl:param</code></a> elements.</p><p>The dynamic context is different for different kinds of parameter:</p><ul><li><p>For <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, the context is the same as the context for evaluating global variables.</p></li><li><p>For <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>, the context is that of the called template. This means that the evaluation of the default has access to the other parameters supplied in the call, provided they are declared earlier. It also means, for example, that if the evaluation of the default value invokes <a href="#element-next-match"><code>xsl:next-match</code></a>, the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is the called template rather than the calling template.</p></li><li><p>For <a title="function parameter" class="termref" href="#dt-function-parameter">function parameters</a>, the dynamic context for evaluating defaults is the dynamic context of the caller, except that no local variables are in scope. This means that it is possible to declare a parameter with <code>&lt;xsl:param name="dot" required="no" select="."/&gt;</code> to take its default value from the context item of the caller. </p></li></ul><p>If a parameter is not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a>, then it may have a default value. The default value is obtained by evaluating the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification does not dictate whether and when the default value of a parameter is evaluated. For example, if the default is specified as <code>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then it is not specified whether a distinct <code>foo</code> element node will be created on each invocation of the template, or whether the same <code>foo</code> element node will be used for each invocation. However, it is permissible for the default value to depend on the values of other parameters, or on the evaluation context, in which case the default must effectively be evaluated on each invocation.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-explicit-default" title="explicit default"></a>An <b>explicit default</b> for a parameter is indicated by the presence of either a <code>select</code> attribute or a non-empty sequence constructor.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-implicit-default" title="implicit default"></a>If a parameter that is not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> has no <a title="explicit default" class="termref" href="#dt-explicit-default">explicit default</a> value, then it has an <b>implicit default</b> value, which is the empty sequence if there is an <code>as</code> attribute, or a zero-length string if not.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-implicitly-mandatory" title="implicitly mandatory"></a>If a parameter has an <a title="implicit default" class="termref" href="#dt-implicit-default">implicit default</a> value which cannot be converted to the <a title="required type" class="termref" href="#dt-required-type">required type</a> (that is, if it has an <code>as</code> attribute which does not permit the empty sequence), then the parameter is <b>implicitly mandatory</b>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of these rules is that specifying <code>&lt;xsl:param name="p" as="xs:date" select="2"/&gt;</code> is an error, but if the default value of the parameter is never used, then the processor has discretion whether or not to report the error. By contrast, <code>&lt;xsl:param name="p" as="xs:date"/&gt;</code> is treated as if <code>required="yes"</code> had been specified: the empty sequence is not a valid instance of <code>xs:date</code>, so in effect there is no default value and the parameter is therefore treated as being mandatory.</p></div><p>Various errors can arise with regard to mandatory parameters when no value is supplied. In the rules below, <b>non-tunnel</b> means: not having a <code>tunnel</code> attribute with the value <code>yes</code>.</p><ul><li><p><a id="err-XTSE3520"><span class="error">[ERR XTSE3520] </span></a>It is a static error if a parameter to <a href="#element-iterate"><code>xsl:iterate</code></a> is <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a>. </p></li><li><p><a id="err-XTSE0690"><span class="error">[ERR XTSE0690] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains both (a) a named template named <var>T</var> that is not overridden by another named template of higher import precedence and that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> non-tunnel parameter named <var>P</var>, and (b) an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute equals <var>T</var> and that has no non-tunnel <a href="#element-with-param"><code>xsl:with-param</code></a> child element whose <code>name</code> attribute equals <var>P</var>. (All names are compared as QNames.) </p></li><li><p><a id="err-XTDE0700"><span class="error">[ERR XTDE0700] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a template that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a> parameter is invoked without supplying a value for that parameter. </p><p>This includes the following cases:</p><ul><li><p>The template is invoked using <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a> and there is no <a href="#element-with-param"><code>xsl:with-param</code></a> child whose <code>name</code> and <code>tunnel</code> attributes match the corresponding attributes of the mandatory parameter.</p></li><li><p>The mandatory parameter is a tunnel parameter, and the template is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a>, and there is no <a href="#element-with-param"><code>xsl:with-param</code></a> child whose <code>name</code> and <code>tunnel</code> attributes match the corresponding attributes of the mandatory parameter.</p></li><li><p>The template is invoked as the entry point to the transformation, either by invoking an initial mode (<a href="#invoking-initial-mode"><i>2.3.3 Apply-Templates Invocation</i></a>) or by invoking an initial template (<a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a>) and no value is supplied for the mandatory parameter by the calling application.</p></li></ul></li></ul></div></div><div class="div2"><h3><a id="variable-values"></a>9.3 <a href="#variable-values" style="text-decoration: none">Values of Variables and Parameters</a></h3><p>A <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> may specify the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a <a title="variable" class="termref" href="#dt-variable">variable</a> or the default value of a <a title="parameter" class="termref" href="#dt-parameter">parameter</a> in four different ways.</p><ul><li><p>If the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code> attribute, then the value of the attribute <span class="verb">must</span> be an <a title="expression" class="termref" href="#dt-expression">expression</a> and the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is the value that results from evaluating the expression. In this case, the content of the variable-binding element <span class="verb">must</span> be empty.</p></li><li><p>If the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has empty content and has neither a <code>select</code> attribute nor an <code>as</code> attribute, then the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is a zero-length string. Thus</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>is equivalent to</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></li><li><p>If a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has no <code>select</code> attribute and has non-empty content (that is, the variable-binding element has one or more child nodes), and has no <code>as</code> attribute, then the content of the variable-binding element specifies the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>. The content of the variable-binding element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>; a new document is constructed with a document node having as its children the sequence of nodes that results from evaluating the sequence constructor and then applying the rules given in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>. The value of the variable is then a singleton sequence containing this document node. For further information, see <a href="#temporary-trees"><i>9.4 Creating Implicit Document Nodes</i></a>. </p></li><li><p>If a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has an <code>as</code> attribute but no <code>select</code> attribute, then the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> is the sequence that results from evaluating the (possibly empty) <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained within the variable-binding element (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>). </p></li></ul><p>These combinations are summarized in the table below.</p><table class="data"><caption>Effect of Different Attribute Combinations on <code>xsl:variable</code></caption><thead><tr><th style="text-align:left; vertical-align:top">select attribute</th><th style="text-align:left; vertical-align:top">as attribute</th><th style="text-align:left; vertical-align:top">content</th><th style="text-align:left; vertical-align:top">Effect</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top">Value is obtained by evaluating the <code>select</code> attribute</td></tr><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top">Value is obtained by evaluating the <code>select</code> attribute, adjusted to the type required by the <code>as</code> attribute</td></tr><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">Static error</td></tr><tr><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">Static error</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top">Value is a zero-length string</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">empty</td><td style="text-align:left; vertical-align:top">Value is an empty sequence, provided the <code>as</code> attribute permits an empty sequence</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">Value is a document node whose content is obtained by evaluating the sequence constructor</td></tr><tr><td style="text-align:left; vertical-align:top">absent</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">present</td><td style="text-align:left; vertical-align:top">Value is obtained by evaluating the sequence constructor, adjusted to the type required by the <code>as</code> attribute</td></tr></tbody></table><p><a id="err-XTSE0620"><span class="error">[ERR XTSE0620] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code> attribute and has non-empty content. </p><div class="example"><div class="exampleHeader"><a id="d8e24091"></a><a id="d8e24197"></a>Example: Values of Variables</div><p>The value of the following variable is the sequence of integers (1, 2, 3):</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">i</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer*</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The value of the following variable is an integer, assuming that the attribute <code>@size</code> exists, and is annotated either as an integer, or as <code>xs:untypedAtomic</code>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">i</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">size</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The value of the following variable is a zero-length string:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">z</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The value of the following variable is a document node containing an empty element as a child:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">doc</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">c</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The value of the following variable is a sequence of integers (2, 4, 6):</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">seq</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">3</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="qname">*2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The value of the following variable is a sequence of parentless attribute nodes:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">attset</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">attribute()+</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">x</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">2</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">y</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">3</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">z</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">4</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The value of the following variable is an empty sequence:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">empty</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">empty-sequence()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>The actual value of the variable depends on the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>, as described above, and the required type, which is determined by the value of the <code>as</code> attribute.</p><div class="example"><div class="exampleHeader"><a id="d8e24127"></a><a id="d8e24233"></a>Example: Pitfalls with Numeric Predicates</div><p>When a variable is used to select nodes by position, be careful not to do:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">n</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">2</span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">td</span><span class="filter">[</span><span class="variable">$n</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>This will output the values of all the <code>td</code> elements, space-separated (or with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, the value of the first <code>td</code> element), because the variable <code>n</code> will be bound to a node, not a number. Instead, do one of the following:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">n</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">td</span><span class="filter">[</span><span class="variable">$n</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>or</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">n</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">2</span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">td</span><span class="filter">[</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">=</span><span class="variable">$n</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>or</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">n</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">2</span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">td</span><span class="filter">[</span><span class="variable">$n</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="temporary-trees"></a>9.4 <a href="#temporary-trees" style="text-decoration: none">Creating Implicit Document Nodes</a></h3><p>A document node is created implicitly when evaluating an <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, or <a href="#element-with-param"><code>xsl:with-param</code></a> element that has non-empty content and that has no <code>as</code> attribute. The value of the <a title="variable" class="termref" href="#dt-variable">variable</a> is this newly constructed document node. The content of the document node is formed from the result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained within the variable-binding element, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The construct:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">tree</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">a</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>can be regarded as a shorthand for:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">tree</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">document-node()</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:document</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">preserve</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">a</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>The base URI of the document node is taken from the base URI of the variable binding element in the stylesheet. (See <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2 base-uri Accessor </a><sup><small>DM30</small></sup> in <a href="#xpath-datamodel-30">[XDM 3.0]</a>)</p><p>No document-level validation takes place (which means, for example, that there is no checking that ID values are unique). However, <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> on nodes within the new tree are copied unchanged.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The base URI of other nodes in the tree is determined by the rules for constructing complex content (see <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>). The effect of these rules is that the base URI of a node in the temporary tree is determined as if all the nodes in the temporary tree came from a single entity whose URI was the base URI of the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a>. Thus, the base URI of the document node will be equal to the base URI of the variable-binding element, while an <code>xml:base</code> attribute within the temporary tree will change the base URI for its parent element and that element’s descendants, just as it would within a document constructed by parsing.</p></div><p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the new document node are set to empty.</p><p>A <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> is available for processing in exactly the same way as any source document. For example, its nodes are accessible using path expressions, and they can be processed using instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a>. Also, the <a href="#func-key"><code>key</code></a> and <a href="https://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup> functions can be used to find nodes within a temporary tree, by supplying the document node at the root of the tree as an argument to the function or by making it the context node.</p><div class="example"><div class="exampleHeader"><a id="d8e24219"></a><a id="d8e24325"></a>Example: Two-Phase Transformation</div><p>The following stylesheet uses a temporary tree as the intermediate result of a two-phase transformation, using different <a title="mode" class="termref" href="#dt-mode">modes</a> for the two phases (see <a href="#modes"><i>6.7 Modes</i></a>). Typically, the template rules in module <code>phase1.xsl</code> will be declared with <code>mode="phase1"</code>, while those in module <code>phase2.xsl</code> will be declared with <code>mode="phase2"</code>: </p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:import</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">phase1.xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:import</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="href">phase2.xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">intermediate</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">phase1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$intermediate</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">phase2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The algorithm for matching nodes against template rules is exactly the same regardless which tree the nodes come from. If different template rules are to be used when processing different trees, then unless nodes from different trees can be distinguished by means of <a title="pattern" class="termref" href="#dt-pattern">patterns</a>, it is a good idea to use <a title="mode" class="termref" href="#dt-mode">modes</a> to ensure that each tree is processed using the appropriate set of template rules.</p></div></div><div class="div2"><h3><a id="global-variables"></a>9.5 <a href="#global-variables" style="text-decoration: none">Global Variables and Parameters</a></h3><p>Both <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are allowed as <a title="declaration" class="termref" href="#dt-declaration">declaration</a> elements: that is, they may appear as children of the <a href="#element-package"><code>xsl:package</code></a> or <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-global-variable" title="global variable"></a>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> declares a <b>global variable</b> that is visible everywhere <span>except (a) within the <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element itself, (b) within any other global variable declaration that binds a variable with the same name, and (c) within any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding.</span>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-parameter" title="stylesheet parameter"></a>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a href="#element-param"><code>xsl:param</code></a> element declares a <b>stylesheet parameter</b>. A stylesheet parameter is a global variable with the additional property that its value can be supplied by the caller when a transformation is initiated.<span class="definition">]</span> As described in <a href="#parameters"><i>9.2 Parameters</i></a>, a stylesheet parameter may be declared as being mandatory, or may have a default value specified for use when no value is supplied by the caller. The mechanism by which the caller supplies a value for a stylesheet parameter is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. An XSLT <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">must</span> provide such a mechanism.</p><p>It is an error if no value is supplied for a mandatory stylesheet parameter <span class="error">[see <a href="#err-XTDE0050">ERR XTDE0050</a>]</span>.</p><p>If a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> contains more than one binding for a global variable of a particular name, then the binding with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p><a id="err-XTSE0630"><span class="error">[ERR XTSE0630] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more than one non-hidden binding of a global variable with the same name and same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains another binding with the same name and higher import precedence. </p><p>For a global variable or the default value of a stylesheet parameter, the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the variable value is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> as follows:</p><ul><li><p>If the declaration appears within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> (including within an <a href="#element-override"><code>xsl:override</code></a> element in the top-level package), then the focus is based on the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if supplied, or <a title="absent" class="termref" href="#dt-absent">absent</a> otherwise.</p></li><li><p>If the declaration appears within a <a title="library package" class="termref" href="#dt-library-package">library package</a>, then the focus is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></li></ul><p>An XPath error will be reported if the evaluation of a global variable or parameter references the context item, context position, or context size when the <a title="focus" class="termref" href="#dt-focus">focus</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>. The values of other components of the dynamic context are the initial values as defined in <a href="#xpath-dynamic-context"><i>5.3.4 Initializing the Dynamic Context</i></a> and <a href="#additional-dynamic-context"><i>5.3.5 Additional Dynamic Context Components used by XSLT</i></a>.</p><p>The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> is always (implicitly) <code>private</code> if the parameter is <code>static</code>, or <code>public</code> if the parameter is non-static.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This rule has the effect that after combining all the packages making up a stylesheet, the non-static stylesheet parameters whose values are required necessarily have distinct names, which simplifies the design of APIs.</p></div><p>For the effect of the <code>static</code> attribute, see <a href="#static-params"><i>9.6 Static Variables and Parameters</i></a>.</p><p>The <code>visibility</code> attribute <span class="verb">must not</span> be specified for a local variable: that is, it is allowed only when the parent element is <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a>.</p><p>If the <code>visibility</code> attribute is present with the value <code>abstract</code> then the <code>select</code> attribute <span class="verb">must</span> be absent and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a><span class="verb">must</span> be empty. In this situation there is no <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>, and therefore the constraint that the supplied value is consistent with the required type does not apply.</p><div class="example"><div class="exampleHeader"><a id="d8e24440"></a><a id="d8e24546"></a>Example: A Stylesheet Parameter</div><p>The following example declares a global parameter <code>para-font-size</code>, which is referenced in an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">para-font-size</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">12pt</span><span class="ez">&lt;/</span><span class="clxsl">xsl:param</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">para</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="z"></span><span class="atn">font-size</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$para-font-size</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The implementation must provide a mechanism allowing the user to supply a value for the parameter <code>para-font-size</code> when invoking the stylesheet; the value <code>12pt</code> acts as a default.</p></div></div><div class="div2"><h3><a id="static-params"></a>9.6 <a href="#static-params" style="text-decoration: none">Static Variables and Parameters</a></h3><p>Static variables and parameters are global variables and can be used in the same way as other global variables. In addition, they can be used in <code>[xsl:]use-when</code> expressions and in shadow attributes.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-static-variable" title="static variable"></a>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> having the attribute <code>static="yes"</code> declares a <b>static variable</b>: that is, a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> whose value is known during static analysis of the stylesheet.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-static-parameter" title="static parameter"></a>A <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declared using an <a href="#element-param"><code>xsl:param</code></a> element is referred to as a <b>static parameter</b>.<span class="definition">]</span></p><p>The <code>static</code> attribute <span class="verb">must not</span> take the value <code>yes</code> on an <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element unless it is a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p><p>When the <code>static</code> attribute is present with the value <code>yes</code>, the <code>visibility</code> attribute <span class="verb">must not</span> have a value other than <code>private</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This rule prevents static variables being overridden in another package. Since the values of such variables may be used at compile time (for example, during processing of <code>[xsl:]use-when</code> expressions), the rule is necessary to ensure that packages can be independently compiled.</p><p>It is possible to make the value of a static variable or parameter available in a using package by binding a non-static public variable to its value, for example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">DEBUG</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">true</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">tracing</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">visibility</span><span class="atneq">=</span><span class="z">"</span><span class="av">public</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$DEBUG</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>When the attribute <code>static="yes"</code> is specified, the <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element <span class="verb">must</span> have empty content. In the case of <a href="#element-variable"><code>xsl:variable</code></a> the <code>select</code> attribute must be present to define the value of the variable <span class="error">[see <a href="#err-XTSE0010">ERR XTSE0010</a>]</span>.</p><p>If the <code>select</code> attribute is present, then it is evaluated using the rules for <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>.</p><p>The rules for the scope of static variables, and the handling of duplicate declarations, are similar to the rules for non-static variables, but with additional constraints designed to disallow forwards references. The reason for disallowing forwards references is to ensure that <code>use-when</code> attributes can always be evaluated as early as possible, and in particular to ensure that the value of a <code>use-when</code> attribute never has circular dependencies. The additional constraints are as follows:</p><ol class="enumar"><li><p>The static context for evaluation of a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a> only contains those <a title="static variable" class="termref" href="#dt-static-variable">static variables</a> visible within the containing package whose declarations occur prior to the element containing the static expression in stylesheet tree order. Stylesheet tree order is the order that results when all <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a> declarations are replaced by the declarations in the imported or included stylesheet module. A static variable is not in scope within its own declaration.</p></li><li><p>If two static variables declared within the same package have the same name, the one that has higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used (it is a consequence of rules defined elsewhere that there cannot be more than one declaration with highest import precedence). However, if the declaration with higher import precedence occurs after the one with lower import precedence in stylesheet tree order, then the two declarations must be consistent. For this purpose two declarations are consistent if (a) they are either both <a href="#element-variable"><code>xsl:variable</code></a> elements, or both <a href="#element-param"><code>xsl:param</code></a> elements, and (b) if the variables are initialized (that is, if the elements are <a href="#element-variable"><code>xsl:variable</code></a> elements, or if they are <a href="#element-param"><code>xsl:param</code></a> elements and no value for the parameter is externally supplied) then the values of both variables must be <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-identical">identical</a><sup><small>FO40</small></sup>, and must not contain function items.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This rule ensures that when a static variable reference is encountered, the value of the most recently declared static variable with that name can be used, knowing that this value cannot be overridden by a subsequent declaration having higher import precedence.</p></div><p><a id="err-XTSE3450"><span class="error">[ERR XTSE3450] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a variable declared with <code>static="yes"</code> is inconsistent with another static variable of the same name that is declared earlier in stylesheet tree order and that has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not an error to have two global variables or parameters with the same name, one static and one non-static, provided that they have different import precedence. If the static variable has higher precedence, then it will be used as the selected binding for all global variable references with this name, whether or not they appear in static expressions. If the non-static variable has higher precedence, then the static variable will be used as the selected binding for variable references appearing in static expressions, while the non-static variable will be used for variable references in non-static expressions. The two variables may have different values. In the case of global parameters, however, a transformation API may restrict them to have the same value.</p><p>If the two variable declarations have the same import precedence, and there is no declaration with higher import precedence, then error condition <span class="error">[see <a href="#err-XTSE0630">ERR XTSE0630</a>]</span> applies. [XSLT 3.0 Erratum E34, bug 30301].</p></div></div><div class="div2"><h3><a id="static-expression"></a>9.7 <a href="#static-expression" style="text-decoration: none">Static Expressions</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-static-expression" title="static expression"></a>A <b>static expression</b> is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> whose value must be computed during static analysis of the stylesheet.<span class="definition">]</span></p><p>Static expressions appear in a number of contexts, in particular:</p><ul><li><p>In <code>[xsl:]use-when</code> attributes (see <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>);</p></li><li><p>In the <code>select</code> attribute of <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declarations (<a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> with <code>static="yes"</code>);</p></li><li><p>In shadow attributes (see <a href="#shadow-attributes"><i>3.13.4 Shadow Attributes</i></a>).</p></li></ul><p>There are no syntactic constraints on the XPath expression that can be used as a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>. However, there are severe constraints on the information provided in its evaluation context. These constraints are designed to ensure that the expression can be evaluated at the earliest possible stage of stylesheet processing, without any dependency on information contained in the stylesheet itself or in any source document.</p><p>Specifically, the components of the static and dynamic context are defined by the following two tables:</p><table class="def"><caption>Static Context Components for Static Expressions</caption><thead><tr><th style="text-align:left; vertical-align:top">Component</th><th style="text-align:left; vertical-align:top">Value</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">XPath 1.0 compatibility mode</td><td style="text-align:left; vertical-align:top">false</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known namespaces</td><td style="text-align:left; vertical-align:top">determined by the in-scope namespaces for the containing element in the stylesheet</td></tr><tr><td style="text-align:left; vertical-align:top">Default element namespace</td><td style="text-align:left; vertical-align:top">determined by the <code>xpath-default-namespace</code> attribute if present (see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>); otherwise the null namespace</td></tr><tr><td style="text-align:left; vertical-align:top">Default type namespace</td><td style="text-align:left; vertical-align:top">determined by the <code>xpath-default-namespace</code> attribute if present (see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>); otherwise the null namespace</td></tr><tr><td style="text-align:left; vertical-align:top">Function name resolver</td><td style="text-align:left; vertical-align:top">Prefixed function names are resolved using the in-scope namespaces of the containing element; unprefixed function names are taken as being in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>. </td></tr><tr><td style="text-align:left; vertical-align:top">In-scope schema types</td><td style="text-align:left; vertical-align:top">The type definitions that would be available in the absence of any <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration</td></tr><tr><td style="text-align:left; vertical-align:top">In-scope element declarations</td><td style="text-align:left; vertical-align:top">None</td></tr><tr><td style="text-align:left; vertical-align:top">In-scope attribute declarations</td><td style="text-align:left; vertical-align:top">None</td></tr><tr><td style="text-align:left; vertical-align:top">In-scope variables</td><td style="text-align:left; vertical-align:top">The <a title="static variable" class="termref" href="#dt-static-variable">static variables</a> visible within the containing package whose declarations occur prior to the element containing the static expression in stylesheet tree order. Stylesheet tree order is the order that results when all <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a> declarations are replaced by the declarations in the imported or included stylesheet module. A static variable is not in scope within its own declaration, and it is in scope only within its declaring package, not in any using packages. If two static variables satisfying this rule have the same name and are both in scope, the one that appears most recently in stylesheet tree order is used; as a consequence of rules defined elsewhere this will always be consistent with the declaration having highest import precedence.</td></tr><tr><td style="text-align:left; vertical-align:top">Context item static type</td><td style="text-align:left; vertical-align:top"><a title="absent" class="termref" href="#dt-absent">Absent</a></td></tr><tr><td style="text-align:left; vertical-align:top">Statically known function signatures</td><td style="text-align:left; vertical-align:top">The functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in the <code>fn</code><code>math</code>, <span><code>map</code>, and <code>array</code></span> namespaces, together with: <ol class="enumar"><li><p>the functions <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-available-system-properties"><code>available-system-properties</code></a>, and <a href="#func-system-property"><code>system-property</code></a> defined in this specification;</p></li><li><p>functions that appear in both this specification and in <a href="#xpath-functions-31">[Functions and Operators 3.1]</a> (for example, the functions in the <code>map</code> namespaces, and a few others such as <code>collation-key</code> and <code>json-to-xml</code>);</p></li><li><p>constructor functions for built-in types;</p></li><li><p>the set of extension functions that are present in the static context of every XPath expression (other than a static expression) within the content of the element that contains the static expression. </p></li></ol> Note that <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> are <em>not</em> included in the context, which means that the function <a href="#func-function-available"><code>function-available</code></a> will return <code>false</code> in respect of such functions, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> will fail to find them. The effect of this rule is to ensure that <a href="#func-function-available"><code>function-available</code></a> returns true in respect of functions that can be called within the static expression. It also has the effect that these extension functions will be recognized within the static expression itself; however, the fact that a function is available in this sense gives no guarantee that a call on the function will succeed.</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known collations</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default collation</td><td style="text-align:left; vertical-align:top">The Unicode Codepoint Collation</td></tr><tr><td style="text-align:left; vertical-align:top">Static Base URI</td><td style="text-align:left; vertical-align:top">The base URI of the containing element in the stylesheet document (see <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-base-uri">Section 5.2 base-uri Accessor </a><sup><small>DM30</small></sup>)</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known documents</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known collections</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known default collection type</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Statically known decimal formats</td><td style="text-align:left; vertical-align:top">A single unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a> equivalent to the decimal format that is created by an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration with no attributes.</td></tr></tbody></table><p>&nbsp;</p><table class="def"><caption>Dynamic Context Components for Static Expressions</caption><thead><tr><th style="text-align:left; vertical-align:top">Component</th><th style="text-align:left; vertical-align:top">Value</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">Context item, position, and size</td><td style="text-align:left; vertical-align:top"><a title="absent" class="termref" href="#dt-absent">Absent</a></td></tr><tr><td style="text-align:left; vertical-align:top">Variable values</td><td style="text-align:left; vertical-align:top">A value for every variable present in the in-scope variables. For <a title="static parameter" class="termref" href="#dt-static-parameter">static parameters</a> where an external value is supplied: the externally supplied value of the parameter. In all other cases: the value of the variable as defined in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>.</td></tr><tr><td style="text-align:left; vertical-align:top">Named functions</td><td style="text-align:left; vertical-align:top">The function implementation corresponding to each function signature in the statically known function signatures</td></tr><tr><td style="text-align:left; vertical-align:top">Current dateTime</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Implicit timezone</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default language</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default calendar</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default place</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Available documents</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Available collections</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Default collection</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr><tr><td style="text-align:left; vertical-align:top">Environment variables</td><td style="text-align:left; vertical-align:top">Implementation-defined</td></tr></tbody></table><p>Within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, all static expressions are evaluated in a single <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO40</small></sup>. This need not be the same execution scope as that used for static expressions in other stylesheet modules, or as that used when evaluating XPath expressions appearing elsewhere in the stylesheet module. This means that a function such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-current-date"><code>current-date</code></a><sup><small>FO30</small></sup> will return the same result when called in different <code>[xsl:]use-when</code> expressions within the same stylesheet module, but will not necessarily return the same result as the same call in an <code>[xsl:]use-when</code> expression within a different stylesheet module, or as a call on the same function executed during the transformation proper.</p><p>If a <a title="static error" class="termref" href="#dt-static-error">static error</a> is present in a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>, it is treated in the same way as any other static error in the stylesheet module. If a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during evaluation of a static expression, it is treated as a static error in the analysis of the stylesheet, while retaining its original error code.</p></div><div class="div2"><h3><a id="local-variables"></a>9.8 <a href="#local-variables" style="text-decoration: none">Local Variables and Parameters</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-local-variable" title="local variable"></a>As well as being allowed as a <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, the <a href="#element-variable"><code>xsl:variable</code></a> element is also allowed in <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a>. Such a variable is known as a <b>local variable</b>.<span class="definition">]</span></p><p>An <a href="#element-param"><code>xsl:param</code></a> element may also be used to create a variable binding with local scope:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-template-parameter" title="template parameter"></a> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-template"><code>xsl:template</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>template parameter</b>. A template parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the template is called, using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-function-parameter" title="function parameter"></a> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-function"><code>xsl:function</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>function parameter</b>. A function parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the function is called, using a function call in an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.<span class="definition">]</span></p></li><li><p>An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. This defines a parameter whose value may be initialized on entry to the iteration, and which may be varied each time round the iteration by use of an <a href="#element-with-param"><code>xsl:with-param</code></a> element in the <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction. </p></li></ul><p>The result of evaluating a local <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element (that is, the contribution it makes to the result of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> it is part of) is an empty sequence.</p></div><div class="div2"><h3><a id="scope-of-variables"></a>9.9 <a href="#scope-of-variables" style="text-decoration: none">Scope of Variables</a></h3><p>For any <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a>, there is a region (more specifically, a set of nodes) of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> within which the binding is visible. The set of variable bindings in scope for an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> consists of those bindings that are visible at the point in the stylesheet where the expression occurs.</p><p>A global <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding element</a> is visible everywhere in the containing <a title="package" class="termref" href="#dt-package">package</a> (including other <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a>) except within the <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element itself and any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding. (For rules regarding the visibility of the variable in other packages, see <a href="#visibility"><i>3.5.3.1 Visibility of Components</i></a>.) </p><p>A local <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding element</a> is visible for all following siblings and their descendants, with the following exceptions:</p><ol class="enumar"><li><p>It is not visible in any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding.</p></li><li><p>It is not visible within the subtree rooted at an <a href="#element-fallback"><code>xsl:fallback</code></a> instruction that is a sibling of the variable binding element.</p></li><li><p>It is not visible within the subtree rooted at an <a href="#element-catch"><code>xsl:catch</code></a> instruction that is a sibling of the variable binding element.</p></li><li><p>Within an <a href="#element-function"><code>xsl:function</code></a> declaration, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a> is not visible within sibling <a href="#element-param"><code>xsl:param</code></a> elements.</p></li></ol><p>The binding is not visible for the <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element itself.</p><p>If a binding is visible for an element then it is visible for every attribute of that element and for every text node child of that element.</p><p>An <a href="#element-param"><code>xsl:param</code></a> element specifying <code>tunnel="yes"</code> is also visible in the <code>test</code> attribute of the containing <a href="#element-template"><code>xsl:template</code></a> element.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-shadows" title="shadows"></a>Within a region of the stylesheet where a binding <var>B</var>1 is visible, <var>B<sub>1</sub></var> shadows another binding <var>B<sub>2</sub></var> having the same name as <var>B<sub>1</sub></var> if <var>B<sub>1</sub></var> occurs at a point where <var>B<sub>2</sub></var> is visible.<span class="definition">]</span> [XSLT 3.0 Erratum E5, bug 30171].</p><div class="example"><div class="exampleHeader"><a id="d8e25147"></a><a id="d8e25253"></a>Example: Local Variable Shadowing a Global Variable</div><p>The following is allowed:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">foo</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>It is also not an error if a binding established by a local <a href="#element-variable"><code>xsl:variable</code></a> element <a title="shadows" class="termref" href="#dt-shadows">shadows</a> a binding established by another local <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a>.</p><div class="example"><div class="exampleHeader"><a id="d8e25164"></a><a id="d8e25270"></a>Example: Misuse of Variable Shadowing</div><p>The following is not an error, but the effect is probably not what was intended. The template outputs <code>&lt;x value="1"/&gt;</code>, because the declaration of the inner variable named <code>$x</code> has no effect on the value of the outer variable named <code>$x</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">foo</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">5</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$x</span><span class="op">+</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">x</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$x</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Once a variable has been given a value, the value cannot subsequently be changed. XSLT does not provide an equivalent to the assignment operator available in many procedural programming languages. </p><p>This is because an assignment operator would make it harder to create an implementation that processes a document other than in a batch-like way, starting at the beginning and continuing through to the end.</p></div><p>As well as global variables and local variables, an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> may also declare range variables for use locally within an expression. For details, see <a href="#xpath-30">[XPath 3.0]</a>.</p><p>Where a reference to a variable occurs in an XPath expression, it is resolved first by reference to range variables that are in scope, then by reference to local variables and parameters, and finally by reference to global variables and parameters. A range variable may shadow a local variable or a global variable. XPath also allows a range variable to shadow another range variable.</p></div><div class="div2"><h3><a id="with-param"></a>9.10 <a href="#with-param" style="text-decoration: none">Setting Parameter Values</a></h3><p class="element-syntax"><a id="element-with-param"></a><code>&lt;xsl:with-param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:with-param&gt;</code></p><p>Parameters are passed to templates using the <a href="#element-with-param"><code>xsl:with-param</code></a> element. The <span class="verb">required</span><code>name</code> attribute specifies the name of the <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> (the variable the value of whose binding is to be replaced). The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p><p>The <a href="#element-with-param"><code>xsl:with-param</code></a> element is also used when passing parameters to an iteration of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, or to a dynamic invocation of an XPath expression using <a href="#element-evaluate"><code>xsl:evaluate</code></a>. In consequence, <a href="#element-with-param"><code>xsl:with-param</code></a> may appear within <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-evaluate"><code>xsl:evaluate</code></a>, <a href="#element-next-iteration"><code>xsl:next-iteration</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>. (Arguments to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, however, are supplied as part of an XPath function call: see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>.) </p><p><a id="err-XTSE0670"><span class="error">[ERR XTSE0670] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two or more sibling <a href="#element-with-param"><code>xsl:with-param</code></a> elements have <code>name</code> attributes that represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>. </p><p>The value of the parameter is specified in the same way as for <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> (see <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>), taking account of the values of the <code>select</code> and <code>as</code> attributes and the content of the <a href="#element-with-param"><code>xsl:with-param</code></a> element, if any.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is possible to have an <code>as</code> attribute on the <a href="#element-with-param"><code>xsl:with-param</code></a> element that differs from the <code>as</code> attribute on the corresponding <a href="#element-param"><code>xsl:param</code></a> element.</p><p>In this situation, the supplied value of the parameter will first be processed according to the rules of the <code>as</code> attribute on the <a href="#element-with-param"><code>xsl:with-param</code></a> element, and the resulting value will then be further processed according to the rules of the <code>as</code> attribute on the <a href="#element-param"><code>xsl:param</code></a> element.</p><p>For example, suppose the supplied value is a node with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untypedAtomic</code>, and the <a href="#element-with-param"><code>xsl:with-param</code></a> element specifies <code>as="xs:integer"</code>, while the <a href="#element-param"><code>xsl:param</code></a> element specifies <code>as="xs:double"</code>. Then the node will first be atomized and the resulting untyped atomic value will be cast to <code>xs:integer</code>. If this succeeds, the <code>xs:integer</code> will then be promoted to an <code>xs:double</code>.</p></div><p>The <a title="focus" class="termref" href="#dt-focus">focus</a> used for computing the value specified by the <a href="#element-with-param"><code>xsl:with-param</code></a> element is the same as that used for its parent <a title="instruction" class="termref" href="#dt-instruction">instruction</a>.</p><p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The default is <code>no</code>. Tunnel parameters are described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>. They are used only when passing parameters to templates: for an <a href="#element-with-param"><code>xsl:with-param</code></a> element that is a child of <a href="#element-evaluate"><code>xsl:evaluate</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> the <code>tunnel</code> attribute <span class="verb">must</span> either be omitted or take the value <code>no</code>. </p><p> In other cases it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the template that is invoked declares a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> with <code>required="yes"</code> and no value for this parameter is supplied by the calling instruction. <span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span></p></div><div class="div2"><h3><a id="circularity"></a>9.11 <a href="#circularity" style="text-decoration: none">Circular Definitions</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-circularity" title="circularity"></a>A <b>circularity</b> is said to exist if a construct such as a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, or a <a title="key" class="termref" href="#dt-key">key</a>, is defined in terms of itself. For example, if the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the value of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><var>X</var> references a global variable <var>Y</var>, then the value for <var>Y</var><span class="verb">must</span> be computed before the value of <var>X</var>. A circularity exists if it is impossible to do this for all global variable definitions.<span class="definition">]</span></p><div class="example"><div class="exampleHeader"><a id="d8e25412"></a><a id="d8e25518"></a>Example: Circular Variable Definitions</div><p>The following two declarations create a circularity:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$y</span><span class="op">+</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">y</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$x</span><span class="op">+</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e25417"></a><a id="d8e25523"></a>Example: Circularity involving Variables and Functions</div><p>The definition of a global variable can be circular even if no other variable is involved. For example the following two declarations (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a> for an explanation of the <a href="#element-function"><code>xsl:function</code></a> element) also create a circularity:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">my:f</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">my:f</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$x</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e25427"></a><a id="d8e25533"></a>Example: Circularity involving Variables and Templates</div><p>The definition of a variable is also circular if the evaluation of the variable invokes an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction and the variable is referenced in the pattern used in the <code>match</code> attribute of any template rule in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example the following definition is circular:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">//</span><span class="qname">param</span><span class="filter">[</span><span class="numeric">1</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">param</span><span class="filter">[</span><span class="variable">$x</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">1</span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e25440"></a><a id="d8e25546"></a>Example: Circularity involving Variables and Keys</div><p>Similarly, a variable definition is circular if it causes a call on the <a href="#func-key"><code>key</code></a> function, and the definition of that <a title="key" class="termref" href="#dt-key">key</a> refers to that variable in its <code>match</code> or <code>use</code> attributes. So the following definition is circular:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">my:f</span><span class="parenthesis">(</span><span class="numeric">10</span><span class="op">,</span><span class="whitespace"></span><span class="step">/</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">my:f</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">top</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">key</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">k</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$arg1</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$top</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:key</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">k</span><span class="z">"</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">item</span><span class="filter">[</span><span class="axis">@</span><span class="qname">code</span><span class="op">=</span><span class="variable">$x</span><span class="filter">]</span><span class="z">"</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">desc</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e25455"></a><a id="d8e25561"></a>Example: Circularity involving Attribute Sets</div><p>An attribute set is circular if its <code>use-attribute-sets</code> attribute references itself, directly or indirectly. So the following definitions establish a circularity:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:attribute-set</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">a</span><span class="z">"</span><span class="z"></span><span class="atn">use-attribute-sets</span><span class="atneq">=</span><span class="z">"</span><span class="av">b</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute-set</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">b</span><span class="z">"</span><span class="z"></span><span class="atn">use-attribute-sets</span><span class="atneq">=</span><span class="z">"</span><span class="av">a</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>Because attribute sets can invoke functions, global variables, or templates, and can also include instructions such as literal result elements that themselves invoke attribute sets, examples of circularity involving attribute sets can be more complex than this simple example illustrates. It is also possible to construct examples in which self-reference among attribute sets could be regarded as (terminating or non-terminating) recursion. However, because such self-references have no practical utility, any requirement to evaluate an attribute set in the course of its own evaluation is considered an error.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In previous versions of this specification, self-reference among attribute sets was defined as a static error. In XSLT 3.0 it is not always detectable statically, because attribute sets can bind to each other across package boundaries. Nevertheless, in cases where a processor can detect a static circularity, it can report this error during the analysis phase, under the general provision for reporting dynamic errors during stylesheet analysis if execution can never succeed.</p></div></div><p><a id="err-XTDE0640"><span class="error">[ERR XTDE0640] </span></a>In general, a <a title="circularity" class="termref" href="#dt-circularity">circularity</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a>. However, as with all other dynamic errors, an implementation will signal the error only if it actually executes the instructions and expressions that participate in the circularity. Because different implementations may optimize the execution of a stylesheet in different ways, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether a particular circularity will actually be signaled.</p><p>For example, in the following declarations, the function declares a local variable <code>$b</code>, but it returns a result that does not require the variable to be evaluated. It is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether the value is actually evaluated, and it is therefore implementation-dependent whether the circularity is signaled as an error:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">x</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">my:f</span><span class="parenthesis">(</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">my:f</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">a</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">b</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$x</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$a</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="numeric">2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Although a circularity is detected as a dynamic error, there is no unique instruction whose evaluation triggers the error condition, and the result of any attempt to catch the error using an <a href="#element-try"><code>xsl:try</code></a> instruction is therefore <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>Circularities usually involve global variables or parameters, but they can also exist between <a title="key" class="termref" href="#dt-key">key</a> definitions (see <a href="#key"><i>20.2 Keys</i></a>), between named <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a> (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), or between any combination of these constructs. For example, a circularity exists if a key definition invokes a function that references an attribute set that calls the <a href="#func-key"><code>key</code></a> function, supplying the name of the original key definition as an argument.</p><p>Circularity is not the same as recursion. Stylesheet functions (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>) and named templates (see <a href="#named-templates"><i>10.1 Named Templates</i></a>) may call other functions and named templates without restriction. With careless coding, recursion may be non-terminating. Implementations are <span class="verb">required</span> to signal circularity as a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>, but they are not <span class="verb">required</span> to detect non-terminating recursion.</p><p>The requirement to report a circularity as a dynamic error overrides the rule that dynamic errors in evaluating <a title="pattern" class="termref" href="#dt-pattern">patterns</a> are normally masked (by treating the pattern as not matching).</p></div></div><div class="div1"><h2><a id="callable-components"></a>10 <a href="#callable-components" style="text-decoration: none">Callable Components</a></h2><p>This section describes three constructs that can be used to provide subroutine-like functionality that can be invoked from anywhere in the stylesheet: named templates (see <a href="#named-templates"><i>10.1 Named Templates</i></a>), named attribute sets (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), and <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>).</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-invocation-construct" title="invocation construct"></a>The following <a title="construct" class="termref" href="#dt-construct">constructs</a> are classified as <b>invocation constructs</b>: the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute. These all have the characteristic that they can cause evaluation of constructs that are not lexically contained within the calling construct.<span class="definition">]</span></p><div class="div2"><h3><a id="named-templates"></a>10.1 <a href="#named-templates" style="text-decoration: none">Named Templates</a></h3><div class="div3"><h4><a id="declaring-named-templates"></a>10.1.1 <a href="#declaring-named-templates" style="text-decoration: none">Declaring Named Templates</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-named-template" title="named template"></a>Templates can be invoked by name. An <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute defines a <b>named template</b>.<span class="definition">]</span> The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>. If an <a href="#element-template"><code>xsl:template</code></a> element has a <code>name</code> attribute, it may, but need not, also have a <code>match</code> attribute. </p><p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an <a href="#element-template"><code>xsl:template</code></a> element have no effect when the <a title="template" class="termref" href="#dt-template">template</a> is invoked by an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. Similarly, the <code>name</code> and <code>visibility</code> attributes on an <a href="#element-template"><code>xsl:template</code></a> element have no effect when the template is invoked by an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p><p><a id="err-XTSE0660"><span class="error">[ERR XTSE0660] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more than one non-hidden <a title="template" class="termref" href="#dt-template">template</a> with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains a <a title="template" class="termref" href="#dt-template">template</a> with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. </p><p>The template name <code>xsl:initial-template</code> is specially recognized in that it provides a default entry point for stylesheet execution (see <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.) </p></div><div class="div3"><h4><a id="invoking-named-templates"></a>10.1.2 <a href="#invoking-named-templates" style="text-decoration: none">Invoking Named Templates</a></h4><p class="element-syntax"><a id="element-call-template"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:call-template<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:call-template&gt;</code></p><p>An <a href="#element-call-template"><code>xsl:call-template</code></a> instruction invokes a template by name; it has a <span class="verb">required</span><code>name</code> attribute that identifies the template to be invoked. Unlike <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction does not change the <a title="focus" class="termref" href="#dt-focus">focus</a>.</p><p><a id="err-XTSE0650"><span class="error">[ERR XTSE0650] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute does not match the <code>name</code> attribute of any <a title="named template" class="termref" href="#dt-named-template">named template</a> visible in the containing <a title="package" class="termref" href="#dt-package">package</a> (this includes any template defined in this package, as well as templates accepted from used packages whose visibility in this package is not <code>hidden</code>). For more details of the process of binding the called template, see <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>. </p><p>The target <a title="template" class="termref" href="#dt-template">template</a> for an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is established using the binding rules described in <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>. This will always be a template whose <code>name</code> attribute matches the <code>name</code> attribute of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. It may be a template defined in the same package that has higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than any other template with this name, or it may be a template accepted from a used package, or (if the template is not defined as <code>private</code> or <code>final</code>) it may be an overriding template in a package that uses the containing package. The result of evaluating an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is the sequence produced by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in its target <a title="template" class="termref" href="#dt-template">template</a> (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>).</p><p>Parameters for a named template can be supplied using <a href="#element-with-param"><code>xsl:with-param</code></a> elements as children of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction: see <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>.</p></div><div class="div3"><h4><a id="invoking-templates-with-extension-instructions"></a>10.1.3 <a href="#invoking-templates-with-extension-instructions" style="text-decoration: none">Invoking Named Templates using Extension Instructions</a></h4><p>As an alternative to the use of <a href="#element-call-template"><code>xsl:call-template</code></a>, it is possible to invoke a named template using an instruction. For example, given the named template:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">log:message</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">message</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">message</span><span class="scx">&gt;</span><span class="txt">{$message}</span><span class="ez">&lt;/</span><span class="cl">message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>a call on the template written as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:call-template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tcall">log:message</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">message</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Good morning</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:call-template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>can be replaced with the instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">log:message</span><span class="z"></span><span class="atn">message</span><span class="atneq">=</span><span class="z">"</span><span class="av">Good morning</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>For this to work, the name of the template must be in a non-null namespace, and this namespace must be designated as an extension element namespace using the attribute <code>[xsl:]extension-element-prefixes</code> on the instruction itself, or on some containing element (see <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>).</p><p>The name of the instruction must match the name of the called template, and the names of its attributes (other than <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attributes</a>) are matched against the names of the template's parameters. <a title="standard attributes" class="termref" href="#dt-standard-attributes">Standard attributes</a> are recognized (they must be in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) and have their standard meaning; for example <code>xsl:default-collation</code> affects the evaluation of any XPath expression used to compute a parameter value.</p><p>The way in which attribute values are handled depends on the type declaration of the template parameter:</p><ol class="enumar"><li><p>If the declared type is <code>xs:boolean</code>, with no occurrence indicator, then the attribute is treated as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> (after whitespace trimming) must be one of <code>yes</code>, <code>true</code>, or <code>1</code>, or <code>no</code>, <code>false</code>, or <code>0</code>, in the same way as boolean attributes on XSLT instructions. </p></li><li><p>If the declared type is any other atomic or union type, with no occurrence indicator, then the attribute is treated as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, and its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is treated as an <code>xs:untypedAtomic</code> value, which forces conversion to the required type by applying the casting rules.</p></li><li><p>In all other cases (that is, if the type of the parameter is not declared, or if it is not atomic, or if there is an occurrence indicator) the attribute is treated as an XPath expression and its value is converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p></li></ol><p>If an instruction is recognized as an implicit call on a named template, then the static and dynamic rules that apply are the same as if it were expanded into an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. The instruction</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">N</span><span class="z"></span><span class="atn">A1</span><span class="atneq">=</span><span class="z">"</span><span class="av">E1</span><span class="z">"</span><span class="z"></span><span class="atn">A2</span><span class="atneq">=</span><span class="z">"</span><span class="av">E2</span><span class="z">"</span><span class="z"></span><span class="atn">A3</span><span class="atneq">=</span><span class="z">"</span><span class="av">E3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>is essentially equivalent to:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:call-template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tcall">N</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">A1</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">E1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">A2</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">E2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">A3</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">E3</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:call-template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>except that the interpretation of the parameter values <code>E1</code>, <code>E2</code>, and <code>E3</code> depends on the declared type as explained above.</p><p>Some of the implications of this equivalence are:</p><ul><li><p>The binding of the instruction to a specific named template (for example, if there are overriding declarations in multiple packages) follows the binding rules in <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>.</p></li><li><p>A value must be supplied for any parameter declared with <code>required="yes"</code>.</p></li><li><p>The context item for the evaluation of the extension instruction must satisfy any constraints defined in an <a href="#element-context-item"><code>xsl:context-item</code></a> declaration in the called template.</p></li><li><p>It is an error if the instruction has attributes that do not correspond to the names of parameters declared on the named template.</p></li></ul><p>It is not possible to supply values for <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a>, but existing tunnel parameters are passed through unchanged.</p><p>For backwards compatibility, if an external implementation of an extension instruction is available to the implementation, then that takes precedence over the existence of a named template with a matching name.</p><p>The XSLT namespace cannot be designated as an extension element namespace, so the template names <code>xsl:initial-template</code> and <code>xsl:original</code> cannot be used as extension instructions.</p></div><div class="div3"><h4><a id="declaring-context-item"></a>10.1.4 <a href="#declaring-context-item" style="text-decoration: none">Declaring the Context Item for a Template</a></h4><p>The <a href="#element-context-item"><code>xsl:context-item</code></a> element is used as a child of <a href="#element-template"><code>xsl:template</code></a>, to declare the required type of the context item. It is intended particularly for use when the containing template is called using an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction, but it also constrains the context item if the same template is invoked using <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>. </p><p class="element-syntax"><a id="element-context-item"></a><code>&lt;xsl:context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"&nbsp;/&gt;</code></p><p>If the <code>as</code> attribute is present then its value must be an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP40</small></sup>. If the attribute is omitted this is equivalent to specifying <code>as="item()"</code>.</p><p><a id="err-XTSE3088"><span class="error">[ERR XTSE3088] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is present when <code>use="absent"</code> is specified.</p><p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> is signaled if the supplied context item does not match its required type. No attempt is made to convert the context item to the required type (using the coercion rules or otherwise). The error code is the same as for <a href="#element-param"><code>xsl:param</code></a>: <span class="error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>.</p><p>If an <a href="#element-context-item"><code>xsl:context-item</code></a> element is present as the first child element of <a href="#element-template"><code>xsl:template</code></a>, it defines whether the template requires a context item to be supplied, and if so, what the type of the context item must be. If this template is the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a>, then this has the effect of placing constraints on the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> for the transformation as a whole.</p><p>The <code>use</code> attribute of <a href="#element-context-item"><code>xsl:context-item</code></a> takes the value <code>required</code>, <code>optional</code>, or <code>absent</code>. The default is <code>optional</code>.</p><p>If the containing <a href="#element-template"><code>xsl:template</code></a> element has no <code>name</code> attribute then the only permitted value is <code>required</code>.</p><ul><li><p>If the value <code>required</code> is specified, then there must be a context item. (This will automatically be the case if the template is invoked using <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>, but not if it is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a>.) </p></li><li><p>If the value <code>optional</code> is specified, or if the attribute is omitted, or if the <a href="#element-context-item"><code>xsl:context-item</code></a> element is omitted, then there may or may not be a context item when the template is invoked.</p></li><li><p>If the value <code>absent</code> is specified, then the contained sequence constructor, and any <a href="#element-param"><code>xsl:param</code></a> elements, are evaluated with an absent focus.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not an error to call such a template with a non-absent focus; the context item is simply treated as absent. This option is useful when streaming, since an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction may become streamable if the referenced template is declared to make no use of the context item.</p></div></li></ul><p> The processor <span class="verb">may</span> signal a <a title="type error" class="termref" href="#dt-type-error">type error</a> statically if the required context item type is incompatible with the <code>match</code> pattern, that is, if no item that satisfies the match pattern can also satisfy the required context item type.</p><p>The <a href="#element-context-item"><code>xsl:context-item</code></a> element plays no part in deciding whether and when the template rule is invoked in response to an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. </p><p><a id="err-XTTE3090"><span class="error">[ERR XTTE3090] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a href="#element-context-item"><code>xsl:context-item</code></a> child of <a href="#element-template"><code>xsl:template</code></a> specifies that a context item is required and none is supplied by the caller, that is, if the context item is absent at the point where <a href="#element-call-template"><code>xsl:call-template</code></a> is evaluated. </p></div><div class="div3"><h4><a id="call-template-params"></a>10.1.5 <a href="#call-template-params" style="text-decoration: none">Passing Parameters to Named Templates</a></h4><p>Parameters are passed to named templates using the <a href="#element-with-param"><code>xsl:with-param</code></a> element as a child of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction.</p><p><a id="err-XTSE0680"><span class="error">[ERR XTSE0680] </span></a>In the case of <a href="#element-call-template"><code>xsl:call-template</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to pass a non-tunnel parameter named <var>x</var> to a template that does not have a non-tunnel <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> named <var>x</var>, unless the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. This is not an error in the case of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; in these cases the parameter is simply ignored.</p><p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The default is <code>no</code>. Tunnel parameters are described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>. </p><div class="example"><div class="exampleHeader"><a id="d8e26075"></a><a id="d8e26181"></a>Example: Calling a Named Template with a Parameter</div><p>This example defines a named template for a <code>numbered-block</code> with a parameter to control the format of the number.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">numbered-block</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">format</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">1. </span><span class="ez">&lt;/</span><span class="clxsl">xsl:param</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$format</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">ol</span><span class="step">//</span><span class="qname">ol</span><span class="step">/</span><span class="qname">li</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:call-template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tcall">numbered-block</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">format</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">a. </span><span class="ez">&lt;/</span><span class="clxsl">xsl:with-param</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:call-template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="tunnel-params"></a>10.1.6 <a href="#tunnel-params" style="text-decoration: none">Tunnel Parameters</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-tunnel-parameter" title="tunnel parameter"></a>A parameter passed to a template may be defined as a <b>tunnel parameter</b>. Tunnel parameters have the property that they are automatically passed on by the called template to any further templates that it calls, and so on recursively.<span class="definition">]</span> Tunnel parameters thus allow values to be set that are accessible during an entire phase of stylesheet processing, without the need for each template that is used during that phase to be aware of the parameter.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Tunnel parameters are conceptually similar to the dynamically scoped variables found in some functional programming languages (for example, early versions of LISP), where evaluating a variable reference involves searching down the dynamic call stack for a matching variable name. There are two main use cases for the feature:</p><ol class="enumar"><li><p>They provide a way to supply context information that might be needed by many templates (for example, the fact that the output is to be localized for a particular language), but which cannot be placed in a global variable because it might vary from one phase of processing to another. Passing such information using conventional parameters is error-prone, because a single <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-call-template"><code>xsl:call-template</code></a> instruction that neglects to pass the information on will lead to failures that are difficult to diagnose.</p><p>This style of processing is even more useful when handling JSON input, because with maps and arrays, there is no ancestor axis to examine properties of nodes further up the tree; with a recursive descent of the tree, all context information needs to be passed down explicitly. One way of handling this is for each level of processing in the tree to bind a tunnel parameter to the map or array encountered at that level, which then becomes available to all template rules processing data further down the tree.</p></li><li><p>They are particularly useful when writing a customization layer for an existing stylesheet. For example, if you want to override a template rule that displays chemical formulae, you might want the new rule to be parameterized so you can apply the house-style of a particular scientific journal. Tunnel parameters allow you to pass this information to the overriding template rule without requiring modifications to all the intermediate template rules. Again, a global variable could be used, but only if the same house-style is to be used for all chemical formulae processed during a single transformation.</p></li></ol></div><p>A <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> is created by using an <a href="#element-with-param"><code>xsl:with-param</code></a> element that specifies <code>tunnel="yes"</code>. A template that requires access to the value of a tunnel parameter must declare it using an <a href="#element-param"><code>xsl:param</code></a> element that also specifies <code>tunnel="yes"</code>.</p><p>On any template call using an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction, a set of <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> is passed from the calling template to the called template. This set consists of any parameters explicitly created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code>, overlaid on a base set of tunnel parameters. If the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction has an <a href="#element-template"><code>xsl:template</code></a> declaration as an ancestor element in the stylesheet, then the base set consists of the tunnel parameters that were passed to that template; otherwise (for example, if the instruction is within a global variable declaration, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> declaration, or a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>), the base set is empty. If a parameter created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as a parameter in the base set, then the parameter created using <a href="#element-with-param"><code>xsl:with-param</code></a> overrides the parameter in the base set; otherwise, the parameter created using <a href="#element-with-param"><code>xsl:with-param</code></a> is added to the base set.</p><p>When a template specifies <code>&lt;xsl:param tunnel="yes"&gt;</code>, this declares the intention to make use of a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>; it does not remove the parameter from the base set of tunnel parameters that is passed on to any templates called by this template. [XSLT 3.0 Erratum E23, bug 30240].</p><p>Two sibling <a href="#element-with-param"><code>xsl:with-param</code></a> elements <span class="verb">must</span> have distinct parameter names, even if one is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> and the other is not. Equally, two sibling <a href="#element-param"><code>xsl:param</code></a> elements representing <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a><span class="verb">must</span> have distinct parameter names, even if one is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> and the other is not. However, the tunnel parameters that are implicitly passed in a template call <span class="verb">may</span> have names that duplicate the names of non-tunnel parameters that are explicitly passed on the same call.</p><p><a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">Tunnel parameters</a> are not passed in calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>.</p><p>All other options of <a href="#element-with-param"><code>xsl:with-param</code></a> and <a href="#element-param"><code>xsl:param</code></a> are available with <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> just as with non-tunnel parameters. For example, parameters may be declared as mandatory or optional, a default value may be specified, and a required type may be specified. If any conversion is required from the supplied value of a tunnel parameter to the required type specified in <a href="#element-param"><code>xsl:param</code></a>, then the converted value is used within the receiving template, but the value that is passed on in any further template calls is the original supplied value before conversion. Equally, any default value is local to the template: specifying a default value for a tunnel parameter does not change the set of tunnel parameters that is passed on in further template calls.</p><p><a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">Tunnel parameters</a> are passed unchanged through a built-in template rule (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>).</p><p>If a tunnel parameter is declared in an <a href="#element-param"><code>xsl:param</code></a> element with the attribute <code>tunnel="yes"</code>, and if the parameter is <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly</a> mandatory, then a dynamic error occurs <span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the set of tunnel parameters passed to the template does not include a parameter with a matching <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p><div class="example"><div class="exampleHeader"><a id="d8e26235"></a><a id="d8e26341"></a>Example: Using Tunnel Parameters</div><p>Suppose that the equations in a scientific paper are to be sequentially numbered, but that the format of the number depends on the context in which the equations appear. It is possible to reflect this using a rule of the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">equation</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">equation-format</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">(1)</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">tunnel</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">level</span><span class="atneq">=</span><span class="z">"</span><span class="av">any</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$equation-format</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>At any level of processing above this level, it is possible to determine how the equations will be numbered, for example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">appendix</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">equation-format</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">[i]</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">tunnel</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:apply-templates</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The parameter value is passed transparently through all the intermediate layers of template rules until it reaches the rule with <code>match="equation"</code>. The effect is similar to using a global variable, except that the parameter can take different values during different phases of the transformation.</p></div></div></div><div class="div2"><h3><a id="attribute-sets"></a>10.2 <a href="#attribute-sets" style="text-decoration: none">Named Attribute Sets</a></h3><p class="element-syntax"><a id="element-attribute-set"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:attribute-set<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"<br>&nbsp;&nbsp;streamable? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>* --&gt;<br>&lt;/xsl:attribute-set&gt;</code></p><p>Attribute sets generate named collections of attributes that can be used repeatedly on different constructed elements. The <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration is used to declare attribute sets. The <span class="verb">required</span><code>name</code> attribute specifies the name of the attribute set. The value of the <code>name</code> attribute is an <code>EQName</code>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-attribute-set" title="attribute set"></a>An <b>attribute set</b> is defined as a set of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.<span class="definition">]</span></p><p>The content of the <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element consists of zero or more <a href="#element-attribute"><code>xsl:attribute</code></a> instructions that are evaluated to produce the attributes in the set.</p><div class="div3"><h4><a id="using-attribute-sets"></a>10.2.1 <a href="#using-attribute-sets" style="text-decoration: none">Using Attribute Sets</a></h4><p><a title="attribute set" class="termref" href="#dt-attribute-set">Attribute sets</a> are used by specifying a <code>use-attribute-sets</code> attribute on the <a href="#element-element"><code>xsl:element</code></a> or <a href="#element-copy"><code>xsl:copy</code></a> instruction, or by specifying an <code>xsl:use-attribute-sets</code> attribute on a literal result element. An attribute set may be defined in terms of other attribute sets by using the <code>use-attribute-sets</code> attribute on the <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element itself. The value of the <code>[xsl:]use-attribute-sets</code> attribute is in each case a whitespace-separated list of names of attribute sets. Each name is specified as an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p><p><a id="err-XTSE0710"><span class="error">[ERR XTSE0710] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>use-attribute-sets</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, or <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, or the <code>xsl:use-attribute-sets</code> attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, is not a whitespace-separated sequence of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>, or if it contains an EQName that does not match the <code>name</code> attribute of any <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. </p><p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> may be considered as comprising a sequence of instructions, each of which is either an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction or an <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a>. Starting with the declarations making up an attribute set, this sequence of instructions can be generated by the following rules: </p><ol class="enumar"><li><p>The relevant attribute set <a title="declaration" class="termref" href="#dt-declaration">declarations</a> (that is, all declarations of attribute sets within a package sharing the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>) are considered in order: first in increasing order of <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, and within each precedence, in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>. </p></li><li><p>Each declaration is expanded to a sequence of instructions as follows. First, one <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> is generated for each EQName present in the <code>use-attribute-sets</code> attribute, if present, retaining the order in which the EQNames appear. This is followed by the sequence of contained <a href="#element-attribute"><code>xsl:attribute</code></a> instructions, in order. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-attribute-set-invocation" title="attribute set invocation"></a>An <b>attribute set invocation</b> is a pseudo-instruction corresponding to a single EQName appearing within an <code>[xsl:]use-attribute-sets</code> attribute; the effect of the pseudo-instruction is to cause the referenced <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to be evaluated.<span class="definition">]</span></p></li></ol><p>Similarly, an <code>[xsl:]use-attribute-sets</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, or <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, or of a literal result element, is expanded to a sequence of <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocations</a>, one for each EQName in order. </p><p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is a named <a title="component" class="termref" href="#dt-component">component</a>, and the binding of QNames appearing in an <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> to attribute set components follows the rules in <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>. </p><p>The following two (mutually recursive) rules define how an <code>[xsl:]use-attribute-set</code> attribute is expanded:</p><ol class="enumar"><li><p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is evaluated by evaluating each of the contained <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocations</a> and <a href="#element-attribute"><code>xsl:attribute</code></a> instructions in order, to deliver a sequence of attribute nodes. </p></li><li><p>An <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> is evaluated by evaluating the <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to which it is bound, as determined by the rules in <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>. </p></li></ol><p>For rules regarding cycles in attribute set declarations, see <a href="#circularity"><i>9.11 Circular Definitions</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of an <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> on the dynamic context is the same as the effect of an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. In particular, it does not change the <a title="focus" class="termref" href="#dt-focus">focus</a>. Although attribute sets are often defined with fixed values, or with values that depend only on global variables, it is possible to define an attribute set in such a way that the values of the constructed attributes are dependent on the context item.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In all cases the result of evaluating an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is subsequently used to create the attributes of an element node, using the rules in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>. The effect of those rules is that when the result of evaluating the attribute set contains attributes with duplicate names, the last duplicate wins. The optimization rules allow a processor to avoid evaluating or validating an attribute if it is able to determine that the attribute will subsequently be discarded as a duplicate. </p></div></div><div class="div3"><h4><a id="visibility-of-attribute-sets"></a>10.2.2 <a href="#visibility-of-attribute-sets" style="text-decoration: none">Visibility of Attribute Sets</a></h4><p>The <code>visibility</code> attribute determines the potential visibility of the attribute set in packages other than the containing package. If the <code>visibility</code> attribute is present on any of the <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations making up the definition of an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> (that is, all declarations within the same package sharing the same name), then it <span class="verb">must</span> be present, with the same value, on every <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration making up the definition of that <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>.</p><p>If the <code>visibility</code> attribute is present with the value <code>abstract</code> then there must be no <a href="#element-attribute"><code>xsl:attribute</code></a> children and no <code>use-attribute-sets</code> attribute.</p></div><div class="div3"><h4><a id="streamability-of-attribute-sets"></a>10.2.3 <a href="#streamability-of-attribute-sets" style="text-decoration: none">Streamability of Attribute Sets</a></h4><p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> may be designated as streamable by including the attribute <code>streamable="yes"</code> on each <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration making up the attribute set. If any <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration for an attribute set has the attribute <code>streamable="yes"</code>, then every <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration for that attribute set <span class="verb">must</span> have the attribute <code>streamable="yes"</code>.</p><p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> if all the following conditions are satisfied:</p><ol class="enumar"><li><p>Every <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration for the attribute set has the attribute <code>streamable="yes"</code>.</p></li><li><p>Every <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration for the attribute set is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a> according to the analysis in <a href="#classifying-attribute-sets"><i>19.8.6 Classifying Attribute Sets</i></a>.</p></li></ol><p>Specifying <code>streamable="yes"</code> on an <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element declares an intent that the attribute set should be streamable, either because it is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, or because it takes advantage of streamability extensions offered by a particular processor. The consequences of declaring the attribute set to be streamable when it is not in fact guaranteed streamable depend on the conformance level of the processor, and are explained in <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>.</p><p><a id="err-XTSE0730"><span class="error">[ERR XTSE0730] </span></a>If an <a href="#element-attribute"><code>xsl:attribute</code></a> set element specifies <code>streamable="yes"</code> then every attribute set referenced in its <code>use-attribute-sets</code> attribute (if present) must also specify <code>streamable="yes"</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is common for attribute sets to create attributes with constant values, and such attribute sets will always be grounded and motionless and therefore streamable. Although such cases are fairly simple for a processor to detect, references to attribute sets are not guaranteed streamable unless the attribute set is declared with the attribute <code>streamable="yes"</code>, which should therefore be used if interoperable streaming is required.</p></div></div><div class="div3"><h4><a id="evaluating-attribute-sets"></a>10.2.4 <a href="#evaluating-attribute-sets" style="text-decoration: none">Evaluating Attribute Sets</a></h4><p>Attribute sets are evaluated as follows:</p><ul><li><p>The <a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-element"><code>xsl:element</code></a> instructions have a <code>use-attribute-sets</code> attribute. The sequence of attribute nodes produced by evaluating this attribute is prepended to the sequence produced by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained within the instruction.</p></li><li><p><a title="literal result element" class="termref" href="#dt-literal-result-element">Literal result elements</a> allow an <code>xsl:use-attribute-sets</code> attribute, which is evaluated in the same way as the <code>use-attribute-sets</code> attribute of <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-copy"><code>xsl:copy</code></a>. The sequence of attribute nodes produced by evaluating this attribute is prepended to the sequence of attribute nodes produced by evaluating the attributes of the literal result element, which in turn is prepended to the sequence produced by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained with the literal result element.</p></li></ul><p>The <a href="#element-attribute"><code>xsl:attribute</code></a> instructions are evaluated using the same <a title="focus" class="termref" href="#dt-focus">focus</a> as is used for evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained by the element that is the parent of the <code>[xsl:]use-attribute-sets</code> attribute forming the initial input to the algorithm. However, the static context for the evaluation depends on the position of the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction in the stylesheet: thus, only local variables declared within an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction, and global variables, are visible.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The above rule means that for an <a href="#element-copy"><code>xsl:copy</code></a> element with a <code>select</code> attribute, the focus for evaluating any referenced attribute sets is the node selected by the <code>select</code> attribute, rather than the context item of the <a href="#element-copy"><code>xsl:copy</code></a> instruction.</p></div><p>The set of attribute nodes produced by expanding <code>xsl:use-attribute-sets</code> may include several attributes with the same name. When the attributes are added to an element node, only the last of the duplicates will take effect.</p><p>The way in which each instruction uses the results of expanding the <code>[xsl:]use-attribute-sets</code> attribute is described in the specification for the relevant instruction: see <a href="#literal-result-element"><i>11.1 Literal Result Elements</i></a>, <a href="#xsl-element"><i>11.2 Creating Element Nodes Using xsl:element </i></a>, and <a href="#copying"><i>11.9 Copying Nodes</i></a>.</p><p>The result of evaluating an attribute set is a sequence of attribute nodes. Evaluating the same attribute set more than once can produce different results, because although an attribute set does not have parameters, it may contain expressions or instructions whose value depends on the evaluation context.</p><p>Each attribute node produced by expanding an attribute set has a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> determined by the rules for the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction that created the attribute node: see <a href="#annotation-for-constructed-attribute"><i>11.3.1 Setting the Type Annotation for a Constructed Attribute Node</i></a>. These type annotations may be preserved, stripped, or replaced as determined by the rules for the instruction that creates the element in which the attributes are used.</p></div><div class="div3"><h4><a id="attribute-sets-examples"></a>10.2.5 <a href="#attribute-sets-examples" style="text-decoration: none">Attribute Sets: Examples</a></h4><div class="example"><div class="exampleHeader"><a id="d8e26659"></a><a id="d8e26765"></a>Example: A Simple Attribute Set</div><p>The following example creates a named <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a><code>title-style</code> and uses it in a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">chapter</span><span class="step">/</span><span class="qname">heading</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="z"></span><span class="atn">font-stretch</span><span class="atneq">=</span><span class="z">"</span><span class="av">condensed</span><span class="z">"</span><span class="z"></span><span class="atn">xsl:use-attribute-sets</span><span class="atneq">=</span><span class="z">"</span><span class="av">title-style</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute-set</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">title-style</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-size</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">12pt</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-weight</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">bold</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute-set</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e26673"></a><a id="d8e26779"></a>Example: Overriding Attributes in an Attribute Set</div><p>The following example creates a named attribute set <code>base-style</code> and uses it in a template rule with multiple specifications of the attributes:</p><dl><dt class="label">font-family</dt><dd><p>is specified only in the attribute set</p></dd><dt class="label">font-size</dt><dd><p>is specified in the attribute set, is specified on the literal result element, and in an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction</p></dd><dt class="label">font-style</dt><dd><p>is specified in the attribute set, and on the literal result element</p></dd><dt class="label">font-weight</dt><dd><p>is specified in the attribute set, and in an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction</p></dd></dl><p>Stylesheet fragment:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:attribute-set</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">base-style</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-family</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Univers</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-size</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">10pt</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-style</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">normal</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-weight</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">normal</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute-set</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">o</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="z"></span><span class="atn">xsl:use-attribute-sets</span><span class="atneq">=</span><span class="z">"</span><span class="av">base-style</span><span class="z">"</span><span class="z"></span><span class="atn">font-size</span><span class="atneq">=</span><span class="z">"</span><span class="av">12pt</span><span class="z">"</span><span class="z"></span><span class="atn">font-style</span><span class="atneq">=</span><span class="z">"</span><span class="av">italic</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-size</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">14pt</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">font-weight</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">bold</span><span class="ez">&lt;/</span><span class="clxsl">xsl:attribute</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Result:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">fo:block</span><span class="z"></span><span class="atn">font-family</span><span class="atneq">=</span><span class="z">"</span><span class="av">Univers</span><span class="z">"</span><span class="z"></span><span class="atn">font-size</span><span class="atneq">=</span><span class="z">"</span><span class="av">14pt</span><span class="z">"</span><span class="z"></span><span class="atn">font-style</span><span class="atneq">=</span><span class="z">"</span><span class="av">italic</span><span class="z">"</span><span class="z"></span><span class="atn">font-weight</span><span class="atneq">=</span><span class="z">"</span><span class="av">bold</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div2"><h3><a id="stylesheet-functions"></a>10.3 <a href="#stylesheet-functions" style="text-decoration: none">Stylesheet Functions</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-function" title="stylesheet function"></a>An <a href="#element-function"><code>xsl:function</code></a> declaration declares the name, parameters, and implementation of a family of <b>stylesheet functions</b> that can be called from any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (subject to visibility rules).<span class="definition">]</span></p><p class="element-syntax"><a id="element-function"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:function<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"<br>&nbsp;&nbsp;streamability? = "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | <var>eqname</var><br>&nbsp;&nbsp;override-extension-function? = <var>boolean</var><br>&nbsp;&nbsp;<span class="grayed">[override]?</span> = <var>boolean</var><br>&nbsp;&nbsp;new-each-time? = "yes" | "true" | "1" | "no" | "false" | "0" | "maybe"<br>&nbsp;&nbsp;cache? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:function&gt;</code></p><p>The effect of an <a href="#element-function"><code>xsl:function</code></a> declaration is to add a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> to the static context for all XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> used in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (including an XPath expression used within a predicate in a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>).</p><p>The content of the <a href="#element-function"><code>xsl:function</code></a> element consists of zero or more <a href="#element-param"><code>xsl:param</code></a> elements that specify the formal parameters of the function, followed by a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that defines the value to be returned by the function.</p><p>The children and attributes of the <a href="#element-function"><code>xsl:function</code></a> declaration translate directly into properties of the <a title="function definition" class="termref" href="#dt-function-definition">function definition</a>:</p><ul><li><p>The <code>xsl:function/@name</code> attribute defines the function's name.</p></li><li><p>The <code>xsl:param</code> children define the function's parameters:</p><ul><li><p>The <code>xsl:param/@name</code> attribute defines the name of the parameter.</p></li><li><p>The <code>xsl:param/@required</code> attribute determines whether the parameter is mandatory or optional.</p></li><li><p>The <code>xsl:param/@as</code> attribute determines the required type of the parameter.</p></li><li><p>The <code>xsl:param/@select</code> attribute determines a default value for an optional parameter.</p></li></ul></li><li><p>The <code>xsl:function/@as</code> attribute defines the return type of the function.</p></li><li><p>The implementation of the function is defined by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> content of the <a href="#element-function"><code>xsl:function</code></a> element.</p></li></ul><p>An <a href="#element-function"><code>xsl:function</code></a> declaration can only appear as a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element in a stylesheet module.</p><div class="div3"><h4><a id="xsl-function-name"></a>10.3.1 <a href="#xsl-function-name" style="text-decoration: none">Function Name and Arity</a></h4><p>The name of the function is given by the <code>name</code> attribute.</p><p><a id="err-XTSE0740"><span class="error">[ERR XTSE0740] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> has a name that is in no namespace.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>To prevent the namespace declaration used for the function name appearing in the result document, use the <code>exclude-result-prefixes</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element: see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>.</p><p>The name of the function must not be in a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>: <span class="error">[see <a href="#err-XTSE0080">ERR XTSE0080</a>]</span></p></div><p>The function parameters are defined by child <a href="#element-param"><code>xsl:param</code></a> elements. The parameters must have distinct names. The list of parameters must contain zero or more required parameters, followed by zero or more optional parameters. A parameter is optional if it has the attribute <code>required="no"</code>; otherwise, it is required.</p><p>The default value for an optional parameter can be defined using the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <a href="#element-param"><code>xsl:param</code></a> element. These must be absent for a required parameter. If an optional parameter has no <code>select</code> attribute and the contained sequence constructor is empty, then the default value will be an empty sequence. This will lead to a type error if the required type of the parameter does not permit an empty sequence.</p><p>The <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> derived from the <a href="#element-function"><code>xsl:function</code></a> declaration has an <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> from <var>M</var> to <var>M</var>+<var>N</var>, where <var>M</var> is the number of required parameters and <var>N</var> is the number of optional parameters. The arity range constrains the number of arguments that may appear in a call to this function.</p><p>For example, the following <a href="#element-function"><code>xsl:function</code></a> declaration declares a function, named <code>f:compare</code>, with an arity range of (2 to 3). The effect of calling <code>f:compare($a, $b)</code> is the same as the effect of calling <code>f:compare($a, $b, map{"order":"ascending"})</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:compare</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg1</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg2</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">options</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(*)</span><span class="z">"</span><span class="z"></span><span class="atn">required</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="op">'</span><span class="property">order</span><span class="op">'</span><span class="op">:</span><span class="op">'</span><span class="literal">ascending</span><span class="op">'</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$options</span><span class="op">?</span><span class="qname">order</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="op">'</span><span class="literal">descending</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">then</span><span class="atneq">=</span><span class="z">"</span><span class="av">$arg1 gt $arg2</span><span class="z">"</span><span class="z"></span><span class="atn">else</span><span class="atneq">=</span><span class="z">"</span><span class="av">$arg2 gt $arg1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The expression defining the default value for a function parameter is evaluated in the dynamic context of the function caller, so a default value such as <code>select="."</code> is permitted.</p><p>Unlike other contexts where <a href="#element-param"><code>xsl:param</code></a> elements may appear, the static context for the select expression and contained sequence constructor of an <a href="#element-param"><code>xsl:param</code></a> child of <a href="#element-function"><code>xsl:function</code></a> does not include variable bindings appearing in its preceding-sibling <a href="#element-param"><code>xsl:param</code></a> elements. This means that the default value of a function parameter cannot depend on the values of other parameters.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Functions are not polymorphic. Although the XPath function call mechanism allows two functions to have the same name and <span>non-overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a></span>, it does not allow them to be distinguished by the types of their arguments.</p></div></div><div class="div3"><h4><a id="function-arguments"></a>10.3.2 <a href="#function-arguments" style="text-decoration: none">Arguments</a></h4><p>The <a href="#element-param"><code>xsl:param</code></a> elements define the formal parameters to the function. In a static function call, these are referenced either positionally or by name. The rules for associating arguments in a static function call with parameter definitions in the function declaration are given in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-eval-static-function-call">Section 4.4.1.2 Evaluating Static Function Calls</a><sup><small>XP40</small></sup>.</p><p><a id="err-XTSE0760"><span class="error">[ERR XTSE0760] </span></a>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of an <a href="#element-function"><code>xsl:function</code></a> element has either a <code>select</code> attribute or non-empty content<span>, unless it specifies <code>required="no"</code>.</span></p><p><a id="err-XTSE0761"><span class="error">[ERR XTSE0761] </span></a>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of an <a href="#element-function"><code>xsl:function</code></a> element specifies <code>required="no"</code>, unless all following-sibling <a href="#element-param"><code>xsl:param</code></a> elements also specify <code>required="no"</code>. </p><p>The <code>as</code> attribute of the <a href="#element-param"><code>xsl:param</code></a> element defines the required type of the parameter. The rules for converting the values of the actual arguments supplied in the function call to the types required by each <a href="#element-param"><code>xsl:param</code></a> element, and the errors that can occur, are defined in <a href="#xpath-30">[XPath 3.0]</a>. The rules that apply are those for the case where <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to <code>false</code>.</p><p>If the <code>as</code> attribute is omitted, no conversion takes place and any value is accepted.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When considering function overriding, dynamic function calls, and details such as the <code>function-lookup</code> function, it is useful to think of an <a href="#element-function"><code>xsl:function</code></a> declaration with optional parameters as a syntactic short-cut for a set of <a href="#element-function"><code>xsl:function</code></a> declarations of varying arity, each of which calls the function with next-higher arity, supplying the default value of the parameter explicitly in the function call.</p><p>This is not an exact equivalence, however, because the default value is evaluated with the dynamic context of the caller.</p></div></div><div class="div3"><h4><a id="function-result"></a>10.3.3 <a href="#function-result" style="text-decoration: none">Function Result</a></h4><p>The result of the function<span>, if all arguments are supplied,</span> is the result of evaluating the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>If a reduced-arity form of the function is invoked by omitting optional arguments, then the result of the function is obtained by evaluating the sequence constructor after binding the omitted arguments to their default values, which are obtained by evaluating the <code>select</code> attribute or sequence constructor of the relevant <a href="#element-param"><code>xsl:param</code></a> element, as described in <a href="#default-values-of-parameters"><i>9.2.2 Default Values of Parameters</i></a>.</p><p>Within the sequence constructor, the <a title="focus" class="termref" href="#dt-focus">focus</a> is initially <a title="absent" class="termref" href="#dt-absent">absent</a>; this means that any attempt to reference the context item, context position, or context size is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a>. (See <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.)</p><p>It is not possible within the body of the <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> to access the values of local variables that were in scope in the place where the function call was written. Global variables, however, remain available.</p><p>The optional <code>as</code> attribute indicates the <a title="required type" class="termref" href="#dt-required-type">required type</a> of the result of the function. The value of the <code>as</code> attribute is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>.</p><p><a id="err-XTTE0780"><span class="error">[ERR XTTE0780] </span></a>If the <code>as</code> attribute is specified, then the result evaluated by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) is converted to the required type, using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if this conversion fails. If the <code>as</code> attribute is omitted, the calculated result is used as supplied, and no conversion takes place.</p></div><div class="div3"><h4><a id="function-visibility-and-overriding"></a>10.3.4 <a href="#function-visibility-and-overriding" style="text-decoration: none">Visibility and Overriding of Functions</a></h4><p>It is possible to have multiple function declarations sharing the same function name and arity:</p><ul><li><p>Multiple <a href="#element-function"><code>xsl:function</code></a> declarations are allowed within a single <a title="package" class="termref" href="#dt-package">package</a> if they have different <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></li><li><p>A function declared using <a href="#element-function"><code>xsl:function</code></a> may have the same name and arity as an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>.</p></li><li><p>A function declared within one package may be overridden (using <a href="#element-override"><code>xsl:override</code></a>) in another package.</p></li></ul><p>The rules governing these three scenarios are given in the sections that follow.</p><div class="div4"><h5><a id="function-overriding-within-package"></a>10.3.4.1 <a href="#function-overriding-within-package" style="text-decoration: none">Overriding Functions within a Package</a></h5><p>Two stylesheet functions with the same name may appear in a package if their <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a> do not overlap. Neither overrides the other; the function that is selected is determined by the arity of the function call or function reference.</p><p>In addition, a stylesheet function may be overridden by another stylesheet function with the same name that has higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. Such overriding is only allowed, however, if the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of the overriding function includes the totality of the arity range of the overridden function.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-eclipsed" title="eclipsed"></a>An <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> is said to be <b>eclipsed</b> if the containing package includes an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same name, <var>F</var> has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of <var>G</var> includes the totality of the arity range of <var>F</var>.<span class="definition">]</span></p><p><a id="err-XTSE0769"><span class="error">[ERR XTSE0769] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain an <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, <var>F</var> has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of <var>G</var> includes part but not all of the arity range of <var>F</var>, unless <var>G</var> is itself <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another <a href="#element-function"><code>xsl:function</code></a> declaration. </p><p><a id="err-XTSE0770"><span class="error">[ERR XTSE0770] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain an <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, if the <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a> of <var>F</var> and <var>G</var> overlap in whole or in part, unless <var>F</var> and <var>G</var> are both <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another <a href="#element-function"><code>xsl:function</code></a> declaration. </p><p>Similarly it is a static error <span class="error">[see <a href="#err-XTDE0770">ERR XTDE0770</a>]</span> for a <a title="package" class="termref" href="#dt-package">package</a> to contain an <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> that is not <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another <a href="#element-function"><code>xsl:function</code></a> declaration, if its name and arity range conflict with a constructor function in the static context. There will be a constructor function (with arity 1) in the static context for every atomic type or plain union type in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>. </p></div><div class="div4"><h5><a id="overriding-extension-functions"></a>10.3.4.2 <a href="#overriding-extension-functions" style="text-decoration: none">Overriding Extension Functions</a></h5><p>The optional <code>override-extension-function</code> attribute defines what happens if an <a href="#element-function"><code>xsl:function</code></a> declaration has the same name and overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> as a function provided by the implementer or made available in the static context using an implementation-defined mechanism. If the <code>override-extension-function</code> attribute has the value <code>yes</code>, then this function is used in preference; if it has the value <code>no</code>, then the other function is used in preference. The default value is <code>yes</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Specifying <code>override-extension-function="yes"</code> ensures interoperable behavior: the same code will execute with all processors. Specifying <code>override-extension-function="no"</code> is useful when writing a fallback implementation of a function that is available with some processors but not others: it allows the vendor’s implementation of the function (or a user’s implementation written as an extension function) to be used in preference to the stylesheet implementation, which is useful when the extension function is more efficient.</p><p>The <code>override-extension-function</code> attribute does <em>not</em> affect the rules for deciding which of several <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> with the same name and <a title="" class="termref" href="#">arity</a> takes precedence.</p></div><p>The <code>override</code> attribute is a <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a> synonym of <code>override-extension-function</code>, retained for compatibility with XSLT 2.0. If both attributes are present then they <span class="verb">must</span> have the same value.</p></div><div class="div4"><h5><a id="overriding-functions-in-used-packages"></a>10.3.4.3 <a href="#overriding-functions-in-used-packages" style="text-decoration: none">Overriding Functions in a Used Package</a></h5><p>When a package is referenced in <a href="#element-use-package"><code>xsl:use-package</code></a>, functions declared in the used package become available in the using package, conditional on their declared <a title="visibility" class="termref" href="#dt-visibility">visibility</a>, as described in <a href="#packages"><i>3.5 Packages</i></a>.</p><p>If the <code>visibility</code> attribute of <a href="#element-function"><code>xsl:function</code></a> is present with the value <code>abstract</code> then the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> defining the function body <span class="verb">must</span> be empty.</p><p>The XPath specification states that the function that is executed as the result of a function call is identified by looking in the static context for a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> whose name and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> match the name and number of arguments in the function call. In XSLT 3.0, final determination of the function to be called cannot be made until all packages have been assembled: see <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>.</p><p>An <a href="#element-function"><code>xsl:function</code></a> declaration defines a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> which forms a <a title="component" class="termref" href="#dt-component">component</a> in its containing <a title="package" class="termref" href="#dt-package">package</a>, unless </p><ul><li><p>it is <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a>, or</p></li><li><p>the <code>override-extension-function</code> or <code>override</code> attribute has the value <code>no</code> and there is already a <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> with the same name and an overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> in the static context.</p></li></ul><p>The optional <code>override-extension-function</code> attribute defines what happens if this function has the same name and an <span><a title="arity range" class="termref" href="#dt-arity-range">arity range</a> that conflicts with a function</span> provided by the implementer or made available in the static context using an implementation-defined mechanism. If the <code>override-extension-function</code> attribute has the value <code>yes</code>, then this function is used in preference; if it has the value <code>no</code>, then the other function is used in preference. The default value is <code>yes</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Specifying <code>override-extension-function="yes"</code> ensures interoperable behavior: the same code will execute with all processors. Specifying <code>override-extension-function="no"</code> is useful when writing a fallback implementation of a function that is available with some processors but not others: it allows the vendor’s implementation of the function (or a user’s implementation written as an extension function) to be used in preference to the stylesheet implementation, which is useful when the extension function is more efficient.</p><p>The <code>override-extension-function</code> attribute does <em>not</em> affect the rules for deciding which of several <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> with the same name and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> takes precedence.</p></div><p>The <code>override</code> attribute is a <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a> synonym of <code>override-extension-function</code>, retained for compatibility with XSLT 2.0. If both attributes are present then they <span class="verb">must</span> have the same value.</p><p>When the <a href="#element-function"><code>xsl:function</code></a> declaration appears as a child of <a href="#element-override"><code>xsl:override</code></a>, there <span class="verb">must</span> be a <a title="compatible" class="termref" href="#dt-compatible">compatible</a> stylesheet function in the <a title="package" class="termref" href="#dt-package">package</a> referenced by the containing <a href="#element-use-package"><code>xsl:use-package</code></a> element; the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of that function must be <code>public</code> or <code>abstract</code> (See also <a href="#package-overriding-components"><i>3.5.3.3 Overriding Components from a Used Package</i></a>.)</p></div></div><div class="div3"><h4><a id="streamability-of-stylesheet-functions"></a>10.3.5 <a href="#streamability-of-stylesheet-functions" style="text-decoration: none">Streamability of Stylesheet Functions</a></h4><p>The <code>streamability</code> attribute of <a href="#element-function"><code>xsl:function</code></a> is used to assign the function to one of a number of <a title="streamability category" class="termref" href="#dt-streamability-category">streamability categories</a>. The various categories, and their effect on the streamability of function calls, are described in <a href="#streamable-stylesheet-functions"><i>19.8.5 Classifying Stylesheet Functions</i></a>.</p><p>The streamability category of a function characterizes the way in which the function processes any streamed nodes supplied in the first argument to the function. (In general, streamed nodes cannot be supplied in other arguments, unless they are atomized by the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.) The <code>streamability</code> attribute is therefore not applicable unless the function takes at least one argument.</p><p><a id="err-XTSE3155"><span class="error">[ERR XTSE3155] </span></a>It is a static error if an <a href="#element-function"><code>xsl:function</code></a> element with no <a href="#element-param"><code>xsl:param</code></a> children has a <code>streamability</code> attribute with any value other than <code>unclassified</code>.</p></div><div class="div3"><h4><a id="function-lookup"></a>10.3.6 <a href="#function-lookup" style="text-decoration: none">Dynamic Access to Functions</a></h4><p>If a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> with a particular <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> exists in the stylesheet, then a call to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> function <span>will return the function as a value if it supplies that name and an arity within that range</span>. This applies only if the static context for the call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> includes the stylesheet function, which implies that the function is visible in the containing package.</p><p>The <a href="#func-function-available"><code>function-available</code></a> function, when called with a particular <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and arity, returns true if and only if a call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> with the same arguments, in the same static context, would return a function item.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For legacy reasons there is also a single-argument version of <a href="#func-function-available"><code>function-available</code></a>, which returns true if there is a function with the given name regardless of arity.</p></div><p>The standard rules for <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> require that if the supplied name and arity identify a context-dependent function such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-name"><code>name#0</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-lang"><code>lang#1</code></a><sup><small>FO30</small></sup> (call it <var>F</var>), then the returned function value includes in its closure a copy of the static and dynamic context of the call to <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>, and the context item for a subsequent dynamic call of <var>F</var> is taken from this saved context. In the case where the context item is a node in a streamed input document, saving the node is not possible. In this case, therefore, the context is saved with an absent focus, so the call on <var>F</var> will fail with a dynamic error saying that there is no context item available.</p></div><div class="div3"><h4><a id="function-determinism"></a>10.3.7 <a href="#function-determinism" style="text-decoration: none">Determinism of Functions</a></h4><p>Stylesheet functions have been designed to be largely deterministic: unless a stylesheet function calls some <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> which is itself nondeterministic, the function will return results that depend only on the supplied arguments. This property (coupled with the fact that the effect of calling extension functions is entirely <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>) enables a processor to implement various optimizations, such as removing invariant function calls from the body of a loop, or combining common subexpressions.</p><p>One exception to the intrinsic determinism of stylesheet functions arises because constructed nodes have distinct identity. This means that when a function that creates a new node is called, two calls on the function will return nodes that can be distinguished: for example, with such a function, <code>f:make-node() is f:make-node()</code> will return false.</p><p>Three classes of functions can be identified:</p><ol class="enumar"><li><p><a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">Deterministic</a><sup><small>FO40</small></sup> functions: as the term is defined in <a href="#xpath-functions-31">[Functions and Operators 3.1]</a>, these offer a guarantee that when a function is called repeatedly with the same arguments, it returns the same results. A classic example is the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function, which offers the guarantee that <code>doc($X) is doc($X)</code>: that is, two calls supplying the same URI return the same node.</p></li><li><p>Proactive functions: these offer the guarantee that each invocation of the function causes a single execution of the function body, or behaves exactly as if it did so. In particular this means that when the function creates new nodes, it creates new nodes on each invocation. By default, <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> are proactive.</p></li><li><p>Elidable functions: these offer no guarantee of determinism, and no guarantee of proactive evaluation. If the function creates new nodes, then two calls on the function with the same arguments may or may not return the same nodes, at the implementation’s discretion. Examples of elidable functions include the <a href="#xpath-functions-31">[Functions and Operators 3.1]</a> functions <a href="https://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>analyze-string</code></a><sup><small>FO30</small></sup> and <a href="#func-json-to-xml"><code>json-to-xml</code></a>.</p></li></ol><p>The <code>new-each-time</code> attribute of <a href="#element-function"><code>xsl:function</code></a> allows a stylesheet function to be assigned to one of these three categories. The value <code>new-each-time="no"</code> means the function is deterministic; the value <code>new-each-time="yes"</code> means it is proactive; and the value <code>new-each-time="maybe"</code> means it is elidable.</p><p>The definition of <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">determinism</a><sup><small>FO40</small></sup> requires a definition of what it means for a function to be called twice with “the same” arguments and to return “the same” result. This is defined in <a href="#xpath-functions-31">[Functions and Operators 3.1]</a>, specifically by the definition of the term <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-identical">identical</a><sup><small>FO40</small></sup>.</p><p>Processors have considerable freedom to optimize execution of stylesheets, and of function calls in particular, but the strategies that are adopted must respect the specification as to whether functions are deterministic, proactive, or elidable. For example, consider a function call that appears within an <a href="#element-for-each"><code>xsl:for-each</code></a> instruction, where the supplied arguments to the function do not depend on the context item or on any variables declared within the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction. A possible optimization is to execute the function call only once, rather than executing it repeatedly each time round the loop (this is sometimes called loop-lifting). This optimization is safe when the function is deterministic or elidable, but it requires great care if the function is proactive; it is permitted only if the processor is able to determine that the results of stylesheet execution are equivalent to the results that would be obtained if the optimization had not been performed. Declaring a function call to be elidable (by writing <code>new-each-time="maybe"</code>) makes it more likely that an implementation will be able to apply this optimization, as well as other optimizations such as caching or memoization.</p></div><div class="div3"><h4><a id="memoization"></a>10.3.8 <a href="#memoization" style="text-decoration: none">Memoization</a></h4><p>The <code>cache</code> attribute is an optimization hint which the processor can use or ignore at its discretion; however it <span class="verb">should</span> be taken seriously, because it may make a difference to whether execution of a stylesheet is practically feasible or not.</p><p>The default value is <code>cache="no".</code></p><p>The value <code>cache="yes"</code> encourages the processor to retain memory of previous calls of this function during the same transformation and to reuse results from this memory whenever possible. The default value <code>cache="no"</code> encourages the processor not to retain memory of previous calls.</p><p>In all cases the results must respect the semantics. If a function is proactive (<code>new-each-time="yes"</code>) then caching of results may be infeasible, especially if the function result can include nodes; but it is not an error to request it, since some implementations may be able to provide caching, or analogous optimizations, even for proactive functions. (One possible strategy is to return a copy of the cached result, thus creating the illusion that the function has been evaluated anew.)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Memoization is essentially a trade-off between time and space; a memoized function can be expected to use more memory to deliver faster execution. Achieving an optimum balance may require configuring the size of the cache that is used; implementations <span class="verb">may</span> use additional <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a> or other mechanisms to provide finer control of this kind.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Memoization of a function generally involves creating an associative table (for example, a hash map) that maps argument values to function results. To get this right, it is vital that the key for this table should correctly reflect what it means for two function calls to have “the same arguments”. Does it matter, for example, that one call passes the <code>xs:string</code> value "Paris", while another passes the <code>xs:untypedAtomic</code> value "Paris"? If the function is declared with <code>new-each-time="maybe"</code>, then the rules say that these cannot be treated as “the same arguments”: the definition of <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-identical">identical</a><sup><small>FO40</small></sup> requires them to have exactly the same type as well as being equal. However, an implementation that is able to determine that all references to the argument within the function body only make use of its string value might be able to take advantage of this fact, and thus perform more efficient caching.</p></div></div><div class="div3"><h4><a id="function-examples"></a>10.3.9 <a href="#function-examples" style="text-decoration: none">Examples of Stylesheet Functions</a></h4><div class="example"><div class="exampleHeader"><a id="d8e27650"></a><a id="d8e27756"></a>Example: A Stylesheet Function</div><p>The following example creates a recursive <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> named <code>str:reverse</code> that reverses the words in a supplied sentence, and then invokes this function from within a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>. </p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:transform</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">default-type-namespace</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:str</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://example.com/namespace</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">exclude-result-prefixes</span><span class="atneq">=</span><span class="z">"</span><span class="av">str</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">str:reverse</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">sentence</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="function">contains</span><span class="parenthesis">(</span><span class="variable">$sentence</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="function">concat</span><span class="parenthesis">(</span><span class="function">str:reverse</span><span class="parenthesis">(</span><span class="function">substring-after</span><span class="parenthesis">(</span><span class="variable">$sentence</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="function">substring-before</span><span class="parenthesis">(</span><span class="variable">$sentence</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="variable">$sentence</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">output</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">str:reverse</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">DOG BITES MAN</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">output</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:transform</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>An alternative way of writing the same function is to implement the conditional logic at the XSLT level, thus:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">str:reverse</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">sentence</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">contains</span><span class="parenthesis">(</span><span class="variable">$sentence</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">then</span><span class="atneq">=</span><span class="z">"</span><span class="av">concat(str:reverse(substring-after($sentence, ' ')), ' ', substring-before($sentence, ' '))</span><span class="z">"</span><span class="z"></span><span class="atn">else</span><span class="atneq">=</span><span class="z">"</span><span class="av">$sentence</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e27667"></a><a id="d8e27773"></a>Example: Declaring the Return Type of a Function</div><p>The following example illustrates the use of the <code>as</code> attribute in a function definition. It returns a string containing the representation of its integer argument, expressed as a roman numeral. For example, the function call <code>num:roman(7)</code> will return the string <code>"vii"</code>. This example uses the <a href="#element-number"><code>xsl:number</code></a> instruction, described in <a href="#number"><i>12 Numbering</i></a>. The <a href="#element-number"><code>xsl:number</code></a> instruction returns a text node, and the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> are invoked to convert this text node to the type declared in the <a href="#element-function"><code>xsl:function</code></a> element, namely <code>xs:string</code>. So the text node is <a title="atomize" class="termref" href="#dt-atomization">atomized</a> to a string.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">num:roman</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">value</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$value</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">i</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e27695"></a><a id="d8e27801"></a>Example: A Higher-Order Function</div><p>XPath 3.0 introduces the ability to pass function items as arguments to a function. A function that takes function items as arguments is known as a higher-order function.</p><p>The following example is a higher-order function that operates on any tree-structured data, for example an organization chart. Given as input a function that finds the direct subordinates of a node in this tree structure (for example, the direct reports of a manager, or the geographical subdivisions of an administrative area), it determines whether one object is present in the subtree rooted at another object (for example, whether one person is among the staff managed directly or indirectly by a manager, or whether one parcel of land is contained directly or indirectly within another parcel). The function does not check for cycles in the data.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:is-subordinate</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">superior</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">subordinate</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">get-direct-children</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">function(node()) as node()*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="whitespace"></span><span class="higher">some</span><span class="whitespace"></span><span class="variable">$sub</span><span class="whitespace"></span><span class="op">in</span><span class="whitespace"></span><span class="function">$get-direct-children</span><span class="parenthesis">(</span><span class="variable">$superior</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">satisfies</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$sub</span><span class="whitespace"></span><span class="op">is</span><span class="whitespace"></span><span class="variable">$subordinate</span><span class="whitespace"></span><span class="op">or</span><span class="whitespace"></span><span class="function">f:is-subordinate</span><span class="parenthesis">(</span><span class="variable">$sub</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$subordinate</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$get-direct-children</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Given source data representing an organization chart in the form of elements such as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">employee</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">P57832</span><span class="z">"</span><span class="z"></span><span class="atn">manager</span><span class="atneq">=</span><span class="z">"</span><span class="av">P68951</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>the following function can be defined to get the direct reports of a manager:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:direct-reports</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">manager</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$manager</span><span class="step">/</span><span class="context">..</span><span class="step">/</span><span class="qname">employee</span><span class="whitespace"></span><span class="filter">[</span><span class="axis">@</span><span class="qname">manager</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="variable">$manager</span><span class="step">/</span><span class="axis">@</span><span class="qname">id</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>It is then possible to test whether one employee <code>$E</code> reports directly or indirectly to another employee <code>$M</code> by means of the function call:</p><div class="exampleInner"><pre>f:is-subordinate($M, $E, f:direct-reports#1)</pre></div></div></div></div><div class="div2"><h3><a id="dynamic-xpath"></a>10.4 <a href="#dynamic-xpath" style="text-decoration: none">Dynamic XPath Evaluation</a></h3><p class="element-syntax"><a id="element-evaluate"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:evaluate<br>&nbsp;&nbsp;<b>xpath</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;base-uri? = { <var>uri</var> }<br>&nbsp;&nbsp;with-params? = <var>expression</var><br>&nbsp;&nbsp;context-item? = <var>expression</var><br>&nbsp;&nbsp;namespace-context? = <var>expression</var><br>&nbsp;&nbsp;schema-aware? = { <var>boolean</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:evaluate&gt;</code></p><p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction constructs an XPath expression in the form of a string, evaluates the expression in a specified context, and returns the result of the evaluation.</p><p>The expression given as the value of the <code>xpath</code> attribute is evaluated and the result is converted to a string using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-target-expression" title="target expression"></a>The string that results from evaluating the expression in the <code>xpath</code> attribute is referred to as the <b>target expression</b>.<span class="definition">]</span></p><p><a id="err-XTDE3160"><span class="error">[ERR XTDE3160] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> is not a valid <a title="expression" class="termref" href="#dt-expression">expression</a> (that is, if a static error occurs when analyzing the string according to the rules of the XPath specification).</p><p>The <code>as</code> attribute, if present, indicates the required type of the result. If the attribute is absent, the required type is <code>item()*</code>, which allows any result. The result of evaluating the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> is converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. This may cause a <a title="type error" class="termref" href="#dt-type-error">type error</a> if conversion is not possible. The result after conversion is returned as the result of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p><p>The target expression may contain variable references; the values of such variables may be supplied using an <a href="#element-with-param"><code>xsl:with-param</code></a> child instruction if the names of the variables are known statically, or using a map supplied as the value of the expression in the <code>with-params</code> attribute if the names are only known dynamically. If the <code>with-params</code> attribute is present then it must contain an expression whose value, when evaluated, is of type <code>map(xs:QName, item()*)</code> (see <a href="#map"><i>21 Maps</i></a> for details of maps).</p><p><a id="err-XTTE3165"><span class="error">[ERR XTTE3165] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the expression in the <code>with-params</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single map of type <code>map(xs:QName, item()*)</code>. </p><div class="div3"><h4><a id="evaluate-static-context"></a>10.4.1 <a href="#evaluate-static-context" style="text-decoration: none">Static context for the target expression</a></h4><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP40</small></sup> for the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> is as follows:</p><ul><li><p>XPath 1.0 compatibility mode is <code>false</code>.</p></li><li><p>Statically known namespaces and default namespaces for elements and for types:</p><ul><li><p>if the <code>namespace-context</code> attribute is present, then its value is an <a title="expression" class="termref" href="#dt-expression">expression</a> whose required type is a single node. The expression is evaluated, and the in-scope namespaces of the resulting node are used as the statically known namespaces for the target expression. The binding for the default namespace in the in-scope namespaces is used as the default namespace for <span>both</span> elements and types in the target expression.</p><p><a id="err-XTTE3170"><span class="error">[ERR XTTE3170] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>namespace-context</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single node. </p></li><li><p>if the <code>namespace-context</code> attribute is absent, then the in-scope namespaces of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction (with the exception of any binding for the default namespace) are used as the statically known namespaces for the target expression, and the values of the attributes <code>[xsl:]default-element-namespace</code>, <code>[xsl:]default-type-namespace</code>, and <code>[xsl:]xpath-default-namespace</code> if any, are used to establish the default namespaces for elements and types in the target expression, as described in <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>XPath 3.0 allows expanded names to be written in a context-independent way using the syntax <code>Q{namespace-uri}local-name</code></p></div></li><li><p>Default function namespace: the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>.</p></li><li><p>In-scope schema definitions: if the <code>schema-aware</code> attribute is present and has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>yes</code>, then the in-scope schema definitions from the stylesheet context (that is, the schema definitions imported using <a href="#element-import-schema"><code>xsl:import-schema</code></a>). Otherwise, the built-in types (see <a href="#built-in-types"><i>3.14 Built-in Types</i></a>).</p></li><li><p>In-scope variables: the names of the in-scope variables are the union of the names appearing in the <code>name</code> attribute of the contained <a href="#element-with-param"><code>xsl:with-param</code></a> elements, and the names present as keys in the map obtained by evaluating the <code>with-params</code> attribute, if present. The corresponding type is <code>item()*</code> in the case of a name found as a key in the <code>with-params</code> map, or the type named in the <code>as</code> attribute of <a href="#element-with-param"><code>xsl:with-param</code></a> child (defaulting to <code>item()*</code>) otherwise.</p><p>If a variable name is present both the static <a href="#element-with-param"><code>xsl:with-param</code></a> children and also in the dynamic <code>with-params</code> map, the value from the latter takes precedence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Variables declared in the stylesheet in <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> elements are <em>not</em> in-scope within the target expression.</p></div></li><li><p>Function signatures:</p><ul><li><p>All functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in the <code>fn</code> and <code>math</code>, <span><code>map</code>, and <code>array</code></span> namespaces;</p></li><li><p>Constructor functions for named simple types included in the in-scope schema definitions;</p></li><li><p>All user-defined functions present in the containing package provided their visibility is not <code>hidden</code> or <code>private</code>;</p></li><li><p>An <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>.</p></li></ul><p>Note that this set deliberately excludes XSLT-defined functions in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a> including for example, <a href="#func-key"><code>key</code></a>, <a href="#func-current-group"><code>current-group</code></a>, and <a href="#func-system-property"><code>system-property</code></a>. A list of these functions is in <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>.</p></li><li><p>Statically known collations: the same as the collations available at this point in the stylesheet.</p></li><li><p>Default collation: the same as the default collation defined at this point in the stylesheet (for example, by use of the <code>[xsl:]default-collation</code> attribute)</p></li><li><p>Base URI: if the <code>base-uri</code> attribute is present, then its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>; otherwise, the base URI of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p></li><li><p>Statically known documents: the empty set</p></li><li><p>Statically known collections: the empty set</p></li><li><p>Statically known default collection type: <code>node()*</code></p></li></ul></div><div class="div3"><h4><a id="evaluate-dynamic-context"></a>10.4.2 <a href="#evaluate-dynamic-context" style="text-decoration: none">Dynamic context for the target expression</a></h4><p>The dynamic context for evaluation of the target expression is as follows:</p><ul><li><p>The context item, position, and size depend on the result of evaluating the expression in the <code>context-item</code> attribute. If this attribute is absent, or if the result is an empty sequence, then the context item, position, and size for evaluation of the target expression are all <a title="absent" class="termref" href="#dt-absent">absent</a>. If the result of evaluating the <code>context-item</code> expression is a single item, then the target expression is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on this item.</p><p><a id="err-XTTE3210"><span class="error">[ERR XTTE3210] </span></a>If the result of evaluating the <code>context-item</code> expression is a sequence containing more than one item, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> is signaled.</p></li><li><p>The <b>variable values</b> consists of the values bound to parameters defined either in the contained <a href="#element-with-param"><code>xsl:with-param</code></a> elements, which are evaluated as described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>, or in the map that results from evaluation of the expression in the <code>with-params</code> attribute; if the same QName is bound in both, the value in the <code>with-params</code> map takes precedence.</p></li><li><p>The XSLT-specific aspects of the dynamic context described in <a href="#additional-dynamic-context"><i>5.3.5 Additional Dynamic Context Components used by XSLT</i></a> are all <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamically-known-function-definitions">dynamically known function definitions</a><sup><small>XP40</small></sup> (representing the functions accessible using <a href="#func-function-available"><code>function-available</code></a> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>) include all the functions available in the static context, and may also include an additional <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of functions that are available dynamically but not statically. </p></li><li><p>All other aspects of the dynamic context are the same as the dynamic context for the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction itself, except that an implementation <code>may</code> restrict the availability of external resources (for example, available documents) or provide options to restrict their availability, for security reasons.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, a processor may disallow access using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions to documents in local filestore.</p></div></li></ul></div><div class="div3"><h4><a id="evaluate-effect"></a>10.4.3 <a href="#evaluate-effect" style="text-decoration: none">The effect of the </a><code>xsl:evaluate</code><a href="#evaluate-effect" style="text-decoration: none"> instruction</a></h4><p>The XPath expression is evaluated in the same <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO40</small></sup> as the calling XSLT transformation; this means that the results of <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO40</small></sup> functions such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-current-dateTime"><code>current-dateTime</code></a><sup><small>FO30</small></sup> will be consistent between the calling stylesheet and the called XPath expression.</p><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if evaluation of the XPath expression fails with a dynamic error. The XPath-defined error code is used unchanged.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations wanting to avoid the cost of repeated compilation of the same XPath expression should cache the compiled form internally.</p></div><p>Stylesheet authors need to be aware of the security risks associated with the use of <a href="#element-evaluate"><code>xsl:evaluate</code></a>. The instruction should not be used to execute code from an untrusted source. To avoid the risk of code injection, user-supplied data should never be inserted into the expression using string concatenation, but should always be referenced by use of parameters.</p></div><div class="div3"><h4><a id="evaluation-as-optional-feature"></a>10.4.4 <a href="#element-evaluate"><code>xsl:evaluate</code></a><a href="#evaluation-as-optional-feature" style="text-decoration: none"> as an optional feature</a></h4><p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is newly introduced in XSLT 3.0. It is part of the dynamic evaluation feature, which is an optional feature of the specification (see <a href="#dynamic-evaluation-feature"><i>28.6 Dynamic Evaluation Feature</i></a>). An XSLT 3.0 processor <span class="verb">may</span> disable the feature, or allow users to disable the feature. The processor <span class="verb">may</span> be able to determine during static analysis whether or not the feature is available, or it <span class="verb">may</span> only be able to determine this during dynamic evaluation. In the first case we refer to the feature being <b>statically disabled</b>, in the second case to it being <b>dynamically disabled</b>.</p><p>If the feature is statically disabled, then:</p><ul><li><p>A call to <code>element-available('xsl:evaluate')</code> returns false, wherever it appears;</p></li><li><p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code> returns the string <code>"no"</code>, wherever it appears;</p></li><li><p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction has an <a href="#element-fallback"><code>xsl:fallback</code></a> child, fallback processing takes place;</p></li><li><p>No static error is raised if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is present in the stylesheet (an error occurs only if it is actually evaluated).</p></li></ul><p>If the feature is dynamically disabled, then:</p><ul><li><p>A call to <code>element-available('xsl:evaluate')</code> appearing in a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a> (for example, in an <code>[xsl:]use-when</code> attribute) returns true;</p></li><li><p>A call to <code>element-available('xsl:evaluate')</code> appearing anywhere else returns false;</p></li><li><p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code> appearing in a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a> (for example, in an <code>[xsl:]use-when</code> attribute) returns the string <code>"yes"</code>;</p></li><li><p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code> appearing anywhere else returns the string <code>"no"</code>;</p></li><li><p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction has an <a href="#element-fallback"><code>xsl:fallback</code></a> child, fallback processing takes place;</p></li><li><p>In the absence of an <a href="#element-fallback"><code>xsl:fallback</code></a> child, a dynamic error is raised if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated. The dynamic error may be caught using <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a>.</p></li></ul><p>If a processor supports the dynamic evaluation feature, it is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> how the processor allows users to disable dynamic evaluation and it is implementation-defined whether the mechanism is static or dynamic.</p><p><a id="err-XTDE3175"><span class="error">[ERR XTDE3175] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated when use of <a href="#element-evaluate"><code>xsl:evaluate</code></a> has been statically or dynamically disabled. </p><p>In consequence of these rules, the recommended approach for stylesheet authors to write code that works whether or not <a href="#element-evaluate"><code>xsl:evaluate</code></a> is enabled is to use an <a href="#element-fallback"><code>xsl:fallback</code></a> child instruction. For example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">isValid</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:evaluate</span><span class="z"></span><span class="atn">xpath</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$validityCondition</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:fallback</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">true</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fallback</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:evaluate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>There may be circumstances where it is inappropriate to allow use of <a href="#element-evaluate"><code>xsl:evaluate</code></a>. For example:</p><ul><li><p>There may be security risks associated with the ability to execute code from an untrusted source, which cannot be inspected during static analysis.</p></li><li><p>There may be environments where the available computing resources are sufficient to enable pre-compiled stylesheets to be executed, but not to enable XPath expressions to be compiled into executable code.</p></li></ul><p> Processors that implement <a href="#element-evaluate"><code>xsl:evaluate</code></a> should provide mechanisms allowing calls on <a href="#element-evaluate"><code>xsl:evaluate</code></a> to be disabled. Implementations may disable the feature by default, and they may disable it unconditionally. </p></div></div><div class="div3"><h4><a id="evaluate-examples"></a>10.4.5 <a href="#evaluate-examples" style="text-decoration: none">Examples of </a><a href="#element-evaluate"><code>xsl:evaluate</code></a></h4><div class="example"><div class="exampleHeader"><a id="d8e28261"></a><a id="d8e28367"></a>Example: Using a Dynamic Sort Key</div><p>A common requirement is to sort a table on the value of an expression which is selected at run-time, perhaps by supplying the expression as a string-valued parameter to the stylesheet. Suppose that such an expression is supplied to the parameter:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">sortkey</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">@name</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>Then the data may be sorted as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:evaluate</span><span class="z"></span><span class="atn">xpath</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$sortkey</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">context-item</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sort</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Note the importance in this use case of caching the compiled expression, since it is evaluated repeatedly, once for each item in the list being sorted.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e28270"></a><a id="d8e28376"></a>Example: Getting a Function if it Exists</div><p>If the <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> function were not available in the standard library, then a very similar function could be implemented like this:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:function-lookup</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">name</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:QName</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arity</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:try</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:evaluate</span><span class="z"></span><span class="atn">xpath</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Q{</span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="function">namespace-uri-from-QName</span><span class="parenthesis">(</span><span class="variable">$name</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">}</span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="function">local-name-from-QName</span><span class="parenthesis">(</span><span class="variable">$name</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">#</span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="variable">$arity</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">name</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:QName</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">arity</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$arity</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:evaluate</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:catch</span><span class="z"></span><span class="atn">errors</span><span class="atneq">=</span><span class="z">"</span><span class="av">err:XTDE3160</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:try</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The main difference between this function and the standard <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> function is that there are differences in the functions that are visible: for example <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> gives access to user-defined functions with private visibility, whereas <a href="#element-evaluate"><code>xsl:evaluate</code></a> does not.</p></div><p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction uses the supplied QName and arity to construct an expression of the form <code>Q{namespace-uri}local#arity</code>, which is then evaluated to return a function item representing the requested function.</p></div></div></div></div><div class="div1"><h2><a id="creating-new-nodes"></a>11 <a href="#creating-new-nodes" style="text-decoration: none">Creating Nodes and Sequences</a></h2><p>This section describes instructions that directly create new nodes, or sequences of nodes, atomic values, and/or function items.</p><div class="div2"><h3><a id="literal-result-element"></a>11.1 <a href="#literal-result-element" style="text-decoration: none">Literal Result Elements</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-literal-result-element" title="literal result element"></a>In a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that does not belong to the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> and that is not an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a>) is classified as a <b>literal result element</b>.<span class="definition">]</span> A literal result element is evaluated to construct a new element node with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (that is, the same namespace URI, local name, and namespace prefix). The result of evaluating a literal result element is a node sequence containing one element, the newly constructed element node.</p><p>The content of the element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>). The sequence obtained by evaluating this sequence constructor, after prepending any attribute nodes produced as described in <a href="#attributes-for-lres"><i>11.1.2 Attribute Nodes for Literal Result Elements</i></a> and namespace nodes produced as described in <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>, is used to construct the content of the element, following the rules in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a></p><p>The base URI of the new element is copied from the base URI of the literal result element in the stylesheet, unless the content of the new element includes an <code>xml:base</code> attribute, in which case the base URI of the new element is the value of that attribute, resolved (if it is a relative URI reference) against the base URI of the literal result element in the stylesheet. (Note, however, that this is only relevant when creating a parentless element. When the literal result element is copied to form a child of an element or document node, the base URI of the new copy is taken from that of its new parent.)</p><div class="div3"><h4><a id="setting-annotation-for-lre"></a>11.1.1 <a href="#setting-annotation-for-lre" style="text-decoration: none">Setting the Type Annotation for Literal Result Elements</a></h4><p>The attributes <code>xsl:type</code> and <code>xsl:validation</code> may be used on a literal result element to invoke validation of the contents of the element against a type definition or element declaration in a schema, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new element node will carry. These attributes also affect the type annotation carried by any elements and attributes that have the new element node as an ancestor. These two attributes are both optional, and if one is specified then the other <span class="verb">must</span> be omitted.</p><p>The value of the <code>xsl:validation</code> attribute, if present, must be one of the values <code>strict</code>, <code>lax</code>, <code>preserve</code>, or <code>strip</code>. The value of the <code>xsl:type</code> attribute, if present, must be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> identifying a type definition that is present in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the stylesheet. Neither attribute may be specified as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template.</a> The effect of these attributes is described in <a href="#validation"><i>26.4 Validation</i></a>.</p></div><div class="div3"><h4><a id="attributes-for-lres"></a>11.1.2 <a href="#attributes-for-lres" style="text-decoration: none">Attribute Nodes for Literal Result Elements</a></h4><p>Attribute nodes for a literal result element may be created by including <a href="#element-attribute"><code>xsl:attribute</code></a> instructions within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. Additionally, attribute nodes are created corresponding to the attributes of the literal result element in the stylesheet, and as a result of expanding the <code>xsl:use-attribute-sets</code> attribute of the literal result element, if present.</p><p>The sequence that is used to construct the content of the literal result element (as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>) is the concatenation of the following four sequences, in order:</p><ol class="enumar"><li><p>The sequence of namespace nodes produced as described in <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>.</p></li><li><p>The sequence of attribute nodes produced by expanding the <code>xsl:use-attribute-sets</code> attribute (if present) following the rules given in <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a></p></li><li><p>The attributes produced by processing the attributes of the literal result element itself, other than attributes in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. The way these are processed is described below.</p></li><li><p>The sequence produced by evaluating the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, if the element is not empty.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The significance of this order is that an attribute produced by an <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction in the content of the literal result element takes precedence over an attribute produced by expanding an attribute of the literal result element itself, which in turn takes precedence over an attribute produced by expanding the <code>xsl:use-attribute-sets</code> attribute. This is because of the rules in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>, which specify that when two or more attributes in the sequence have the same name, all but the last of the duplicates are discarded.</p><p>Although the above rules place namespace nodes before attributes, this is not strictly necessary, because the rules in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a> allow the namespaces and attributes to appear in any order so long as both come before other kinds of node. The order of namespace nodes and attribute nodes in the sequence has no effect on the relative position of the nodes in document order once they are added to a tree.</p></div><p>Each attribute of the literal result element, other than an attribute in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, is processed to produce an attribute for the element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p><p>The value of such an attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>: it can therefore contain <a title="expression" class="termref" href="#dt-expression">expressions</a> contained in curly brackets (<code>{}</code>). The new attribute node will have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (that is, the same namespace URI, local name, and namespace prefix) as the attribute in the stylesheet tree, and its <a title="string value" class="termref" href="#dt-string-value">string value</a> will be the same as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute in the stylesheet tree. The <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> on the attribute will initially be <code>xs:untypedAtomic</code>, and the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of the attribute node will be the same as its <a title="string value" class="termref" href="#dt-string-value">string value</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The eventual <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the attribute in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> depends on the <code>xsl:validation</code> and <code>xsl:type</code> attributes of the parent literal result element, and on the instructions used to create its ancestor elements. If the <code>xsl:validation</code> attribute is set to <code>preserve</code> or <code>strip</code>, the type annotation will be <code>xs:untypedAtomic</code>, and the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of the attribute node will be the same as its <a title="string value" class="termref" href="#dt-string-value">string value</a>. If the <code>xsl:validation</code> attribute is set to <code>strict</code> or <code>lax</code>, or if the <code>xsl:type</code> attribute is used, the type annotation on the attribute will be set as a result of the schema validation process applied to the parent element. If neither attribute is present, the type annotation on the attribute will be <code>xs:untypedAtomic</code>.</p></div><p>If the name of a constructed attribute is <code>xml:id</code>, the processor must perform attribute value normalization by effectively applying the <a href="https://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>normalize-space</code></a><sup><small>FO30</small></sup> function to the value of the attribute, and the resulting attribute node must be given the <code>is-id</code> property.</p><div class="note"><p class="prefix"><b>Note:</b></p><p> If the attribute name is <code>xml:space</code>, it is <em>not</em> an error when the value is something other than <code>default</code> or <code>preserve</code>. Although the XML specification states that other values are erroneous, a document containing such values is well-formed; if erroneous values are to be rejected, schema validation should be used. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>xml:base</code>, <code>xml:lang</code>, <code>xml:space</code>, and <code>xml:id</code> attributes have two effects in XSLT. They behave as standard XSLT attributes, which means for example that if they appear on a literal result element, they will be copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> in the same way as any other attribute. In addition, they have their standard meaning as defined in the core XML specifications. Thus, an <code>xml:base</code> attribute in the stylesheet affects the base URI of the element on which it appears, and an <code>xml:space</code> attribute affects the interpretation of <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> within that element. One consequence of this is that it is inadvisable to write these attributes as attribute value templates: although an XSLT processor will understand this notation, the XML parser will not. See also <a href="#namespace-aliasing"><i>11.1.4 Namespace Aliasing</i></a> which describes how to use <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> with these attributes.</p><p>The same is true of the schema-defined attributes <code>xsi:type</code>, <code>xsi:nil</code>, <code>xsi:noNamespaceSchemaLocation</code>, and <code>xsi:schemaLocation</code>. If the stylesheet is processed by a schema processor, these attributes will be recognized and interpreted by the schema processor, but in addition the XSLT processor treats them like any other attribute on a literal result element: that is, their <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> (after expanding <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>) is copied to the result tree in the same way as any other attribute. If the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is validated, the copied attributes will again be recognized and interpreted by the schema processor.</p><p>None of these attributes will be generated in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> unless the stylesheet writes them to the result tree explicitly, in the same way as any other attribute.</p></div><p><a id="err-XTSE0805"><span class="error">[ERR XTSE0805] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an attribute on a literal result element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, unless it is one of the attributes explicitly defined in this specification. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>If there is a need to create attributes in the XSLT namespace, this can be achieved using <a href="#element-attribute"><code>xsl:attribute</code></a>, or by means of the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration.</p></div></div><div class="div3"><h4><a id="lre-namespaces"></a>11.1.3 <a href="#lre-namespaces" style="text-decoration: none">Namespace Nodes for Literal Result Elements</a></h4><p>The created element node will have a copy of the namespace nodes that were present on the element node in the stylesheet tree with the exception of any namespace node whose <a title="string value" class="termref" href="#dt-string-value">string value</a> is designated as an <b>excluded namespace</b>. Special considerations apply to aliased namespaces: see <a href="#namespace-aliasing"><i>11.1.4 Namespace Aliasing</i></a>. </p><p>The following namespaces are designated as excluded namespaces:</p><ul><li><p>The <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> URI (<code>http://www.w3.org/1999/XSL/Transform</code>)</p></li><li><p>A namespace URI declared as an extension namespace (see <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a>)</p></li><li><p>A namespace URI designated by using an <code>[xsl:]exclude-result-prefixes</code> attribute either on the literal result element itself or on an ancestor element. The attribute <span class="verb">must</span> be in the XSLT namespace only if its parent element is <em>not</em> in the XSLT namespace.</p><p>The value of the attribute is either <code>#all</code>, or a whitespace-separated list of tokens, each of which is either a namespace prefix or <code>#default</code>. The namespace bound to each of the prefixes is designated as an excluded namespace.</p><p><a id="err-XTSE0808"><span class="error">[ERR XTSE0808] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a namespace prefix is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and there is no namespace binding in scope for that prefix. </p><p>The default namespace of the parent element of the <code>[xsl:]exclude-result-prefixes</code> attribute (see <a href="https://www.w3.org/TR/xpath-datamodel-30/#ElementNode">Section 6.2 Element Nodes </a><sup><small>DM30</small></sup>) may be designated as an excluded namespace by including <code>#default</code> in the list of namespace prefixes.</p><p><a id="err-XTSE0809"><span class="error">[ERR XTSE0809] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value <code>#default</code> is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and the parent element of the <code>[xsl:]exclude-result-prefixes</code> attribute has no default namespace. </p><p>The value <code>#all</code> indicates that all namespaces that are in scope for the stylesheet element that is the parent of the <code>[xsl:]exclude-result-prefixes</code> attribute are designated as excluded namespaces.</p><p>The designation of a namespace as an excluded namespace is effective within the subtree of the stylesheet module rooted at the element bearing the <code>[xsl:]exclude-result-prefixes</code> attribute; a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element does not include any stylesheet modules imported or included by children of that <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p></li></ul><p>The excluded namespaces, as described above, <em>only</em> affect namespace nodes copied from the stylesheet when processing a literal result element. There is no guarantee that an excluded namespace will not appear on the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> for some other reason. Namespace nodes are also written to the result tree as part of the process of namespace fixup (see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>), or as the result of instructions such as <a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-element"><code>xsl:element</code></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When a stylesheet uses a namespace declaration only for the purposes of addressing a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>, specifying the prefix in the <code>[xsl:]exclude-result-prefixes</code> attribute will avoid superfluous namespace declarations in the serialized <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. The attribute is also useful to prevent namespaces used solely for the naming of stylesheet functions or extension functions from appearing in the serialized result tree.</p></div><div class="example"><div class="exampleHeader"><a id="d8e28715"></a><a id="d8e28821"></a>Example: Excluding Namespaces from the Result Tree</div><p>Consider the following stylesheet:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">1.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:a</span><span class="atneq">=</span><span class="z">"</span><span class="av">a.uri</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:b</span><span class="atneq">=</span><span class="z">"</span><span class="av">b.uri</span><span class="z">"</span><span class="z"></span><span class="atn">exclude-result-prefixes</span><span class="atneq">=</span><span class="z">"</span><span class="av">#all</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">foo</span><span class="z"></span><span class="atn">xmlns:c</span><span class="atneq">=</span><span class="z">"</span><span class="av">c.uri</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:d</span><span class="atneq">=</span><span class="z">"</span><span class="av">d.uri</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:a2</span><span class="atneq">=</span><span class="z">"</span><span class="av">a.uri</span><span class="z">"</span><span class="z"></span><span class="atn">xsl:exclude-result-prefixes</span><span class="atneq">=</span><span class="z">"</span><span class="av">c</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The result of this stylesheet will be:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">foo</span><span class="z"></span><span class="atn">xmlns:d</span><span class="atneq">=</span><span class="z">"</span><span class="av">d.uri</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The namespaces <code>a.uri</code> and <code>b.uri</code> are excluded by virtue of the <code>exclude-result-prefixes</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, and the namespace <code>c.uri</code> is excluded by virtue of the <code>xsl:exclude-result-prefixes</code> attribute on the <code>foo</code> element. The setting <code>#all</code> does not affect the namespace <code>d.uri</code> because <code>d.uri</code> is not an in-scope namespace for the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element. The element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> does not have a namespace node corresponding to <code>xmlns:a2="a.uri"</code> because the effect of <code>exclude-result-prefixes</code> is to designate the namespace URI <code>a.uri</code> as an excluded namespace, irrespective of how many prefixes are bound to this namespace URI.</p><p>If the stylesheet is changed so that the literal result element has an attribute <code>b:bar="3"</code>, then the element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> will typically have a namespace declaration <code>xmlns:b="b.uri"</code> (the processor may choose a different namespace prefix if this is necessary to avoid conflicts). The <code>exclude-result-prefixes</code> attribute makes <code>b.uri</code> an excluded namespace, so the namespace node is not automatically copied from the stylesheet, but the presence of an attribute whose name is in the namespace <code>b.uri</code> forces the namespace fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>) to introduce a namespace node for this namespace.</p></div><p>A literal result element may have an optional <code>xsl:inherit-namespaces</code> attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>. If the value is set to <code>yes</code>, or is omitted, then the namespace nodes created for the newly constructed element are copied to the children and descendants of the newly constructed element, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>. If the value is set to <code>no</code>, then these namespace nodes are not automatically copied to the children. This may result in namespace undeclarations (such as <code>xmlns=""</code> or, in the case of XML 1.1, <code>xmlns:p=""</code>) appearing on the child elements when they are serialized.</p></div><div class="div3"><h4><a id="namespace-aliasing"></a>11.1.4 <a href="#namespace-aliasing" style="text-decoration: none">Namespace Aliasing</a></h4><p>When a stylesheet is used to define a transformation whose output is itself a stylesheet module, or in certain other cases where the result document uses namespaces that it would be inconvenient to use in the stylesheet, namespace aliasing can be used to declare a mapping between a namespace URI used in the stylesheet and the corresponding namespace URI to be used in the result document.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-literal-namespace-uri" title="literal namespace URI"></a>A namespace URI in the stylesheet tree that is being used to specify a namespace URI in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is called a <b>literal namespace URI</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-target-namespace-uri" title="target namespace URI"></a>The namespace URI that is to be used in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> as a substitute for a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is called the <b>target namespace URI</b>.<span class="definition">]</span></p><p>Either of the <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> or the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a> can be <em>null</em>: this is treated as a reference to the set of names that are in no namespace.</p><p class="element-syntax"><a id="element-namespace-alias"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:namespace-alias<br>&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | "#default"<br>&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> | "#default"&nbsp;/&gt;</code></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-alias" title="alias"></a>A stylesheet can use the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is being used as an <b>alias</b> for a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>.<span class="definition">]</span></p><p>The effect is that when names in the namespace identified by the <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> are copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>, the namespace URI in the result tree will be the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, instead of the literal namespace URI. This applies to:</p><ul><li><p>the namespace URI in the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of a literal result element in the stylesheet</p></li><li><p>the namespace URI in the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an attribute specified on a literal result element in the stylesheet</p></li></ul><p>The effect of an <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration is local to the <a title="package" class="termref" href="#dt-package">package</a> in which it appears: that is, it only affects the result of <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a> within the same package.</p><p>Where namespace aliasing changes the namespace URI part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> containing the name of an element or attribute node, the namespace prefix in that expanded QName is replaced by the prefix indicated by the <code>result-prefix</code> attribute of the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration.</p><p>The <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element declares that the namespace URI bound to the prefix specified by the <code>stylesheet-prefix</code> is the <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a>, and the namespace URI bound to the prefix specified by the <code>result-prefix</code> attribute is the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>. Thus, the <code>stylesheet-prefix</code> attribute specifies the namespace URI that will appear in the stylesheet, and the <code>result-prefix</code> attribute specifies the corresponding namespace URI that will appear in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. </p><p>The default namespace (as declared by <code>xmlns</code>) may be specified by using <code>#default</code> instead of a prefix. If no default namespace is in force, specifying <code>#default</code> denotes the null namespace URI. This allows elements that are in no namespace in the stylesheet to acquire a namespace in the result document, or vice versa. <span> Defining an alias for the null namespace URI does not affect no-namespace attributes; these remain in no namespace. However, where <code>result-prefix="#default"</code> is specified and no default namespace is in force, attributes whose namespace matches the literal namespace URI are renamed to be in no namespace. [XSLT 3.0 Erratum E48, bug 30397] </span></p><p>If a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is declared to be an alias for multiple different <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">target namespace URIs</a>, then the declaration with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p><a id="err-XTSE0810"><span class="error">[ERR XTSE0810] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within a <a title="package" class="termref" href="#dt-package">package</a> there is more than one such declaration with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and different values for the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, unless there is also an <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and a higher import precedence. </p><p>No error occurs if there is more than one such <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration having the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and the same <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, even if the <code>result-prefix</code> differs; in this case the <code>result-prefix</code> used is the one that appears last in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>. </p><p><a id="err-XTSE0812"><span class="error">[ERR XTSE0812] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a value other than <code>#default</code> is specified for either the <code>stylesheet-prefix</code> or the <code>result-prefix</code> attributes of the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element when there is no in-scope binding for that namespace prefix. </p><p>When a literal result element is processed, its namespace nodes are handled as follows:</p><ul><li><p>A namespace node whose string value is a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is not copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p></li><li><p>A namespace node whose string value is a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a> is copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>, whether or not the URI identifies an excluded namespace.</p></li></ul><p>In the event that the same URI is used as a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, the second of these rules takes precedence.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>These rules achieve the effect that the element generated from the literal result element will have an in-scope namespace node that binds the <code>result-prefix</code> to the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, provided that the namespace declaration associating this prefix with this URI is in scope for both the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> instruction and for the literal result element. Conversely, the <code>stylesheet-prefix</code> and the <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> will not normally appear in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p></div><div class="example"><div class="exampleHeader"><a id="d8e29064"></a><a id="d8e29170"></a>Example: Using <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> to Generate a Stylesheet</div><p>When literal result elements are being used to create element, attribute, or namespace nodes that use the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> URI, the stylesheet may use an alias. </p><p>For example, the stylesheet</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:fo</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Format</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:axsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">file://namespace.alias</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:namespace-alias</span><span class="z"></span><span class="atn">stylesheet-prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">axsl</span><span class="z">"</span><span class="z"></span><span class="atn">result-prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">xsl</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">axsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">axsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">elements</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">axsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="av">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">axsl:comment</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="av">system-property('xsl:version')</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">axsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">axsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">block</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">axsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="context">.</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">axsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">axsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>will generate an XSLT stylesheet from a document of the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">elements</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">block</span><span class="scx">&gt;</span><span class="txt">p</span><span class="ez">&lt;/</span><span class="cl">block</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">block</span><span class="scx">&gt;</span><span class="txt">h1</span><span class="ez">&lt;/</span><span class="cl">block</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">block</span><span class="scx">&gt;</span><span class="txt">h2</span><span class="ez">&lt;/</span><span class="cl">block</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">block</span><span class="scx">&gt;</span><span class="txt">h3</span><span class="ez">&lt;/</span><span class="cl">block</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">block</span><span class="scx">&gt;</span><span class="txt">h4</span><span class="ez">&lt;/</span><span class="cl">block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">elements</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The output of the transformation will be a stylesheet such as the following. Whitespace has been added for clarity. Note that an implementation may output different namespace prefixes from those appearing in this example; however, the rules guarantee that there will be a namespace node that binds the prefix <code>xsl</code> to the URI <code>http://www.w3.org/1999/XSL/Transform</code>, which makes it safe to use the QName <code>xsl:version</code> in the content of the generated stylesheet.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:fo</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Format</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:comment</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">system-property</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">xsl:version</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">p</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">h1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">h2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">h3</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">h4</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It may be necessary also to use aliases for namespaces other than the XSLT namespace URI. For example, it can be useful to define an alias for the namespace <code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the stylesheet can use the attributes <code>xsi:type</code>, <code>xsi:nil</code>, and <code>xsi:schemaLocation</code> on a literal result element, without running the risk that a schema processor will interpret these as applying to the stylesheet itself. Equally, literal result elements belonging to a namespace dealing with digital signatures might cause XSLT stylesheets to be mishandled by general-purpose security software; using an alias for the namespace would avoid the possibility of such mishandling.</p></div><div class="example"><div class="exampleHeader"><a id="d8e29102"></a><a id="d8e29208"></a>Example: Aliasing the XML Namespace</div><p>It is possible to define an alias for the XML namespace.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">xmlns:axml</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.example.com/alias-xml</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:namespace-alias</span><span class="z"></span><span class="atn">stylesheet-prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">axml</span><span class="z">"</span><span class="z"></span><span class="atn">result-prefix</span><span class="atneq">=</span><span class="z">"</span><span class="av">xml</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">name</span><span class="z"></span><span class="atn">axml:space</span><span class="atneq">=</span><span class="z">"</span><span class="av">preserve</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">first</span><span class="scx">&gt;</span><span class="txt">James</span><span class="ez">&lt;/</span><span class="cl">first</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">last</span><span class="scx">&gt;</span><span class="txt">Clark</span><span class="ez">&lt;/</span><span class="cl">last</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">name</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>produces the output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">name</span><span class="z"></span><span class="atn">xml:space</span><span class="atneq">=</span><span class="z">"</span><span class="av">preserve</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">first</span><span class="scx">&gt;</span><span class="txt">James</span><span class="ez">&lt;/</span><span class="cl">first</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">last</span><span class="scx">&gt;</span><span class="txt">Clark</span><span class="ez">&lt;/</span><span class="cl">last</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">name</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This allows an <code>xml:space</code> attribute to be generated in the output without affecting the way the stylesheet is parsed. The same technique can be used for other attributes such as <code>xml:lang</code>, <code>xml:base</code>, and <code>xml:id</code>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Namespace aliasing is only necessary when literal result elements are used. The problem of reserved namespaces does not arise when using <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-attribute"><code>xsl:attribute</code></a> to construct the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. Therefore, as an alternative to using <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>, it is always possible to achieve the desired effect by replacing literal result elements with <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-attribute"><code>xsl:attribute</code></a> instructions.</p></div></div></div><div class="div2"><h3><a id="xsl-element"></a>11.2 <a href="#xsl-element" style="text-decoration: none">Creating Element Nodes Using </a><code>xsl:element</code><a href="#xsl-element" style="text-decoration: none"></a></h3><p class="element-syntax"><a id="element-element"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:element<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var><br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:element&gt;</code></p><p>The <a href="#element-element"><code>xsl:element</code></a> instruction allows an element to be created with a computed name. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element to be created is specified by a <span class="verb">required</span><code>name</code> attribute and an optional <code>namespace</code> attribute.</p><p>The result of evaluating the <a href="#element-element"><code>xsl:element</code></a> instruction, in usual circumstances, is the newly constructed element node.</p><div class="div3"><h4><a id="xsl-element-content"></a>11.2.1 <a href="#xsl-element-content" style="text-decoration: none">The Content of the Constructed Element Node</a></h4><p>The content of the <a href="#element-element"><code>xsl:element</code></a> instruction is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> for the children, attributes, and namespaces of the created element. The sequence obtained by evaluating this sequence constructor (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) is used to construct the content of the element, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>.</p><p>The <a href="#element-element"><code>xsl:element</code></a> element may have a <code>use-attribute-sets</code> attribute, whose value is a whitespace-separated list of QNames that identify <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations. If this attribute is present, it is expanded as described in <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a> to produce a sequence of attribute nodes. This sequence is prepended to the sequence produced as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>.</p></div><div class="div3"><h4><a id="xsl-element-name"></a>11.2.2 <a href="#xsl-element-name" style="text-decoration: none">The Name of the Constructed Element Node</a></h4><p>The <code>name</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><span class="verb">must</span> be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p><p><a id="err-XTDE0820"><span class="error">[ERR XTDE0820] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>. </p><p><a id="err-XTDE0830"><span class="error">[ERR XTDE0830] </span></a>In the case of an <a href="#element-element"><code>xsl:element</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-element"><code>xsl:element</code></a> instruction. </p><p>If the <code>namespace</code> attribute is not present then the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in effect for the <a href="#element-element"><code>xsl:element</code></a> element, including any default namespace declaration.</p><p>If the <code>namespace</code> attribute is present, then it too is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><span class="verb">must</span> be in the lexical space of the <code>xs:anyURI</code> type. If the string is zero-length, then the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element has a null namespace URI. Otherwise, the string is used as the namespace URI of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element to be created. The local part of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> specified by the <code>name</code> attribute is used as the local part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element to be created.</p><p><a id="err-XTDE0835"><span class="error">[ERR XTDE0835] </span></a> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>namespace</code> attribute is not in the lexical space of the <code>xs:anyURI</code> datatype or if it is the string <code>http://www.w3.org/2000/xmlns/</code>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The XDM data model requires the name of a node to be an instance of <code>xs:QName</code>, and XML Schema defines the namespace part of an <code>xs:QName</code> to be an instance of <code>xs:anyURI</code>. However, the schema specification, and the specifications that it refers to, give implementations some flexibility in how strictly they enforce these constraints.</p></div><p>The prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> specified in the <code>name</code> attribute (or the absence of a prefix) is copied to the prefix part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> representing the name of the new element node. In the event of a conflict a prefix may subsequently be added, changed, or removed during the namespace fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>). The term <em>conflict</em> here means any violation of the constraints defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>, for example the use of the same prefix to refer to two different namespaces in the element and in one of its attributes, the use of the prefix <code>xml</code> to refer to a namespace other than the XML namespace, or any use of the prefix <code>xmlns</code>.</p></div><div class="div3"><h4><a id="xsl-element-properties"></a>11.2.3 <a href="#xsl-element-properties" style="text-decoration: none">Other Properties of the Constructed Element Node</a></h4><p>The <a href="#element-element"><code>xsl:element</code></a> instruction has an optional <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>. If the value is set to <code>yes</code>, or is omitted, then the namespace nodes created for the newly constructed element (whether these were copied from those of the source node, or generated as a result of namespace fixup) are copied to the children and descendants of the newly constructed element, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>. If the value is set to <code>no</code>, then these namespace nodes are not automatically copied to the children. This may result in namespace undeclarations (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements when the element is serialized.</p><p>The base URI of the new element is copied from the base URI of the <a href="#element-element"><code>xsl:element</code></a> instruction in the stylesheet, unless the content of the new element includes an <code>xml:base</code> attribute, in which case the base URI of the new element is the value of that attribute, resolved (if it is a relative URI) against the base URI of the <a href="#element-element"><code>xsl:element</code></a> instruction in the stylesheet. (Note, however, that this is only relevant when creating parentless elements. When the new element is copied to form a child of an element or document node, the base URI of the new copy is taken from that of its new parent.)</p><p>The values of the <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties of the new element depend on the <code>type</code> and <code>validation</code> attributes of the <a href="#element-element"><code>xsl:element</code></a> instruction, as explained in <a href="#validation"><i>26.4 Validation</i></a>.</p></div><div class="div3"><h4><a id="annotation-for-constructed-element"></a>11.2.4 <a href="#annotation-for-constructed-element" style="text-decoration: none">The Type Annotation of the Constructed Element Node</a></h4><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-element"><code>xsl:element</code></a> instruction to invoke validation of the contents of the element against a type definition or element declaration in a schema, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new element node will carry. These attributes also affect the type annotation carried by any elements and attributes that have the new element node as an ancestor. These two attributes are both optional, and if one is specified then the other <span class="verb">must</span> be omitted. The permitted values of these attributes and their semantics are described in <a href="#validation"><i>26.4 Validation</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The final type annotation of the element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> also depends on the <code>type</code> and <code>validation</code> attributes of the instructions used to create the ancestors of the element.</p></div></div></div><div class="div2"><h3><a id="creating-attributes"></a>11.3 <a href="#creating-attributes" style="text-decoration: none">Creating Attribute Nodes Using </a><code>xsl:attribute</code><a href="#creating-attributes" style="text-decoration: none"></a></h3><p class="element-syntax"><a id="element-attribute"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:attribute<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:attribute&gt;</code></p><p>The <a href="#element-attribute"><code>xsl:attribute</code></a> element can be used to add attributes to result elements whether created by literal result elements in the stylesheet or by instructions such as <a href="#element-element"><code>xsl:element</code></a> or <a href="#element-copy"><code>xsl:copy</code></a>. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the attribute to be created is specified by a <span class="verb">required</span><code>name</code> attribute and an optional <code>namespace</code> attribute. Except in error cases, the result of evaluating an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction is the newly constructed attribute node.</p><p>The string value of the new attribute node may be defined either by using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-attribute"><code>xsl:attribute</code></a> element. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the string value of the new attribute node will be a zero-length string. The way in which the value is constructed is specified in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p><p><a id="err-XTSE0840"><span class="error">[ERR XTSE0840] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-attribute"><code>xsl:attribute</code></a> element is present unless the element has empty content. </p><p>If the <code>separator</code> attribute is present, then the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of this attribute is used to separate adjacent items in the result sequence, as described in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>. In the absence of this attribute, the default separator is a single space (#x20) when the content is specified using the <code>select</code> attribute, or a zero-length string when the content is specified using a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>The <code>name</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><span class="verb">must</span> be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p><p><a id="err-XTDE0850"><span class="error">[ERR XTDE0850] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>. </p><p><a id="err-XTDE0855"><span class="error">[ERR XTDE0855] </span></a>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is the string <code>xmlns</code>. </p><p><a id="err-XTDE0860"><span class="error">[ERR XTDE0860] </span></a>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction. </p><p>If the <code>namespace</code> attribute is not present, then the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in effect for the <a href="#element-attribute"><code>xsl:attribute</code></a> element, <em>not</em> including any default namespace declaration.</p><p>If the <code>namespace</code> attribute is present, then it too is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><span class="verb">must</span> be in the lexical space of the <code>xs:anyURI</code> type. If the string is zero-length, then the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the attribute has a null namespace URI. Otherwise, the string is used as the namespace URI of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the attribute to be created. The local part of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> specified by the <code>name</code> attribute is used as the local part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the attribute to be created.</p><p><a id="err-XTDE0865"><span class="error">[ERR XTDE0865] </span></a> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>namespace</code> attribute is not in the lexical space of the <code>xs:anyURI</code> datatype or if it is the string <code>http://www.w3.org/2000/xmlns/</code>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The same considerations apply as for elements: <span class="error">[see <a href="#err-XTDE0835">ERR XTDE0835</a>]</span> in <a href="#xsl-element"><i>11.2 Creating Element Nodes Using xsl:element </i></a>.</p></div><p>The prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> specified in the <code>name</code> attribute (or the absence of a prefix) is copied to the prefix part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> representing the name of the new attribute node. In the event of a conflict this prefix may subsequently be added, changed, or removed during the namespace fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>). If the attribute is in a non-null namespace and no prefix is specified, then the namespace fixup process will invent a prefix. The term <em>conflict</em> here means any violation of the constraints defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>, for example the use of the same prefix to refer to two different namespaces in the element and in one of its attributes, the use of the prefix <code>xml</code> to refer to a namespace other than the XML namespace, or any use of the prefix <code>xmlns</code>.</p><p>If the name of a constructed attribute is <code>xml:id</code>, the processor must perform attribute value normalization by effectively applying the <a href="https://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>normalize-space</code></a><sup><small>FO30</small></sup> function to the value of the attribute, and the resulting attribute node must be given the <code>is-id</code> property. This applies whether the attribute is constructed using the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction or whether it is constructed using an attribute of a literal result element. This does not imply any constraints on the value of the attribute, or on its uniqueness, and it does not affect the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the attribute, unless the containing document is validated.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of setting the <code>is-id</code> property is that the parent element can be located within the containing document by use of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-id"><code>id</code></a><sup><small>FO30</small></sup> function. In effect, XSLT when constructing a document performs some of the functions of an <code>xml:id</code> processor, as defined in <a href="#xml-id">[xml:id]</a>; the other aspects of <code>xml:id</code> processing are performed during validation.</p></div><div class="example"><div class="exampleHeader"><a id="d8e29743"></a><a id="d8e29848"></a>Example: Creating a List-Valued Attribute</div><p>The following instruction creates the attribute <code>colors="red green blue"</code>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">colors</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">red</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">green</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">blue</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e29751"></a><a id="d8e29856"></a>Example: Namespaces are not Attributes</div><p>It is not an error to write:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">xmlns:xsl</span><span class="z">"</span><span class="z"></span><span class="atn">namespace</span><span class="atneq">=</span><span class="z">"</span><span class="av">file://some.namespace</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">http://www.w3.org/1999/XSL/Transform</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>However, this will not result in the namespace declaration <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output. Instead, it will produce an attribute node with local name <code>xsl</code>, and with a system-allocated namespace prefix mapped to the namespace URI <code>file://some.namespace</code>. This is because the namespace fixup process is not allowed to use <code>xmlns</code> as the name of a namespace node.</p></div><p>As described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>, in a sequence that is used to construct the content of an element, any attribute nodes <span class="verb">must</span> appear in the sequence before any element, text, comment, or processing instruction nodes. Where the sequence contains two or more attribute nodes with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, the one that comes last is the only one that takes effect.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If a collection of attributes is generated repeatedly, this can be done conveniently by using named attribute sets: see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a></p></div><div class="div3"><h4><a id="annotation-for-constructed-attribute"></a>11.3.1 <a href="#annotation-for-constructed-attribute" style="text-decoration: none">Setting the Type Annotation for a Constructed Attribute Node</a></h4><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction to invoke validation of the contents of the attribute against a type definition or attribute declaration in a schema, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new attribute node will carry. These two attributes are both optional, and if one is specified then the other <span class="verb">must</span> be omitted. The permitted values of these attributes and their semantics are described in <a href="#validation"><i>26.4 Validation</i></a>.</p><p>The process of validation also determines the values of the <code>is-id</code> and <code>is-idrefs</code> properties on the new attribute node.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The final <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the attribute in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> also depends on the <code>type</code> and <code>validation</code> attributes of the instructions used to create the ancestors of the attribute.</p></div></div></div><div class="div2"><h3><a id="creating-text-nodes"></a>11.4 <a href="#creating-text-nodes" style="text-decoration: none">Creating Text Nodes</a></h3><p>This section describes three different ways of creating text nodes: by means of literal text nodes in the stylesheet, or by using the <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions. It is also possible to create text nodes using the <a href="#element-number"><code>xsl:number</code></a> instruction described in <a href="#number"><i>12 Numbering</i></a>.</p><p>If and when the sequence that results from evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is used to form the content of a node, as described in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a> and <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>, adjacent text nodes in the sequence are merged. Within the sequence itself, however, they exist as distinct nodes.</p><div class="example"><div class="exampleHeader"><a id="d8e29837"></a><a id="d8e29942"></a>Example: A Sequence of Text Nodes</div><p>The following function returns a sequence of three text nodes:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:wrap</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">s</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">(</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$s</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">)</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>When this function is called as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">f:wrap</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">---</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>the result is:</p><div class="exampleInner"><pre>(---)</pre></div><p>No additional spaces are inserted, because the calling <a href="#element-value-of"><code>xsl:value-of</code></a> instruction merges adjacent text nodes before atomizing the sequence. However, the result of the instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">data</span><span class="parenthesis">(</span><span class="function">f:wrap</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">---</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>is:</p><div class="exampleInner"><pre>( --- )</pre></div><p>because in this case the three text nodes are atomized to form three strings, and spaces are inserted between adjacent strings.</p></div><p>It is possible to construct text nodes whose string value is zero-length. A zero-length text node, when atomized, produces a zero-length string. However, zero-length text nodes are ignored when they appear in a sequence that is used to form the content of a node, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a> and <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p><div class="div3"><h4><a id="literal-text-nodes"></a>11.4.1 <a href="#literal-text-nodes" style="text-decoration: none">Literal Text Nodes</a></h4><p>A <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> can contain text nodes. Each text node in a sequence constructor remaining after <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> have been stripped as specified in <a href="#stylesheet-stripping"><i>3.13.1 Stripping Whitespace and Commentary from the Stylesheet</i></a> will construct a new text node with the same <a title="string value" class="termref" href="#dt-string-value">string value</a>. The resulting text node is added to the result of the containing sequence constructor.</p><p>Text is processed at the tree level. Thus, markup of <code>&amp;lt;</code> in a template will be represented in the stylesheet tree by a text node that includes the character <code>&lt;</code>. This will create a text node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that contains a <code>&lt;</code> character, which will be represented by the markup <code>&amp;lt;</code> (or an equivalent character reference) when the result tree is serialized as an XML document, unless otherwise specified using <a title="character map" class="termref" href="#dt-character-map">character maps</a> (see <a href="#character-maps"><i>27.1 Character Maps</i></a>) or <code>disable-output-escaping</code> (see <a href="#disable-output-escaping"><i>27.2 Disabling Output Escaping</i></a>).</p></div><div class="div3"><h4><a id="xsl-text"></a>11.4.2 <a href="#xsl-text" style="text-decoration: none">Creating Text Nodes Using </a><code>xsl:text</code><a href="#xsl-text" style="text-decoration: none"></a></h4><p class="element-syntax"><a id="element-text"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:text<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: #PCDATA --&gt;<br>&lt;/xsl:text&gt;</code></p><p>The <a href="#element-text"><code>xsl:text</code></a> element is evaluated to construct a new text node.</p><p>If the element or one of its ancestors has an <code>[xsl:]expand-text</code> attribute, and the nearest ancestor with such an attribute has the value <code>yes</code>, then any unescaped curly brackets in the value of the element indicate the presence of <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>, which are expanded as described in <a href="#text-value-templates"><i>5.7.2 Text Value Templates</i></a>.</p><p><span style="display: none;" class="delete_version">In the absence of such an attribute, or if the effective value is <code>no</code>, the content of the <a href="#element-text"><code>xsl:text</code></a> element is a single text node whose value forms the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the new text node. An <a href="#element-text"><code>xsl:text</code></a> element may be empty, in which case the result of evaluating the instruction is a text node whose string value is the zero-length string.</span><span style="display: none;" class="add_version">In the absence of such an attribute, or if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>no</code>, the content of the <a href="#element-text"><code>xsl:text</code></a> element is a single text node whose value forms the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the new text node. An <a href="#element-text"><code>xsl:text</code></a> element may be empty, in which case the result of evaluating the instruction is a text node whose string value is the zero-length string.</span><span class="modify_version">In the absence of such an attribute, or if the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>is <code>no</code>, the content of the <a href="#element-text"><code>xsl:text</code></a> element is a single text node whose value forms the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the new text node. An <a href="#element-text"><code>xsl:text</code></a> element may be empty, in which case the result of evaluating the instruction is a text node whose string value is the zero-length string.</span></p><p>The result of evaluating an <a href="#element-text"><code>xsl:text</code></a> instruction is the newly constructed text node.</p><p>A text node that is an immediate child of an <a href="#element-text"><code>xsl:text</code></a> instruction will not be stripped from the stylesheet tree, even if it consists entirely of whitespace (see <a href="#strip"><i>4.3.2 Stripping Whitespace from a Source Tree</i></a>).</p><p>For the effect of the <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a><code>disable-output-escaping</code> attribute, see <a href="#disable-output-escaping"><i>27.2 Disabling Output Escaping</i></a></p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not always necessary to use the <a href="#element-text"><code>xsl:text</code></a> instruction to write text nodes to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. Literal text can be written to the result tree by including it anywhere in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, while computed text can be output using the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction. The principal reason for using <a href="#element-text"><code>xsl:text</code></a> is that it offers improved control over whitespace handling.</p></div></div><div class="div3"><h4><a id="value-of"></a>11.4.3 <a href="#value-of" style="text-decoration: none">Generating Text with </a><a href="#element-value-of"><code>xsl:value-of</code></a><a href="#value-of" style="text-decoration: none"></a></h4><p>Within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction can be used to generate computed text nodes. The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction computes the text using an <a title="expression" class="termref" href="#dt-expression">expression</a> that is specified as the value of the <code>select</code> attribute, or by means of contained instructions. This might, for example, extract text from a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> or insert the value of a variable. </p><p class="element-syntax"><a id="element-value-of"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:value-of<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:value-of&gt;</code></p><p>The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is evaluated to construct a new text node; the result of the instruction is the newly constructed text node.</p><p>The string value of the new text node may be defined either by using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) that forms the content of the <a href="#element-value-of"><code>xsl:value-of</code></a> element. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the result of the instruction is a text node whose string value is zero-length. The way in which the value is constructed is specified in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p><p><a id="err-XTSE0870"><span class="error">[ERR XTSE0870] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-value-of"><code>xsl:value-of</code></a> element is present when the content of the element is non-empty. </p><p>If the <code>separator</code> attribute is present, then the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of this attribute is used to separate adjacent items in the result sequence, as described in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>. In the absence of this attribute, the default separator is a single space (#x20) when the content is specified using the <code>select</code> attribute, or a zero-length string when the content is specified using a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>Special rules apply when the instruction is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. If no <code>separator</code> attribute is present, and if the <code>select</code> attribute is present, then all items in the <a title="atomize" class="termref" href="#dt-atomization">atomized</a> result sequence other than the first are ignored.</p><div class="example"><div class="exampleHeader"><a id="d8e30070"></a><a id="d8e30177"></a>Example: Generating a List with Separators</div><p>The instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">x</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">4</span><span class="z">"</span><span class="z"></span><span class="atn">separator</span><span class="atneq">=</span><span class="z">"</span><span class="av">|</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">x</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>produces the output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">x</span><span class="scx">&gt;</span><span class="txt">1|2|3|4</span><span class="ez">&lt;/</span><span class="cl">x</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a> element can be used to copy a sequence of nodes to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> without <a title="atomize" class="termref" href="#dt-atomization">atomization</a>. See <a href="#copy-of"><i>11.9.2 Deep Copy</i></a>.</p></div><p>For the effect of the <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a><code>disable-output-escaping</code> attribute, see <a href="#disable-output-escaping"><i>27.2 Disabling Output Escaping</i></a></p></div></div><div class="div2"><h3><a id="creating-document-nodes"></a>11.5 <a href="#creating-document-nodes" style="text-decoration: none">Creating Document Nodes</a></h3><p class="element-syntax"><a id="element-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:document<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:document&gt;</code></p><p>The <a href="#element-document"><code>xsl:document</code></a> instruction is used to create a new document node. The content of the <a href="#element-document"><code>xsl:document</code></a> element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> for the children of the new document node. A document node is created, and the sequence obtained by evaluating the sequence constructor is used to construct the content of the document, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>. </p><p>Except in error situations, the result of evaluating the <a href="#element-document"><code>xsl:document</code></a> instruction is a single node, the newly constructed document node.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The new document is not serialized. To construct a document that is to form a final result rather than an intermediate result, use the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction described in <a href="#creating-result-trees"><i>26.1 Creating Secondary Results</i></a>.</p></div><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-document"><code>xsl:document</code></a> instruction to validate the contents of the new document, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that elements and attributes within the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> will carry. The permitted values and their semantics are described in <a href="#validating-document-nodes"><i>26.4.2 Validating Document Nodes</i></a>.</p><p>The base URI of the new document node is taken from the base URI of the <a href="#element-document"><code>xsl:document</code></a> instruction.</p><p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the new document node are set to empty.</p><div class="example"><div class="exampleHeader"><a id="d8e30162"></a><a id="d8e30269"></a>Example: Checking Uniqueness Constraints in a Temporary Tree</div><p>The following example creates a temporary tree held in a variable. The use of an enclosed <a href="#element-document"><code>xsl:document</code></a> instruction ensures that uniqueness constraints defined in the schema for the relevant elements are checked.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">tree</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">document-node()</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:document</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strict</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="creating-processing-instructions"></a>11.6 <a href="#creating-processing-instructions" style="text-decoration: none">Creating Processing Instructions</a></h3><p class="element-syntax"><a id="element-processing-instruction"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:processing-instruction<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:processing-instruction&gt;</code></p><p>The <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is evaluated to create a processing instruction node.</p><p>The <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element has a <span class="verb">required</span><code>name</code> attribute that specifies the name of the processing instruction node. The value of the <code>name</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>.</p><p>The string value of the new processing-instruction node may be defined either by using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the string value of the new processing-instruction node will be a zero-length string. The way in which the value is constructed is specified in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p><p><a id="err-XTSE0880"><span class="error">[ERR XTSE0880] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is present unless the element has empty content. </p><p>Except in error situations, the result of evaluating the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> instruction is a single node, the newly constructed processing instruction node.</p><div class="example"><div class="exampleHeader"><a id="d8e30234"></a><a id="d8e30341"></a>Example: Creating a Processing Instruction</div><p>This instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:processing-instruction</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">xml-stylesheet</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">href=&amp;quot;book.css&amp;quot;</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">type=&amp;quot;text/css&amp;quot;</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>creates the processing instruction</p><div class="exampleInner"><pre class="spectrum"><span class="z">&lt;?</span><span class="pi">xml-stylesheet href="book.css" type="text/css"</span><span class="z">?&gt;</span><span class="txt"></span></pre></div><p>Note that the <code>xml-stylesheet</code> processing instruction contains <em>pseudo-attributes</em> in the form <code>name="value"</code>. Although these have the same textual form as attributes in an element start tag, they are not represented as XDM attribute nodes, and cannot therefore be constructed using <a href="#element-attribute"><code>xsl:attribute</code></a> instructions.</p></div><p><a id="err-XTDE0890"><span class="error">[ERR XTDE0890] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is not both an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup> and a <a href="https://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because these rules disallow the name <code>xml</code>, the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> cannot be used to output an XML declaration. The <a href="#element-output"><code>xsl:output</code></a> declaration should be used to control this instead (see <a href="#serialization"><i>27 Serialization</i></a>).</p></div><p>If the result of evaluating the content of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> contains the string <code>?&gt;</code>, this string is modified by inserting a space between the <code>?</code> and <code>&gt;</code> characters.</p><p>The base URI of the new processing-instruction is copied from the base URI of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element in the stylesheet. (Note, however, that this is only relevant when creating a parentless processing instruction. When the new processing instruction is copied to form a child of an element or document node, the base URI of the new copy is taken from that of its new parent.)</p></div><div class="div2"><h3><a id="creating-namespace-nodes"></a>11.7 <a href="#creating-namespace-nodes" style="text-decoration: none">Creating Namespace Nodes</a></h3><p class="element-syntax"><a id="element-namespace"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:namespace<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:namespace&gt;</code></p><p>The <a href="#element-namespace"><code>xsl:namespace</code></a> element is evaluated to create a namespace node. Except in error situations, the result of evaluating the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction is a single node, the newly constructed namespace node.</p><p>The <a href="#element-namespace"><code>xsl:namespace</code></a> element has a <span class="verb">required</span><code>name</code> attribute that specifies the name of the namespace node (that is, the namespace prefix). The value of the <code>name</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is a zero-length string, a namespace node is added for the default namespace.</p><p>The string value of the new namespace node (that is, the namespace URI) may be defined either by using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-namespace"><code>xsl:namespace</code></a> element. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. Since the string value of a namespace node cannot be a zero-length string, either a <code>select</code> attribute or a non-empty sequence constructor <span class="verb">must</span> be present. The way in which the value is constructed is specified in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p><p><a id="err-XTDE0905"><span class="error">[ERR XTDE0905] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the string value of the new namespace node is not valid in the lexical space of the datatype <code>xs:anyURI</code>, or if it is the string <code>http://www.w3.org/2000/xmlns/</code>. </p><p><a id="err-XTSE0910"><span class="error">[ERR XTSE0910] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-namespace"><code>xsl:namespace</code></a> element is present when the element has content other than one or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions, or if the <code>select</code> attribute is absent when the element has empty content. </p><p>Note the restrictions described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a> for the position of a namespace node relative to other nodes in the node sequence returned by a sequence constructor.</p><div class="example"><div class="exampleHeader"><a id="d8e30395"></a><a id="d8e30502"></a>Example: Constructing a QName-Valued Attribute</div><p>This literal result element:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">data</span><span class="z"></span><span class="atn">xsi:type</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsi</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema-instance</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:namespace</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">http://www.w3.org/2001/XMLSchema</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">42</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">data</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>would typically cause the output document to contain the element:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">data</span><span class="z"></span><span class="atn">xsi:type</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xs</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsi</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/2001/XMLSchema-instance</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">42</span><span class="ez">&lt;/</span><span class="cl">data</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>In this case, the element is constructed using a literal result element, and the namespace <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could therefore have been added to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> simply by declaring it as one of the in-scope namespaces in the stylesheet. In practice, the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction is more likely to be useful in situations where the element is constructed using an <a href="#element-element"><code>xsl:element</code></a> instruction, which does not copy all the in-scope namespaces from the stylesheet.</p></div><p><a id="err-XTDE0920"><span class="error">[ERR XTDE0920] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is neither a zero-length string nor an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, or if it is <code>xmlns</code>. </p><p><a id="err-XTDE0925"><span class="error">[ERR XTDE0925] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction generates a namespace node whose name is <code>xml</code> and whose string value is not <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose name is not <code>xml</code>. </p><p><a id="err-XTDE0930"><span class="error">[ERR XTDE0930] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if evaluating the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of an <a href="#element-namespace"><code>xsl:namespace</code></a> instruction results in a zero-length string. </p><p>For details of other error conditions that may arise, see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is rarely necessary to use <a href="#element-namespace"><code>xsl:namespace</code></a> to create a namespace node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>; in most circumstances, the required namespace nodes will be created automatically, as a side-effect of writing elements or attributes that use the namespace. An example where <a href="#element-namespace"><code>xsl:namespace</code></a> is needed is a situation where the required namespace is used only within attribute values in the result document, not in element or attribute names; especially where the required namespace prefix or namespace URI is computed at run-time and is not present in either the source document or the stylesheet.</p><p>Adding a namespace node to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> will never change the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of any element or attribute node in the result tree: that is, it will never change the namespace URI of an element or attribute. It might, however, constrain the choice of prefixes when namespace fixup is performed.</p><p>Namespace prefixes for element and attribute names are initially established by the rules of the instruction that creates the element or attribute node, and in the event of conflicts, they may be changed by the namespace fixup process described in <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>. The fixup process ensures that an element has in-scope namespace nodes for the namespace URIs used in the element name and in its attribute names, and the serializer will typically use these namespace nodes to determine the prefix to use in the serialized output. The fixup process cannot generate namespace nodes that are inconsistent with those already present in the tree. This means that it is not possible for the processor to decide the prefix to use for an element or for any of its attributes until all the namespace nodes for the element have been added.</p><p>If a namespace prefix is mapped to a particular namespace URI using the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction, or by using <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> to copy a namespace node, this prevents the namespace fixup process (and hence the serializer) from using the same prefix for a different namespace URI on the same element.</p></div><div class="example"><div class="exampleHeader"><a id="d8e30509"></a><a id="d8e30616"></a>Example: Conflicting Namespace Prefixes</div><p>Given the instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:element</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">p:item</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:p</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.example.com/p</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:namespace</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">p</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">http://www.example.com/q</span><span class="ez">&lt;/</span><span class="clxsl">xsl:namespace</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:element</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>a possible serialization of the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">ns0:item</span><span class="z"></span><span class="atn">xmlns:ns0</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.example.com/p</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:p</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.example.com/q</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The processor must invent a namespace prefix for the URI <code>p.uri</code>; it cannot use the prefix <code>p</code> because that prefix has been explicitly associated with a different URI.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-namespace"><code>xsl:namespace</code></a> instruction cannot be used to generate a <b>namespace undeclaration</b> of the form <code>xmlns=""</code> (nor the new forms of namespace undeclaration permitted in <a href="#xml-names11">[Namespaces in XML 1.1]</a>). Namespace undeclarations are generated automatically by the serializer if <code>undeclare-prefixes="yes"</code> is specified on <a href="#element-output"><code>xsl:output</code></a>, whenever a parent element has a namespace node for the default namespace prefix, and a child element has no namespace node for that prefix.</p></div></div><div class="div2"><h3><a id="creating-comments"></a>11.8 <a href="#creating-comments" style="text-decoration: none">Creating Comments</a></h3><p class="element-syntax"><a id="element-comment"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:comment<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:comment&gt;</code></p><p>The <a href="#element-comment"><code>xsl:comment</code></a> element is evaluated to construct a new comment node. Except in error cases, the result of evaluating the <a href="#element-comment"><code>xsl:comment</code></a> instruction is a single node, the newly constructed comment node.</p><p>The string value of the new comment node may be defined either by using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-comment"><code>xsl:comment</code></a> element. These are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty, and if the sequence constructor is non-empty then the <code>select</code> attribute must be absent. If the <code>select</code> attribute is absent and the sequence constructor is empty, then the string value of the new comment node will be a zero-length string. The way in which the value is constructed is specified in <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>.</p><p><a id="err-XTSE0940"><span class="error">[ERR XTSE0940] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-comment"><code>xsl:comment</code></a> element is present unless the element has empty content. </p><div class="example"><div class="exampleHeader"><a id="d8e30589"></a><a id="d8e30696"></a>Example: Generating a Comment Node</div><p>For example, this</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:comment</span><span class="scx">&gt;</span><span class="txt">This file is automatically generated. Do not edit!</span><span class="ez">&lt;/</span><span class="clxsl">xsl:comment</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>would create the comment</p><div class="exampleInner"><pre class="spectrum"><span class="z">&lt;!--</span><span class="cm">This file is automatically generated. Do not edit!</span><span class="z">--&gt;</span><span class="txt"></span></pre></div></div><p>In the generated comment node, the processor <span class="verb">must</span> insert a space after any occurrence of <code>x2D</code> (hyphen) that is followed by another occurrence of <code>x2D</code> (hyphen) or that ends the comment.</p></div><div class="div2"><h3><a id="copying"></a>11.9 <a href="#copying" style="text-decoration: none">Copying Nodes</a></h3><div class="div3"><h4><a id="shallow-copy"></a>11.9.1 <a href="#shallow-copy" style="text-decoration: none">Shallow Copy</a></h4><p class="element-syntax"><a id="element-copy"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:copy<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var><br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:copy&gt;</code></p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction provides a way of copying a selected item. The selected item is the item selected by evaluating the expression in the <code>select</code> attribute if present, or the <a title="context item" class="termref" href="#dt-context-item">context item</a> otherwise. If the selected item is a node, evaluating the <a href="#element-copy"><code>xsl:copy</code></a> instruction constructs a copy of the selected node, and the result of the <a href="#element-copy"><code>xsl:copy</code></a> instruction is this newly constructed node. By default, the namespace nodes of the context node are automatically copied as well, but the attributes and children of the node are not automatically copied.</p><p><a id="err-XTTE0945"><span class="error">[ERR XTTE0945] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> instruction with no <code>select</code> attribute when the context item is absent. </p><p>If the <code>select</code> expression returns an empty sequence, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns an empty sequence, and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated.</p><p><a id="err-XTTE3180"><span class="error">[ERR XTTE3180] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>select</code> expression is a sequence of more than one item.</p><p>When the selected item is an atomic value or function item, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns this value. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated. </p><p>When the selected item is an attribute node, text node, comment node, processing instruction node, or namespace node, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns a new node that is a copy of the context node. The new node will have the same node kind, name, and string value as the context node. In the case of an attribute node, it will also have the same values for the <code>is-id</code> and <code>is-idrefs</code> properties. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated. </p><p>When the selected item is a document node or element node, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns a new node that has the same node kind and name as the selected node. The content of the new node is formed by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the <a href="#element-copy"><code>xsl:copy</code></a> instruction. If the <code>select</code> attribute is present then the sequence constructor is evaluated with the selected item as the <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a>; otherwise it is evaluated using the context of the <a href="#element-copy"><code>xsl:copy</code></a> instruction unchanged. The sequence obtained by evaluating this sequence constructor is used (after prepending any attribute nodes or namespace nodes as described in the following paragraphs) to construct the content of the document or element node, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>.</p><p>When the selected item is a document node, the <code>unparsed-entities</code> property of the existing document node is copied to the new document node.</p><p>When the selected item is an element or attribute node, the values of the <code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code> properties of the new element or attribute depend on the values of the <code>validation</code> and <code>type</code> attributes, as defined in <a href="#validation"><i>26.4 Validation</i></a>.</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional <code>use-attribute-sets</code> attribute, whose value is a whitespace-separated list of QNames that identify <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations. This attribute is used only when copying element nodes. This list is expanded as described in <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a> to produce a sequence of attribute nodes. This sequence is prepended to the sequence produced as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional <code>copy-namespaces</code> attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>. The attribute is used only when copying element nodes. If the value is set to <code>yes</code>, or is omitted, then all the namespace nodes of the source element are copied as namespace nodes for the result element. These copied namespace nodes are prepended to the sequence produced as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (it is immaterial whether they come before or after any attribute nodes produced by expanding the <code>use-attribute-sets</code> attribute). If the value is set to <code>no</code>, then the namespace nodes are not copied. However, namespace nodes will still be added to the result element as <span class="verb">required</span> by the namespace fixup process: see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>.</p><p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or <code>no</code>. The default value is <code>yes</code>. The attribute is used only when copying element nodes. If the value is set to <code>yes</code>, or is omitted, then the namespace nodes created for the newly constructed element (whether these were copied from those of the source node, or generated as a result of namespace fixup) are copied to the children and descendants of the newly constructed element, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>. If the value is set to <code>no</code>, then these namespace nodes are not automatically copied to the children. This may result in namespace undeclarations (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements when a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is serialized.</p><p><a id="err-XTTE0950"><span class="error">[ERR XTTE0950] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy a node that has namespace-sensitive content if the <code>copy-namespaces</code> attribute has the value <code>no</code> and its explicit or implicit <code>validation</code> attribute has the value <code>preserve</code>. It is also a type error if either of these instructions (with <code>validation="preserve"</code>) is used to copy an attribute having namespace-sensitive content, unless the parent element is also copied. A node has namespace-sensitive content if its typed value contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived therefrom. The reason this is an error is because the validity of the content depends on the namespace context being preserved. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>When attribute nodes are copied, whether with <a href="#element-copy"><code>xsl:copy</code></a> or with <a href="#element-copy-of"><code>xsl:copy-of</code></a>, the processor does not automatically copy any associated namespace information. The namespace used in the attribute name itself will be declared by virtue of the namespace fixup process (see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>) when the attribute is added to an element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>, but if namespace prefixes are used in the content of the attribute (for example, if the value of the attribute is an XPath expression) then it is the responsibility of the stylesheet author to ensure that suitable namespace nodes are added to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. This can be achieved by copying the namespace nodes using <a href="#element-copy"><code>xsl:copy</code></a>, or by generating them using <a href="#element-namespace"><code>xsl:namespace</code></a>.</p></div><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-copy"><code>xsl:copy</code></a> instruction to validate the contents of an element, attribute or document node against a type definition, element declaration, or attribute declaration in a schema, and thus to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new copy of an element or attribute node will carry. These attributes are ignored when copying an item that is not an element, attribute or document node. When the node being copied is an element or document node, these attributes also affect the type annotation carried by any elements and attributes that have the copied element or document node as an ancestor. These two attributes are both optional, and if one is specified then the other <span class="verb">must</span> be omitted. The permitted values of these attributes and their semantics are described in <a href="#validation"><i>26.4 Validation</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The final <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> also depends on the <code>type</code> and <code>validation</code> attributes of the instructions used to create the ancestors of the node.</p></div><p>When a node is copied, its base URI is copied, except when the result of the <a href="#element-copy"><code>xsl:copy</code></a> instruction is an element node having an <code>xml:base</code> attribute, in which case the base URI of the new node is taken as the value of its <code>xml:base</code> attribute, resolved if it is relative against the base URI of the <a href="#element-copy"><code>xsl:copy</code></a> instruction. </p><p>When an <code>xml:id</code> attribute is copied, using either the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction, it is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether the value of the attribute is subjected to attribute value normalization (that is, effectively applying the <a href="https://www.w3.org/TR/xpath-functions-30/#func-normalize-space"><code>normalize-space</code></a><sup><small>FO30</small></sup> function).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In most cases the value will already have been subjected to attribute value normalization on the source tree, but if this processing has not been performed on the source tree, it is not an error for it to be performed on the result tree.</p></div></div><div class="div3"><h4><a id="copy-of"></a>11.9.2 <a href="#copy-of" style="text-decoration: none">Deep Copy</a></h4><p class="element-syntax"><a id="element-copy-of"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:copy-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;copy-accumulators? = <var>boolean</var><br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;/&gt;</code></p><p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction can be used to construct a copy of a sequence of nodes, atomic values, and/or function items with each new node containing copies of all the children, attributes, and (by default) namespaces of the original node, recursively. The result of evaluating the instruction is a sequence of items corresponding one-to-one with the supplied sequence, and retaining its order.</p><p>The <span class="verb">required</span><code>select</code> attribute contains an <a title="expression" class="termref" href="#dt-expression">expression</a>, whose value may be any sequence of nodes, atomic values, and/or function items. The items in this sequence are processed as follows:</p><ul><li><p>If the item is an element node, a new element is constructed and appended to the result sequence. The new element will have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as the original, and it will have deep copies of the attribute nodes and children of the element node.</p><p>The new element will also have namespace nodes copied from the original element node, unless they are excluded by specifying <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes the value <code>yes</code>, then all the namespace nodes of the original element are copied to the new element. If it takes the value <code>no</code>, then none of the namespace nodes are copied: however, namespace nodes will still be created in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> as <span class="verb">required</span> by the namespace fixup process: see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>. This attribute affects all elements copied by this instruction: both elements selected directly by the <code>select</code><a title="expression" class="termref" href="#dt-expression">expression</a>, and elements that are descendants of nodes selected by the <code>select</code> expression. </p><p>The values of the <code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code> properties of the new element depend on the values of the <code>validation</code> and <code>type</code> attributes, as defined in <a href="#validation"><i>26.4 Validation</i></a>.</p></li><li><p>If the item is a document node, the instruction adds a new document node to the result sequence; the children of this document node will be one-to-one copies of the children of the original document node (each copied according to the rules for its own node kind). The <code>unparsed-entities</code> property of the original document node is copied to the new document node.</p></li><li><p>If the item is an attribute or namespace node, or a text node, a comment, or a processing instruction, the same rules apply as with <a href="#element-copy"><code>xsl:copy</code></a> (see <a href="#shallow-copy"><i>11.9.1 Shallow Copy</i></a>).</p></li><li><p>If the item is an atomic value or a function item, the value is appended to the result sequence, as with <a href="#element-sequence"><code>xsl:sequence</code></a>.</p></li></ul><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to validate the contents of an element, attribute or document node against a type definition, element declaration, or attribute declaration in a schema and thus to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new copy of an element or attribute node will carry. These attributes are applied individually to each element, attribute, and document node that is selected by the expression in the <code>select</code> attribute. These attributes are ignored when copying an item that is not an element, attribute or document node.</p><p>The specified <code>type</code> and <code>validation</code> apply directly only to elements, attributes and document nodes created as copies of nodes actually selected by the <code>select</code> expression, they do not apply to nodes that are implicitly copied because they have selected nodes as an ancestor. However, these attributes do indirectly affect the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> carried by such implicitly copied nodes, as a consequence of the validation process.</p><p>These two attributes are both optional, and if one is specified then the other <span class="verb">must</span> be omitted. The permitted values of these attributes and their semantics are described in <a href="#validation"><i>26.4 Validation</i></a>.</p><p>Errors may occur when copying namespace-sensitive elements or attributes using <code>validation="preserve"</code>. <span class="error">[see <a href="#err-XTTE0950">ERR XTTE0950</a>]</span>.</p><p>If removal of namespaces is requested using <code>copy-namespaces="no"</code>, then any validation that is requested is applied to the tree that remains after the relevant namespaces have been removed. This will cause validation to fail if there is namespace-sensitive content that depends on the presence of the removed namespaces.</p><p> For any node <var>N</var> that is explicitly selected by the evaluation of the <code>select</code> expression, the base URI of the new copy is as follows:</p><ul><li><p>If <var>N</var> is an element node having an <code>xml:base</code> attribute, the base URI of the new node is taken as the value of the <code>xml:base</code> attribute, resolved if it is relative against the static base URI of the <code>xsl:copy-of</code> instruction. </p></li><li><p>Otherwise, the base URI of the new copy is the same as the base URI of <var>N</var>. </p></li></ul><p>For any element or processing-instruction node that has <var>N</var> as an ancestor, the base URI of the new copy is set to be the same as that of its new parent, with the following exception: if a copied element has an <code>xml:base</code> attribute, then its base URI is set to the value of that attribute, resolved if it is relative against the base URI of the new parent node. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>If two elements in a subtree have different base URIs for some reason unconnected with <code>xml:base</code> attributes (for example, if they originated in different external entities), then these differences are lost when the subtree is copied. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>As a consequence of rules specified elsewhere (see <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>), if a node created using the <code>xsl:copy-of</code> instruction is subsequently attached as a child to a new element or document node, the final copy of the node inherits its base URI from its new parent node, unless this is overridden using an <code>xml:base</code> attribute. </p></div><p>[XSLT 3.0 Erratum E16, bug 30222]</p><p>The effect of the <code>copy-accumulators</code> attribute is described in <a href="#applicability-of-accumulators"><i>18.2.2 Applicability of Accumulators</i></a>.</p></div></div><div class="div2"><h3><a id="constructing-sequences"></a>11.10 <a href="#constructing-sequences" style="text-decoration: none">Constructing Sequences</a></h3><p class="element-syntax"><a id="element-sequence"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:sequence<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sequence&gt;</code></p><p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction may be used within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> to construct a sequence of nodes, atomic values, and/or function items. This sequence is returned as the result of the instruction. Unlike most other instructions, <a href="#element-sequence"><code>xsl:sequence</code></a> can return a sequence containing existing nodes, rather than constructing new nodes. When <a href="#element-sequence"><code>xsl:sequence</code></a> is used to select atomic values or function items, the effect is very similar to the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction.</p><p>The items comprising the result sequence are evaluated either using the <code>select</code> attribute, or using the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are mutually exclusive; if the instruction has a <code>select</code> attribute, then it <span class="verb">must</span> have no children other than <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. If there is no <code>select</code> attribute and no contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the result is an empty sequence.</p><p><a id="err-XTSE3185"><span class="error">[ERR XTSE3185] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of <a href="#element-sequence"><code>xsl:sequence</code></a> is present and the instruction has children other than <a href="#element-fallback"><code>xsl:fallback</code></a>. </p><p>Any contained <a href="#element-fallback"><code>xsl:fallback</code></a> instructions are ignored by an XSLT 2.0 or 3.0 processor, but can be used to define fallback behavior for an XSLT 1.0 processor running in forwards compatibility mode.</p><div class="example"><div class="exampleHeader"><a id="d8e31156"></a><a id="d8e31263"></a>Example: Constructing a Sequence of Integers</div><p>The following code:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">values</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="numeric">1</span><span class="op">,</span><span class="numeric">2</span><span class="op">,</span><span class="numeric">3</span><span class="op">,</span><span class="numeric">4</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="numeric">8</span><span class="op">,</span><span class="numeric">9</span><span class="op">,</span><span class="numeric">10</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">sum</span><span class="parenthesis">(</span><span class="variable">$values</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>produces the output: <code>37</code></p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e31272"></a>Example: Using <code>xsl:for-each</code> to Construct a Sequence<a id="d8e31272"></a>Example: Using <code>xsl:for-each</code> to Construct a Sequence</div><p>The following code constructs a sequence containing the value of the <code>@price</code> attribute for selected elements (which we assume to be typed as <code>xs:decimal</code>), or a computed price for those elements that have no <code>@price</code> attribute. It then returns the average price:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">prices</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:decimal*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">//</span><span class="qname">product</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">price</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">price</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">cost</span><span class="whitespace"></span><span class="op">*</span><span class="whitespace"></span><span class="numeric">1.5</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">avg</span><span class="parenthesis">(</span><span class="variable">$prices</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>Note that the existing <code>@price</code> attributes could equally have been added to the <code>$prices</code> sequence using <a href="#element-copy-of"><code>xsl:copy-of</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a>. However, <a href="#element-copy-of"><code>xsl:copy-of</code></a> would create a copy of the attribute node, which is not needed in this situation, while <a href="#element-value-of"><code>xsl:value-of</code></a> would create a new text node, which then has to be converted to an <code>xs:decimal</code>. Using <a href="#element-sequence"><code>xsl:sequence</code></a>, which in this case atomizes the existing attribute node and adds an <code>xs:decimal</code> atomic value to the result sequence, is a more direct way of achieving the same result.</p><p>This example could alternatively be solved at the XPath level:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">avg</span><span class="parenthesis">(</span><span class="step">//</span><span class="qname">product</span><span class="step">/</span><span class="parenthesis">(</span><span class="op">+</span><span class="axis">@</span><span class="qname">price</span><span class="op">,</span><span class="whitespace"></span><span class="axis">@</span><span class="qname">cost</span><span class="qname">*1.5</span><span class="parenthesis">)</span><span class="filter">[</span><span class="numeric">1</span><span class="filter">]</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The apparently redundant <code>+</code> operator is there to atomize the attribute value: the expression on the right hand side of the <code>/</code> operator must not return a sequence containing both nodes and non-nodes (atomic values or function items).</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The main use case for allowing <a href="#element-sequence"><code>xsl:sequence</code></a> to contain a sequence constructor is to allow the instructions within an <a href="#element-fork"><code>xsl:fork</code></a> element to be divided into groups.</p><p>It can also be used to limit the scope of local variables or of standard attributes such as <code>[xsl:]default-collation</code>.</p></div></div></div><div class="div1"><h2><a id="number"></a>12 <a href="#number" style="text-decoration: none">Numbering</a></h2><p class="element-syntax"><a id="element-number"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:number<br>&nbsp;&nbsp;value? = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;level? = "single" | "multiple" | "any"<br>&nbsp;&nbsp;count? = <var>pattern</var><br>&nbsp;&nbsp;from? = <var>pattern</var><br>&nbsp;&nbsp;format? = { <var>string</var> }<br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;letter-value? = { "alphabetic" | "traditional" }<br>&nbsp;&nbsp;ordinal? = { <var>string</var> }<br>&nbsp;&nbsp;start-at? = { <var>string</var> }<br>&nbsp;&nbsp;grouping-separator? = { <var>char</var> }<br>&nbsp;&nbsp;grouping-size? = { <var>integer</var> }&nbsp;/&gt;</code></p><p>The <a href="#element-number"><code>xsl:number</code></a> instruction is used to create a formatted number. The result of the instruction is a newly constructed text node containing the formatted number as its <a title="string value" class="termref" href="#dt-string-value">string value</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-place-marker" title="place marker"></a>The <a href="#element-number"><code>xsl:number</code></a> instruction performs two tasks: firstly, determining a <b>place marker</b> (this is a sequence of integers, to allow for hierarchic numbering schemes such as <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place marker for output as a text node in the result sequence.<span class="definition">]</span> The place marker to be formatted can either be supplied directly, in the <code>value</code> attribute, or it can be computed based on the position of a selected node within the tree that contains it.</p><p><a id="err-XTSE0975"><span class="error">[ERR XTSE0975] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> is present unless the <code>select</code>, <code>level</code>, <code>count</code>, and <code>from</code> attributes are all absent. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The facilities described in this section are specifically designed to enable the calculation and formatting of section numbers, paragraph numbers, and the like. For formatting of other numeric quantities, the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function may be more suitable.</p><p>Furthermore, formatting of integers where there is no requirement to calculate the position of a node in the document can now be accomplished using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-integer"><code>format-integer</code></a><sup><small>FO30</small></sup> function, which borrows many concepts from the <a href="#element-number"><code>xsl:number</code></a> specification.</p></div><div class="div2"><h3><a id="start-at"></a>12.1 <a href="#start-at" style="text-decoration: none">The </a><code>start-at</code><a href="#start-at" style="text-decoration: none"> Attribute</a></h3><p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>start-at</code> attribute <span class="verb">must</span> be a string representing a whitespace-separated sequence of one or more integers, each one optionally preceded by a minus sign, separated by whitespace. More specifically, the value must be a string matching the regular expression <code>-?[0-9]+(\s+-?[0-9]+)*</code>. This sequence of integers is used to <b>re-base</b> the sequence of integers being formatted. Specifically if <var>$S</var> is the sequence of integers represented by the <code>start-at</code> attribute, and <var>$V</var> is the sequence of integers to be formatted, then the following transformation is applied to <var>$V</var>:</p><div class="exampleInner"><pre>for $i in 1 to count($V) return if ($i le count($S)) then $V[$i] + $S[$i] - 1 else $V[$i] + $S[last()] - 1 </pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that if there are <var>N</var> integers in the <code>start-at</code> attribute, then these are used to re-base the first <var>N</var> numbers, while numbers after the <var>Nth</var> are re-based using the last (<var>Nth</var>) integer in the <code>start-at</code> attribute. If the <code>start-at</code> attribute contains more integers than are required, the surplus is ignored.</p></div><p>For example, if the attribute is given as <code>start-at="3 0 0"</code>, and the number sequence to be formatted is <code>(1, 1, 1, 1)</code>, then the re-based sequence is <code>3, 0, 0, 0</code>.</p></div><div class="div2"><h3><a id="formatting-supplied-number"></a>12.2 <a href="#formatting-supplied-number" style="text-decoration: none">Formatting a Supplied Number</a></h3><p>The <a title="place marker" class="termref" href="#dt-place-marker">place marker</a> to be formatted may be specified by an expression. The <code>value</code> attribute contains the <a title="expression" class="termref" href="#dt-expression">expression</a>. The value of this expression is <a title="atomize" class="termref" href="#dt-atomization">atomized</a> using the procedure defined in <a href="#xpath-30">[XPath 3.0]</a>, and each value <var>$V</var> in the atomized sequence is then converted to the integer value returned by the XPath expression <code>xs:integer(round(number($V)))</code>. If the <code>start-at</code> attribute is present, this sequence is then re-based as described in <a href="#start-at"><i>12.1 The start-at Attribute</i></a>. The resulting sequence of integers is used as the place marker to be formatted.</p><p>If the instruction is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then:</p><ul><li><p>All items in the <a title="atomize" class="termref" href="#dt-atomization">atomized</a> sequence after the first are discarded;</p></li><li><p>If the atomized sequence is empty, it is replaced by a sequence containing the <code>xs:double</code> value <code>NaN</code> as its only item;</p></li><li><p>If any value in the sequence cannot be converted to an integer (this includes the case where the sequence contains a <code>NaN</code> value) then the string <code>NaN</code> is inserted into the formatted result string in its proper position. The error described in the following paragraph does not apply in this case.</p></li></ul><p><a id="err-XTDE0980"><span class="error">[ERR XTDE0980] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if any undiscarded item in the atomized sequence supplied as the value of the <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> cannot be converted to an integer, or if the resulting integer is less than 0 (zero). </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The value zero does not arise when numbering nodes in a source document, but it can arise in other numbering sequences. It is permitted specifically because the rules of the <a href="#element-number"><code>xsl:number</code></a> instruction are also invoked by functions such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-time"><code>format-time</code></a><sup><small>FO30</small></sup>: the minutes and seconds component of a time value can legitimately be zero.</p></div><p>The resulting sequence is formatted as a string using the <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> of the attributes specified in <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a>; each of these attributes is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. After conversion, the <a href="#element-number"><code>xsl:number</code></a> element constructs a new text node containing the resulting string, and returns this node.</p><div class="example"><div class="exampleHeader"><a id="d8e31457"></a><a id="d8e31564"></a>Example: Numbering a Sorted List</div><p>The following example numbers a sorted list:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">items</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">item</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">1. </span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="numbering-based-on-position"></a>12.3 <a href="#numbering-based-on-position" style="text-decoration: none">Numbering based on Position in a Document </a></h3><p>If no <code>value</code> attribute is specified, then the <a href="#element-number"><code>xsl:number</code></a> instruction returns a new text node containing a formatted <a title="place marker" class="termref" href="#dt-place-marker">place marker</a> that is based on the position of a selected node within its containing document. If the <code>select</code> attribute is present, then the expression contained in the <code>select</code> attribute is evaluated to determine the selected node. If the <code>select</code> attribute is omitted, then the selected node is the <a title="context node" class="termref" href="#dt-context-node">context node</a>.</p><p><a id="err-XTTE0990"><span class="error">[ERR XTTE0990] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a href="#element-number"><code>xsl:number</code></a> instruction is evaluated, with no <code>value</code> or <code>select</code> attribute, when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. </p><p><a id="err-XTTE1000"><span class="error">[ERR XTTE1000] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>select</code> attribute of the <a href="#element-number"><code>xsl:number</code></a> instruction is anything other than a single node. </p><p> The following attributes control how the selected node is to be numbered:</p><ul><li><p>The <code>level</code> attribute specifies rules for selecting the nodes that are taken into account in allocating a number; it has the values <code>single</code>, <code>multiple</code> or <code>any</code>. The default is <code>single</code>.</p></li><li><p>The <code>count</code> attribute is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that specifies which nodes are to be counted at those levels. If <code>count</code> attribute is not specified, then it defaults to the pattern that matches any node with the same node kind as the selected node and, if the selected node has an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as the selected node.</p></li><li><p>The <code>from</code> attribute is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that specifies where counting starts.</p></li></ul><p>In addition, the attributes specified in <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a> are used for number to string conversion, as in the case when the <code>value</code> attribute is specified.</p><p>The <a href="#element-number"><code>xsl:number</code></a> element first constructs a sequence of positive integers using the <code>level</code>, <code>count</code> and <code>from</code> attributes. Where <code>level</code> is <code>single</code> or <code>any</code>, this sequence will either be empty or contain a single number; where <code>level</code> is <code>multiple</code>, the sequence may be of any length. The sequence is constructed as follows:</p><p>Let <code>matches-count($node)</code> be a function that returns true if and only if the given node <code>$node</code> matches the pattern given in the <code>count</code> attribute, or the implied pattern (according to the rules given above) if the <code>count</code> attribute is omitted.</p><p>Let <code>matches-from($node)</code> be a function that returns true if and only if the given node <code>$node</code> matches the pattern given in the <code>from</code> attribute, or if <code>$node</code> is the root node of a tree. If the <code>from</code> attribute is omitted, then the function returns true if and only if <code>$node</code> is the root node of a tree.</p><p>Let <code>$S</code> be the selected node.</p><p>When <code>level="single"</code>: </p><ul><li><p>Let <code>$A</code> be the node sequence selected by the following expression:</p><p><code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-count(.)][1]</code></p><p>(this selects the innermost ancestor-or-self node that matches the <code>count</code> pattern)</p></li><li><p>Let <code>$F</code> be the node sequence selected by the expression:</p><p><code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p><p>(this selects the innermost ancestor-or-self node that matches the <code>from</code> pattern)</p></li><li><p>Let <code>$AF</code> be the value of:</p><p><code>&nbsp;&nbsp;&nbsp;$A[ancestor-or-self::node()[. is $F]]</code></p><p>(this selects $A if it is in the subtree rooted at $F, or the empty sequence otherwise)</p></li><li><p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code></p></li><li><p>Otherwise return the value of:</p><p><code>&nbsp;&nbsp;&nbsp;1 + count($AF/preceding-sibling::node()[matches-count(.)])</code></p><p>(the number of preceding siblings of the counted node that match the <code>count</code> pattern, plus one).</p></li></ul><p>When <code>level="multiple"</code>: </p><ul><li><p>Let <code>$A</code> be the node sequence selected by the expression:</p><p><code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-count(.)]</code></p><p>(the set of ancestor-or-self nodes that match the <code>count</code> pattern)</p></li><li><p>Let <code>$F</code> be the node sequence selected by the expression:</p><p><code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-from(.)][1]</code></p><p>(the innermost ancestor-or-self node that matches the <code>from</code> pattern)</p></li><li><p>Let <code>$AF</code> be the value of:</p><p><code>&nbsp;&nbsp;&nbsp;$A[ancestor-or-self::node()[. is $F]]</code></p><p>(the nodes selected in the first step that are in the subtree rooted at the node selected in the second step)</p></li><li><p>Return the result of the expression:</p><p><code>&nbsp;&nbsp;&nbsp;for $af in $AF return 1+count($af/preceding-sibling::node()[matches-count(.)])</code></p><p>(a sequence of integers containing, for each of these nodes, one plus the number of preceding siblings that match the <code>count</code> pattern)</p></li></ul><p>When <code>level="any"</code>: </p><ul><li><p>Let <code>$A</code> be the node sequence selected by the expression:</p><p><code>&nbsp;&nbsp;&nbsp;$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code></p><p>(the set of nodes consisting of the selected node together with all nodes, other than attributes and namespaces, that precede the selected node in document order, provided that they match the <code>count</code> pattern)</p></li><li><p>Let <code>$F</code> be the node sequence selected by the expression:</p><p><code>&nbsp;&nbsp;&nbsp;$S/(preceding::node()|ancestor-or-self::node())[matches-from(.)][last()]</code></p><p>(the last node in document order that matches the <code>from</code> pattern and that precedes the selected node, using the same definition)</p></li><li><p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or . &gt;&gt; $F]</code></p><p>(the nodes selected in the first step, excluding those that precede the node selected in the second step)</p></li><li><p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code></p></li><li><p>Otherwise return the value of the expression <code>count($AF)</code></p></li></ul><p>The resulting sequence of numbers is referred to as the <a title="place marker" class="termref" href="#dt-place-marker">place marker</a>.</p><p>If the <code>start-at</code> attribute is present, then the <a title="place marker" class="termref" href="#dt-place-marker">place marker</a> is re-based as described in <a href="#start-at"><i>12.1 The start-at Attribute</i></a>.</p><p>The sequence of numbers is then converted into a string using the <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> of the attributes specified in <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a>; each of these attributes is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. After conversion, the resulting string is used to create a text node, which forms the result of the <a href="#element-number"><code>xsl:number</code></a> instruction.</p><div class="example"><div class="exampleHeader"><a id="d8e31795"></a><a id="d8e31902"></a>Example: Numbering the Items in an Ordered List</div><p>The following will number the items in an ordered list:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">ol</span><span class="step">/</span><span class="qname">item</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">. </span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e31800"></a><a id="d8e31907"></a>Example: Multi-Level Numbering</div><p>The following two rules will number <code>title</code> elements. This is intended for a document that contains a sequence of chapters followed by a sequence of appendices, where both chapters and appendices contain sections, which in turn contain subsections. Chapters are numbered 1, 2, 3; appendices are numbered A, B, C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices are numbered A.1, A.2, A.3. Subsections within a chapter are numbered 1.1.1, 1.1.2, 1.1.3; subsections within an appendix are numbered A.1.1, A.1.2, A.1.3.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">title</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">level</span><span class="atneq">=</span><span class="z">"</span><span class="av">multiple</span><span class="z">"</span><span class="z"></span><span class="atn">count</span><span class="atneq">=</span><span class="z">"</span><span class="qname">chapter</span><span class="op">|</span><span class="qname">section</span><span class="op">|</span><span class="qname">subsection</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">1.1 </span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">appendix</span><span class="step">//</span><span class="qname">title</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">level</span><span class="atneq">=</span><span class="z">"</span><span class="av">multiple</span><span class="z">"</span><span class="z"></span><span class="atn">count</span><span class="atneq">=</span><span class="z">"</span><span class="qname">appendix</span><span class="op">|</span><span class="qname">section</span><span class="op">|</span><span class="qname">subsection</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">A.1 </span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e31809"></a><a id="d8e31916"></a>Example: Numbering Notes within a Chapter</div><p>This example numbers notes sequentially within a chapter, starting from the number 100: :</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">note</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fo:block</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">level</span><span class="atneq">=</span><span class="z">"</span><span class="av">any</span><span class="z">"</span><span class="z"></span><span class="atn">from</span><span class="atneq">=</span><span class="z">"</span><span class="av">chapter</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">(1) </span><span class="z">"</span><span class="z"></span><span class="atn">start-at</span><span class="atneq">=</span><span class="z">"</span><span class="av">100</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fo:block</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="convert"></a>12.4 <a href="#convert" style="text-decoration: none">Number to String Conversion Attributes</a></h3><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification is aligned with that of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-integer"><code>format-integer</code></a><sup><small>FO30</small></sup> function, but there are differences; for example grouping separators are part of the primary format token in <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-integer"><code>format-integer</code></a><sup><small>FO30</small></sup>, but are indicated by separate attributes in <a href="#element-number"><code>xsl:number</code></a>.</p></div><p>The following attributes are used to control conversion of a sequence of numbers into a string. The numbers are integers greater than or equal to 0 (zero). The attributes are all optional.</p><p>The main attribute is <code>format</code>. The default value for the <code>format</code> attribute is <code>1</code>. The <code>format</code> attribute is split into a sequence of tokens where each token is a maximal sequence of alphanumeric characters or a maximal sequence of non-alphanumeric characters. <em>Alphanumeric</em> means any character that has a Unicode category of Nd, Nl, No, Lu, Ll, Lt, Lm or Lo (see <a href="#UNICODE">[UNICODE]</a>). The alphanumeric tokens (<em>format tokens</em>) indicate the format to be used for each number in the sequence; in most cases the format token is the same as the required representation of the number 1 (one).</p><p>Each non-alphanumeric token is either a prefix, a separator, or a suffix. If there is a non-alphanumeric token but no format token, then the single non-alphanumeric token is used as both the prefix and the suffix. The prefix, if it exists, is the non-alphanumeric token that precedes the first format token: the prefix always appears exactly once in the constructed string, at the start. The suffix, if it exists, is the non-alphanumeric token that follows the last format token: the suffix always appears exactly once in the constructed string, at the end. All other non-alphanumeric tokens (those that occur between two format tokens) are <em>separator tokens</em> and are used to separate numbers in the sequence.</p><p>The <var>n</var>th format token is used to format the <var>n</var>th number in the sequence. If there are more numbers than format tokens, then the last format token is used to format remaining numbers. If there are no format tokens, then a format token of <code>1</code> is used to format all numbers. Each number after the first is separated from the preceding number by the separator token preceding the format token used to format that number, or, if that is the first format token, then by <code>.</code> (dot).</p><div class="example"><div class="exampleHeader"><a id="d8e31857"></a><a id="d8e31964"></a>Example: Formatting a List of Numbers</div><p>Given the sequence of numbers <code>5, 13, 7</code> and the format token <code>A-001(i)</code>, the output will be the string <code>E-013(vii)</code></p></div><p>Format tokens are interpreted as follows:</p><ul><li><p>Any token where the last character has a decimal digit value of 1 (as specified in the Unicode character property database, see <a href="#UNICODE">[UNICODE]</a>), and the Unicode value of preceding characters is one less than the Unicode value of the last character generates a decimal representation of the number where each number is at least as long as the format token. The digits used in the decimal representation are the set of digits containing the digit character used in the format token. Thus, a format token <code>1</code> generates the sequence <code>0 1 2 ... 10 11 12 ...</code>, and a format token <code>01</code> generates the sequence <code>00 01 02 ... 09 10 11 12 ... 99 100 101</code>. A format token of <code>&amp;#x661;</code> (Arabic-Indic digit one) generates the sequence <code>١</code> then <code>٢</code> then <code>٣</code> ...</p></li><li><p>A format token <code>A</code> generates the sequence <code>A B C ... Z AA AB AC...</code>.</p></li><li><p>A format token <code>a</code> generates the sequence <code>a b c ... z aa ab ac...</code>.</p></li><li><p>A format token <code>i</code> generates the sequence <code>i ii iii iv v vi vii viii ix x ...</code>.</p></li><li><p>A format token <code>I</code> generates the sequence <code>I II III IV V VI VII VIII IX X ...</code>.</p></li><li><p>A format token <code>w</code> generates numbers written as lower-case words, for example in English, <code>one two three four ...</code>. </p></li><li><p>A format token <code>W</code> generates numbers written as upper-case words, for example in English, <code>ONE TWO THREE FOUR ...</code>. </p></li><li><p>A format token <code>Ww</code> generates numbers written as title-case words, for example in English, <code>One Two Three Four ...</code>. </p></li><li><p>Any other format token indicates a numbering sequence in which that token represents the number 1 (one) (but see the note below). It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> which numbering sequences, additional to those listed above, are supported. If an implementation does not support a numbering sequence represented by the given token, it <span class="verb">must</span> use a format token of <code>1</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In some traditional numbering sequences additional signs are added to denote that the letters should be interpreted as numbers; these are not included in the format token. An example, see also the example below, is classical Greek where a <em>dexia keraia</em> and sometimes an <em>aristeri keraia</em> is added.</p></div></li></ul><p>For all format tokens other than the first kind above (one that consists of decimal digits), there <span class="verb">may</span> be <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> lower and upper bounds on the range of numbers that can be formatted using this format token; indeed, for some numbering sequences there may be intrinsic limits. For example, the format token <code>&amp;#x2460;</code> (circled digit one, ①) has a range imposed by the Unicode character repertoire (zero to 20 in Unicode versions prior to 3.2, or zero to 50 in subsequent versions). For the numbering sequences described above any upper bound imposed by the implementation <span class="verb">must not</span> be less than 1000 (one thousand) and any lower bound must not be greater than 1. Numbers that fall outside this range <span class="verb">must</span> be formatted using the format token <code>1</code>. The numbering sequence associated with the format token <code>1</code> has a lower bound of 0 (zero).</p><p>The above expansions of numbering sequences for format tokens such as <code>a</code> and <code>i</code> are indicative but not prescriptive. There are various conventions in use for how alphabetic sequences continue when the alphabet is exhausted, and differing conventions for how roman numerals are written (for example, <code>IV</code> versus <code>IIII</code> as the representation of the number 4). Sometimes alphabetic sequences are used that omit letters such as <code>i</code> and <code>o</code>. This specification does not prescribe the detail of any sequence other than those sequences consisting entirely of decimal digits.</p><p>Many numbering sequences are language-sensitive. This applies especially to the sequence selected by the tokens <code>w</code>, <code>W</code> and <code>Ww</code>. It also applies to other sequences, for example different languages using the Cyrillic alphabet use different sequences of characters, each starting with the letter #x410 (Cyrillic capital letter A). In such cases, the <code>lang</code> attribute specifies which language’s conventions are to be used; its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><span class="verb">must</span> either be a string in the value space of <code>xs:language</code>, or a zero-length string. If no <code>lang</code> value is specified, or if the value is a zero-length string, the language that is used is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The set of languages for which numbering is supported is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. If a language is requested that is not supported, the processor <span class="verb">may</span> use a fallback language identified by removing successive hyphen-separated suffixes from the supplied value until a supported language code is obtained; failing this, the processor uses the language that it would use if the <code>lang</code> attribute were omitted.</p><p>The optional <code>ordinal</code> attribute is used to indicate whether cardinal or ordinal numbers are required, and to select other options relating to the grammatical context of the number to be formatted. The allowed set of values is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. If the attribute is absent, or if its value is zero-length, or if its value is <code>no</code> or <code>0</code> or <code>false</code>, then cardinal numbers appropriate to the selected language are output. If the value is <code>yes</code> or <code>1</code> or <code>true</code>, then ordinal numbers appropriate to the target language are output. Other values are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>For example, in English, the value <code>ordinal="yes"</code> when used with the format token <code>1</code> outputs the sequence <code>1st 2nd 3rd 4th ...</code>, and when used with the format token <code>w</code> outputs the sequence <code>first second third fourth ...</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In some languages, the form of numbers (especially ordinal numbers) varies depending on the grammatical context: they may have different genders and may decline with the noun that they qualify. In such cases the value of the <code>ordinal</code> attribute may be used to indicate the variation of the cardinal or ordinal number required, in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. </p><p>The way in which the variation is indicated will depend on the conventions of the language.</p><p>For inflected languages that vary the ending of the word, the approach recommended in the previous version of this specification was to indicate the required ending, preceded by a hyphen: for example in German, appropriate values might be <code>ordinal="-e"</code>, <code>ordinal="-er"</code>, <code>ordinal="-es"</code>, <code>ordinal="-en"</code>. </p><p>Another approach, which might usefully be adopted by an implementation based on the open-source ICU localization library <a href="#ICU">[ICU]</a>, or any other library making use of the Unicode Common Locale Data Repository <a href="#CLDR">[Unicode CLDR]</a>, is to allow the value of the attribute to be the name of a registered numbering rule set for the language in question, conventionally prefixed with a percent sign: for example, <code>ordinal="%spellout-ordinal-masculine"</code>, or <code>ordinal="%spellout-cardinal-year"</code>. (The attribute name <code>ordinal</code> in this case is a misnomer, but serves the purpose.) </p></div><div class="example"><div class="exampleHeader"><a id="d8e32096"></a><a id="d8e32203"></a>Example: Ordinal Numbering in Italian</div><p>The specification <code>format="1" ordinal="-º" lang="it"</code>, if supported, should produce the sequence:</p><div class="exampleInner"><pre>1º 2º 3º 4º ...</pre></div><p>The specification <code>format="Ww" ordinal="-o" lang="it"</code>, if supported, should produce the sequence:</p><div class="exampleInner"><pre>Primo Secondo Terzo Quarto Quinto ...</pre></div></div><p>The <code>letter-value</code> attribute disambiguates between numbering sequences that use letters. In many languages there are two commonly used numbering sequences that use letters. One numbering sequence assigns numeric values to letters in alphabetic sequence, and the other assigns numeric values to each letter in some other manner traditional in that language. In English, these would correspond to the numbering sequences specified by the format tokens <code>a</code> and <code>i</code>. In some languages, the first member of each sequence is the same, and so the format token alone would be ambiguous. A value of <code>alphabetic</code> specifies the alphabetic sequence; a value of <code>traditional</code> specifies the other sequence. If the <code>letter-value</code> attribute is not specified, then it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> how any ambiguity is resolved.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations may use <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a> on <a href="#element-number"><code>xsl:number</code></a> to provide additional control over the way in which numbers are formatted.</p></div><p>The <code>grouping-separator</code> attribute gives the separator used as a grouping (for example, thousands) separator in decimal numbering sequences, and the optional <code>grouping-size</code> specifies the size (normally 3) of the grouping. For example, <code>grouping-separator=","</code> and <code>grouping-size="3"</code> would produce numbers of the form <code>1,000,000</code> while <code>grouping-separator="."</code> and <code>grouping-size="2"</code> would produce numbers of the form <code>1.00.00.00</code>. If only one of the <code>grouping-separator</code> and <code>grouping-size</code> attributes is specified, then it is ignored.</p><p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>grouping-separator</code> attribute <span class="verb">may</span> be any string, including a zero-length string. </p><p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>grouping-size</code> attribute <span class="verb">must</span> be a string in the lexical space of <code>xs:integer</code>. If the resulting integer is positive then it defines the number of digits between adjacent grouping separators; it if is zero or negative, then no grouping separators are inserted. </p><div class="example"><div class="exampleHeader"><a id="d8e32180"></a><a id="d8e32287"></a>Example: Format Tokens and the Resulting Sequences</div><p>These examples use non-Latin characters which might not display correctly in all browsers, depending on the system configuration.</p><table class="data"><caption>Format tokens for use with xsl:number</caption><thead><tr><th style="text-align:left; vertical-align:top">Description</th><th style="text-align:left; vertical-align:top">Format Token</th><th style="text-align:left; vertical-align:top">Sequence</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">French cardinal words</td><td style="text-align:left; vertical-align:top"><code>format="Ww" lang="fr"</code></td><td style="text-align:left; vertical-align:top">Un, Deux, Trois, Quatre</td></tr><tr><td style="text-align:left; vertical-align:top">German ordinal words</td><td style="text-align:left; vertical-align:top"><code>format="w" ordinal="-e" lang="de"</code></td><td style="text-align:left; vertical-align:top">erste, zweite, dritte, vierte</td></tr><tr><td style="text-align:left; vertical-align:top">Katakana numbering</td><td style="text-align:left; vertical-align:top"><code>format="&amp;#x30A2;"</code></td><td style="text-align:left; vertical-align:top">ア, イ, ウ, エ, オ, カ, キ, ク, ケ, コ, サ, シ, ス, セ, ソ, タ, チ, ツ, テ, ト, ナ, ニ, ヌ, ネ, ノ, ハ, ヒ, フ, ヘ, ホ, マ, ミ, ム, メ, モ, ヤ, ユ, ヨ, ラ, リ, ル, レ, ロ, ワ, ヰ, ヱ, ヲ, ン</td></tr><tr><td style="text-align:left; vertical-align:top">Katakana numbering in iroha order</td><td style="text-align:left; vertical-align:top"><code>format="&amp;#x30A4;"</code></td><td style="text-align:left; vertical-align:top">イ, ロ, ハ, ニ, ホ, ヘ, ト, チ, リ, ヌ, ル, ヲ, ワ, カ, ヨ, タ, レ, ソ, ツ, ネ, ナ, ラ, ム, ウ, ヰ, ノ, オ, ク, ヤ, マ, ケ, フ, コ, エ, テ, ア, サ, キ, ユ, メ, ミ, シ, ヱ, ヒ, モ, セ, ス</td></tr><tr><td style="text-align:left; vertical-align:top">Thai numbering</td><td style="text-align:left; vertical-align:top"><code>format="&amp;#x0E51;"</code></td><td style="text-align:left; vertical-align:top">๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘, ๙, ๑๐, ๑๑, ๑๒, ๑๓, ๑๔, ๑๕, ๑๖, ๑๗, ๑๘, ๑๙, ๒๐</td></tr><tr><td style="text-align:left; vertical-align:top">Traditional Hebrew numbering</td><td style="text-align:left; vertical-align:top"><code>format="&amp;#x05D0;" letter-value="traditional"</code></td><td style="text-align:left; vertical-align:top">א, ב, ג, ד, ה, ו, ז, ח, ט, י, יא, יב, יג, יד, טו, טז, יז, יח, יט, כ</td></tr><tr><td style="text-align:left; vertical-align:top">Traditional Georgian numbering</td><td style="text-align:left; vertical-align:top"><code>format="&amp;#x10D0;" letter-value="traditional"</code></td><td style="text-align:left; vertical-align:top">ა, ბ, გ, დ, ე, ვ, ზ, ჱ, თ, ი, ია, იბ, იგ, იდ, იე, ივ, იზ, იჱ, ით, კ </td></tr><tr><td style="text-align:left; vertical-align:top">Classical Greek numbering (see note)</td><td style="text-align:left; vertical-align:top"><code>format="&amp;#x03B1;" letter-value="traditional"</code></td><td style="text-align:left; vertical-align:top"> αʹ, βʹ, γʹ, δʹ, εʹ, ϛʹ, ζʹ, ηʹ, θʹ, ιʹ, ιαʹ, ιβʹ, ιγʹ, ιδʹ, ιεʹ, ιϛʹ, ιζʹ, ιηʹ, ιθʹ, κʹ</td></tr><tr><td style="text-align:left; vertical-align:top">Old Slavic numbering</td><td style="text-align:left; vertical-align:top"><code>format="&amp;#x0430;" letter-value="traditional"</code></td><td style="text-align:left; vertical-align:top">А, В, Г, Д, Е, Ѕ, З, И, Ѳ, Ӏ, АӀ, ВӀ, ГӀ, ДӀ, ЕӀ, ЅӀ, ЗӀ, ИӀ, ѲӀ, К</td></tr></tbody></table><p>Note that Classical Greek is an example where the format token is not the same as the representation of the number 1.</p></div></div></div><div class="div1"><h2><a id="sorting"></a>13 <a href="#sorting" style="text-decoration: none">Sorting</a></h2><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-specification" title="sort key specification"></a>A <b>sort key specification</b> is a sequence of one or more adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules for sorting the items in an input sequence to form a sorted sequence.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-component" title="sort key component"></a>Within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>, each <a href="#element-sort"><code>xsl:sort</code></a> element defines one <b>sort key component</b>.<span class="definition">]</span> The first <a href="#element-sort"><code>xsl:sort</code></a> element specifies the primary component of the sort key specification, the second <a href="#element-sort"><code>xsl:sort</code></a> element specifies the secondary component of the sort key specification, and so on.</p><p>A sort key specification may occur immediately within an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When used within <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, or <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, <a href="#element-sort"><code>xsl:sort</code></a> elements must occur before any other children.</p></div><div class="div2"><h3><a id="xsl-sort"></a>13.1 <a href="#xsl-sort" style="text-decoration: none">The </a><a href="#element-sort"><code>xsl:sort</code></a><a href="#xsl-sort" style="text-decoration: none"> Element</a></h3><p class="element-syntax"><a id="element-sort"></a><code>&lt;xsl:sort<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;stable? = { <var>boolean</var> }<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sort&gt;</code></p><p>The <a href="#element-sort"><code>xsl:sort</code></a> element defines a <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>. A sort key component specifies how a <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a> is to be computed for each item in the sequence being sorted, and also how two sort key values are to be compared.</p><p>The value of a <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a> is determined either by its <code>select</code> attribute or by the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. If neither is present, the default is <code>select="."</code>, which has the effect of sorting on the actual value of the item if it is an atomic value, or on the typed-value of the item if it is a node. If a <code>select</code> attribute is present, its value <span class="verb">must</span> be an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p><p><a id="err-XTSE1015"><span class="error">[ERR XTSE1015] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-sort"><code>xsl:sort</code></a> element with a <code>select</code> attribute has non-empty content. </p><p>Those attributes of the <a href="#element-sort"><code>xsl:sort</code></a> elements whose values are <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> are evaluated using the same <a title="focus" class="termref" href="#dt-focus">focus</a> as is used to evaluate the <code>select</code> attribute of the containing instruction (specifically, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, or <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>).</p><p>The <code>stable</code> attribute is permitted only on the first <a href="#element-sort"><code>xsl:sort</code></a> element within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>. </p><p><a id="err-XTSE1017"><span class="error">[ERR XTSE1017] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-sort"><code>xsl:sort</code></a> element other than the first in a sequence of sibling <a href="#element-sort"><code>xsl:sort</code></a> elements has a <code>stable</code> attribute. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-stable" title="stable"></a>A <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is said to be <b>stable</b> if its first <a href="#element-sort"><code>xsl:sort</code></a> element has no <code>stable</code> attribute, or has a <code>stable</code> attribute whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>yes</code>.<span class="definition">]</span></p><div class="div3"><h4><a id="sorting-process"></a>13.1.1 <a href="#sorting-process" style="text-decoration: none">The Sorting Process</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-sequence" title="initial sequence"></a>The sequence to be sorted is referred to as the <b>initial sequence</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sorted-sequence" title="sorted sequence"></a>The sequence after sorting as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements is referred to as the <b>sorted sequence</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-value" title="sort key value"></a> For each item in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, a value is computed for each <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a> within the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>. The value computed for an item by using the <var>N</var>th sort key component is referred to as the <var>N</var>th <b>sort key value</b> of that item.<span class="definition">]</span></p><p>The items in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> are ordered into a <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> by comparing their <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a>. The relative position of two items <var>A</var> and <var>B</var> in the sorted sequence is determined as follows. The first sort key value of <var>A</var> is compared with the first sort key value of <var>B</var>, according to the rules of the first <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>. If, under these rules, <var>A</var> is less than <var>B</var>, then <var>A</var> will precede <var>B</var> in the sorted sequence, unless the <code>order</code> attribute of this <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a> specifies <code>descending</code>, in which case <var>B</var> will precede <var>A</var> in the sorted sequence. If, however, the relevant sort key values compare equal, then the second sort key value of <var>A</var> is compared with the second sort key value of <var>B</var>, according to the rules of the second <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>. This continues until two sort key values are found that compare unequal. If all the sort key values compare equal, and the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is <a title="stable" class="termref" href="#dt-stable">stable</a>, then <var>A</var> will precede <var>B</var> in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> if and only if <var>A</var> preceded <var>B</var> in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>. If all the sort key values compare equal, and the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is not <a title="stable" class="termref" href="#dt-stable">stable</a>, then the relative order of <var>A</var> and <var>B</var> in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If two items have equal <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a>, and the sort is <a title="stable" class="termref" href="#dt-stable">stable</a>, then their order in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> will be the same as their order in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, regardless of whether <code>order="descending"</code> was specified on any or all of the <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key components</a>.</p></div><p>The <var>N</var>th sort key value is computed by evaluating either the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <var>N</var>th <a href="#element-sort"><code>xsl:sort</code></a> element, or the expression <code>.</code> (dot) if neither is present. This evaluation is done with the <a title="focus" class="termref" href="#dt-focus">focus</a> set as follows:</p><ul><li><p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the item in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> whose <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a> is being computed.</p></li><li><p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of that item in the initial sequence.</p></li><li><p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is the size of the initial sequence.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>As in any other XPath expression, the <a href="#func-current"><code>current</code></a> function may be used within the <code>select</code> expression of <a href="#element-sort"><code>xsl:sort</code></a> to refer to the item that is the context item for the expression as a whole; that is, the item whose <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a> is being computed.</p></div><p>The <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> are <a title="atomize" class="termref" href="#dt-atomization">atomized</a>, and are then compared. The way they are compared depends on their datatype, as described in the next section.</p></div><div class="div3"><h4><a id="comparing-sort-keys"></a>13.1.2 <a href="#comparing-sort-keys" style="text-decoration: none">Comparing Sort Key Values</a></h4><p>It is possible to force the system to compare <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> using the rules for a particular datatype by including a cast as part of the <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>. For example, <code>&lt;xsl:sort select="xs:date(@dob)"/&gt;</code> will force the attributes to be compared as dates. In the absence of such a cast, the sort key values are compared using the rules appropriate to their datatype. Any values of type <code>xs:untypedAtomic</code> are cast to <code>xs:string</code>.</p><p><span style="display: none;" class="delete_version">For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute remains available. If this has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>text</code>, the atomized <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> are converted to strings before being compared. If it has the effective value <code>number</code>, the atomized sort key values are converted to doubles before being compared. The conversion is done by using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-string"><code>string</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-number"><code>number</code></a><sup><small>FO30</small></sup> function as appropriate. If the <code>data-type</code> attribute has any other <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>, then this value <span class="verb">must</span> be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> denoting an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with a non-absent namespace, and the effect of the attribute is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</span><span style="display: none;" class="add_version">For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute remains available. If this has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>text</code>, the atomized <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> are converted to strings before being compared. If it has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>number</code>, the atomized sort key values are converted to doubles before being compared. The conversion is done by using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-string"><code>string</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-number"><code>number</code></a><sup><small>FO30</small></sup> function as appropriate. If the <code>data-type</code> attribute has any other <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>, then this value <span class="verb">must</span> be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> denoting an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with a non-absent namespace, and the effect of the attribute is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</span><span class="modify_version">For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute remains available. If this has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>text</code>, the atomized <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> are converted to strings before being compared. If it has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>number</code>, the atomized sort key values are converted to doubles before being compared. The conversion is done by using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-string"><code>string</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-number"><code>number</code></a><sup><small>FO30</small></sup> function as appropriate. If the <code>data-type</code> attribute has any other <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>, then this value <span class="verb">must</span> be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> denoting an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with a non-absent namespace, and the effect of the attribute is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</span></p><p><a id="err-XTTE1020"><span class="error">[ERR XTTE1020] </span></a>If any <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a>, after <a title="atomize" class="termref" href="#dt-atomization">atomization</a> and any type conversion <span class="verb">required</span> by the <code>data-type</code> attribute, is a sequence containing more than one item, then the effect depends on whether the <a href="#element-sort"><code>xsl:sort</code></a> element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. With XSLT 1.0 behavior, the effective sort key value is the first item in the sequence. In other cases, this is a <a title="type error" class="termref" href="#dt-type-error">type error</a>. </p><p>The set of <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> (after any conversion) is first divided into two categories: empty values, and ordinary values. The empty sort key values represent those items where the sort key value is an empty sequence. These values are considered for sorting purposes to be equal to each other, but less than any other value. The remaining values are classified as ordinary values.</p><p><a id="err-XTDE1030"><span class="error">[ERR XTDE1030] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if, for any <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>, the set of <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> evaluated for all the items in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, after any type conversion requested, contains a pair of ordinary values for which the result of the XPath <code>lt</code> operator is an error. If the processor is able to detect the error statically, it <span class="verb">may</span> optionally signal it as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The above error condition may occur if the values to be sorted are of a type that does not support ordering (for example, <code>xs:QName</code>) or if the sequence is heterogeneous (for example, if it contains both strings and numbers). The error can generally be prevented by invoking a cast or constructor function within the sort key component.</p><p>The error condition is subject to the usual caveat that a processor is not required to evaluate any expression solely in order to determine whether it raises an error. For example, if there are several sort key components, then a processor is not required to evaluate or compare minor sort key values unless the corresponding major sort key values are equal.</p></div><p>In general, comparison of two ordinary values is performed according to the rules of the XPath <code>lt</code> operator. To ensure a total ordering, the same implementation of the <code>lt</code> operator <span class="verb">must</span> be used for all the comparisons: the one that is chosen is the one appropriate to the most specific type to which all the values can be converted by subtype substitution and/or type promotion. For example, if the sequence contains both <code>xs:decimal</code> and <code>xs:double</code> values, then the values are compared using <code>xs:double</code> comparison, even when comparing two <code>xs:decimal</code> values. NaN values, for sorting purposes, are considered to be equal to each other, and less than any other numeric value. Special rules also apply to the <code>xs:string</code> and <code>xs:anyURI</code> types, and types derived by restriction therefrom, as described in the next section.</p></div><div class="div3"><h4><a id="collating-sequences"></a>13.1.3 <a href="#collating-sequences" style="text-decoration: none">Sorting Using Collations</a></h4><p>The rules given in this section apply when comparing values whose type is <code>xs:string</code> or a type derived by restriction from <code>xs:string</code>, or whose type is <code>xs:anyURI</code> or a type derived by restriction from <code>xs:anyURI</code>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-collation" title="collation"></a>Facilities in XSLT 3.0 and XPath 3.0 that require strings to be ordered rely on the concept of a named <b>collation</b>. A collation is a set of rules that determine whether two strings are equal, and if not, which of them is to be sorted before the other.<span class="definition">]</span> A collation is identified by a URI, but the manner in which this URI is associated with an actual rule or algorithm is largely <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>For more information about collations, see <a href="https://qt4cg.org/specifications/xpath-functions-40/#string-compare">Section 5.3 Comparison of strings</a><sup><small>FO40</small></sup> in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. Some specifications, for example <a href="#UNICODE-TR10">[UNICODE TR10]</a>, use the term “collation” to describe rules that can be tailored or parameterized for various purposes. In this specification, a collation URI refers to a collation in which all such parameters have already been fixed. Therefore, if a collation URI is specified, other attributes such as <code>case-order</code> and <code>lang</code> are ignored. </p><p>Every implementation <span class="verb">must</span> recognize the collation URI <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>, which provides the ability to compare strings based on the Unicode codepoint values of the characters in the string.</p><p>Furthermore, every implementation must recognize collation URIs representing tailorings of the Unicode Collation Algorithm (UCA), as described in <a href="#uca-collations"><i>13.4 The Unicode Collation Algorithm</i></a>. Although this form of collation URI must be recognized, implementations are not required to support every possible tailoring.</p><p>If the <a href="#element-sort"><code>xsl:sort</code></a> element has a <code>collation</code> attribute, then the strings are compared according to the rules for the named <a title="collation" class="termref" href="#dt-collation">collation</a>: that is, they are compared using the XPath function call <code>compare($a, $b, $collation)</code>.</p><p>If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>collation</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> is a relative URI, then it is resolved against the base URI of the <a href="#element-sort"><code>xsl:sort</code></a> element.</p><p><a id="err-XTDE1035"><span class="error">[ERR XTDE1035] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <code>collation</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> (after resolving against the base URI) is not a URI that is recognized by the implementation as referring to a collation. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is entirely for the implementation to determine whether it recognizes a particular collation URI. For example, if the implementation allows collation URIs to contain parameters in the query part of the URI, it is the implementation that determines whether a URI containing an unknown or invalid parameter is or is not a recognized collation URI. The fact that this situation is described as an error thus does not prevent an implementation applying a fallback collation if it chooses to do so.</p></div><p>The <code>lang</code> and <code>case-order</code> attributes are ignored if a <code>collation</code> attribute is present. But in the absence of a <code>collation</code> attribute, these attributes provide input to an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> algorithm to locate a suitable collation:</p><ul><li><p>The <code>lang</code> attribute indicates that a collation suitable for a particular natural language <span class="verb">should</span> be used. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute <span class="verb">must</span> either be a string in the value space of <code>xs:language</code>, or a zero-length string. Supplying the zero-length string has the same effect as omitting the attribute. If a language is requested that is not supported, the processor <span class="verb">may</span> use a fallback language identified by removing successive hyphen-separated suffixes from the supplied value until a supported language code is obtained; failing this, the processor behaves as if the <code>lang</code> attribute were omitted. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The fallback algorithm described above is identical to the rules in RFC4647 Basic Filtering used in BCP 47, and is specified in <a href="#RFC4647">[RFC4647]</a> in greater detail.</p></div></li><li><p>The <code>case-order</code> attribute indicates whether the desired collation <span class="verb">should</span> sort upper-case letters before lower-case or vice versa. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute <span class="verb">must</span> be either <code>lower-first</code> (indicating that lower-case letters precede upper-case letters in the collating sequence) or <code>upper-first</code> (indicating that upper-case letters precede lower-case).</p><p>When <code>lower-first</code> is requested, the returned collation <span class="verb">should</span> have the property that when two strings differ only in the case of one or more characters, then a string in which the first differing character is lower-case should precede a string in which the corresponding character is title-case, which should in turn precede a string in which the corresponding character is upper-case. When upper-first is requested, the returned collation <span class="verb">should</span> have the property that when two strings differ only in the case of one or more characters, then a string in which the first differing character is upper-case should precede a string in which the corresponding character is title-case, which should in turn precede a string in which the corresponding character is lower-case.</p><p>So, for example, if <code>lang="en"</code>, then <code>A a B b</code> are sorted with <code>case-order="upper-first"</code> and <code>a A b B</code> are sorted with <code>case-order="lower-first"</code>.</p><p>As a further example, if <code>lower-first</code> is requested, then a sorted sequence might be “MacAndrew, macintosh, macIntosh, Macintosh, MacIntosh, macintoshes, Macintoshes, McIntosh”. If <code>upper-first</code> is requested, the same sequence would sort as “MacAndrew, MacIntosh, Macintosh, macIntosh, macintosh, MacIntoshes, macintoshes, McIntosh”.</p></li></ul><p>If none of the <code>collation</code>, <code>lang</code>, or <code>case-order</code> attributes is present, the collation is chosen in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. It is not <span class="verb">required</span> that the default collation for sorting should be the same as the <a title="default collation" class="termref" href="#dt-default-collation">default collation</a> used when evaluating XPath expressions, as described in <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a> and <a href="#default-collation-attribute"><i>3.7.1 The default-collation Attribute</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is usually appropriate, when sorting, to use a strong collation, that is, one that takes account of secondary differences (accents) and tertiary differences (case) between strings that are otherwise equal. A weak collation, which ignores such differences, may be more suitable when comparing strings for equality.</p><p>Useful background information on international sorting is provided in <a href="#UNICODE-TR10">[UNICODE TR10]</a>. The <code>case-order</code> attribute may be interpreted as described in section 6.6 of <a href="#UNICODE-TR10">[UNICODE TR10]</a>.</p></div><p> The <code>collation</code>, <code>case-order</code>, and <code>lang</code> attributes are ignored when no string comparisons are performed during the sorting process; this includes the cases where (a) the sequences to be sorted are empty, (b) the sort keys are of a non-string type such as <code>xs:integer</code>, or (c) <code>data-type="number"</code> is specified. In these cases, an implementation may report errors in the value of these attributes, but is not required to do so. As always, an implementation may issue warnings. [XSLT 3.0 Erratum E45, bug 30386] </p></div></div><div class="div2"><h3><a id="creating-sorted-sequence"></a>13.2 <a href="#creating-sorted-sequence" style="text-decoration: none">Creating a Sorted Sequence</a></h3><p class="element-syntax"><a id="element-perform-sort"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:perform-sort<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:perform-sort&gt;</code></p><p>The <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction is used to return a <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a>.</p><p>The <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> is obtained either by evaluating the <code>select</code> attribute or by evaluating the contained sequence constructor (but not both). If there is no <code>select</code> attribute and no sequence constructor then the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> (and therefore, the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a>) is an empty sequence.</p><p><a id="err-XTSE1040"><span class="error">[ERR XTSE1040] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction with a <code>select</code> attribute has any content other than <a href="#element-sort"><code>xsl:sort</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. </p><p>The result of the <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction is the result of sorting its <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> using its contained <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>.</p><div class="example"><div class="exampleHeader"><a id="d8e33116"></a><a id="d8e33223"></a>Example: Sorting a Sequence of Atomic Values</div><p>The following stylesheet function sorts a sequence of atomic values using the value itself as the sort key.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">local:sort</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:anyAtomicType*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">in</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:anyAtomicType*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:perform-sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$in</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:perform-sort</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e33121"></a><a id="d8e33228"></a>Example: Writing a Function to Perform a Sort</div><p>The following example defines a function that sorts books by price, and uses this function to output the five books that have the lowest prices:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">bib:books-by-price</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">schema-element(bib:book)*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">in</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">schema-element(bib:book)*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:perform-sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$in</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:decimal</span><span class="parenthesis">(</span><span class="qname">bib:price</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:perform-sort</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">bib:books-by-price</span><span class="parenthesis">(</span><span class="step">//</span><span class="qname">bib:book</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="filter">[</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">5</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="sorted-iteration"></a>13.3 <a href="#sorted-iteration" style="text-decoration: none">Processing a Sequence in Sorted Order</a></h3><p>When used within <a href="#element-for-each"><code>xsl:for-each</code></a> or <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> indicates that the sequence of items selected by that instruction is to be processed in sorted order, not in the order of the supplied sequence.</p><div class="example"><div class="exampleHeader"><a id="d8e33137"></a><a id="d8e33244"></a>Example: Processing Elements in Sorted Order</div><p>For example, suppose an employee database has the form</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">employees</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">employee</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">name</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">given</span><span class="scx">&gt;</span><span class="txt">James</span><span class="ez">&lt;/</span><span class="cl">given</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">family</span><span class="scx">&gt;</span><span class="txt">Clark</span><span class="ez">&lt;/</span><span class="cl">family</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">name</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">employee</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">employees</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Then a list of employees sorted by name could be generated using:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">employees</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">ul</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">employee</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="step">/</span><span class="qname">family</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="step">/</span><span class="qname">given</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:apply-templates</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">ul</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">employee</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="step">/</span><span class="qname">given</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="step">/</span><span class="qname">family</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>When used within <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> indicates the order in which the groups are to be processed. For the effect of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, see <a href="#grouping"><i>14 Grouping</i></a>. </p></div></div><div class="div1"><h2><a id="grouping"></a>14 <a href="#grouping" style="text-decoration: none">Grouping</a></h2><p>The facilities described in this section are designed to allow items in a sequence to be grouped based on common values; for example it allows grouping of elements having the same value for a particular attribute, or elements with the same name, or elements with common values for any other <a title="expression" class="termref" href="#dt-expression">expression</a>. Since grouping identifies items with duplicate values, the same facilities also allow selection of the distinct values in a sequence of items, that is, the elimination of duplicates.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Simple elimination of duplicates can also be achieved using the function <a href="https://www.w3.org/TR/xpath-functions-30/#func-distinct-values"><code>distinct-values</code></a><sup><small>FO30</small></sup>: see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p></div><p>In addition these facilities allow grouping based on sequential position, for example selecting groups of adjacent <code>para</code> elements. The facilities also provide an easy way to do fixed-size grouping, for example identifying groups of three adjacent nodes, which is useful when arranging data in multiple columns.</p><p>For each group of items identified, it is possible to evaluate a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> for the group. Grouping is nestable to multiple levels so that groups of distinct items can be identified, then from among the distinct groups selected, further sub-grouping of distinct items in the current group can be done. </p><p>It is also possible for one item to participate in more than one group.</p><div class="div2"><h3><a id="xsl-for-each-group"></a>14.1 <a href="#xsl-for-each-group" style="text-decoration: none">The </a><code>xsl:for-each-group</code><a href="#xsl-for-each-group" style="text-decoration: none"> Element</a></h3><p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a><a title="instruction" class="termref" href="#dt-instruction">instruction</a> allows a flat sequence of items to be processed as a sequence of groups, allowing a number of criteria to be used to define the grouping. The instruction may be used anywhere within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>As with <code>xsl:for-each</code>, the instruction is extended in XSLT 4.0 to allow maps and arrays to be processed.</p><p class="element-syntax"><a id="element-for-each-group"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each-group<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;group-by? = <var>expression</var><br>&nbsp;&nbsp;group-adjacent? = <var>expression</var><br>&nbsp;&nbsp;group-starting-with? = <var>pattern</var><br>&nbsp;&nbsp;group-ending-with? = <var>pattern</var><br>&nbsp;&nbsp;break-when? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var><br>&nbsp;&nbsp;collation? = { <var>uri</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each-group&gt;</code></p><p>The <code>select</code> attribute <span>(whether written explicitly, or constructed as described above)</span> contains an <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a sequence, called the <a title="population" class="termref" href="#dt-population">population</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-group" title="group"></a>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction allocates the items in an input sequence into <b>groups</b> of items (that is, it establishes a collection of sequences) based either on common values of a grouping key, or on a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that the initial or final item in a group must match.<span class="definition">]</span> The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is evaluated once for each of these groups.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-population" title="population"></a>The sequence of items to be grouped, which is referred to as the <b>population</b>, is determined by evaluating the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>select</code> attribute, <span>or constructed from the expressions in the <code>array</code> or <code>map</code> attributes</span>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-population-order" title="population order"></a>The population is treated as a sequence; the order of items in this sequence is referred to as <b>population order</b>.<span class="definition">]</span></p><p>A group is never empty. If the population is empty, the number of groups will be zero.</p><p>The assignment of items to groups depends on the <code>group-by</code>, <code>group-adjacent</code>, <code>group-starting-with</code>, <code>group-ending-with</code>, <span>and <code>break-when</code></span> attributes. </p><p><a id="err-XTSE1080"><span class="error">[ERR XTSE1080] </span></a>These <span>five</span> attributes are mutually exclusive: it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if none of these attributes is present or if more than one of them is present. </p><p><a id="err-XTSE1090"><span class="error">[ERR XTSE1090] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to specify the <code>collation</code> attribute or the <code>composite</code> attribute if neither the <code>group-by</code> attribute nor <code>group-adjacent</code> attribute is specified. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-grouping-key" title="grouping key"></a>If either of the <code>group-by</code> or <code>group-adjacent</code> attributes is present, then for each item in the <a title="population" class="termref" href="#dt-population">population</a> a set of <b>grouping keys</b> is calculated, as follows: the expression contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> values are cast to <code>xs:string</code>. If <code>composite="yes"</code> is specified, there is a single grouping key whose value is the resulting sequence; otherwise, there is a set of grouping keys, consisting of the distinct atomic values present in the result sequence.<span class="definition">]</span></p><p>When calculating grouping keys for an item in the population, the <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated with that item as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, with its position in <a title="population order" class="termref" href="#dt-population-order">population order</a> as the <a title="context position" class="termref" href="#dt-context-position">context position</a>, and with the size of the population as the <a title="context size" class="termref" href="#dt-context-size">context size</a>.</p><p>If the <code>group-by</code> attribute is present, and if the <code>composite</code> attribute is omitted or takes the value <code>no</code>, then an item in the population <span class="verb">may</span> have multiple grouping keys: that is, the <code>group-by</code> expression evaluates to a sequence, and each item in the sequence is treated as a separate grouping key. The item is included in as many groups as there are distinct grouping keys (which may be zero).</p><p>If the <code>group-adjacent</code> attribute is used, and if the <code>composite</code> attribute is omitted or takes the value <code>no</code>, then each item in the population <span class="verb">must</span> have exactly one grouping key value.</p><p><a id="err-XTTE1100"><span class="error">[ERR XTTE1100] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is an empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified. </p><p><a title="grouping key" class="termref" href="#dt-grouping-key">Grouping keys</a> are compared using the rules of the <a href="#func-distinct-values"><code>distinct-values</code></a> function, using the relevant collation. The relevant collation is the collation specified as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>collation</code> attribute, resolved if relative against the base URI of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element; if there is no <code>collation</code> attribute then the <a title="default collation" class="termref" href="#dt-default-collation">default collation</a> is used. Given this collation, two grouping keys <var>K<sub>1</sub></var> and <var>K<sub>2</sub></var> are considered equal if <code>count(distinct-values(($K1, $K2), $collation)) = 1</code>. </p><p><a id="err-XTDE1110"><span class="error">[ERR XTDE1110] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the collation URI specified to <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (after resolving against the base URI) is a collation that is not recognized by the implementation. (For notes, <span class="error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.) </p><p>For more information on collations, see <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>.</p><p>The way in which an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element is evaluated depends on which of the four group-defining attributes is present:</p><ul><li><p>If the <code>group-by</code> attribute is present, the items in the <a title="population" class="termref" href="#dt-population">population</a> are examined, in population order. For each item <var>J</var>, the expression in the <code>group-by</code> attribute is evaluated to produce a sequence of zero or more <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> values. If <code>composite="yes"</code> is specified, there will be a single grouping key, which will in general be a sequence of zero or more atomic values; otherwise, there will be zero or more grouping keys, each of which will be a single atomic value. For each one of these <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a>, if there is already a group created to hold items having that grouping key value, <var>J</var> is appended to that group; otherwise a new group is created for items with that grouping key value, and <var>J</var> becomes its first member.</p><p>An item in the population may thus be appended to zero, one, or many groups. An item will never be appended more than once to the same group; if two or more grouping keys for the same item are equal, then the duplicates are ignored. An <em>item</em> here means the item at a particular position within the population—if the population contains the same node at several different positions in the sequence then a group may indeed contain duplicate nodes.</p><p>The number of groups will be the same as the number of distinct grouping key values present in the <a title="population" class="termref" href="#dt-population">population</a>. </p></li><li><p>If the <code>group-adjacent</code> attribute is present, the items in the <a title="population" class="termref" href="#dt-population">population</a> are examined, in population order. If an item has the same value for the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> as its preceding item within the <a title="population" class="termref" href="#dt-population">population</a> (in <a title="population order" class="termref" href="#dt-population-order">population order</a>), then it is appended to the same group as its preceding item; otherwise a new group is created and the item becomes its first member.</p></li><li><p>If the <code>group-starting-with</code> attribute is present, then its value <span class="verb">must</span> be a <a href="#doc-xslt40-patterns-Pattern40">pattern</a>. </p><p>The items in the <a title="population" class="termref" href="#dt-population">population</a> are examined in <a title="population order" class="termref" href="#dt-population-order">population order</a>. If an item matches the pattern, or is the first item in the population, then a new group is created and the item becomes its first member. Otherwise, the item is appended to the same group as its preceding item within the population.</p></li><li><p>If the <code>group-ending-with</code> attribute is present, then its value <span class="verb">must</span> be a <a href="#doc-xslt40-patterns-Pattern40">pattern</a>. </p><p>The items in the <a title="population" class="termref" href="#dt-population">population</a> are examined in <a title="population order" class="termref" href="#dt-population-order">population order</a>. If an item is the first item in the population, or if the previous item in the population matches the pattern, then a new group is created and the item becomes its first member. Otherwise, the item is appended to the same group as its preceding item within the population.</p></li><li><p>If the <code>break-when</code> attribute is present, then its value <span class="verb">must</span> be an expression. This expression is evaluated once for every item in the <a title="population" class="termref" href="#dt-population">population</a> except the first. The context item is that item, the context position is its position in the <a title="population" class="termref" href="#dt-population">population</a>, and the context size is the size of the population. The <a title="current group" class="termref" href="#dt-current-group">current group</a> is set to contain all items that have already been added to the latest group. It is supplied with two variables: <code>$group</code> is set to the current group being constructed, and <code>$next</code> is the next item in the population. If the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP40</small></sup> of the expression is <code>true</code>, then this item forms the start of a new group; if it is <code>false</code>, the item is added to the existing group.</p><p>For example:</p><ul><li><p><code>break-when="count($group) = 3"</code> starts a new group whenever the existing group has exactly three members; that is, it partitions the population into groups of size 3 (with the last group being smaller if necessary).</p></li><li><p><code>break-when="$next[self::h1]"</code> starts a new group whenever an <code>h1</code> element is encountered. The effect is the same as specifying <code>group-starting-with="h1"</code></p></li><li><p><code>break-when="$group[last()]/@continued='no'"</code> starts a new group immediately after any element having <code>@continued="no"</code>. The effect is the same as specifying <code>group-ending-with="*[@continued='no']"</code></p></li><li><p><code>break-when="node-name($group[last()] != node-name($next)"</code> starts a new group whenever the name of an item differs from the name of the previous item. The effect is the same as specifying <code>group-adjacent="node-name(.)"</code>.</p></li><li><p><code>break-when="$group[last()][self::hr] or $next[self::hr]"</code> starts a new group immediately before and immediately after every <code>hr</code> element. (That is, <code>hr</code> elements become singleton groups.)</p></li><li><p><code>break-when="$next ne $group[last()] + 1"</code> starts a new group whenever the current item is not equal to the previous item plus one. For example <code>1, 2, 5, 6, 7, 10, 11</code> is grouped as <code>(1, 2), (5, 6, 7), (10, 11)</code>.</p></li><li><p><code>break-when="sum($group/string-length()) gt 40"</code> starts a new group when the sum of the string lengths of the items in the current group exceeds 40.</p></li><li><p><code>break-when="ends-with($group[last()], '.') and matches($next, '^\p{Lu}')"</code> starts a new group when the last item in the current group ends with <code>"."</code> and the next item starts with a capital letter.</p></li><li><p><code>break-when="deep-equal(slice($group, -2 to -1), ('', ''))"</code> starts a new group after two consecutive zero-length strings.</p></li><li><p><code>break-when="count($group) gt 1 and $group[1]/@name = $group[last()]/@name"</code> starts a new group if the last item in the current group has the same value for <code>@name</code> as the first item in that group (provided they are not the same item).</p></li></ul></li></ul><p>In all cases the order of items within each group is predictable, and reflects the original <a title="population order" class="termref" href="#dt-population-order">population order</a>, in that the items are processed in population order and each item is appended at the end of zero or more groups.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>As always, a different algorithm may be used if it achieves the same effect.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-item" title="initial item"></a>For each <a title="group" class="termref" href="#dt-group">group</a>, the item within the group that is first in <a title="population order" class="termref" href="#dt-population-order">population order</a> is known as the <b>initial item</b> of the group.<span class="definition">]</span></p><p>The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element is evaluated once for each of the <a title="group" class="termref" href="#dt-group">groups</a>, in <a title="processing order" class="termref" href="#dt-processing-order">processing order</a>. The sequences that result are concatenated, in <a title="processing order" class="termref" href="#dt-processing-order">processing order</a>, to form the result of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element. Within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of the relevant group, the <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of this group in the <a title="processing order" class="termref" href="#dt-processing-order">processing order</a> of the groups, and the <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of groups This has the effect that within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, a call on <code>position()</code> takes successive values <code>1, 2, ... last()</code>.</p></div><div class="div2"><h3><a id="information-about-group"></a>14.2 <a href="#information-about-group" style="text-decoration: none">Accessing Information about the Current Group Value</a></h3><p>Two pieces of information are available during the processing of each group (that is, while evaluating the sequence constructor contained in the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction, and also while evaluating the sort key of a group as expressed by the <code>select</code> attribute or sequence constructor of an <a href="#element-sort"><code>xsl:sort</code></a> child of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element):</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-group" title="current group"></a>The <b>current group</b> is the <a title="group" class="termref" href="#dt-group">group</a> itself, as a sequence of items<span class="definition">]</span>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-grouping-key" title="current grouping key"></a>The <b>current grouping key</b> is a single atomic value, or in the case of a composite key, a sequence of atomic values, containing the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of the items in the <a title="current group" class="termref" href="#dt-current-group">current group</a>.<span class="definition">]</span></p></li></ul><p>Information about the <a title="current group" class="termref" href="#dt-current-group">current group</a> and the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is held in the dynamic context, and is available using the <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> functions respectively.</p><p>In XSLT 2.0, the <a title="current group" class="termref" href="#dt-current-group">current group</a> and the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> were passed unchanged through calls of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-call-template"><code>xsl:call-template</code></a>, and also <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a>. This behavior is retained in XSLT 3.0 except in the case where streaming is in use: specifically, if the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction occurs within a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> construct (typically, within an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, or within a streamable <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>), then the current group and current grouping key are set to <a title="absent" class="termref" href="#dt-absent">absent</a> in the called template. The reason for this is to allow the streamability of an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction to be assessed statically, as described in <a href="#streamability-xsl-for-each-group"><i>19.8.4.19 Streamability of xsl:for-each-group</i></a>.</p><div class="div3"><h4><a id="func-current-group"></a>14.2.1 <a href="#func-current-group" style="text-decoration: none">fn:current-group</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the group currently being processed by an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:current-group</span></code><span class="deltaxml-old" style="background:#FF5555">()</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-current-group"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:current-group</span></code><span class="deltaxml-new" style="background:#90EE90">()</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p> The evaluation context for XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> includes a component called the <a title="current group" class="termref" href="#dt-current-group">current group</a>, which is a sequence. </p><p>The function <a href="#func-current-group"><code>current-group</code></a> returns the sequence of items making up the current group.</p><p>The current group is bound during evaluation of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction. If no <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is being evaluated, the current group will be <a title="absent" class="termref" href="#dt-absent">absent</a>: that is, any reference to it will cause a dynamic error.</p><p>The effect of <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation constructs</a> on the <a title="current group" class="termref" href="#dt-current-group">current group</a> is as follows:</p><ul><li><p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is contained within a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a><a title="construct" class="termref" href="#dt-construct">construct</a> (for example, if it is within an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction with the attribute <code>streamable="yes"</code>, or within a streamable template), then the invocation construct sets the current group to <a title="absent" class="termref" href="#dt-absent">absent</a>. In this situation the scope of the current group is effectively static; it can only be referenced within the body of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction to which it applies.</p></li><li><p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is a (static or dynamic) function call, then the invocation construct sets the current group to <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></li><li><p>Otherwise the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> leaves the current group unchanged. In this situation the scope of the current group is effectively dynamic: it can be referenced within called templates and attribute sets.</p></li></ul><p>The current group is initially <a title="absent" class="termref" href="#dt-absent">absent</a> during the evaluation of global variables and stylesheet parameters, during the evaluation of the <code>use</code> attribute or contained sequence constructor of <a href="#element-key"><code>xsl:key</code></a>, and during the evaluation of the <code>initial-value</code> attribute of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> attribute of contained sequence constructor of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTSE1060"><span class="error">[ERR XTSE1060] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-group"><code>current-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>. </p><p><a id="err-XTDE1061"><span class="error">[ERR XTDE1061] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-group"><code>current-group</code></a> function is used when the current group is <a title="absent" class="termref" href="#dt-absent">absent</a> , or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically. </p></dd><dt class="label">Notes</dt><dd><p class="note">Like other XSLT extensions to the dynamic evaluation context, the <a title="current group" class="termref" href="#dt-current-group">current group</a> is not retained as part of the closure of a function value. This means that the expression <code>current-group#0</code> is valid and returns a function value, but any invocation of this function will fail with a dynamic error <span class="error">[see <a href="#err-XTDE1061">ERR XTDE1061</a>]</span>. </p></dd></dl></div><div class="div3"><h4><a id="func-current-grouping-key"></a>14.2.2 <a href="#func-current-grouping-key" style="text-decoration: none">fn:current-grouping-key</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the grouping key of the group currently being processed using the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:current-grouping-key</span></code><span class="deltaxml-old" style="background:#FF5555">()</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-old" style="background:#FF5555">xs:anyAtomicType*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-current-grouping-key"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:current-grouping-key</span></code><span class="deltaxml-new" style="background:#90EE90">()</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType*</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p> The evaluation context for XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> includes a component called the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a>, which is a sequence of atomic values. The current grouping key is the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> shared in common by all the items within the <a title="current group" class="termref" href="#dt-current-group">current group</a>. </p><p>The function <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> returns the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a>.</p><p>The current grouping key is bound during evaluation of an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction that has a <code>group-by</code> or <code>group-adjacent</code> attribute. If <span>no <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is being evaluated, the current grouping key will be <a title="absent" class="termref" href="#dt-absent">absent</a>, which means that any reference to it causes a dynamic error. The current grouping key is also set to <a title="absent" class="termref" href="#dt-absent">absent</a> during the evaluation of an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction with a <code>group-starting-with</code> or <code>group-ending-with</code> attribute</span>.</p><p>The effect of <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation constructs</a> on the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is as follows:</p><ul><li><p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is contained within a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a><a title="construct" class="termref" href="#dt-construct">construct</a> (for example, if it is within an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction with the attribute <code>streamable="yes"</code>, or within a streamable template), then the invocation construct sets the current grouping key to <a title="absent" class="termref" href="#dt-absent">absent</a>. In this situation the scope of the current group is effectively static; it can only be referenced within the body of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction to which it applies.</p></li><li><p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is a (static or dynamic) function call, then the invocation construct sets the current grouping key to <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></li><li><p>Otherwise the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> leaves the current grouping key unchanged. In this situation the scope of the current group is effectively dynamic: it can be referenced within called templates and attribute sets.</p></li></ul><p>The current grouping key is initially <a title="absent" class="termref" href="#dt-absent">absent</a> during the evaluation of global variables and stylesheet parameters, during the evaluation of the <code>use</code> attribute or contained sequence constructor of <a href="#element-key"><code>xsl:key</code></a>, and during the evaluation of the <code>initial-value</code> attribute of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> attribute of contained sequence constructor of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p><p>While an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction with a <code>group-by</code> or <code>group-adjacent</code> attribute is being evaluated, the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> will be a single atomic value if <code>composite="no"</code> is specified (explicitly or implicitly), or a sequence of atomic values if <code>composite="yes"</code> is specified. </p><p>At other times, the current grouping key will be <a title="absent" class="termref" href="#dt-absent">absent</a>.</p><p>The <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a> of all items in a group are not necessarily identical. For example, one might be an <code>xs:float</code> while another is a numerically equal <code>xs:decimal</code>. The <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function returns the grouping key of the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> in the group, after atomization and casting of <code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p><p>The function takes no arguments.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTSE1070"><span class="error">[ERR XTSE1070] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>. </p><p><a id="err-XTDE1071"><span class="error">[ERR XTDE1071] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used when the current grouping key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically. </p></dd><dt class="label">Notes</dt><dd><p class="note">Like other XSLT extensions to the dynamic evaluation context, the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is not retained as part of the closure of a function value. This means that the expression <code>current-grouping-key#0</code> is valid and returns a function value, but any invocation of this function will fail with a dynamic error <span class="error">[see <a href="#err-XTDE1071">ERR XTDE1071</a>]</span>. </p></dd></dl></div></div><div class="div2"><h3><a id="order-of-groups"></a>14.3 <a href="#order-of-groups" style="text-decoration: none">Ordering among Groups</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-first-appearance" title="order of first appearance"></a>There is a total ordering among <a title="group" class="termref" href="#dt-group">groups</a> referred to as the <b>order of first appearance</b>. A group <var>G</var> is defined to precede a group <var>H</var> in order of first appearance if the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of <var>G</var> precedes the initial item of <var>H</var> in population order. If two groups <var>G</var> and <var>H</var> have the same initial item (because the item is in both groups) then <var>G</var> precedes <var>H</var> if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of <var>G</var> precedes the grouping key of <var>H</var> in the sequence that results from evaluating the <code>group-by</code> expression of this initial item.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-processing-order" title="processing order"></a>There is another total ordering among groups referred to as <b>processing order</b>. If group <var>R</var> precedes group <var>S</var> in processing order, then in the result sequence returned by the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction the items generated by processing group <var>R</var> will precede the items generated by processing group <var>S</var>.<span class="definition">]</span></p><p>If there are no <a href="#element-sort"><code>xsl:sort</code></a> elements immediately within the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element, the <a title="processing order" class="termref" href="#dt-processing-order">processing order</a> of the <a title="group" class="termref" href="#dt-group">groups</a> is the <a title="order of first appearance" class="termref" href="#dt-first-appearance">order of first appearance</a>.</p><p>Otherwise, the <a href="#element-sort"><code>xsl:sort</code></a> elements immediately within the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element define the processing order of the <a title="group" class="termref" href="#dt-group">groups</a> (see <a href="#sorting"><i>13 Sorting</i></a>). They do not affect the order of items within each group. Multiple <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key components</a> are allowed, and are evaluated in major-to-minor order. If two groups have the same values for all their sort key components, they are processed in <a title="order of first appearance" class="termref" href="#dt-first-appearance">order of first appearance</a> if the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is <a title="stable" class="termref" href="#dt-stable">stable</a>, otherwise in an <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</p><p>The <code>select</code><a title="expression" class="termref" href="#dt-expression">expression</a> of an <a href="#element-sort"><code>xsl:sort</code></a> element is evaluated once for each <a title="group" class="termref" href="#dt-group">group</a>. During this evaluation, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of the group, the <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of this item within the set of initial items (that is, one item for each group in the <a title="population" class="termref" href="#dt-population">population</a>) in <a title="population order" class="termref" href="#dt-population-order">population order</a>, the <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of groups, the <a title="current group" class="termref" href="#dt-current-group">current group</a> is the group whose <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a> is being determined, and the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is the grouping key for that group. If the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction uses the <code>group-starting-with</code>, <code>group-ending-with</code><span>, or <code>break-when</code></span> attributes, then the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p><div class="example"><div class="exampleHeader"><a id="d8e34576"></a><a id="d8e34683"></a>Example: Sorting Groups</div><p>For example, this means that if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> is <code>@category</code>, you can sort the groups in order of their grouping key by writing <code>&lt;xsl:sort select="current-grouping-key()"/&gt;</code>; or you can sort the groups in order of size by writing <code>&lt;xsl:sort select="count(current-group())"/&gt;</code></p></div></div><div class="div2"><h3><a id="grouping-examples"></a>14.4 <a href="#grouping-examples" style="text-decoration: none">Examples of Grouping</a></h3><div class="example"><div class="exampleHeader"><a id="d8e34591"></a><a id="d8e34698"></a>Example: Grouping Nodes based on Common Values</div><p>The following example groups a list of nodes based on common values. The resulting groups are numbered and sorted, and a total is calculated for each group. </p><p>Source XML document:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">cities</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Milano</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">Italia</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">5</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Paris</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">France</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">7</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">München</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">Deutschland</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">4</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Lyon</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">France</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Venezia</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">Italia</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">cities</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>More specifically, the aim is to produce a four-column table, containing one row for each distinct country. The four columns are to contain first, a sequence number giving the number of the row; second, the name of the country, third, a comma-separated alphabetical list of the city names within that country, and fourth, the sum of the <code>pop</code> attribute for the cities in that country.</p><p>Desired output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Position</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Country</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">List of Cities</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Population</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">1</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">Italia</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">Milano, Venezia</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">6</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">2</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">France</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">Lyon, Paris</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">9</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">3</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">Deutschland</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">München</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt">4</span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">table</span><span class="z"></span><span class="atn">xsl:version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Position</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Country</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">City List</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Population</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">cities</span><span class="step">/</span><span class="qname">city</span><span class="z">"</span><span class="z"></span><span class="atn">group-by</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">country</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">name</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">ne</span><span class="whitespace"></span><span class="numeric">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">, </span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">sum</span><span class="parenthesis">(</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">pop</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e34607"></a><a id="d8e34714"></a>Example: A Composite Grouping Key</div><p>Sometimes it is necessary to use a composite grouping key: for example, suppose the source document is similar to the one used in the previous examples, but allows multiple entries for the same country and city, such as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">cities</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Milano</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">Italia</span><span class="z">"</span><span class="z"></span><span class="atn">year</span><span class="atneq">=</span><span class="z">"</span><span class="av">1950</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">5.23</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Milano</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">Italia</span><span class="z">"</span><span class="z"></span><span class="atn">year</span><span class="atneq">=</span><span class="z">"</span><span class="av">1960</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">5.29</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Padova</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">Italia</span><span class="z">"</span><span class="z"></span><span class="atn">year</span><span class="atneq">=</span><span class="z">"</span><span class="av">1950</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">0.69</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Padova</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">Italia</span><span class="z">"</span><span class="z"></span><span class="atn">year</span><span class="atneq">=</span><span class="z">"</span><span class="av">1960</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">0.93</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Paris</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">France</span><span class="z">"</span><span class="z"></span><span class="atn">year</span><span class="atneq">=</span><span class="z">"</span><span class="av">1951</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">7.2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">city</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">Paris</span><span class="z">"</span><span class="z"></span><span class="atn">country</span><span class="atneq">=</span><span class="z">"</span><span class="av">France</span><span class="z">"</span><span class="z"></span><span class="atn">year</span><span class="atneq">=</span><span class="z">"</span><span class="av">1961</span><span class="z">"</span><span class="z"></span><span class="atn">pop</span><span class="atneq">=</span><span class="z">"</span><span class="av">7.6</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">cities</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Now suppose we want to list the average value of <code>@pop</code> for each (country, name) combination. One way to handle this is to concatenate the parts of the key, for example <code>&lt;xsl:for-each-group select="concat(@country, '/', @name)"&gt;</code>. A second solution is to nest one <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element directly inside another. XSLT 3.0 introduces a third option, which is to define the grouping key as composite:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">cities</span><span class="step">/</span><span class="qname">city</span><span class="z">"</span><span class="z"></span><span class="atn">group-by</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">name</span><span class="op">,</span><span class="whitespace"></span><span class="axis">@</span><span class="qname">country</span><span class="z">"</span><span class="z"></span><span class="atn">composite</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="filter">[</span><span class="numeric">1</span><span class="filter">]</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">, </span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="filter">[</span><span class="numeric">2</span><span class="filter">]</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">: </span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="function">avg</span><span class="parenthesis">(</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">pop</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The string concatenation operator <code>||</code> is new in XPath 3.0.</p></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e34627"></a><a id="d8e34734"></a>Example: Identifying a Group by its Initial Element</div><p>The next example identifies a group not by the presence of a common value, but rather by adjacency in document order. A group consists of an <code>h2</code> element, followed by all the <code>p</code> elements up to the next <code>h2</code> element.</p><p>Source XML document:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h2</span><span class="scx">&gt;</span><span class="txt">Introduction</span><span class="ez">&lt;/</span><span class="cl">h2</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">XSLT is used to write stylesheets.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">XQuery is used to query XML databases.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h2</span><span class="scx">&gt;</span><span class="txt">What is a stylesheet?</span><span class="ez">&lt;/</span><span class="cl">h2</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">A stylesheet is an XML document used to define a transformation.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Stylesheets may be written in XSLT.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">XSLT 2.0 introduces new grouping constructs.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Desired output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">chapter</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">section</span><span class="z"></span><span class="atn">title</span><span class="atneq">=</span><span class="z">"</span><span class="av">Introduction</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">para</span><span class="scx">&gt;</span><span class="txt">XSLT is used to write stylesheets.</span><span class="ez">&lt;/</span><span class="cl">para</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">para</span><span class="scx">&gt;</span><span class="txt">XQuery is used to query XML databases.</span><span class="ez">&lt;/</span><span class="cl">para</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">section</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">section</span><span class="z"></span><span class="atn">title</span><span class="atneq">=</span><span class="z">"</span><span class="av">What is a stylesheet?</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">para</span><span class="scx">&gt;</span><span class="txt">A stylesheet is used to define a transformation.</span><span class="ez">&lt;/</span><span class="cl">para</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">para</span><span class="scx">&gt;</span><span class="txt">Stylesheets may be written in XSLT.</span><span class="ez">&lt;/</span><span class="cl">para</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">para</span><span class="scx">&gt;</span><span class="txt">XSLT 2.0 introduces new grouping constructs.</span><span class="ez">&lt;/</span><span class="cl">para</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">section</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">body</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">group-starting-with</span><span class="atneq">=</span><span class="z">"</span><span class="qname">h2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">section</span><span class="z"></span><span class="atn">title</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="axis">self::</span><span class="qname">h2</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="filter">[</span><span class="axis">self::</span><span class="qname">p</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">para</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">para</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">section</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is to handle the case where the first element is not an <code>h2</code> element.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e34654"></a><a id="d8e34761"></a>Example: Identifying a Group by its Final Element</div><p>The next example illustrates how a group of related elements can be identified by the last element in the group, rather than the first. Here the absence of the attribute <code>continued="yes"</code> indicates the end of the group.</p><p>Source XML document:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="z"></span><span class="atn">continued</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Some text</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="z"></span><span class="atn">continued</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">More text</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">Yet more text</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="z"></span><span class="atn">continued</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Some words</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="z"></span><span class="atn">continued</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">More words</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">Yet more words</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Desired output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">pageset</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">Some text</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">More text</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">Yet more text</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">pageset</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">pageset</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">Some words</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">More words</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt">Yet more words</span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">pageset</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">doc</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">doc</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">group-ending-with</span><span class="atneq">=</span><span class="z">"</span><span class="qname">page</span><span class="filter">[</span><span class="function">not</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">continued</span><span class="op">=</span><span class="op">'</span><span class="literal">yes</span><span class="op">'</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">pageset</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">page</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">page</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">pageset</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">doc</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e34669"></a><a id="d8e34776"></a>Example: Adding an Element to Several Groups</div><p>The next example shows how an item can be added to multiple groups. Book titles will be added to one group for each indexing term marked up within the title.</p><p>Source XML document:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">titles</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">A Beginner's Guide to </span><span class="es">&lt;</span><span class="en">ix</span><span class="scx">&gt;</span><span class="txt">Java</span><span class="ez">&lt;/</span><span class="cl">ix</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">Learning </span><span class="es">&lt;</span><span class="en">ix</span><span class="scx">&gt;</span><span class="txt">XML</span><span class="ez">&lt;/</span><span class="cl">ix</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">Using </span><span class="es">&lt;</span><span class="en">ix</span><span class="scx">&gt;</span><span class="txt">XML</span><span class="ez">&lt;/</span><span class="cl">ix</span><span class="ec">&gt;</span><span class="txt"> with </span><span class="es">&lt;</span><span class="en">ix</span><span class="scx">&gt;</span><span class="txt">Java</span><span class="ez">&lt;/</span><span class="cl">ix</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">titles</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Desired output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">h2</span><span class="scx">&gt;</span><span class="txt">Java</span><span class="ez">&lt;/</span><span class="cl">h2</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">A Beginner's Guide to Java</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Using XML with Java</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h2</span><span class="scx">&gt;</span><span class="txt">XML</span><span class="ez">&lt;/</span><span class="cl">h2</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Learning XML</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Using XML with Java</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">titles</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">title</span><span class="z">"</span><span class="z"></span><span class="atn">group-by</span><span class="atneq">=</span><span class="z">"</span><span class="qname">ix</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h2</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">h2</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e34681"></a><a id="d8e34788"></a>Example: Grouping Alternating Sequences of Elements</div><p>In this example, the membership of a node within a group is based both on adjacency of the nodes in document order, and on common values. In this case, the grouping key is a boolean condition, true or false, so the effect is that a grouping establishes a maximal sequence of nodes for which the condition is true, followed by a maximal sequence for which it is false, and so on.</p><p>Source XML document:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Do </span><span class="es">&lt;</span><span class="en">em</span><span class="scx">&gt;</span><span class="txt">not</span><span class="ez">&lt;/</span><span class="cl">em</span><span class="ec">&gt;</span><span class="txt">: </span><span class="es">&lt;</span><span class="en">ul</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt">talk,</span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt">eat, or</span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt">use your mobile telephone</span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">ul</span><span class="ec">&gt;</span><span class="txt"> while you are in the cinema.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Desired output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Do </span><span class="es">&lt;</span><span class="en">em</span><span class="scx">&gt;</span><span class="txt">not</span><span class="ez">&lt;/</span><span class="cl">em</span><span class="ec">&gt;</span><span class="txt">:</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">ul</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt">talk,</span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt">eat, or</span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">li</span><span class="scx">&gt;</span><span class="txt">use your mobile telephone</span><span class="ez">&lt;/</span><span class="cl">li</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">ul</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">while you are in the cinema.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Solution:</p><p>This requires creating a <code>p</code> element around the maximal sequence of sibling nodes that does not include a <code>ul</code> or <code>ol</code> element.</p><p>This can be done by using <code>group-adjacent</code>, with a grouping key that is true if the element is a <code>ul</code> or <code>ol</code> element, and false otherwise:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">p</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="axis">self::</span><span class="qname">ul</span><span class="whitespace"></span><span class="op">or</span><span class="whitespace"></span><span class="axis">self::</span><span class="qname">ol</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e34709"></a><a id="d8e34816"></a>Example: Grouping entries in a Map</div><p>Consider a map with composite keys that might appear in a JSON document as:</p><div class="exampleInner"><pre>{ "Africa/Abidjan": {"offset": "+00:00", "DST-offset": "+00:00" }, "Africa/Algiers": {"offset": "+01:00", "DST-offset": "+01:00" }, "Africa/Nairobi": {"offset": "+03:00", "DST-offset": "+03:00" }, "America/Anchorage": {"offset": "-09:00", "DST-offset": "-08:00" }, "America/Los_Angeles": {"offset": "-08:00", "DST-offset": "-07:00" }, "Asia/Dubai": {"offset": "+04:00", "DST-offset": "+04:00" }, "Asia/Kolkata": {"offset": "+05:30", "DST-offset": "+05:30" } }</pre></div><p>And suppose we wish to group this into a two-level map, thus:</p><div class="exampleInner"><pre>{ "Africa": { "Abidjan": {"offset": "+00:00", "DST-offset": "+00:00" }, "Algiers": {"offset": "+01:00", "DST-offset": "+01:00" }, "Nairobi": {"offset": "+03:00", "DST-offset": "+03:00" } }, "America": { "Anchorage": {"offset": "-09:00", "DST-offset": "-08:00" }, "Los_Angeles": {"offset": "-08:00", "DST-offset": "-07:00" } }, "Asia": { "Dubai": {"offset": "+04:00", "DST-offset": "+04:00" }, "Kolkata": {"offset": "+05:30", "DST-offset": "+05:30" } } }</pre></div><p>This can be achieved as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:map</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">map</span><span class="atneq">=</span><span class="z">"</span><span class="av">json-doc('tz.json')</span><span class="z">"</span><span class="z"></span><span class="atn">group-by</span><span class="atneq">=</span><span class="z">"</span><span class="function">substring-before</span><span class="parenthesis">(</span><span class="op">?</span><span class="qname">key</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">/</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="function">substring-after</span><span class="parenthesis">(</span><span class="op">?</span><span class="qname">key</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">/</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="qname">value</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map-entry</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div1"><h2><a id="merging"></a>15 <a href="#merging" style="text-decoration: none">Merging</a></h2><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction allows a sorted sequence of items to be constructed by merging several input sequences. Each input sequence <span class="verb">must</span> have a merge key (one or more atomic values that can be computed as a function of the items in the sequence); the input sequence <span class="verb">must</span> either already be sorted on the value of its merge keys, or pre-sorting on these values must be requested. The merge keys for the different input sequences <span class="verb">must</span> be compatible in the sense that key values from an item in one sequence are always comparable with key values from an item in a different sequence.</p><p>For example, if two log files contain details of events sorted by date and time, then the <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to combine these into a single sequence that is also sorted by date and time.</p><p>The data written to the output sequence can be computed in an arbitrary way from the data in the input sequences, provided it follows the ordering of the input sequences.</p><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to merge several sequences of items that all have the same structure (more precisely, sequences whose merge keys are computed in the same way): for example, log files created by the same application running on different machines in a server farm. Alternatively, <a href="#element-merge"><code>xsl:merge</code></a> can be used to merge sequences that have different structure (sequences whose merge keys are computed in different ways), provided that the computed merge keys are compatible: an example might be two log files created by different applications, using different XML vocabularies, that both contain timestamped events but represent the timestamp in different ways. The <a href="#element-merge-source"><code>xsl:merge-source</code></a> element represents a set of input sequences that follow common rules, including the rules for computing the merge key. The <a href="#element-merge"><code>xsl:merge</code></a> operation may take any number of <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements representing different rules for input sequences, and each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element may describe any number (zero or more) of input sequences. The number of input sequences to the merging operation is thus fixed only at the time the <a href="#element-merge"><code>xsl:merge</code></a> instruction is evaluated, and <span class="verb">may</span> vary from one evaluation to another.</p><p>The following examples illustrate some of the possibilities. The detailed explanation of the constructs used follows later in this section.</p><div class="example"><div class="exampleHeader"><a id="d8e34844"></a><a id="d8e34951"></a>Example: Merging All the Files in a Collection</div><p>This example takes as input a homogeneous collection of XML log files each of which contains a sorted sequence of <code>event</code> elements with a <code>timestamp</code> attribute validated as an instance of <code>xs:dateTime</code>. It merges the events from the input files into a single sorted output file.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">merged-events.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">events</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">uri-collection('log-files')</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">events</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">timestamp</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The example assumes that there are several input files each of which has a structure similar to the following, in which the <code>timestamp</code> attribute has a typed value that is an instance of <code>xs:dateTime</code>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">events</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">timestamp</span><span class="atneq">=</span><span class="z">"</span><span class="av">2009-08-20T12:01:01Z</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Transaction T1234 started</span><span class="ez">&lt;/</span><span class="cl">event</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">timestamp</span><span class="atneq">=</span><span class="z">"</span><span class="av">2009-08-20T12:01:08Z</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Transaction T1235 started</span><span class="ez">&lt;/</span><span class="cl">event</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">timestamp</span><span class="atneq">=</span><span class="z">"</span><span class="av">2009-08-20T12:01:12Z</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Transaction T1235 ended</span><span class="ez">&lt;/</span><span class="cl">event</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">timestamp</span><span class="atneq">=</span><span class="z">"</span><span class="av">2009-08-20T12:01:15Z</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">Transaction T1234 ended</span><span class="ez">&lt;/</span><span class="cl">event</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The output file will have the same structure, and will contain copies of all the <code>event</code> elements from all of the input files, in sorted order. Note that multiple events with the same timestamp can occur either within a single file or across multiple files: the order of appearance of these events in the output file corresponds to the order of the log files within the collection (which might or might not be predictable, depending on the implementation).</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e34868"></a><a id="d8e34975"></a>Example: Merging Two Heterogeneous Files</div><p>This example takes as input two log files with different structure, producing a single merged output in which the entries have a common structure:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">merged-events.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">events</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">log-file-1.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="qname">events</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">timestamp</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">log-files-2.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="qname">log</span><span class="step">/</span><span class="qname">day</span><span class="step">/</span><span class="qname">record</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">dateTime</span><span class="parenthesis">(</span><span class="context">..</span><span class="step">/</span><span class="axis">@</span><span class="qname">date</span><span class="op">,</span><span class="whitespace"></span><span class="qname">time</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">standardize-log-entry</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Here the first input file has a structure similar to that shown in the previous example, while the second input has a different structure, of the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">log</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">day</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="av">2009-08-20</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">record</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">time</span><span class="scx">&gt;</span><span class="txt">12:01:09-05:00</span><span class="ez">&lt;/</span><span class="cl">time</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">message</span><span class="scx">&gt;</span><span class="txt">Temperature 15.4C</span><span class="ez">&lt;/</span><span class="cl">message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">record</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">record</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">time</span><span class="scx">&gt;</span><span class="txt">12:03:00-05:00</span><span class="ez">&lt;/</span><span class="cl">time</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">message</span><span class="scx">&gt;</span><span class="txt">Temperature 18.2C</span><span class="ez">&lt;/</span><span class="cl">message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">record</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">day</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">log</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The templates in mode <code>standardize-log-entry</code> convert the log entries to a common output format, for example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">event</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">standardize-log-entry</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">schema-element(event)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">preserve</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">record</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">standardize-log-entry</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">schema-element(event)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">timestamp</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">dateTime</span><span class="parenthesis">(</span><span class="context">..</span><span class="step">/</span><span class="axis">@</span><span class="qname">date</span><span class="op">,</span><span class="whitespace"></span><span class="qname">time</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">xsl:validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strict</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">message</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">event</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction is designed to enable streaming of data, so that there is no need to allocate memory to hold the input sequences. However, it can also be used in cases where streamed processing is not possible, for example when the input needs to be sorted.</p></div><div class="div2"><h3><a id="merge-terminology"></a>15.1 <a href="#merge-terminology" style="text-decoration: none">Terminology for Merging</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-source-definition" title="merge source definition"></a>A <b>merge source definition</b> is the definition of one kind of input to the merge operation. It selects zero or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a>, and it includes a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> to define how the <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> are computed for each such merge input sequence.<span class="definition">]</span> A merge source definition corresponds to an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element in the stylesheet.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-input-sequence" title="merge input sequence"></a>A <b>merge input sequence</b> is an arbitrary <a href="https://www.w3.org/TR/xpath-datamodel-30/#dt-sequence">sequence</a><sup><small>DM30</small></sup> of items which is already sorted according to the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> for the corresponding <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-specification" title="merge key specification"></a>A <b>merge key specification</b> consists of one or more adjacent <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements which together define how the <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a> selected by a <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a> are sorted. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a>.<span class="definition">]</span> For example, a merge key specification for a log file might specify two merge key components, <code>date</code> and <code>time</code>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-component" title="merge key component"></a>A <b>merge key component</b> specifies one component of a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>; it corresponds to a single <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the stylesheet.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-value" title="merge key value"></a> For each item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. The value computed for an item by using the <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the <var>N</var>th <b>merge key value</b> of that item.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-composite-merge-key-value" title="composite merge key value"></a> The ordered collection of <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> computed for one item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a> (one for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>) is referred to as a <b>composite merge key value</b>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-activation" title="merge activation"></a>A <b>merge activation</b> is a single evaluation of the sequence constructor contained within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, which occurs once for each distinct <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key value</a>.<span class="definition">]</span></p></div><div class="div2"><h3><a id="merge-instruction"></a>15.2 <a href="#merge-instruction" style="text-decoration: none">The </a><a href="#element-merge"><code>xsl:merge</code></a><a href="#merge-instruction" style="text-decoration: none"> Instruction</a></h3><p class="element-syntax"><a id="element-merge"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:merge&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-merge-source">xsl:merge-source</a>+, <a href="#element-merge-action">xsl:merge-action</a>, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:merge&gt;</code></p><p>The effect of the <a href="#element-merge"><code>xsl:merge</code></a> instruction is to produce a sorted result sequence from a number of input sequences.</p><p>The input sequences to the merge operation are defined by the <a href="#element-merge-source"><code>xsl:merge-source</code></a> child elements, as described in the next section.</p><p>The sequence constructor contained in the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element is evaluated once for each distinct <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key value</a> to form a partial result sequence. The result of the <a href="#element-merge"><code>xsl:merge</code></a> instruction is the concatenation of these partial result sequences. For example, the action might be to copy the items from all the input sequences to the result sequence without change; or it might be to select the items from one input sequence in preference to the others. In the general case, the items in the partial result sequence are produced by an arbitrary computation that has access to the items (from the various input sequences) that share the same value for the composite merge key.</p><p>The <a href="#element-merge-source"><code>xsl:merge-source</code></a> and <a href="#element-merge-action"><code>xsl:merge-action</code></a> elements are described in the following sections.</p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a> instruction are ignored by an XSLT 3.0 processor, but are used by an XSLT 1.0 or XSLT 2.0 processor to perform fallback processing.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An <a href="#element-merge"><code>xsl:merge</code></a> instruction that has no input sequences returns an empty sequence. An <a href="#element-merge"><code>xsl:merge</code></a> instruction with a single input sequence performs processing that is very similar in concept to <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> with the <code>group-adjacent</code> attribute, except that it requires the input to be sorted on the grouping key.</p></div></div><div class="div2"><h3><a id="merge-input-sequences"></a>15.3 <a href="#merge-input-sequences" style="text-decoration: none">Selecting the Sequences to be Merged</a></h3><p class="element-syntax"><a id="element-merge-source"></a><code>&lt;xsl:merge-source<br>&nbsp;&nbsp;name? = <var>ncname</var><br>&nbsp;&nbsp;for-each-item? = <var>expression</var><br>&nbsp;&nbsp;for-each-source? = <var>expression</var><br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var><br>&nbsp;&nbsp;sort-before-merge? = <var>boolean</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-merge-key">xsl:merge-key</a>+ --&gt;<br>&lt;/xsl:merge-source&gt;</code></p><p>Each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element defines one or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a>.</p><p>The <code>name</code> attribute provides a means of distinguishing items from different merge sources within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> instructions. If the <code>name</code> attribute is present on an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, then it must not be equal to the <code>name</code> attribute of any sibling <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. If the <code>name</code> attribute is absent, then an <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> name, different from all explicitly specified names, is allocated to the merge source.</p><p><a id="err-XTSE3195"><span class="error">[ERR XTSE3195] </span></a>If the <code>for-each-item</code> attribute is present then the <code>for-each-source</code>, <code>use-accumulators</code>, and <code>streamable</code> attributes must all be absent. If <span>either or both of the <code>use-accumulators</code> or <code>streamable</code> attributes is present </span> then the <code>for-each-source</code> attribute must be present. If the <code>for-each-source</code> attribute is present then the <code>for-each-item</code> attribute must be absent. <span>[XSLT 3.0 Erratum E40, bugs 30265 and 30378].</span></p><p>The <code>use-accumulators</code> attribute defines the set of accumulators that are applicable to the streamed document, as explained in <a href="#applicability-of-accumulators"><i>18.2.2 Applicability of Accumulators</i></a>.</p><p>If neither of <code>for-each-item</code> and <code>for-each-source</code> is present, the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element defines a single merge input sequence. This sequence is the result of evaluating the expression in the <code>select</code> attribute. This is evaluated using the dynamic context of the containing <a href="#element-merge"><code>xsl:merge</code></a> instruction. This sequence will be merged with the sequences defined by other <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, if present.</p><p>When the <code>for-each-item</code> attribute is present, the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element defines a collection of merge input sequences. The selection of items in these input sequences is a two-stage process: the <code>for-each-item</code> attribute of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is an expression that selects a sequence of <em>anchor items</em>, and for each anchor item, the <code>select</code> attribute is evaluated to select the items that make up one merge input sequence. The <code>for-each-item</code> expression is evaluated with the dynamic context of the containing <a href="#element-merge"><code>xsl:merge</code></a> instruction, while the <code>select</code> attribute is evaluated with the <a title="focus" class="termref" href="#dt-focus">focus</a> for the evaluation as follows:</p><ul><li><p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the anchor item</p></li><li><p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of the anchor item within the sequence of anchor items</p></li><li><p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of anchor items.</p></li></ul><p>When the <code>for-each-source</code> attribute is present, its value must be an expression that returns a sequence of URIs. The expression is evaluated with the same dynamic context as the containing <a href="#element-merge"><code>xsl:merge</code></a> instruction. The expected type of the expression is <code>xs:string*</code>, and the actual result of the expression is converted to this type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. Each of these URIs is used to obtain a document node. Each <span class="verb">must</span> be a valid URI reference. If it is an absolute URI reference, it is used as is; if it is a relative URI reference, it is made absolute by resolving it against the base URI of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. The process of obtaining a document node given a URI is the same as for the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function, and may trigger the same error conditions. However, unlike the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function, the <a href="#element-merge"><code>xsl:merge</code></a> instruction offers no guarantee that the resulting document will be stable (that is, that multiple calls specifying the same URI will return the same document). The resulting document nodes act as the <b>anchor items</b>. These anchor items are then used in the same way as a sequence of anchor items selected directly using the <code>for-each-item</code> attribute: in particular, the <a title="focus" class="termref" href="#dt-focus">focus</a> is determined in the same way.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Examples of expressions that return a sequence of URIs are:</p><ul><li><p><code>for-each-source="'inputA.xml', 'inputB.xml'"</code></p></li><li><p><code>for-each-source="(1 to $N) ! ('input' || $N || '.xml')"</code></p></li><li><p><code>for-each-source="uri-collection('input/dir/')</code></p></li></ul><p>Relative URIs are resolved relative to the base URI of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element.</p></div><p>The attributes <code>validation</code> and <code>type</code> are used to control schema validation of documents read by virtue of their appearance in the result of the <code>for-each-source</code> expression. These attributes are mutually exclusive <span class="error">[see <a href="#err-XTSE1505">ERR XTSE1505</a>]</span>. If the <code>for-each-source</code> attribute is absent, then the <code>validation</code> and <code>type</code> attributes <span class="verb">must</span> both be absent. <span>The process of validation follows the rules defined in <a href="#validation"><i>26.4 Validation</i></a> [XSLT 3.0 Erratum E44, bug 30384].</span></p><p>If the <code>sort-before-merge</code> attribute is absent or has the value <code>no</code>, then each merge input sequence <span class="verb">must</span> already be in the correct order for merging (a dynamic error occurs if it is not). If the attribute is present with the value <code>yes</code>, then each input sequence will first be sorted to ensure that it is in the correct order. <span> The sorting is carried out as if by evaluating an <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction with <a href="#element-sort"><code>xsl:sort</code></a> children corresponding one-to-one with the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, differing only (a) in the change of element name, and (b) in the addition of the attribute <code>stable="yes"</code> to the first such element. [XSLT 3.0 Erratum E41, bug 30380]. </span></p><div class="example"><div class="exampleHeader"><a id="d8e35297"></a><a id="d8e35404"></a>Example: Merging Several Documents with the Same Structure</div><p>The following <a href="#element-merge-source"><code>xsl:merge-source</code></a> element selects two anchor items (the root nodes of two documents), and for each of these it selects an input sequence consisting of selected <code>event</code> elements within the relevant document.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">'log-A.xml', 'log-B.xml'</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">events</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">timestamp</span><span class="z">"</span><span class="z"></span><span class="atn">order</span><span class="atneq">=</span><span class="z">"</span><span class="av">ascending</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This example can be extended to merge any number of input documents with the same structure:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">uri-collection('log-collection')</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">events</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">time</span><span class="z">"</span><span class="z"></span><span class="atn">order</span><span class="atneq">=</span><span class="z">"</span><span class="av">ascending</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>In both the above examples the anchor items are document nodes, and the items in the input sequence are elements within the document that is rooted at this node. This is a common usage pattern, but by no means the only way in which the construct can be used.</p></div><p>The number of anchor items selected by an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, and therefore the number of input sequences, is variable, but the input sequences selected by one <a href="#element-merge-source"><code>xsl:merge-source</code></a> element must all use the same expressions to select the items in the input sequence and to compute their merge keys. If different expressions are needed for different input sequences, then multiple <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements can be used.</p><div class="example"><div class="exampleHeader"><a id="d8e35319"></a><a id="d8e35426"></a>Example: Merging Two Documents with Different Structure</div><p>The following code merges two log files having different internal structure:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">'event-log.xml'</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="op">*</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">timestamp</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">'error-log.xml'</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="op">*</span><span class="step">/</span><span class="qname">error</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">dateTime</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">date</span><span class="op">,</span><span class="whitespace"></span><span class="axis">@</span><span class="qname">time</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Although the merge keys are computed in different ways for the two input sequences, the keys must be compatible across the two sequences: in this case they are both atomic values of type <code>xs:dateTime</code>.</p></div><p>In the common case where there is only one input sequence of a particular kind, the <code>for-each-item</code> attribute of <a href="#element-merge-source"><code>xsl:merge-source</code></a> may be omitted; the <code>select</code> expression is then evaluated relative to the <a title="focus" class="termref" href="#dt-focus">focus</a> of the <a href="#element-merge"><code>xsl:merge</code></a> instruction itself.</p><div class="example"><div class="exampleHeader"><a id="d8e35341"></a><a id="d8e35448"></a>Example: Sorting before Merging</div><p>Where one or more of the inputs to the merging process is not pre-sorted, a sort can be requested using the <code>sort-before-merge</code> attribute. For example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">event-log.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="op">*</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">timestamp</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">error-log.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">//</span><span class="qname">error</span><span class="z">"</span><span class="z"></span><span class="atn">sort-before-merge</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">dateTime</span><span class="parenthesis">(</span><span class="function">current-date</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="axis">@</span><span class="qname">time</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p><a id="err-XTSE3190"><span class="error">[ERR XTSE3190] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two sibling <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements have the same name. </p></div><div class="div2"><h3><a id="streamable-merging"></a>15.4 <a href="#streamable-merging" style="text-decoration: none">Streamable Merging</a></h3><p>Any input to a merging operation, provided it is selected by means of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element with a <code>for-each-source</code> attribute, may be designated as streamable by including the attribute <code>streamable="yes"</code> on the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. </p><p>When <code>streamable="yes"</code> is specified on an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, then (whether or not streamed processing is actually used, and whether or not the processor supports streaming) the expression appearing in the <code>select</code> attribute is implicitly used as the argument of a call on the <a href="#func-snapshot"><code>snapshot</code></a> function, which means that merge keys for each selected node are computed with reference to this snapshot, and the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function, when used within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> sequence constructor, delivers snapshots of the selected nodes.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are therefore no constraints on the navigation that may be performed in computing the merge key, or in the course of evaluating the <a href="#element-merge-action"><code>xsl:merge-action</code></a> body. An attempt to navigate outside the portion of the source document delivered by the <a href="#func-snapshot"><code>snapshot</code></a> function will typically not cause an error, but will return empty results.</p><p>There is no rule to prevent the <code>select</code> expression returning atomic values, or grounded nodes from a different source document, or newly constructed nodes, but they are still processed using the <a href="#func-snapshot"><code>snapshot</code></a> function.</p><p>Because the <a href="#func-snapshot"><code>snapshot</code></a> copies accumulator values as described in <a href="#copying-accumulators"><i>18.2.10 Copying Accumulator Values</i></a>, the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a> may be used to gain access to information that is not directly available in the nodes that are present within each snapshot (for example, information in a header section of the merge input document).</p></div><p>An <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> if it satisfies all the following conditions:</p><ol class="enumar"><li><p>The <a href="#element-merge-source"><code>xsl:merge-source</code></a> element has the attribute value <code>streamable="yes"</code>;</p></li><li><p>The <code>for-each-source</code> attribute is present on that <a href="#element-merge-source"><code>xsl:merge-source</code></a> element;</p></li><li><p>The expression in the <code>select</code> attribute of that <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="striding" class="termref" href="#dt-striding">striding</a> and a <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> of <var>U{document-node()}</var>, has <a title="striding" class="termref" href="#dt-striding">striding</a> or <a title="grounded" class="termref" href="#dt-grounded">grounded</a><a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a><a title="sweep" class="termref" href="#dt-sweep">sweep</a>; </p></li><li><p>The <code>sort-before-merge</code> attribute of that <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is either absent or takes its default value of <code>no</code>.</p></li></ol><p>Specifying <code>streamable="yes"</code> on an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element declares an intent that the <a href="#element-merge"><code>xsl:merge</code></a> instruction should be streamable with respect to that particular source, either because it is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, or because it takes advantage of streamability extensions offered by a particular processor. The consequences of declaring the instruction to be streamable when it is not in fact guaranteed streamable depend on the conformance level of the processor, and are explained in <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>.</p><div class="example"><div class="exampleHeader"><a id="d8e35481"></a><a id="d8e35588"></a>Example: Streamed Merging</div><p>The following example merges two log files, processing each of them using streaming.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">events</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">'log-file-1.xml'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="qname">events</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">timestamp</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">'log-files-2.xml'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="qname">log</span><span class="step">/</span><span class="qname">day</span><span class="step">/</span><span class="qname">record</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">dateTime</span><span class="parenthesis">(</span><span class="context">..</span><span class="step">/</span><span class="axis">@</span><span class="qname">date</span><span class="op">,</span><span class="whitespace"></span><span class="qname">time</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">events</span><span class="z"></span><span class="atn">time</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">current-merge-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>Note that the merge key for the second merge source includes data from a child element of the selected element and also from an attribute of the parent element. This works because the merge key is evaluated on the result of implicitly applying the <a href="#func-snapshot"><code>snapshot</code></a> function.</p><div class="example"><div class="exampleHeader"><a id="d8e35490"></a><a id="d8e35597"></a>Example: Merging XML and non-XML Data</div><p>The following example merges two log files, one in text format and one in XML format.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">events</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">fax</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">unparsed-text-lines</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">fax-log.txt</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:dateTime</span><span class="parenthesis">(</span><span class="function">substring-before</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">mail</span><span class="z">"</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">'mail-log.xml'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="qname">log</span><span class="step">/</span><span class="qname">day</span><span class="step">/</span><span class="qname">message</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">dateTime</span><span class="parenthesis">(</span><span class="context">..</span><span class="step">/</span><span class="axis">@</span><span class="qname">date</span><span class="op">,</span><span class="whitespace"></span><span class="axis">@</span><span class="qname">time</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">messages</span><span class="z"></span><span class="atn">at</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">current-merge-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:where-populated</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">fax</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">fax</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">message</span><span class="z"></span><span class="atn">xsl:expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">true</span><span class="z">"</span><span class="scx">&gt;</span><span class="op">{</span><span class="whitespace"></span><span class="function">substring-after</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">fax</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">mail</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">mail</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">mail</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:where-populated</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">messages</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">events</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="merge-keys"></a>15.5 <a href="#merge-keys" style="text-decoration: none">Defining the Merge Keys</a></h3><p>The keys on which the input sequences are sorted are referred to as merge keys. If the attribute <code>sort-before-merge</code> has the value <code>yes</code>, the input sequences will be sorted into the correct sequence before the merge operation takes place (alternatively, the processor <span class="verb">may</span> use an algorithm that has the same effect as sorting followed by merging). If the attribute is absent or has the value <code>no</code>, then the input sequences <span class="verb">must</span> already be in the correct order.</p><p>The merge key for each type of input sequence (that is, for each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element) is defined by a sequence of <a href="#element-merge-key"><code>xsl:merge-key</code></a> element children of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one merge key component. The syntax and semantics of an <a href="#element-merge-key"><code>xsl:merge-key</code></a> element are closely based on the rules for the <a href="#element-sort"><code>xsl:sort</code></a> element (<span>with minor exceptions noted below; the only difference in syntax is</span> the absence of the <code>stable</code> attribute); the <span>main</span> difference is that <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements do not cause a sort to take place, they merely declare the existing sort order of the input sequence. <span>[See XSLT 3.0 Erratum E42, bugs 30130 and 30382].</span></p><p class="element-syntax"><a id="element-merge-key"></a><code>&lt;xsl:merge-key<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-key&gt;</code></p><p>The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are mutually exclusive:</p><p><a id="err-XTSE3200"><span class="error">[ERR XTSE3200] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-merge-key"><code>xsl:merge-key</code></a> element with a <code>select</code> attribute has non-empty content. </p><p>The value of <var>N</var>th item in the merge key of an item <var>J</var> in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a><var>S</var> is computed as follows, where <var>K</var> is the <var>N</var>th <a href="#element-merge-key"><code>xsl:merge-key</code></a> element of the relevant <a href="#element-merge-source"><code>xsl:merge-source</code></a>:</p><ol class="enumar"><li><p>If <var>K</var> has a <code>select</code> attribute, then the result of evaluating and atomizing that <code>select</code> expression;</p></li><li><p>If <var>K</var> contains a non-empty sequence constructor, then the result of evaluating and atomizing that sequence constructor;</p></li><li><p>Otherwise, the result of atomizing the context item.</p></li></ol><p>In each case the evaluation uses a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>J</var>, or, if <code>streamable="yes"</code> is specified on the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on a snapshot of <var>J</var> (see <a href="#streamable-merging"><i>15.4 Streamable Merging</i></a>). [XSLT 3.0 Erratum E42, bugs 30130 and 30382].</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that <code>position()</code> and <code>last()</code> return 1 (one). This differs from the way <a href="#element-sort"><code>xsl:sort</code></a> keys are evaluated, where <code>position()</code> is the position in the unsorted sequence, and <code>last()</code> is the size of the unsorted sequence.</p></div><p>The effect of the <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements is defined in terms of the rules for an equivalent sequence of <a href="#element-sort"><code>xsl:sort</code></a> elements: if the rules for sorting (see <a href="#sorting-process"><i>13.1.1 The Sorting Process</i></a>) with <code>stable="yes"</code> would place an item <var>A</var> before an item <var>B</var> in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> produced by the sorting process, then <var>A</var> must precede <var>B</var> in the input sequence to the merging process.</p><p>The merge keys of the various input sequences to a merge operation must be compatible with each other, since the merge operation will decide the ordering of the result sequence by comparing merge key values across input sequences. This means that across all the <a href="#element-merge-source"><code>xsl:merge-source</code></a> children of an <a href="#element-merge"><code>xsl:merge</code></a> instruction:</p><ul><li><p>Each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element <span class="verb">must</span> have the same number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> child elements; let this number be <var>N</var>.</p></li><li><p>For each integer <var>J</var> in 1..<var>N</var>, consider the set <var>S</var> of <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that are in position <var>J</var> among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of their parent <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. For each attribute <var>A</var> in the set <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, and <code>data-type</code> it must be the case that for any two elements <var>s1</var> and <var>s2</var> in <var>S</var>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of attribute <var>A</var> on <var>s1</var> is the same as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of attribute <var>A</var> on <var>s2</var>, where two attributes are said to have the same effective value if either (a) both attributes are absent, or (b) both attributes are present and the results of evaluating them (they are attribute value templates) are codepoint-equal. Furthermore, in the case of the <code>collation</code> attribute, the absolute collation URI must be the same after resolving against the base URI. [XSLT 3.0 Erratum E29, bug 30267].</p></li></ul><p>If any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code> are <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>, then their <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> are evaluated using the <a title="focus" class="termref" href="#dt-focus">focus</a> of the containing <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p><p><a id="err-XTSE2200"><span class="error">[ERR XTSE2200] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of a <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is not equal to the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of another <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the same <a href="#element-merge"><code>xsl:merge</code></a> instruction. </p><p><span style="display: none;" class="delete_version"><a id="err-XTDE2210"><span class="error">[ERR XTDE2210] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if the attribute is present on one element and not on the other, or if it is present on both elements with <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> that are not equal to each other. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be reported statically if it is detected statically. </span><span style="display: none;" class="add_version"><a id="err-XTDE2210"><span class="error">[ERR XTDE2210] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if they have different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a>. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be reported statically if it is detected statically. </span><span class="modify_version"><a id="err-XTDE2210"><span class="error">[ERR XTDE2210] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if <span class="deltaxml-old" style="background:#FF5555">the attribute is present on one element and not on the other, or if it is present on both elements with</span><span class="deltaxml-new" style="background:#90EE90">they have different</span> <a title="effective value" class="termref" href="#dt-effective-value">effective values</a><span class="deltaxml-old" style="background:#FF5555"> that are not equal to each other</span>. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be reported statically if it is detected statically. </span></p><p><a id="err-XTDE2220"><span class="error">[ERR XTDE2220] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if any input sequence to an <a href="#element-merge"><code>xsl:merge</code></a> instruction contains two items that are not correctly sorted according to the merge key values defined on the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the corresponding <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, when compared using the collation rules defined by the attributes of the corresponding <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a> instruction, unless the attribute <code>sort-before-merge</code> is present with the value <code>yes</code>. </p><p><a id="err-XTTE2230"><span class="error">[ERR XTTE2230] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if some item selected by a particular merge key in one input sequence is not comparable using the XPath <code>le</code> operator with some item selected by the corresponding sort key in another input sequence. </p></div><div class="div2"><h3><a id="current-merge-group-and-key"></a>15.6 <a href="#current-merge-group-and-key" style="text-decoration: none">The Current Merge Group and Key</a></h3><p>During processing of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, two additional values are available within the dynamic context:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-merge-group" title="current merge group"></a>The <b>current merge group</b> is a map. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key values</a> is processed, the current merge group is set to a map whose keys are the names of the various merge sources, and whose associated values are the items from each merge source having the relevant composite merge key value.<span class="definition">]</span></p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-merge-key" title="current merge key"></a>The <b>current merge key</b> is a sequence of atomic values. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key values</a> is processed, the current merge key is set to the composite merge key value that these items have in common.<span class="definition">]</span></p></li></ul><p>These values are made available through the functions <a href="#func-current-merge-group"><code>current-merge-group</code></a> and <a href="#func-current-merge-key"><code>current-merge-key</code></a>.</p><p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> are available within the sequence constructor contained by an <a href="#element-merge-action"><code>xsl:merge-action</code></a> element. The values are initially <a title="absent" class="termref" href="#dt-absent">absent</a> during the evaluation of global variables and stylesheet parameters, during the evaluation of the <code>use</code> attribute or contained sequence constructor of <a href="#element-key"><code>xsl:key</code></a>, and during the evaluation of the <code>initial-value</code> attribute of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> attribute of contained sequence constructor of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>. All <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation constructs</a> set the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> to <a title="absent" class="termref" href="#dt-absent">absent</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Taken together, these rules mean that any invocation of <a href="#func-current-merge-group"><code>current-merge-group</code></a> or <a href="#func-current-merge-key"><code>current-merge-key</code></a> that is not lexically scoped by an <a href="#element-merge-action"><code>xsl:merge-action</code></a> element will raise a dynamic error.</p></div><p>When an inner <a href="#element-merge"><code>xsl:merge</code></a> instruction is lexically nested within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element of an outer <a href="#element-merge"><code>xsl:merge</code></a> instruction, any use of <a href="#func-current-merge-group"><code>current-merge-group</code></a> or <a href="#func-current-merge-key"><code>current-merge-key</code></a> that appears within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> of the inner <a href="#element-merge"><code>xsl:merge</code></a> instruction is a reference to the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> or <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> of the inner <a href="#element-merge"><code>xsl:merge</code></a> instruction, while any such reference that appears within the outer <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, but not within the inner <a href="#element-merge-action"><code>xsl:merge-action</code></a>, is a reference to the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> or <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> of the outer <a href="#element-merge"><code>xsl:merge</code></a> instruction. This means, for example, that a reference to the current merge group of the outer <a href="#element-merge"><code>xsl:merge</code></a> can appear in the <code>select</code> attribute of an <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the inner <a href="#element-merge"><code>xsl:merge</code></a>.</p><p>On completion of the evaluation of the <a href="#element-merge-action"><code>xsl:merge-action</code></a> sequence constructor, the current merge group and current merge key revert to their previous values.</p><div class="div3"><h4><a id="func-current-merge-group"></a>15.6.1 <a href="#func-current-merge-group" style="text-decoration: none">fn:current-merge-group</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the group of items currently being processed by an <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:current-merge-group</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$source</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">xs:string?</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-current-merge-group"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:current-merge-group</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$source</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">xs:string?</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> is bound during evaluation of the <a href="#element-merge-action"><code>xsl:merge-action</code></a> child of an <a href="#element-merge"><code>xsl:merge</code></a> instruction. If no <a href="#element-merge-action"><code>xsl:merge-action</code></a> is being evaluated, then the current merge group is <a title="absent" class="termref" href="#dt-absent">absent</a>, in which case the function raises a dynamic error (see below).</p><p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> (if not absent) is a map. It contains the set of items, from all merge inputs, that share a common value for the merge key. This is structured as a map so that the items from each merge source can be identified. The key in the map is the value of the <code>name</code> attribute of the corresponding <a href="#element-merge-source"><code>xsl:merge-source</code></a> element (or an invented name, in its absence), and the associated value is the set of items contributed by that merge group.</p><p>The map itself is not made visible, but this function returns values derived from the map. Specifically, if the map is denoted by <var>$G</var>:</p><ul><li><p><span>If <code>$source</code> is supplied and is non-empty, the</span> function returns the value of the expression <code>if (map:contains($source)) then $G($source) else error()</code>. Informally, if there is an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element whose <code>name</code> attribute matches <code>$source</code>, the function returns the items in the current merge group that are contributed by this merge source; otherwise it raises a dynamic error (see below).</p></li><li><p><span>Otherwise (when <code>$source</code> is absent or empty)</span> the function returns the value of the expression <code>sort(map:keys($G))!$G(.)</code>, where the <code>sort()</code> function sorts the names of <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements into the document order of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements in the stylesheet. Informally, it returns all the items in the current merge group regardless of which merge source they derive from.</p></li></ul><p>Within the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a>, the ordering of items from the input sequences is as follows, in major-to-minor order:</p><ul><li><p>Items are first ordered by the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element that defined the input sequence from which the item was taken; items from <a href="#element-merge-source"><code>xsl:merge-source</code></a><var>A</var> precede items from <a href="#element-merge-source"><code>xsl:merge-source</code></a><var>B</var> if <var>A</var> precedes <var>B</var> in document order within the stylesheet.</p></li><li><p>Items from different input sequences selected by the same <a href="#element-merge-source"><code>xsl:merge-source</code></a> element are then ordered based on the order of the anchor items in the sequence selected by evaluating the <code>select</code> attribute of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element.</p></li><li><p>Finally, duplicate items from the same input sequence retain their order from the input sequence.</p></li></ul><p>Duplicates are not eliminated: for example, if the same node is selected in more than one input sequence, it may appear twice in the current merge group.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTSE3470"><span class="error">[ERR XTSE3470] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>. </p><p><a id="err-XTDE3480"><span class="error">[ERR XTDE3480] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used when the current merge group is <a title="absent" class="termref" href="#dt-absent">absent</a>. The error <span class="verb">may</span> be reported statically if it can be detected statically. </p><p><a id="err-XTDE3490"><span class="error">[ERR XTDE3490] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <code>$source</code> argument of the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function <span>(when supplied)</span> does not match the <code>name</code> attribute of any <a href="#element-merge-source"><code>xsl:merge-source</code></a> element for the current merge operation. The error <span class="verb">may</span> be reported statically if it can be detected statically. </p></dd><dt class="label">Notes</dt><dd><p class="note">Because the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> is cleared by function calls and template calls, the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function only has useful effect when the call appears as a descendant of an <a href="#element-merge-action"><code>xsl:merge-action</code></a> element.</p><p class="note">If an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element has no <code>name</code> attribute, then it is not possible to discover the items in the current merge group that derive specifically from that source, but these items will still be present in the current merge group, and will be included in the result when the function is called with no arguments.</p><p class="note">Like other XSLT extensions to the dynamic evaluation context, the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> is not retained as part of the closure of a function value. This means that the expression <code>current-merge-group#0</code> is valid and returns a function value, but any invocation of this function will fail with a dynamic error <span class="error">[see <a href="#err-XTDE3480">ERR XTDE3480</a>]</span>. </p></dd></dl></div><div class="div3"><h4><a id="func-current-merge-key"></a>15.6.2 <a href="#func-current-merge-key" style="text-decoration: none">fn:current-merge-key</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the merge key of the merge group currently being processed using the <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:current-merge-key</span></code><span class="deltaxml-old" style="background:#FF5555">()</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-old" style="background:#FF5555">xs:anyAtomicType*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-current-merge-key"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:current-merge-key</span></code><span class="deltaxml-new" style="background:#90EE90">()</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:anyAtomicType*</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The evaluation context for XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> includes a component called the <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>, which is a sequence of atomic values. The current merge key is the <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key value</a> shared in common by all the items within the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a>. </p><p>The function <a href="#func-current-merge-key"><code>current-merge-key</code></a> returns the <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>.</p><p>While the <a href="#element-merge-action"><code>xsl:merge-action</code></a> child of an <a href="#element-merge"><code>xsl:merge</code></a> instruction is being evaluated, the <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> will be a single atomic value if there is a single merge key, or a sequence of atomic values if there are multiple merge keys.</p><p>At other times, the current merge key will be <a title="absent" class="termref" href="#dt-absent">absent</a>.</p><p>The <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">merge keys</a> of all items in a group are not necessarily identical. For example, one might be an <code>xs:float</code> while another is a numerically equal <code>xs:decimal</code>. The <a href="#func-current-merge-key"><code>current-merge-key</code></a> function returns the merge key of the first item in the group, after atomization and casting of <code>xs:untypedAtomic</code> values to <code>xs:string</code>.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTSE3500"><span class="error">[ERR XTSE3500] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>. </p><p><a id="err-XTDE3510"><span class="error">[ERR XTDE3510] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used when the current merge key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically. </p></dd><dt class="label">Notes</dt><dd><p class="note">Like other XSLT extensions to the dynamic evaluation context, the <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> is not retained as part of the closure of a function value. This means that the expression <code>current-merge-key#0</code> is valid and returns a function value, but any invocation of this function will fail with a dynamic error <span class="error">[see <a href="#err-XTDE3510">ERR XTDE3510</a>]</span>. </p></dd></dl></div></div><div class="div2"><h3><a id="merge-action"></a>15.7 <a href="#merge-action" style="text-decoration: none">The </a><a href="#element-merge-action"><code>xsl:merge-action</code></a><a href="#merge-action" style="text-decoration: none"> Element</a></h3><p>The <a href="#element-merge-action"><code>xsl:merge-action</code></a> child of an <a href="#element-merge"><code>xsl:merge</code></a> instruction defines the processing to be applied for each distinct <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key value</a> found in the input sequences to the <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p><p class="element-syntax"><a id="element-merge-action"></a><code>&lt;xsl:merge-action&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-action&gt;</code></p><p>The merge key values for each item in an input sequence are calculated based on the corresponding <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements, in the same way as <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> are calculated using a sequence of <a href="#element-sort"><code>xsl:sort</code></a> elements (see <a href="#sorting-process"><i>13.1.1 The Sorting Process</i></a>). If several items from the same or from different input sequences have the same values for all their merge keys (comparing pairwise), then they are considered to form a group. The sequence constructor contained in the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element is evaluated once for each such group of items, and the result of the <a href="#element-merge"><code>xsl:merge</code></a> instruction is the concatenation of the results obtained by processing each group in turn.</p><p>The groups are processed one by one, based on the values of the merge keys for the group. If group <var>G</var> has a set of merge key values <var>M</var>, while group <var>H</var> has a set of merge key values <var>N</var>, then in the result of the <a href="#element-merge"><code>xsl:merge</code></a> instruction, the result of processing group <var>G</var> will precede the result of processing <var>H</var> if and only if <var>M</var> precedes <var>N</var> in the sort order defined by the <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, and <code>data-type</code> attributes of the merge key definitions.</p><p><span>Comparison of merge key values follows the rules for <a href="#element-sort"><code>xsl:sort</code></a> given in <a href="#comparing-sort-keys"><i>13.1.2 Comparing Sort Key Values</i></a>. This means that except for special cases such as empty sequences and NaN</span>, two sets of merge key values are distinct if any corresponding items in the two sets of values do not compare equal under the rules for the XPath <code>eq</code> operator, under the collating rules for the corresponding merge key definition. In rare cases, when considering more than two sets of merge key values, ambiguities may arise because of the non-transitivity of the <code>eq</code> operator when applied across different numeric types. In this situation, the partitioning of items into sets having distinct key values is handled in the same way as for <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (see <a href="#non-transitivity"><i>14.5 Non-Transitivity</i></a>), and is to some extent <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. <span>[XSLT 3.0 Erratum E39, bug 30377].</span></p><p>The <a title="focus" class="termref" href="#dt-focus">focus</a> for evaluation of the sequence constructor contained in the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element is as follows:</p><ul><li><p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the first item in the group being processed, that is <code>current-merge-group()[1]</code></p></li><li><p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of the current group within the sequence of groups (so the first evaluation of <a href="#element-merge-action"><code>xsl:merge-action</code></a> has <code>position()=1</code>, the second has <code>position()=2</code>, and so on).</p></li><li><p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is as follows:</p><ul><li><p>If any of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements within the <a href="#element-merge"><code>xsl:merge</code></a> instruction specifies <code>streamable="yes"</code> (explicitly or implicitly), then absent.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> of a streamable <a href="#element-merge"><code>xsl:merge</code></a>, calling <code>last()</code> throws error <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.</p></div></li><li><p>Otherwise, the number of groups, that is, the number of distinct sets of merge key values. </p></li></ul></li></ul><div class="example"><div class="exampleHeader"><a id="d8e36456"></a><a id="d8e36566"></a>Example: Selective Processing of Merge Inputs</div><p>Consider a situation where there are two merge sources, named <code>"master"</code> and <code>"update"</code>; the master source identifies a single merge input file (the master file), while the update source identifies a set of <var>N</var> update files, perhaps one for each day of the week. The required logic is that if a merge key is present only in the master file, then the corresponding item should be copied to the output; if it is present in a single update file then that item replaces the corresponding item from the master file; if it is present in several update files, then an error is raised. This can be achieved as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">master</span><span class="z">"</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">'master.xml'</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="qname">events</span><span class="step">/</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">key</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">updates</span><span class="z">"</span><span class="z"></span><span class="atn">for-each-source</span><span class="atneq">=</span><span class="z">"</span><span class="av">uri-collection('updates')</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="qname">events</span><span class="step">/</span><span class="qname">event-change</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">affected-key</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">master</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="scx">&gt;</span><span class="txt"> Error: update is present with no matching master record! </span><span class="ez">&lt;/</span><span class="clxsl">xsl:message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">updates</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">master</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">updates</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="numeric">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">updates</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="scx">&gt;</span><span class="txt"> Conflict: multiple updates for the same master record! </span><span class="ez">&lt;/</span><span class="clxsl">xsl:message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Some words of explanation:</p><ul><li><p>Error messages are produced if there is an update element whose key does not correspond to any element in the master source, or if there is more than one update element corresponding to the same master element.</p></li><li><p>In the absence of errors, if there is a single update element then it is copied to the output; if there is none, then the master element is copied.</p></li></ul></div></div><div class="div2"><h3><a id="merge-examples"></a>15.8 <a href="#merge-examples" style="text-decoration: none">Examples of xsl:merge</a></h3><p>Previous sections introduced examples designed to illustrate some specific features of the <a href="#element-merge"><code>xsl:merge</code></a> instruction. This section provides some further examples to illustrate different ways in which the instruction can be used.</p><div class="example"><div class="exampleHeader"><a id="d8e36480"></a><a id="d8e36590"></a>Example: Applying Transactions to a Master File</div><p>This example applies transactions from a transaction file to a master file. Records in the master file for which there is no corresponding transaction are copied unchanged. The transaction file contains instructions to delete, replace, or insert records identified by an ID value. The master file is known to be sorted on the ID value; the transaction file is unsorted.</p><p>Master file document structure:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">data</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">record</span><span class="z"></span><span class="atn">ID</span><span class="atneq">=</span><span class="z">"</span><span class="av">A0001</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">record</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">record</span><span class="z"></span><span class="atn">ID</span><span class="atneq">=</span><span class="z">"</span><span class="av">A0002</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">record</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">record</span><span class="z"></span><span class="atn">ID</span><span class="atneq">=</span><span class="z">"</span><span class="av">A0003</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">record</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">data</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Transaction file document structure:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">transactions</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">update</span><span class="z"></span><span class="atn">record</span><span class="atneq">=</span><span class="z">"</span><span class="av">A0004</span><span class="z">"</span><span class="z"></span><span class="atn">action</span><span class="atneq">=</span><span class="z">"</span><span class="av">insert</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">update</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">update</span><span class="z"></span><span class="atn">record</span><span class="atneq">=</span><span class="z">"</span><span class="av">A0002</span><span class="z">"</span><span class="z"></span><span class="atn">action</span><span class="atneq">=</span><span class="z">"</span><span class="av">delete</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">update</span><span class="z"></span><span class="atn">record</span><span class="atneq">=</span><span class="z">"</span><span class="av">A0003</span><span class="z">"</span><span class="z"></span><span class="atn">action</span><span class="atneq">=</span><span class="z">"</span><span class="av">replace</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">update</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">transactions</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">master</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">master.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="qname">data</span><span class="step">/</span><span class="qname">record</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">ID</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">updates</span><span class="z">"</span><span class="z"></span><span class="atn">sort-before-merge</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">doc</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">transactions.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">update</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">record</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">empty</span><span class="parenthesis">(</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">updates</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">master</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">updates</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">action</span><span class="op">=</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">insert</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">replace</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">record</span><span class="z"></span><span class="atn">ID</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">current-merge-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">updates</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">record</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">updates</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">action</span><span class="op">=</span><span class="op">'</span><span class="literal">delete</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e36492"></a><a id="d8e36602"></a>Example: Merging Two Sequences of Numbers</div><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to determine the union, intersection, or difference of two sequences of numbers (or other atomic values). This code gives the union:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">30</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">20</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">40</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>While this gives the intersection:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:merge</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">30</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-source</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">20</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">40</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-key</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-source</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:merge-action</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="function">current-merge-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">eq</span><span class="whitespace"></span><span class="numeric">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-merge-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge-action</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:merge</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div1"><h2><a id="splitting"></a>16 <a href="#splitting" style="text-decoration: none">Splitting</a></h2><p>Sometimes it is convenient to be able to compute multiple results during a single scan of the input data. For example, a transformation may wish to rename selected elements, and also to output a count of how many elements have been renamed. Traditionally in a functional language this means computing two separate functions of the input sequence, which (in the absence of sophisticated optimization) will result in the input being scanned twice. This is inconsistent with streaming, where the input is only available to be scanned once, and it can also lead to poor performance in non-streaming applications.</p><p>To meet this requirement, XSLT 3.0 introduces the instruction <a href="#element-fork"><code>xsl:fork</code></a>. The content of this instruction is a restricted form of <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and in a formal sense the effect of the instruction is simply to return the result of evaluating the sequence constructor. However, the presence of the instruction affects the analysis of streamability (see <a href="#streamability"><i>19 Streamability</i></a>). In particular, when <a href="#element-fork"><code>xsl:fork</code></a> is used in a context where streaming is required, each independent instruction within the sequence constructor must be streamable, but the analysis assumes that these instructions can all be evaluated during a single pass of the streamed input document.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The semantics of the instruction require a number of result sequences to be computed during a single pass of the input. A processor may interpret this as a request to use multiple threads. However, implementations using a single thread are feasible, and this instruction is not intended primarily as a means for stylesheet authors to express their intentions with regard to multi-threaded execution.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Because multiple results are computed during a single pass of the input, and then concatenated into a single sequence, this instruction will generally involve some buffering of results. The amount of memory used should not exceed that needed to hold the results of the instruction. However, within this principle, implementations may adopt a variety of strategies for evaluation; for example, there may be cases where buffering of the input is more efficient than buffering of output.</p><p>Generally, stylesheet authors indicate that buffering of input is the preferred strategy by using the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> functions, and indicate that buffering of output is preferred by using <a href="#element-fork"><code>xsl:fork</code></a>. However, conformant processors are not constrained in their choice of evaluation strategies.</p></div><p>The content model of the <a href="#element-fork"><code>xsl:fork</code></a> instruction (given that an XSLT 3.0 processor ignores <a href="#element-fallback"><code>xsl:fallback</code></a>) takes two possible forms:</p><ol class="enumar"><li><p>A sequence of <a href="#element-sequence"><code>xsl:sequence</code></a> instructions</p></li><li><p>A single <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction. This will normally use the <code>group-by</code> attribute, because in all other cases the containing <a href="#element-fork"><code>xsl:fork</code></a> instruction has no useful effect.</p></li></ol><p>The first form is appropriate when splitting a single input stream into a fixed number of output streams, known statically: for example, one output stream for credit transactions, a second for debit transactions. The second form is appropriate when the number of output streams depends on the data: for example, one output stream for each distinct city name found in the input data.</p><p>The following section describes the <a href="#element-fork"><code>xsl:fork</code></a> instruction more formally.</p><div class="div2"><h3><a id="fork-instruction"></a>16.1 <a href="#fork-instruction" style="text-decoration: none">The </a><code>xsl:fork</code><a href="#fork-instruction" style="text-decoration: none"> Instruction</a></h3><p class="element-syntax"><a id="element-fork"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:fork&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-fallback">xsl:fallback</a>*, ((<a href="#element-sequence">xsl:sequence</a>, <a href="#element-fallback">xsl:fallback</a>*)* | (<a href="#element-for-each-group">xsl:for-each-group</a>, <a href="#element-fallback">xsl:fallback</a>*))) --&gt;<br>&lt;/xsl:fork&gt;</code></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The content model can be described as follows: there is either a single <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction, or a sequence of zero or more <a href="#element-sequence"><code>xsl:sequence</code></a> instructions; in addition, <a href="#element-fallback"><code>xsl:fallback</code></a> instructions may be added anywhere.</p></div><p>The result of the <a href="#element-fork"><code>xsl:fork</code></a> instruction is the sequence formed by concatenating the results of evaluating each of its contained instructions, in order. That is, the result can be determined by treating the content as a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> and evaluating it as such.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children will be ignored by an XSLT 3.0 processor.</p></div><p>By using the <a href="#element-fork"><code>xsl:fork</code></a> instruction, the stylesheet author is suggesting to the <a title="processor" class="termref" href="#dt-processor">processor</a> that buffering of output is acceptable even though this might use unbounded memory and thus violate the normal expectations of streamable processing</p><p>The presence of an <a href="#element-fork"><code>xsl:fork</code></a> instruction affects the analysis of streamability, as described in <a href="#streamability"><i>19 Streamability</i></a>.</p></div><div class="div2"><h3><a id="splitting-examples"></a>16.2 <a href="#splitting-examples" style="text-decoration: none">Examples of Splitting with Streamed Data</a></h3><p>This section gives examples of how splitting using <a href="#element-fork"><code>xsl:fork</code></a> can be used to enable streaming of input documents in cases where several results need to be computed during a single pass over the input data.</p><div class="example"><div class="exampleHeader"><a id="d8e36613"></a><a id="d8e36723"></a>Example: Splitting a Transaction File into Credits and Debits</div><p>Consider a transaction file that contains a sequence of debits and credits:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">transactions</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">5.60</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">11.20</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">-3.40</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">8.90</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">-1.99</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">transactions</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>where the requirement is to split this into two separate files containing credits and debits respectively.</p><p>This can be achieved in <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> code as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:fork</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">credits.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">credits</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="filter">[</span><span class="axis">@</span><span class="op">value</span><span class="whitespace"></span><span class="qname">&amp;</span><span class="op">gt</span><span class="op">;</span><span class="op">=</span><span class="whitespace"></span><span class="numeric">0</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">credits</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sequence</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">debits.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">debits</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="filter">[</span><span class="axis">@</span><span class="op">value</span><span class="whitespace"></span><span class="qname">&amp;</span><span class="op">lt</span><span class="op">;</span><span class="whitespace"></span><span class="numeric">0</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">debits</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sequence</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fork</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>In the absence of the <a href="#element-fork"><code>xsl:fork</code></a> instruction, this would not be streamable, because the sequence constructor includes two <a title="consuming" class="termref" href="#dt-consuming">consuming</a> instructions. With the addition of the <a href="#element-fork"><code>xsl:fork</code></a> instruction, however, each <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is allowed to make a downwards selection. </p><p>One possible implementation model for this is as follows: a single thread reads the source document, and sends parsing events such as start-element and end-element to two other threads, each of which is writing one of the two result documents. Each of these implements the downwards-selecting path expression using a process that waits until the next <code>transaction</code> start-element event is received; when this event is received, the process examines the <code>@value</code> attribute to determine whether or not this transaction is to be copied; if it is, then all events until the matching <code>transaction</code> end-element event are copied to the serializer for the result document; otherwise, these events are discarded.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e36643"></a><a id="d8e36753"></a>Example: Splitting a Transaction File by Customer Account</div><p>Consider a transaction file that contains a sequence of debits and credits:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">transactions</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">5.60</span><span class="z">"</span><span class="z"></span><span class="atn">account</span><span class="atneq">=</span><span class="z">"</span><span class="av">01826370</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">11.20</span><span class="z">"</span><span class="z"></span><span class="atn">account</span><span class="atneq">=</span><span class="z">"</span><span class="av">92741838</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">-3.40</span><span class="z">"</span><span class="z"></span><span class="atn">account</span><span class="atneq">=</span><span class="z">"</span><span class="av">01826370</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">8.90</span><span class="z">"</span><span class="z"></span><span class="atn">account</span><span class="atneq">=</span><span class="z">"</span><span class="av">92741838</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">-1.99</span><span class="z">"</span><span class="z"></span><span class="atn">account</span><span class="atneq">=</span><span class="z">"</span><span class="av">43861562</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">transactions</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>where the requirement is to split this into a number of separate files, one for each account number found in the input.</p><p>This can be achieved in <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> code as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:fork</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="z">"</span><span class="z"></span><span class="atn">group-by</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">account</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">account</span><span class="op">{</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="av">.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transactions</span><span class="z"></span><span class="atn">account</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">transactions</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fork</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>In the absence of the <a href="#element-fork"><code>xsl:fork</code></a> instruction, this would not be streamable, because in the general case the output of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> with a <code>group-by</code> attribute needs to be buffered. (The streamability rules do not recognize an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> whose body comprises an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction as a special case.) With the addition of the <a href="#element-fork"><code>xsl:fork</code></a> instruction, however, the code becomes guaranteed streamable. </p><p>One possible implementation model for this is as follows: the processor opens a new serializer each time a new account number is encountered in the input, and writes the <code>&lt;transactions&gt;</code> start tag to the serializer. When a <code>transaction</code> element is encountered in the input, it is copied to the relevant serializer, according to the value of the <code>account</code> attribute. At the end of the input, a <code>&lt;transactions&gt;</code> end tag is written to each of the serializers, and each output file is closed.</p><p>In the more general case, where the body of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction contributes output to the principal result document, the output generated by processing each group needs to be buffered in memory. The requirement to use <a href="#element-fork"><code>xsl:fork</code></a> exists so that this use of (potentially unbounded) memory has to be a conscious decision by the stylesheet author.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e36686"></a><a id="d8e36796"></a>Example: Arithmetic using Multiple Child Elements as Operands</div><p>The rules for streamability do not allow two instructions in a sequence constructor to both read child or descendant elements of the context node, which makes it tricky to perform a calculation in which multiple child elements act as operands. This restriction can be avoided by using <a href="#element-fork"><code>xsl:fork</code></a>, as shown below, where each of the two branches of the <a href="#element-fork"><code>xsl:fork</code></a> instruction selects children of the context node.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">order</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">a-streamable-mode</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">price-and-discount</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:decimal+</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:fork</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:decimal</span><span class="parenthesis">(</span><span class="qname">price</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:decimal</span><span class="parenthesis">(</span><span class="qname">discount</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fork</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$price-and-discount</span><span class="filter">[</span><span class="numeric">1</span><span class="filter">]</span><span class="whitespace"></span><span class="op">-</span><span class="whitespace"></span><span class="variable">$price-and-discount</span><span class="filter">[</span><span class="numeric">2</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>A possible implementation strategy here is for events from the XML parser to be sent to two separate agents (perhaps but not necessarily running in different threads), one of which computes <code>xs:decimal(price)</code> and the other <code>xs:decimal(discount)</code>; on completion the results computed by the two agents are appended to the sequence that forms the value of the variable.</p><p>With this strategy, the processor would require sufficient memory to hold the results of evaluating each branch of the fork. If these results (unlike this example) are large, this could defeat the purpose of streaming by requiring large amounts of memory; nevertheless, this code is treated as streamable.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An alternative solution to this requirement is to use map constructors: see <a href="#map-constructors"><i>21.3 Map Constructors</i></a>.</p></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e36708"></a><a id="d8e36818"></a>Example: Deleting Elements, and Counting Deletions</div><p>In this example the input is a narrative document containing <code>note</code> elements at any level of nesting. The requirement is to output a copy of the input document in which (a) the <code>note</code> elements have been removed, and (b) a <code>footnote</code> is added at the end indicating how many <code>note</code> elements have been deleted.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">on-no-match</span><span class="atneq">=</span><span class="z">"</span><span class="av">shallow-copy</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">note</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="op">*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:fork</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sequence</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">footnote</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Removed </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="context">.</span><span class="step">//</span><span class="qname">note</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> note elements.</span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">footnote</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:sequence</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fork</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The <a href="#element-fork"><code>xsl:fork</code></a> instruction contains two independent branches. These can therefore be evaluated in the same pass over the input data. The first branch (the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction) causes everything except the <code>note</code> elements to be copied to the result; the second instruction (the literal result element <code>footnote</code>) outputs a count of the number of descendant <code>note</code> elements.</p><p>Note that although the processing makes a single pass over the input stream, there is some buffering of results required, because the results of the instructions within the <a href="#element-fork"><code>xsl:fork</code></a> instruction need to be concatenated. In this case an intelligent implementation might be able to restrict the buffered data to a single integer.</p><p>In a formal sense, however, the result is exactly the same as if the <a href="#element-fork"><code>xsl:fork</code></a> element were not there.</p><p>An alternative way of solving this example problem would be to count the number of <code>note</code> elements using an accumulator: see <a href="#accumulators"><i>18.2 Accumulators</i></a>.</p></div></div></div><div class="div1"><h2><a id="regular-expressions"></a>17 <a href="#regular-expressions" style="text-decoration: none">Regular Expressions</a></h2><p>The function library for XPath 3.0 defines several functions that make use of regular expressions:</p><ul><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-matches"><code>matches</code></a><sup><small>FO30</small></sup> returns a boolean result that indicates whether or not a string matches a given regular expression.</p></li><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-replace"><code>replace</code></a><sup><small>FO30</small></sup> takes a string as input and returns a string obtained by replacing all substrings that match a given regular expression with a replacement string.</p></li><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-tokenize"><code>tokenize</code></a><sup><small>FO30</small></sup> returns a sequence of strings formed by breaking a supplied input string at any separator that matches a given regular expression.</p></li><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>analyze-string</code></a><sup><small>FO30</small></sup> returns a tree of nodes that effectively add markup to a string indicating the parts of the string that matched the regular expression, as well as its captured groups.</p></li></ul><p>These functions are described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p><p>Supplementing these functions, XSLT provides an instruction <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, which is defined in this section.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction predates the <a href="https://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>analyze-string</code></a><sup><small>FO30</small></sup> function, and provides very similar functionality, though in a different way. The two constructs are not precisely equivalent; for example, <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> allows a regular expression that matches a zero-length string while the <a href="https://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>analyze-string</code></a><sup><small>FO30</small></sup> function does not. The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction (via the use of <a href="#func-regex-group"><code>regex-group</code></a>) provides information about the value of captured substrings; the <a href="https://www.w3.org/TR/xpath-functions-30/#func-analyze-string"><code>analyze-string</code></a><sup><small>FO30</small></sup> function additionally provides information about the position of the captured substrings within the original string.</p></div><p>The regular expressions used by this instruction, and the flags that control the interpretation of these regular expressions, <span class="verb">must</span> conform to the syntax defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> (see <a href="https://qt4cg.org/specifications/xpath-functions-40/#regex-syntax">Section 5.6.1 Regular expression syntax</a><sup><small>FO40</small></sup>), which is itself based on the syntax defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p><div class="div2"><h3><a id="analyze-string"></a>17.1 <a href="#analyze-string" style="text-decoration: none">The </a><code>xsl:analyze-string</code><a href="#analyze-string" style="text-decoration: none"> Instruction</a></h3><p class="element-syntax"><a id="element-analyze-string"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:analyze-string<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;<b>regex</b> = { <var>string</var> }<br>&nbsp;&nbsp;flags? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-matching-substring">xsl:matching-substring</a>?, <a href="#element-non-matching-substring">xsl:non-matching-substring</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:analyze-string&gt;</code></p><p class="element-syntax"><a id="element-matching-substring"></a><code>&lt;xsl:matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:matching-substring&gt;</code></p><p class="element-syntax"><a id="element-non-matching-substring"></a><code>&lt;xsl:non-matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:non-matching-substring&gt;</code></p><p><span style="display: none;" class="delete_version">The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction takes as input a string (the result of evaluating the expression in the <code>select</code> attribute) and a regular expression (the effective value of the <code>regex</code> attribute).</span><span style="display: none;" class="add_version">The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction takes as input a string (the result of evaluating the expression in the <code>select</code> attribute) and a regular expression (the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute).</span><span class="modify_version">The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction takes as input a string (the result of evaluating the expression in the <code>select</code> attribute) and a regular expression (the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>regex</code> attribute).</span></p><p>If the result of evaluating the <code>select</code> expression is an empty sequence, it is treated as a zero-length string. If the value is not a string, it is converted to a string by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p><p>The <code>flags</code> attribute may be used to control the interpretation of the regular expression. If the attribute is omitted, the effect is the same as supplying a zero-length string. This is interpreted in the same way as the <code>$flags</code> attribute of the functions <a href="https://www.w3.org/TR/xpath-functions-30/#func-matches"><code>matches</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-replace"><code>replace</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-tokenize"><code>tokenize</code></a><sup><small>FO30</small></sup>. Specifically, if it contains the letter <code>m</code>, the match operates in multiline mode. If it contains the letter <code>s</code>, it operates in dot-all mode. If it contains the letter <code>i</code>, it operates in case-insensitive mode. If it contains the letter <code>x</code>, then whitespace within the regular expression is ignored. For more detailed specifications of these modes, see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> (<a href="https://qt4cg.org/specifications/xpath-functions-40/#flags">Section 5.6.2 Flags</a><sup><small>FO40</small></sup>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because the <code>regex</code> attribute is an attribute value template, curly brackets within the regular expression must be doubled. For example, to match a sequence of one to five characters, write <code>regex=".{{1,5}}"</code>. For regular expressions containing many curly brackets it may be more convenient to use a notation such as <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or to use a variable.</p></div><p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction may have two child elements: <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>. Both elements are optional, and neither may appear more than once. At least one of them must be present. If both are present, the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> element must come first.</p><p>The content of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction must take one of the following forms:</p><ol class="enumar"><li><p>A single <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction, followed by zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p></li><li><p>A single <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction, followed by zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p></li><li><p>A single <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction, followed by a single <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction, followed by zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p></li></ol><p><a id="err-XTSE1130"><span class="error">[ERR XTSE1130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction contains neither an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> nor an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element. </p><p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> elements among the children of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction are ignored by an XSLT 2.0 or 3.0 processor, but allow fallback behavior to be defined when the stylesheet is used with an XSLT 1.0 processor operating with forwards-compatible behavior.</p><p>This instruction is designed to process all the non-overlapping substrings of the input string that match the regular expression supplied.</p><p><a id="err-XTDE1140"><span class="error">[ERR XTDE1140] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute does not conform to the <span class="verb">required</span> syntax for regular expressions, as specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the regular expression is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> signal the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><p><a id="err-XTDE1145"><span class="error">[ERR XTDE1145] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>flags</code> attribute has a value other than the values defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the value of the attribute is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> signal the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><p>To explain the behavior of the instruction it is useful to consider an input string of length <var>N</var> characters as having <var>N+1</var> inter-character positions, including one just before the first character and one just after the last. Each of these positions is a possible position for testing whether the regular expression matches. These positions are numbered from zero to <code>N</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <b>character</b>, here as elsewhere in this specification, means a Unicode codepoint. When strings are held in decomposed form, the multiple codepoints representing a composite character are considered to be multiple characters. A codepoint greater than 65535 is considered as one character, not as a surrogate pair.</p></div><p>The processor starts by setting the current position to position zero, and the current non-matching substring to a zero-length string. It then does the following repeatedly:</p><ol class="enumar"><li><p>Test whether the regular expression matches at the current position.</p></li><li><p>If there is a match:</p><ol class="enumla"><li><p>If the current non-matching substring has length greater than zero, evaluate the <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> sequence constructor with the current non-matching substring as the context item.</p></li><li><p>Reset the current non-matching substring to a zero-length string.</p></li><li><p>Evaluate the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> sequence constructor with the matching substring as the context item.</p></li><li><p>Do the appropriate one of the following:</p><ol class="enumlr"><li><p>If the matching substring is non-zero length, set the current position to coincide with the end of the matching substring, exit, and repeat.</p></li><li><p>If the matching substring is zero length and the current position is at the end of the input string, exit.</p></li><li><p>If the matching substring is zero length and the current position is not at the end of the input string, add the character that immediately follows the current position to the current non-matching substring, set the current position to the position immediately after this character, exit, and repeat.</p></li></ol></li></ol></li><li><p>If there is no match:</p><ol class="enumla"><li><p>If the current position is the last position (that is, just after the last character):</p><ol class="enumlr"><li><p>If the current non-matching substring has length greater than zero, evaluate the <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> sequence constructor with the current non-matching substring as the context item.</p></li><li><p>Exit.</p></li></ol></li><li><p>Otherwise, add the character at the current position to the current non-matching substring, increment the current position, and repeat.</p></li></ol></li></ol><p>When the matcher is looking for a match at a particular starting position and there are several alternatives within the regular expression that match at this position in the input string, then the match that is chosen is the first alternative that matches. For example, if the input string is <code>The quick brown fox jumps</code> and the regular expression is <code>jump|jumps</code>, then the match that is chosen is <code>jump</code>. </p><p>The input string is thus partitioned into a sequence of substrings, some of which match the regular expression, others which do not match it. Each non-matching substring will contain at least one character, but a matching substring may be zero-length. This sequence of substrings is processed using the instructions within the contained <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> elements. A matching substring is processed using the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> element, a non-matching substring using the <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element. Each of these elements takes a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as its content. If the element is absent, the effect is the same as if it were present with empty content. In processing each substring, the contents of the substring will be the <a title="context item" class="termref" href="#dt-context-item">context item</a> (as a value of type <code>xs:string</code>); the position of the substring within the sequence of matching and non-matching substrings will be the <a title="context position" class="termref" href="#dt-context-position">context position</a>; and the number of matching and non-matching substrings will be the <a title="context size" class="termref" href="#dt-context-size">context size</a>.</p></div><div class="div2"><h3><a id="func-regex-group"></a>17.2 <a href="#func-regex-group" style="text-decoration: none">fn:regex-group</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns the string captured by a parenthesized subexpression of the regular expression used during evaluation of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:regex-group</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$number</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">xs:integer</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:string</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-regex-group"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:regex-group</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$number</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">xs:integer</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-captured-substrings" title="current captured substrings"></a>While the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active, a set of <b>current captured substrings</b> is available, corresponding to the parenthesized subexpressions of the regular expression.<span class="definition">]</span> These captured substrings are accessible using the function <a href="#func-regex-group"><code>regex-group</code></a>. This function takes an integer argument to identify the group, and returns a string representing the captured substring.</p><p>The <var>N</var>th captured substring (where <var>N</var> &gt; 0) is the string matched by the subexpression contained by the <var>N</var>th left parenthesis in the regex, excluding any non-capturing groups, which are written as <code>(?:xxx)</code>. The zeroth captured substring is the string that matches the entire regex. This means that the value of <code>regex-group(0)</code> is initially the same as the value of <code>.</code> (dot).</p><p>The function returns the zero-length string if there is no captured substring with the relevant number. This can occur for a number of reasons:</p><ol class="enumar"><li><p>The number is negative.</p></li><li><p>The regular expression does not contain a parenthesized subexpression with the given number.</p></li><li><p>The parenthesized subexpression exists, and did not match any part of the input string.</p></li><li><p>The parenthesized subexpression exists, and matched a zero-length substring of the input string.</p></li></ol><p>The set of captured substrings is a context variable with dynamic scope. It is initially an empty sequence. During the evaluation of an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction it is set to the sequence of matched substrings for that regex match. During the evaluation of an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction or a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> or a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> it is set to an empty sequence. On completion of an instruction that changes the value, the variable reverts to its previous value.</p><p>The value of the <a title="current captured substrings" class="termref" href="#dt-current-captured-substrings">current captured substrings</a> is unaffected through calls of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>, or by expansion of named <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a>.</p></dd></dl></div><div class="div2"><h3><a id="regex-examples"></a>17.3 <a href="#regex-examples" style="text-decoration: none">Examples of Regular Expression Matching</a></h3><div class="example"><div class="exampleHeader"><a id="d8e37196"></a><a id="d8e37306"></a>Example: Replacing Characters by Elements</div><p>Problem: replace all newline characters in the <code>abstract</code> element by empty <code>br</code> elements:</p><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:analyze-string</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">abstract</span><span class="z">"</span><span class="z"></span><span class="atn">regex</span><span class="atneq">=</span><span class="z">"</span><span class="av">\n</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:matching-substring</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">br</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:matching-substring</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:non-matching-substring</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:non-matching-substring</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:analyze-string</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37207"></a><a id="d8e37317"></a>Example: Recognizing non-XML Markup Structure</div><p>Problem: replace all occurrences of <code>[...]</code> in the <code>body</code> by <code>cite</code> elements, retaining the content between the square brackets as the content of the new element.</p><p>Solution:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:analyze-string</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">body</span><span class="z">"</span><span class="z"></span><span class="atn">regex</span><span class="atneq">=</span><span class="z">"</span><span class="av">\[(.*?)\]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:matching-substring</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">cite</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">regex-group</span><span class="parenthesis">(</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">cite</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:matching-substring</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:non-matching-substring</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:non-matching-substring</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:analyze-string</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Note that this simple approach fails if the <code>body</code> element contains markup that needs to be retained. In this case it is necessary to apply the regular expression processing to each text node individually. If the <code>[...]</code> constructs span multiple text nodes (for example, because there are elements within the square brackets) then it probably becomes necessary to make two or more passes over the data.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37226"></a><a id="d8e37336"></a>Example: Parsing a Date</div><p>Problem: the input string contains a date such as <code>23 March 2002</code>. Convert it to the form <code>2002-03-23</code>.</p><p>Solution (with no error handling if the input format is incorrect):</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">months</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">January</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">February</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">March</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="context">..</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:analyze-string</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">normalize-space</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">regex</span><span class="atneq">=</span><span class="z">"</span><span class="av">([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:matching-substring</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="function">regex-group</span><span class="parenthesis">(</span><span class="numeric">3</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">0001</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">-</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="function">index-of</span><span class="parenthesis">(</span><span class="variable">$months</span><span class="op">,</span><span class="whitespace"></span><span class="function">regex-group</span><span class="parenthesis">(</span><span class="numeric">2</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">01</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">-</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:number</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="function">regex-group</span><span class="parenthesis">(</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">01</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:matching-substring</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:analyze-string</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Note the use of <code>normalize-space</code> to simplify the work done by the regular expression, and the use of doubled curly brackets because the <code>regex</code> attribute is an attribute value template.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37243"></a><a id="d8e37353"></a>Example: Matching Zero-Length Strings</div><p>This example removes all empty and whitespace-only lines from a file.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:analyze-string</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">unparsed-text</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">in.txt</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">regex</span><span class="atneq">=</span><span class="z">"</span><span class="av">^[\t ]*$</span><span class="z">"</span><span class="z"></span><span class="atn">flags</span><span class="atneq">=</span><span class="z">"</span><span class="av">m</span><span class="z">"</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:non-matching-substring</span><span class="scx">&gt;</span><span class="op">{</span><span class="context">.</span><span class="op">}</span><span class="ez">&lt;/</span><span class="clxsl">xsl:non-matching-substring</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:analyze-string</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37248"></a><a id="d8e37358"></a>Example: Parsing comma-separated values</div><p>There are many variants of CSV formats. This example is designed to handle input where:</p><ul><li><p>Each record occupies one line.</p></li><li><p>Fields are separated by commas.</p></li><li><p>Quotation marks around a field are optional, unless the field contains a comma or quotation mark, in which case they are mandatory.</p></li><li><p>A quotation mark within the value of a field is represented by a pair of two adjacent quotation marks.</p></li></ul><p>For example, the input record:</p><div class="exampleInner"><pre>Ten Thousand,10000,,"10,000","It's ""10 Grand"", mister",10K</pre></div><p>contains six fields, specifically:</p><ul><li><p>Ten Thousand</p></li><li><p>10000</p></li><li><p>&lt;zero-length-string&gt;</p></li><li><p>10,000</p></li><li><p>It's "10 Grand", mister</p></li><li><p>10K</p></li></ul><p>The following code parses such CSV input into an XML structure containing <code>row</code> and <code>col</code> elements:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">unparsed-text-lines</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">in.csv</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">expand-text</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">row</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:analyze-string</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">regex</span><span class="atneq">=</span><span class="z">'</span><span class="av">(?:^|,)(?:"((?:[^"]|"")*)"|([^",]*))</span><span class="z">'</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:matching-substring</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">col</span><span class="scx">&gt;</span><span class="op">{</span><span class="function">replace</span><span class="parenthesis">(</span><span class="function">regex-group</span><span class="parenthesis">(</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">""</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">"</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">||</span><span class="function">regex-group</span><span class="parenthesis">(</span><span class="numeric">2</span><span class="parenthesis">)</span><span class="op">}</span><span class="ez">&lt;/</span><span class="cl">col</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:matching-substring</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:analyze-string</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">row</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Note that because this regular expression matches a zero-length string, it is not permitted in XSLT 2.0.</p></div></div></div><div class="div1"><h2><a id="streaming"></a>18 <a href="#streaming" style="text-decoration: none">Streaming</a></h2><p>XSLT 3.0 introduces a number of constructs that are specifically designed to enable streamed applications to be written, but which are also useful in their own right; it also includes some features that are very specialized to streaming.</p><div class="div2"><h3><a id="source-document-instruction"></a>18.1 <a href="#source-document-instruction" style="text-decoration: none">The </a><code>xsl:source-document</code><a href="#source-document-instruction" style="text-decoration: none"> Instruction</a></h3><p class="element-syntax"><a id="element-source-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:source-document<br>&nbsp;&nbsp;<b>href</b> = { <var>uri</var> }<br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:source-document&gt;</code></p><p>The <a href="#element-source-document"><code>xsl:source-document</code></a> instruction reads a source document whose URI is supplied, and processes the content of the document by evaluating the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The <code>streamable</code> attribute (default <code>"no"</code>) allows streamed processing to be requested.</p><p>For example, if a document represents a book holding a sequence of chapters, then the following code can be used to split the book into multiple XML files, one per chapter, without allocating memory to hold the entire book in memory at one time:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">book.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">book</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">chapter</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">chapter</span><span class="op">{</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="av">.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>In earlier drafts of this specification the <a href="#element-source-document"><code>xsl:source-document</code></a> element was named <code>xsl:stream</code>. The instruction has been generalised to handle both streamed and unstreamed input.</p></div><p>The document to be read is determined by the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>href</code> attribute (which is defined as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>). This <span class="verb">must</span> be a valid URI reference. If it is an absolute URI reference, it is used as is; if it is a relative URI reference, it is made absolute by resolving it against the base URI of the <a href="#element-source-document"><code>xsl:source-document</code></a> element. The process of obtaining a document node given a URI is the same as for the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function. However, unlike the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function, the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction offers no guarantee that the resulting document will be stable (that is, that multiple calls specifying the same URI will return the same document).</p><p>Specifically, if an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is evaluated several times (or if different <a href="#element-source-document"><code>xsl:source-document</code></a> instructions are evaluated) with the same URI (after making it absolute) as the value of the <code>href</code> attribute, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether the same nodes or different nodes are returned on each occasion; it is also possible that the actual document content will be different. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A different node will necessarily be returned if there are differences in attributes such as <code>validation</code>, <code>type</code>, <code>streamable</code>, or <code>use-accumulators</code>, or if the calls are in different <a title="package" class="termref" href="#dt-package">packages</a> with variations in the rules for whitespace stripping or stripping of type annotations.</p></div><p>The result of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is the same as the result of the following (non-streaming) process:</p><ol class="enumar"><li><p>The source document is read from the supplied URI and parsed to form a tree of nodes in the XDM data model.</p></li><li><p>The contained sequence constructor is evaluated with the root node of this tree as the context item, and with the context position and context size set to one; and the resulting sequence is returned as the result of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction.</p></li></ol><p>The <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> if both the following conditions are satisfied:</p><ol class="enumar"><li><p>It is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>, by specifying <code>streamable="yes"</code>.</p></li><li><p>the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, as assessed using the streamability analysis in <a href="#streamability"><i>19 Streamability</i></a>. The consequences of being or not being guaranteed streamable depend on the processor conformance level, and are explained in <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>.</p></li></ol><p>The <code>use-accumulators</code> attribute defines the set of accumulators that are applicable to the document, as explained in <a href="#applicability-of-accumulators"><i>18.2.2 Applicability of Accumulators</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The following notes apply specifically to streamed processing.</p><p>The rules for <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed streamability</a> ensure that the sequence constructor (and therefore the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction) cannot return any nodes from the <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a>. For example, it cannot contain the instruction <code>&lt;xsl:sequence select="//chapter"/&gt;</code>. If nodes from this document are to be returned, they must first be copied, for example by using the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction or by calling the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> functions.</p><p>Because the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction cannot (if it satisfies the rules for guaranteed streamability) return nodes from the streamed document, any nodes it does return will be conventional (unstreamed) nodes that can be processed without restriction. For example, if <a href="#element-source-document"><code>xsl:source-document</code></a> is invoked within a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a><code>f:firstChapter</code>, and the sequence constructor consists of the instruction <code>&lt;xsl:copy-of select="//chapter"/&gt;</code>, then the calling code can manipulate the resulting <code>chapter</code> elements as ordinary trees rooted at parentless element nodes.</p><p>If the sequence constructor in an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction were to return nodes from the document for which streaming has been requested, the instruction would not be guaranteed streamable. Processors which support the streaming feature would then not be required to process it in a streaming manner, and this specification imposes no restrictions on the processing of the nodes returned. (The ability of a streaming processor to handle such stylesheets in a streaming manner might, of course, depend on how the nodes returned are processed, but those details are out of scope for this specification.) </p></div><div class="div3"><h4><a id="source-document-validation"></a>18.1.1 <a href="#source-document-validation" style="text-decoration: none">Validation of Source Documents</a></h4><p>The <code>validation</code> and <code>type</code> attributes of <a href="#element-source-document"><code>xsl:source-document</code></a> may be used to control schema validation of the input document. They have the same effect as the corresponding attributes of the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction when applied to a document node, except that when <code>streamable="yes"</code> is specified, the copy that is produced is itself a streamed document. The process is described in more detail in <a href="#validating-document-nodes"><i>26.4.2 Validating Document Nodes</i></a>.</p><p>These two attributes are both optional, and if one is specified then the other <span class="verb">must</span> be omitted (<span class="error">[see <a href="#err-XTSE1505">ERR XTSE1505</a>]</span>).</p><p>The presence of a <code>validation</code> or <code>type</code> attribute on an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction causes any <code>input-type-annotations</code> attribute to have no effect on any document read using that instruction.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In effect, setting <code>validation</code> to <code>strict</code> or <code>lax</code>, or supplying the <code>type</code> attribute, requests document-level validation of the input as it is read. Setting <code>validation="preserve"</code> indicates that if the incoming document contains type annotations (for example, produced by validating the output of a previous step in a streaming pipeline) then they should be retained, while the value <code>strip</code> indicates that any such type annotations should be dropped.</p><p>It is a consequence of the way validation is defined in XSD that the type annotation of an element node can be determined during the processing of its start tag, although the actual validity of the element is not known until the end tag is encountered. When validation is requested, a streamed document should not present data to the stylesheet except to the extent that such data could form the leading part of a valid document. If the document proves to be invalid, the processor should not pass invalid data to the stylesheet to be processed, but should immediately signal the appropriate error. For the purposes of <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a>, this error can only be caught at the level of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction that initiated validation, not at a finer level. If validation errors are caught in this way, any output that has been computed up to the point of the error is not added to the final result tree; the mechanisms to achieve this may use memory, which may reduce the efficacy of streaming.</p><p>The analysis of guaranteed streamability (see <a href="#streamability"><i>19 Streamability</i></a>) takes no account of information that might be obtained from a schema-aware static analysis of the stylesheet. Implementations may, however, be able to use streaming strategies for stylesheets that are not guaranteed-streamable, by taking advantage of such information. For example, an implementation might be able to treat the expression <code>.//title</code> as <a title="striding" class="termref" href="#dt-striding">striding</a> rather than <a title="crawling" class="termref" href="#dt-crawling">crawling</a> if it can establish from knowledge of the schema that two <code>title</code> elements will never be nested one inside the other.</p></div></div><div class="div3"><h4><a id="stream-examples"></a>18.1.2 <a href="#stream-examples" style="text-decoration: none">Examples of </a><code>xsl:source-document</code></h4><p>The <a href="#element-source-document"><code>xsl:source-document</code></a> instruction can be used to initiate processing of a document using streaming with a variety of coding styles, illustrated in the examples below.</p><div class="example"><div class="exampleHeader"><a id="d8e37541"></a><a id="d8e37650"></a>Example: Using <a href="#element-source-document"><code>xsl:source-document</code></a> with Aggregate Functions</div><p>The following example computes the number of transactions in a transaction file</p><p>Input:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">transactions</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">12.51</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">transaction</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.99</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">transactions</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Stylesheet code:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">count</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">count</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Result:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">count</span><span class="scx">&gt;</span><span class="txt">2</span><span class="ez">&lt;/</span><span class="cl">count</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Analysis:</p><ol class="enumar"><li><p>The literal result element <code>count</code> has the same sweep as the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction.</p></li><li><p>The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction has the same sweep as its <code>select</code> expression.</p></li><li><p>The call to <code>count</code> has the same sweep as its argument.</p></li><li><p>The argument to <code>count</code> is a <code>RelativePathExpr</code>. Under the rules in <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a>, this expression is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. The call on <code>count</code> is therefore <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. </p></li><li><p>The entire body of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is therefore <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol><p>The following example computes the highest-value transaction in the same input file:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">maxValue</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">max</span><span class="parenthesis">(</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="step">/</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">maxValue</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Result:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">maxValue</span><span class="scx">&gt;</span><span class="txt">12.51</span><span class="ez">&lt;/</span><span class="cl">maxValue</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Analysis:</p><ol class="enumar"><li><p>The literal result element <code>maxValue</code> has the same sweep as the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction.</p></li><li><p>The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction has the same sweep as its <code>select</code> expression.</p></li><li><p>The call to <code>max</code> has the same sweep as its argument.</p></li><li><p>The argument to <code>max</code> is a <code>RelativePathExpr</code> whose two operands are the <code>RelativePathExpr</code><code>transactions/transaction</code> and the <code>AxisStep</code><code>@value</code>. The left-hand operand <code>transactions/transaction</code> has <a title="striding" class="termref" href="#dt-striding">striding</a><a title="posture" class="termref" href="#dt-posture">posture</a>. The right-hand operand <code>@value</code>, given that <span>the context posture is striding</span>, is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. The <code>RelativePathExpr</code> argument to <code>max</code> is therefore consuming. <span>[XSLT 3.0 Erratum E9, bug 30130].</span></p></li><li><p>The entire body of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is therefore <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol><p>To compute both the count and the maximum value in a single pass over the input, several approaches are possible. The simplest is to use maps (map constructors are exempt from the usual rule that multiple downward selections are not allowed):</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">tally</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="whitespace"></span><span class="op">'</span><span class="property">count</span><span class="op">'</span><span class="op">:</span><span class="whitespace"></span><span class="function">count</span><span class="parenthesis">(</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="property">max</span><span class="op">'</span><span class="op">:</span><span class="whitespace"></span><span class="function">max</span><span class="parenthesis">(</span><span class="qname">transactions</span><span class="step">/</span><span class="qname">transaction</span><span class="step">/</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">value</span><span class="z"></span><span class="atn">count</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">$tally</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">count</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">max</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">$tally</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">max</span><span class="op">'</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Other options include the use of <a href="#element-fork"><code>xsl:fork</code></a>, or multiple <a href="#element-accumulator"><code>xsl:accumulator</code></a> declarations, one for each value to be computed.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37686"></a><a id="d8e37795"></a>Example: Using <a href="#element-source-document"><code>xsl:source-document</code></a> with <a href="#element-for-each"><code>xsl:for-each</code></a> to Process a Collection of Input Documents </div><p>This example displays a list of the chapter titles extracted from each book in a collection of books.</p><p>Each input document is assumed to have a structure such as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">book</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">number-of-pages</span><span class="atneq">=</span><span class="z">"</span><span class="av">18</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The first chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">number-of-pages</span><span class="atneq">=</span><span class="z">"</span><span class="av">15</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The second chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">number-of-pages</span><span class="atneq">=</span><span class="z">"</span><span class="av">12</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The third chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">book</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Stylesheet code:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">chapter-titles</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">uri-collection</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">books</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="context">.</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">book</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">chapter</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">title</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">chapter-titles</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">chapter-titles</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The first chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The second chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The first chapter of book B</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter-titles</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This example uses the function <a href="https://www.w3.org/TR/xpath-functions-30/#func-uri-collection"><code>uri-collection</code></a><sup><small>FO30</small></sup> to obtain the document URIs of all the documents in a collection, so that each one can be processed in turn using <a href="#element-source-document"><code>xsl:source-document</code></a>.</p></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37710"></a><a id="d8e37819"></a>Example: Using <a href="#element-source-document"><code>xsl:source-document</code></a> with <a href="#element-iterate"><code>xsl:iterate</code></a></div><p>This example assumes that the input is a book with multiple chapters, as shown in the previous example, with the page count for each chapter given as an attribute of the chapter. The transformation determines the starting page number for each chapter by accumulating the page counts for previous chapters, and rounding up to an odd number if necessary.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">chapter-start-page</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">book.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">book</span><span class="step">/</span><span class="qname">chapter</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">start-page</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">title</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="qname">title</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">start-page</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="variable">$start-page</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">start-page</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$start-page</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="axis">@</span><span class="qname">number-of-pages</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">number-of-pages</span><span class="whitespace"></span><span class="op">mod</span><span class="whitespace"></span><span class="numeric">2</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">chapter-start-page</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">chapter-start-page</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">title</span><span class="atneq">=</span><span class="z">"</span><span class="av">The first chapter of book A</span><span class="z">"</span><span class="z"></span><span class="atn">start-page</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">title</span><span class="atneq">=</span><span class="z">"</span><span class="av">The second chapter of book A</span><span class="z">"</span><span class="z"></span><span class="atn">start-page</span><span class="atneq">=</span><span class="z">"</span><span class="av">19</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">title</span><span class="atneq">=</span><span class="z">"</span><span class="av">The third chapter of book A</span><span class="z">"</span><span class="z"></span><span class="atn">start-page</span><span class="atneq">=</span><span class="z">"</span><span class="av">35</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter-start-page</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37723"></a><a id="d8e37832"></a>Example: Using <a href="#element-source-document"><code>xsl:source-document</code></a> with <a href="#element-for-each-group"><code>xsl:for-each-group</code></a></div><p>This example assumes that the input is a book with multiple chapters, and that each chapter belongs to a part, which is present as an attribute of the chapter (for example, chapters 1-4 might constitute Part 1, the next three chapters forming Part 2, and so on):</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">book</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">part</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The first chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">part</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The second chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">part</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The fifth chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">book</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The transformation copies the full text of the chapters, creating an extra level of hierarchy for the parts.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">book</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">book.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">book</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">chapter</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="function">data</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">part</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">part</span><span class="z"></span><span class="atn">number</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">part</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">book</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">book</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">part</span><span class="z"></span><span class="atn">number</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">part</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The first chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">part</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The second chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">part</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">part</span><span class="z"></span><span class="atn">number</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">chapter</span><span class="z"></span><span class="atn">part</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">The fifth chapter of book A</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">chapter</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">part</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">book</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e37739"></a><a id="d8e37848"></a>Example: Using <a href="#element-source-document"><code>xsl:source-document</code></a> with <a href="#element-apply-templates"><code>xsl:apply-templates</code></a></div><p>This example copies an XML document while deleting all the <code>ednote</code> elements at any level of the tree, together with their descendants. This example is a complete stylesheet, which is intended to be evaluated by nominating <code>main</code> as the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a>. The use of <code>on-no-match="deep-copy"</code> in the <a href="#element-mode"><code>xsl:mode</code></a> declaration means that the built-in template rule copies nodes unchanged, except where overridden by a user-defined template rule.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:transform</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">delete-ednotes</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">on-no-match</span><span class="atneq">=</span><span class="z">"</span><span class="av">shallow-copy</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">main</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">book.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">delete-ednotes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">ednote</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">delete-ednotes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:transform</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Additional template rules could be added to process other elements and attributes in the same pass through the data: for example, to modify the value of a <code>last-updated</code> attribute (wherever it appears) to the current date and time, the following rule suffices:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">last-updated</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">delete-ednotes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:attribute</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">last-updated</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-dateTime</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div3"><h4><a id="func-stream-available"></a>18.1.3 <a href="#func-stream-available" style="text-decoration: none">fn:stream-available</a></h4><dl><dt class="label">Summary</dt><dd><p>Determines, as far as possible, whether a document is available for streamed processing using <a href="#element-source-document"><code>xsl:source-document</code></a>.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:stream-available</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$uri</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">xs:string?</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:boolean</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-stream-available"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:stream-available</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$uri</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">xs:string?</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. It depends on available documents. </p></dd><dt class="label">Rules</dt><dd><p>The intent of the <a href="#func-stream-available"><code>stream-available</code></a> function is to allow a stylesheet author to determine, before calling <a href="#element-source-document"><code>xsl:source-document</code></a> with <code>streamable="yes"</code> and with a particular URI as the value of its <code>href</code> attribute, whether a document is available at that location for streamed processing.</p><p>If the <code>$uri</code> argument is an empty sequence then the function returns <code>false</code>.</p><p>If the function returns <code>true</code> then the caller can conclude that the following conditions are true:</p><ol class="enumar"><li><p>The supplied URI is valid;</p></li><li><p>A resource can be retrieved at that URI;</p></li><li><p>An XML representation of the resource can be delivered, which is well-formed at least to the extent that some initial sequence of octets can be decoded into characters and matched against the production:</p><p><code>prolog (EmptyElemTag | STag )</code></p><p>as defined in the XML 1.0 or XML 1.1 Recommendation.</p><div class="note"><p class="prefix"><b>Note:</b></p>That is, the XML is well-formed at least as far as the end of the first element start tag; to establish this, a parser will typically retrieve any external entities referenced in the Doctype declaration or DTD.</div></li></ol><p>If the function returns <code>false</code>, the caller can conclude that either one of the above conditions is not satisfied, or the processor detected some other condition that would prevent a call on <a href="#element-source-document"><code>xsl:source-document</code></a> with <code>streamable="yes"</code> executing successfully.</p><p>Like <a href="#element-source-document"><code>xsl:source-document</code></a> itself, the function is not deterministic, which means that multiple calls during the execution of a stylesheet will not necessarily return the same result. The caller cannot make any inferences about the point in time at which the input conditions for <a href="#func-stream-available"><code>stream-available</code></a> are present, and in particular there is no guarantee that because <a href="#func-stream-available"><code>stream-available</code></a> returns true, <a href="#element-source-document"><code>xsl:source-document</code></a> will necessarily succeed.</p><p>The value of the <code>$uri</code> argument <span class="verb">must</span> be a URI in the form of a string. If it is a relative URI, it is resolved relative to the static base URI of the function call.</p></dd><dt class="label">Error Conditions</dt><dd><p>If the URI is invalid, such that a call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc-available"><code>doc-available</code></a><sup><small>FO30</small></sup> would signal an error, then <a href="#func-stream-available"><code>stream-available</code></a> signals the same error: <a href="https://www.w3.org/TR/xpath-functions-30/#ERRFODC0005" title="FODC0005"><span class="error">[ERR FODC0005] </span></a><sup><small>FO30</small></sup>.</p></dd></dl></div></div><div class="div2"><h3><a id="accumulators"></a>18.2 <a href="#accumulators" style="text-decoration: none">Accumulators</a></h3><p>Accumulators are introduced in XSLT 3.0 to enable data that is read during streamed processing of a document to be accumulated, processed or retained for later use. However, they may equally be used with non-streamed processing.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-accumulator" title="accumulator"></a>An <b>accumulator</b> defines a series of values associated with the nodes of the tree. If an accumulator is applicable to a particular tree, then for each node in the tree, other than attribute and namespace nodes, there will be two values available, called the pre-descent and post-descent values. These two values are available via a pair of functions, <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>.<span class="definition">]</span></p><p>There are two ways the values of an accumulator can be established for a given tree: they can be computed by evaluating the rules appearing in the <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration, or they can be copied from the corresponding nodes in a different tree. The second approach (copying the values) is available via the <a href="#func-snapshot"><code>snapshot</code></a> and <a href="#func-copy-of"><code>copy-of</code></a> functions, or by use of the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction specifying <code>copy-accumulators="yes"</code>. Accumulator values are also copied during the implicit invocation of the snapshot function performed by the <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Accumulators can apply to trees rooted at any kind of node. But because they are most often applied to trees rooted at a document node, this section sometimes refers to the “document” to which an accumulator applies; use of this term should be taken to include all trees whether or not they are rooted at a document node.</p><p>Accumulators can apply to trees rooted at nodes (such as text nodes) that cannot have children, though this serves no useful purpose. In the case of a tree rooted at an attribute or namespace node, there is no way to obtain the value of the accumulator.</p></div><p>The following sections give first, the syntax rules for defining an accumulator; then an informal description of the semantics; then a more formal definition; and finally, examples. But to illustrate the concept intuitively, the following simple example shows how an accumulator can be used for numbering of nodes:</p><div class="example"><div class="exampleHeader"><a id="d8e37898"></a><a id="d8e38007"></a>Example: Numbering Figures within a Chapter</div><p>This example assumes document input in which <code>figure</code> elements can appear within <code>chapter</code> elements (which we assume are not nested), and the requirement is to render the figures with a caption that includes the figure number within its containing chapter.</p><p>When the document is processed using streaming, the <a href="#element-number"><code>xsl:number</code></a> instruction is not available, so a solution using accumulators is needed.</p><p>The required accumulator can be defined and used like this:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:accumulator</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">figNr</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">initial-value</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">chapter</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">figure</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$value</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:mode</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">figure</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Figure </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">accumulator-before</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">figNr</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="div3"><h4><a id="accumulator-declaration"></a>18.2.1 <a href="#accumulator-declaration" style="text-decoration: none">Declaring an Accumulator</a></h4><p class="element-syntax"><a id="element-accumulator"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:accumulator<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>initial-value</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br>&lt;/xsl:accumulator&gt;</code></p><p class="element-syntax"><a id="element-accumulator-rule"></a><code>&lt;xsl:accumulator-rule<br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;phase? = "start" | "end"<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:accumulator-rule&gt;</code></p><p>An <a href="#element-accumulator"><code>xsl:accumulator</code></a> element is a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of an accumulator. The <code>name</code> attribute defines the name of the accumulator. The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p><p>An <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration can only appear as a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element in a stylesheet module.</p><p>The functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a> return, respectively, the value of the accumulator before visiting the descendants of a given node, and the value after visiting the descendants of a node. Each of these functions takes a single argument, the name of the accumulator, and the function applies implicitly to the context node. The type of the return value (for both functions) is determined by the <code>as</code> attribute of the <a href="#element-accumulator"><code>xsl:accumulator</code></a> element.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-accumulator-function" title="accumulator function"></a>The functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a> are referred to as the <b>accumulator functions</b>.<span class="definition">]</span></p><p>For constructs that use accumulators to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>:</p><ul><li><p>The <a href="#func-accumulator-before"><code>accumulator-before</code></a> function for a streamed node can be called at any time the node is available (it behaves like other properties of the node such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-name"><code>name</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-base-uri"><code>base-uri</code></a><sup><small>FO30</small></sup>).</p></li><li><p>The <a href="#func-accumulator-after"><code>accumulator-after</code></a> function, however, is restricted to appear after any instruction that reads the descendants of the node in question. The constraints are expressed as static rules: see <a href="#streamability-fn-accumulator-after"><i>19.8.9.1 Streamability of the accumulator-after Function</i></a> for more details.</p></li></ul><p>The initial value of the accumulator is obtained by evaluating the expression in the <code>initial-value</code> attribute. This attribute is mandatory. The expression in the <code>initial-value</code> attribute is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on the root node of the streamed input tree to which the accumulator is being applied.</p><p>The values of the accumulator for individual nodes in a tree are obtained by applying the <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> rules contained within the <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration, as described in subsequent sections. The <code>match</code> attribute of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> which determines which nodes trigger execution of the rule; the <code>phase</code> attribute indicates whether the rule fires before descendants are processed (<code>phase="start"</code>, which is the default), or after descendants are processed (<code>phase="end"</code>).</p><p>The <code>select</code> attribute and the contained sequence constructor of the <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> element are mutually exclusive: if the <code>select</code> attribute is present then the sequence constructor must be empty. The expression in the <code>select</code> attribute of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> or the contained sequence constructor is evaluated with a static context that follows the normal rules for expressions in stylesheets, except that:</p><ul><li><p>An additional variable is present in the context. The name of this variable is <code>value</code> (in no namespace), and its type is the type that appears in the <code>as</code> attribute of the <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration.</p></li><li><p>The context item for evaluation of the expression or sequence constructor will always be a node that matches the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> in the <code>match</code> attribute.</p></li></ul><p>The result of both the <code>initial-value</code> and <code>select</code> expressions (or contained sequence constructor) is converted to the type declared in the <code>as</code> attribute by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs if conversion is not possible. The <code>as</code> attribute defaults to <code>item()*</code>.</p><p>The effect of the <code>streamable</code> attribute is defined in <a href="#streamability-of-accumulators"><i>18.2.9 Streamability of Accumulators</i></a>.</p></div><div class="div3"><h4><a id="applicability-of-accumulators"></a>18.2.2 <a href="#applicability-of-accumulators" style="text-decoration: none">Applicability of Accumulators</a></h4><p>It is not the case that every accumulator is applicable to every tree. The details depend on how the accumulator is declared, and how the tree is created. The rules are as follows:</p><ol class="enumar"><li><p>An accumulator is applicable to a tree unless otherwise specified in these rules. (For example, when a document is read using the <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, or <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions, all accumulators are applicable. Similarly, all accumulators are applicable to a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> created using <a href="#element-variable"><code>xsl:variable</code></a>.)</p></li><li><p>Regardless of the rules below, an accumulator is not applicable to a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a> unless the accumulator is declared with <code>streamable="yes"</code>. (The converse does not apply: for unstreamed documents, accumulators are applicable regardless of the value of the <code>streamable</code> attribute.)</p></li><li><p>For a document read using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, the accumulators that are applicable are those determined by the <code>use-accumulators</code> attribute of that instruction.</p></li><li><p>For a document read using the <code>for-each-source</code> attribute of an <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, the accumulators that are applicable are those determined by the <code>use-accumulators</code> attribute of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element.</p></li><li><p>For a document containing nodes supplied in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, the accumulators that are applicable are those determined by the <a href="#element-mode"><code>xsl:mode</code></a> declaration of the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. This means that in the absence of an <a href="#element-mode"><code>xsl:mode</code></a> declaration, no accumulators are applicable.</p></li><li><p>For a tree <var>T</var> created by copying a node in a tree <var>S</var> using the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> functions, or the instruction <a href="#element-copy-of"><code>xsl:copy-of</code></a> with <code>copy-accumulators="yes"</code>, an accumulator is applicable to <var>T</var> if and only if it is applicable to <var>S</var>.</p></li></ol><p>If an accumulator is not applicable to the tree containing the context item, calls to the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>, supplying the name of that accumulator, will fail with a dynamic error.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The reason that accumulators are not automatically applicable to every streamed document is to avoid the cost of evaluating them, and to avoid the possibility of dynamic errors occuring if they are not designed to work with a particular document structure.</p><p>In the case of unstreamed documents, there are no compelling reasons to restrict which accumulators are applicable, because an implementation can avoid the cost of evaluating every accumulator against every document by evaluating the accumulator lazily, for example, by only evaluating the accumulator for a particular tree the first time its value is requested for a node in that tree. In the interests of orthogonality, however, restricting the applicable accumulators works in the same way for streamable and non-streamable documents. </p></div><p>The value of the <code>use-accumulators</code> attribute of <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-merge-source"><code>xsl:merge-source</code></a>, or <a href="#element-mode"><code>xsl:mode</code></a> must either be a whitespace-separated list of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>, or the special token <code>#all</code>. The list may be empty, and the default value is an empty list. Every <code>EQName</code> in the list must be the name of an accumulator, visible in the containing package, and declared with <code>streamable="yes"</code>. The value <code>#all</code> indicates that all accumulators that are visible in the containing package are applicable (except that for a streamable input document, an accumulator is not applicable unless it specifies <code>streamable="yes"</code>).</p><p><a id="err-XTSE3300"><span class="error">[ERR XTSE3300] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of accumulator names contains an invalid token, contains the same token more than once, or contains the token <code>#all</code> along with any other value; or if any token (other than <code>#all</code>) is not the name of a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> accumulator visible in the containing package. </p></div><div class="div3"><h4><a id="accumulator-informal-rules"></a>18.2.3 <a href="#accumulator-informal-rules" style="text-decoration: none">Informal Model for Accumulators</a></h4><p><em>This section describes how accumulator values are established by evaluating the rules in an <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration. This process does not apply to trees created with accumulator values copied from another document, for example by using the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> functions.</em></p><p>Informally, an accumulator is evaluated by traversing a tree, as follows.</p><p>Each node is visited twice, once before processing its descendants, and once after processing its descendants. For consistency, this applies even to leaf nodes: each is visited twice. Attribute and namespace nodes, however, are not visited.</p><p>Before the traversal starts, a variable (called the accumulator variable) is initialized to the value of the expression given as the <code>initial-value</code> attribute.</p><p>On each node visit, the <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> elements are examined to see if there is a matching rule. For a match to occur, the pattern in the <code>match</code> attribute must match the node, and the <code>phase</code> attribute must be <code>start</code> if this is the first visit, and <code>end</code> if it is the second visit. If there is a matching rule, then a new value is computed for the accumulator variable using the expression contained in that rule’s <code>select</code> attribute or the contained sequence constructor. If there is more than one matching rule, the last in document order is used. If there is no matching rule, the value of the accumulator variable does not change.</p><p>Each node is labeled with a pre-descent value for the accumulator, which is the value of the accumulator variable immediately <em>after</em> processing the first visit to that node, and with a post-descent value for the accumulator, which is the value of the accumulator variable immediately <em>after</em> processing the second visit.</p><p>The function <a href="#func-accumulator-before"><code>accumulator-before</code></a> delivers the pre-descent value of the accumulator at the context node; the function <a href="#func-accumulator-after"><code>accumulator-after</code></a> delivers the post-descent value of the accumulator at the context node.</p><p>Although this description is expressed in procedural terms, it can be seen that the two values of the accumulator for any given node depend only on the node and its preceding and (in the case of the post-descent value) descendant nodes. Calculation of both values is therefore deterministic and free of side-effects; moreover, it is clear that the values can be computed during a streaming pass of a document, provided that the rules themselves use only information that is available without repositioning the input stream.</p><p>It is permitted for the <code>select</code> expression of an accumulator rule, or the contained sequence constructor, to invoke an accumulator function. For a streamable accumulator, the rules ensure that a rule with <code>phase="start"</code> cannot call the <a href="#func-accumulator-after"><code>accumulator-after</code></a> function. When such function calls exist in an accumulator rule, they impose a dependency of one accumulator on another, and create the possibility of cyclic dependencies. Processors are allowed to report the error statically if they can detect it statically. Failing this, processors are allowed to fail catastrophically in the event of a cycle, in the same way as they might fail in the event of infinite function or template recursion. Catastrophic failure might manifest itself, for example, as a stack overflow, or as non-termination of the transformation.</p></div><div class="div3"><h4><a id="accumulator-formal-rules"></a>18.2.4 <a href="#accumulator-formal-rules" style="text-decoration: none">Formal Model for Accumulators</a></h4><p><em>This section describes how accumulator values are established by evaluating the rules in an <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration. This process does not apply to trees created with accumulator values copied from another document, for example by using the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> functions.</em></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-traversal" title="traversal"></a>A <b>traversal</b> of a tree is a sequence of <a title="traversal-event" class="termref" href="#dt-traversal-event">traversal events</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-traversal-event" title="traversal-event"></a>a <b>traversal event</b> (shortened to <b>event</b> in this section) is a pair comprising a phase (start or end) and a node.<span class="definition">]</span> It is modelled as a map with two entries: <code>map{"phase": p, "node": n}</code> where p is the string <code>"start"</code> or <code>"end"</code> and <code>n</code> is a node.</p><p>The traversal of a tree contains two traversal events for each node in the tree, other than attribute and namespace nodes. One of these events (the “start event”) has phase = "start", the other (the "end event") has phase = "end".</p><p>The order of traversal events within a traversal is such that, given any two nodes <var>M</var> and <var>N</var> with start/end events denoted by <var>M<sub>0</sub></var>, <var>M<sub>1</sub></var>, <var>N<sub>0</sub></var>, and <var>N<sub>1</sub></var>, :</p><ul><li><p>For any node <var>N</var>, <var>N<sub>0</sub></var> precedes <var>N<sub>1</sub></var>;</p></li><li><p>If <var>M</var> is an ancestor of <var>N</var> then <var>M<sub>0</sub></var> precedes <var>N<sub>0</sub></var> and <var>N<sub>1</sub></var> precedes <var>M<sub>1</sub></var>;</p></li><li><p>If <var>M</var> is on the preceding axis of <var>N</var> then <var>M<sub>1</sub></var> precedes <var>N<sub>0</sub></var>.</p></li></ul><p>The accumulator defines a (private) delta function <var>Δ</var>. The delta function computes the value of the accumulator for one traversal event in terms of its value for the previous traversal event. The function is defined as follows:</p><ol class="enumar"><li><p>The signature of <var>Δ</var> is <code>function ($old-value as T, $event as map(*)) as T</code>, where <var>T</var> is the sequence type declared in the <code>as</code> attribute of the accumulator declaration;</p></li><li><p>The implementation of the function is equivalent to the following algorithm:</p><ol class="enumla"><li><p>Let <var>R</var> be the set of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> elements among the children of the accumulator declaration whose <code>phase</code> attribute equals <code>$event("phase")</code> and whose <code>match</code> attribute is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that matches <code>$event("node")</code></p></li><li><p>If <var>R</var> is empty, return <code>$old-value</code></p></li><li><p>Let <var>Q</var> be the <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> in <var>R</var> that is last in document order</p></li><li><p>Return the value of the expression in the <code>select</code> attribute of <var>Q</var>, or the contained sequence constructor, evaluating this with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> set to <code>$event("node")</code> and with a dynamic context that binds the variable whose name is <code>$value</code> (in no namespace) to the value <code>$old-value</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The argument names <code>old-value</code> and <code>event</code> are used here purely for definitional purposes; these names are not available for use within the <code>select</code> expression or contained sequence constructor.</p></div></li></ol></li></ol><p>For every node <var>N</var>, other than attribute and namespace nodes, the accumulator defines a pre-descent value <var>B<sub>N</sub></var> and a post-descent value <var>A<sub>N</sub></var> whose values are as follows:</p><ol class="enumar"><li><p>Let <var>T</var> be the <a title="traversal" class="termref" href="#dt-traversal">traversal</a> of the tree rooted at <code>fn:root(N)</code>.</p></li><li><p>Let <var>SB</var> be the subsequence of <var>T</var> starting at the first event in <var>T</var> and ending with the start event for node <var>N</var> (that is, the event <code>map{ "phase":"start", "node":N }</code>).</p></li><li><p>Let <var>SA</var> be the subsequence of <var>T</var> starting at the first event in <var>T</var>, and ending with the end event for node <var>N</var> (that is, the event <code>map{ "phase":"end", "node":N }</code>).</p></li><li><p>Let <var>Z</var> be the result of evaluating the expression contained in the <code>initial-value</code> attribute of the <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration, evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <code>root(N)</code>.</p></li><li><p>Then the pre-descent value <var>B<sub>N</sub></var> is the value of <code>fn:fold-left(SB, Z, Δ)</code>, and the post-descent value <var>A<sub>N</sub></var> is the value of <code>fn:fold-left(SA, Z, Δ)</code>.</p></li></ol></div><div class="div3"><h4><a id="errors-in-accumulators"></a>18.2.5 <a href="#errors-in-accumulators" style="text-decoration: none">Dynamic Errors in Accumulators</a></h4><p>If a dynamic error occurs when evaluating the <code>initial-value</code> expression of <a href="#element-accumulator"><code>xsl:accumulator</code></a>, or the <code>select</code> expression of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>, <span>or the sequence constructor contained in <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>, </span> then the error is signaled as an error from any subsequent call on <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> that references the accumulator. If no such call on <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> happens, then the error goes unreported. <span>[XSLT 3.0 Erratum E38, bug 30376].</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the above rule, the phrase <b>subsequent call</b> is to be understood in terms of functional dependency; that is, a call to <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> signals an error if the accumulator value at the node in question is functionally dependent on a computation that fails with a dynamic error.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Particularly in the case of streamed accumulators, this may mean that the implementation has to “hold back” the error until the next time the accumulator is referenced, to give applications the opportunity to catch the error using <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a> in a predictable way.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Errors that occur during the evaluation of the pattern in the <code>match</code> attribute of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> are handled as described in <a href="#pattern-errors"><i>5.4.3 Errors in Patterns</i></a>: specifically, the pattern does not match the relevant node, and no error is signaled.</p></div></div><div class="div3"><h4><a id="func-accumulator-before"></a>18.2.6 <a href="#func-accumulator-before" style="text-decoration: none">fn:accumulator-before</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the pre-descent value of the selected accumulator at the context node.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:accumulator-before</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$name</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">union(xs:QName, xs:string)</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-accumulator-before"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:accumulator-before</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$name</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">union(xs:QName, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The <code>$name</code> argument specifies the name of the <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>. The value of the argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or</span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then it is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> (no prefix means no namespace).</p><p>The function returns the pre-descent value <var>B(N)</var>of the selected accumulator where <var>N</var> is the context node, as defined in <a href="#accumulator-formal-rules"><i>18.2.4 Formal Model for Accumulators</i></a>.</p><p>If the context item is a node in a streamed document, then the accumulator must be declared with <code>streamable="yes"</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The converse is not true: an accumulator declared to be streamable is available on both streamed and unstreamed nodes.</p></div></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE3340"><span class="error">[ERR XTDE3340] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the first argument to the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function is <span>a string that is</span> not a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if there is no namespace declaration in scope for the prefix of the QName, or if the name obtained by expanding the QName is not the same as the expanded name of any <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration appearing in the <a title="package" class="termref" href="#dt-package">package</a> in which the function call appears. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><p><a id="err-XTDE3350"><span class="error">[ERR XTDE3350] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when there is no <a title="context item" class="termref" href="#dt-context-item">context item</a>. </p><p><a id="err-XTTE3360"><span class="error">[ERR XTTE3360] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node, or when it is an attribute or namespace node. </p><p><a id="err-XTDE3362"><span class="error">[ERR XTDE3362] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the context item is a node in a tree to which the selected accumulator is not applicable (including the case where it is not applicable because the document is streamed and the accumulator is not declared with <code>streamable="yes"</code>). Implementations <span class="verb">may</span> raise this error but are <span class="verb">not required</span> to do so, if they are capable of streaming documents without imposing this restriction. </p><p><a id="err-XTDE3400"><span class="error">[ERR XTDE3400] </span></a>It is an error if there is a cyclic set of dependencies among accumulators such that the (pre- or post-descent) value of an accumulator depends directly or indirectly on itself. A processor <span class="verb">may</span> report this as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if it can be detected statically. Alternatively a processor <span class="verb">may</span> report this as a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>. As a further option, a processor may fail catastrophically when this error occurs. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <b>catastrophic failure</b> here means a failure similar to infinite function or template recursion, which might result in stack overflow or even in non-termination of the transformation, rather than in a dynamic error of the kind that can be processed using <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a>.</p></div></dd><dt class="label">Notes</dt><dd><p class="note">The <a href="#func-accumulator-before"><code>accumulator-before</code></a> function can be applied to a node whether or not the accumulator has a <code>phase="start"</code> rule for that node. In effect, there is a <code>phase="start"</code> rule for every node, where the default rule is to leave the accumulator value unchanged; the <a href="#func-accumulator-before"><code>accumulator-before</code></a> function delivers the value of the accumulator after processing the explicit or implicit <code>phase="start"</code> rule.</p></dd><dt class="label">Examples</dt><dd><div class="example"><p>Given the accumulator:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:accumulator</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">a</span><span class="z">"</span><span class="z"></span><span class="atn">initial-value</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">section</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$value</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>and the template rule:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">section</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">accumulator-before</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">a</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The stylesheet will precede the output from processing each section with a section number that runs sequentially 1, 2, 3... irrespective of the nesting of sections.</p></div></dd></dl></div><div class="div3"><h4><a id="func-accumulator-after"></a>18.2.7 <a href="#func-accumulator-after" style="text-decoration: none">fn:accumulator-after</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the post-descent value of the selected accumulator at the context node.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:accumulator-after</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$name</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">union(xs:QName, xs:string)</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-accumulator-after"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:accumulator-after</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$name</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">union(xs:QName, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The <code>$name</code> argument specifies the name of the <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>. The value of the argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or</span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then it is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> (no prefix means no namespace).</p><p>The function returns the post-descent value <var>A(N)</var> of the selected accumulator where <var>N</var> is the context node, as defined in <a href="#accumulator-formal-rules"><i>18.2.4 Formal Model for Accumulators</i></a>.</p><p>If the context item is a node in a streamed document, then the accumulator must be declared with <code>streamable="yes"</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The converse is not true: an accumulator declared to be streamable is available on both streamed and unstreamed nodes.</p></div></dd><dt class="label">Error Conditions</dt><dd><p>The following errors apply: <span class="error">[see <a href="#err-XTDE3340">ERR XTDE3340</a>]</span>, <span class="error">[see <a href="#err-XTDE3350">ERR XTDE3350</a>]</span>, <span class="error">[see <a href="#err-XTTE3360">ERR XTTE3360</a>]</span>, <span class="error">[see <a href="#err-XTDE3362">ERR XTDE3362</a>]</span>, <span class="error">[see <a href="#err-XTDE3400">ERR XTDE3400</a>]</span>. </p><p>For constraints on the use of <a href="#func-accumulator-after"><code>accumulator-after</code></a> when streaming, see <a href="#streamability-fn-accumulator-after"><i>19.8.9.1 Streamability of the accumulator-after Function</i></a>.</p></dd><dt class="label">Notes</dt><dd><p class="note">The <a href="#func-accumulator-after"><code>accumulator-after</code></a> function can be applied to a node whether or not the accumulator has a <code>phase="end"</code> rule for that node. In effect, there is a <code>phase="end"</code> rule for every node, where the default rule is to leave the accumulator value unchanged; the <a href="#func-accumulator-after"><code>accumulator-after</code></a> function delivers the value of the accumulator after processing the explicit or implicit <code>phase="end"</code> rule.</p></dd><dt class="label">Examples</dt><dd><div class="example"><p>Given the accumulator:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:accumulator</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">w</span><span class="z">"</span><span class="z"></span><span class="atn">initial-value</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">true</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">text</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$value</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">count</span><span class="parenthesis">(</span><span class="function">tokenize</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>and the template rule:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">section</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"> (words: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">accumulator-after</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">w</span><span class="op">'</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">-</span><span class="whitespace"></span><span class="function">accumulator-before</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">w</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt">) </span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The stylesheet will output at the end of each section a (crude) count of the number of words in that section.</p><p><em>Note: the call on <code>tokenize(.)</code> relies on XPath 3.1</em></p></div></dd></dl></div><div class="div3"><h4><a id="accumulators-visibility-and-overriding"></a>18.2.8 <a href="#accumulators-visibility-and-overriding" style="text-decoration: none">Importing of Accumulators</a></h4><p>If a <a title="package" class="termref" href="#dt-package">package</a> contains more than one <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration with a particular name, then the one with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p><a id="err-XTSE3350"><span class="error">[ERR XTSE3350] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain two or more accumulators with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another accumulator with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, and a higher import precedence. </p><p>Accumulators cannot be referenced from, or overridden in, a different package from the one in which they are declared.</p></div><div class="div3"><h4><a id="streamability-of-accumulators"></a>18.2.9 <a href="#streamability-of-accumulators" style="text-decoration: none">Streamability of Accumulators</a></h4><p>An accumulator is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> if it satisfies all the following conditions:</p><ol class="enumar"><li><p>The <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration has the attribute <code>streamable="yes"</code>.</p></li><li><p>In every contained <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>, the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> in the <code>match</code> attribute is a <a title="motionless" class="termref" href="#dt-motionless">motionless</a> pattern (see <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a>).</p></li><li><p>The <a title="expression" class="termref" href="#dt-expression">expression</a> in the <code>initial-value</code> attribute is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>The <a title="expression" class="termref" href="#dt-expression">expression</a> in the <code>select</code> attribute or contained sequence constructor is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol><p>Specifying <code>streamable="yes"</code> on an <a href="#element-accumulator"><code>xsl:accumulator</code></a> element declares an intent that the accumulator should be streamable, either because it is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, or because it takes advantage of streamability extensions offered by a particular processor. The consequences of declaring the accumulator to be streamable when it is not in fact guaranteed streamable depend on the conformance level of the processor, and are explained in <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>.</p><p>When an accumulator is declared to be streamable, the stylesheet author must ensure that the accumulator function <a href="#func-accumulator-after"><code>accumulator-after</code></a> is only called at appropriate points in the processing, as explained in <a href="#streamability-fn-accumulator-after"><i>19.8.9.1 Streamability of the accumulator-after Function</i></a>.</p></div><div class="div3"><h4><a id="copying-accumulators"></a>18.2.10 <a href="#copying-accumulators" style="text-decoration: none">Copying Accumulator Values</a></h4><p>When nodes (including streamed nodes) are copied using the <a href="#func-snapshot"><code>snapshot</code></a> or <a href="#func-copy-of"><code>copy-of</code></a> functions, or using the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with the attribute <code>copy-accumulators="yes"</code>, then the pre-descent and post-descent values of accumulators for that tree are not determined by traversing the tree as described in <a href="#accumulator-informal-rules"><i>18.2.3 Informal Model for Accumulators</i></a> and <a href="#accumulator-formal-rules"><i>18.2.4 Formal Model for Accumulators</i></a>. Instead the values are the same as the values on the corresponding nodes of the source tree. </p><p>This applies also to the implicit invocation of the <a href="#func-snapshot"><code>snapshot</code></a> function that happens during the evaluation of <a href="#element-merge"><code>xsl:merge</code></a>.</p><p>If an accumulator is not applicable to a tree <var>S</var>, then it is also not applicable to any tree formed by copying nodes from <var>S</var> using the above methods.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>During streamed processing, accumulator values will typically be computed “on the fly”; when the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> functions are applied to a streamed node, the computed accumulator values for the streamed document will typically be materialized and saved as part of the copy.</p><p>Accumulator values for a non-streamed document will often be computed lazily, that is, they will not be computed unless and until they are needed. A call on <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> on a non-streamed document whose accumulator values have not yet been computed can then be handled in a variety of ways. The implementation might interpret the call on <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> as a trigger causing the accumulator values to be computed; or it might retain a link between the nodes of the copied tree and the nodes of the original tree, so that a request for accumulator values on the copied tree can trigger computation of accumulator values for the original tree. </p></div></div><div class="div3"><h4><a id="accumulator-examples"></a>18.2.11 <a href="#accumulator-examples" style="text-decoration: none">Examples of Accumulators</a></h4><div class="example"><div class="exampleHeader"><a id="d8e39024"></a><a id="d8e39133"></a>Example: Remember the Title of a Document</div><p>Consider an XHTML document in which the title of the document is represented by the content of a <code>title</code> element appearing as a child of the <code>head</code> element, which in turn appears as a child of the <code>html</code> element. Suppose that we want to process the document in streaming mode, and that we want to avoid outputting the content of the <code>h1</code> element if it is the same as the document title.</p><p>This can be achieved by remembering the value of the title in an accumulator variable.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:accumulator</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">firstTitle</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string?</span><span class="z">"</span><span class="z"></span><span class="atn">initial-value</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="qname">html</span><span class="step">/</span><span class="qname">head</span><span class="step">/</span><span class="qname">title</span><span class="step">/</span><span class="node-type">text</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Subsequently, while processing an <code>h1</code> element appearing later in the document, the value can be referenced:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">h1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">firstTitle</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">accumulator-before</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">firstTitle</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">thisTitle</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:if</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$thisTitle</span><span class="whitespace"></span><span class="op">ne</span><span class="whitespace"></span><span class="variable">$firstTitle</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">div</span><span class="z"></span><span class="atn">class</span><span class="atneq">=</span><span class="z">"</span><span class="av">heading-1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$thisTitle</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">div</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:if</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e39045"></a><a id="d8e39154"></a>Example: Keep a Word Count</div><p>Suppose that there is a requirement to output, at the end of the HTML rendition of a document, a paragraph giving the total number of words in the document.</p><p>An accumulator can be used to maintain a (crude) word count as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:accumulator</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">word-count</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">initial-value</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">text</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$value</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">count</span><span class="parenthesis">(</span><span class="function">tokenize</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The final value can be output at the end of the document:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt">Word count: </span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">accumulator-after</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">word-count</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e39059"></a><a id="d8e39168"></a>Example: Output Hierarchic Section Numbers</div><p>Consider a document in which <code>section</code> elements are nested within <code>section</code> elements to arbitrary depth, and there is a requirement to render the document with hierarchic section numbers of the form <code>3.5.1.4</code>.</p><p>The current section number can be maintained in an accumulator in the form of a sequence of integers, managed as a stack. The number of integers represents the current level of nesting, and the value of each integer represents the number of preceding sibling sections encountered at that level. For convenience the first item in the sequence represents the top of the stack.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:accumulator</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">section-nr</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer*</span><span class="z">"</span><span class="z"></span><span class="atn">initial-value</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">section</span><span class="z">"</span><span class="z"></span><span class="atn">phase</span><span class="atneq">=</span><span class="z">"</span><span class="av">start</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="op">,</span><span class="whitespace"></span><span class="function">head</span><span class="parenthesis">(</span><span class="variable">$value</span><span class="parenthesis">)</span><span class="quantifier">+</span><span class="numeric">1</span><span class="op">,</span><span class="whitespace"></span><span class="function">tail</span><span class="parenthesis">(</span><span class="variable">$value</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">section</span><span class="z">"</span><span class="z"></span><span class="atn">phase</span><span class="atneq">=</span><span class="z">"</span><span class="av">end</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">tail</span><span class="parenthesis">(</span><span class="variable">$value</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="comment">(:pop:)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>To illustrate this, consider the values after processing a series of start and end tags:</p><table class="data"><caption>Example data illustrating the effect of parsing events on an accumulator</caption><thead><tr><th style="text-align:left; vertical-align:top">events</th><th style="text-align:left; vertical-align:top">accumulator value</th><th style="text-align:left; vertical-align:top">required section number</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>0, 1</code></td><td style="text-align:left; vertical-align:top">1</td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>0, 1, 1</code></td><td style="text-align:left; vertical-align:top">1.1</td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>1, 1</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>0, 2, 1</code></td><td style="text-align:left; vertical-align:top">1.2</td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>2, 1</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>0, 3, 1</code></td><td style="text-align:left; vertical-align:top">1.3</td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>0, 1, 3, 1</code></td><td style="text-align:left; vertical-align:top">1.3.1</td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>1, 3, 1</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>0, 2, 3, 1</code></td><td style="text-align:left; vertical-align:top">1.3.2</td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>2, 3, 1</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>3, 1</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td><td style="text-align:left; vertical-align:top"><code>1</code></td><td style="text-align:left; vertical-align:top"></td></tr></tbody></table><p>The section number for a section can thus be generated as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">section</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">reverse</span><span class="parenthesis">(</span><span class="function">tail</span><span class="parenthesis">(</span><span class="function">accumulator-before</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">section-nr</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">separator</span><span class="atneq">=</span><span class="z">"</span><span class="av">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e39172"></a><a id="d8e39281"></a>Example: Compute a Histogram showing the Number of Books, by Publisher</div><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:accumulator</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">histogram</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:string, xs:integer)</span><span class="z">"</span><span class="z"></span><span class="atn">initial-value</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:accumulator-rule</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">book</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">map:contains</span><span class="parenthesis">(</span><span class="variable">$value</span><span class="op">,</span><span class="whitespace"></span><span class="axis">@</span><span class="qname">publisher</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">map:put</span><span class="parenthesis">(</span><span class="variable">$value</span><span class="op">,</span><span class="whitespace"></span><span class="function">string</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">publisher</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="function">$value</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">publisher</span><span class="parenthesis">)</span><span class="quantifier">+</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">map:put</span><span class="parenthesis">(</span><span class="variable">$value</span><span class="op">,</span><span class="whitespace"></span><span class="function">string</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">publisher</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator-rule</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:accumulator</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The <code>contained sequence constructor</code> is evaluated with the variable <code>$value</code> set to the current value, and with the context node as the node being visited.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In the two calls on <code>map:put()</code>, it is necessary to explicitly convert <code>@publisher</code> to an <code>xs:string</code> value, because this is the declared type of the keys in the result map. Relying on atomization would produce keys of type <code>xs:untypedAtomic</code>, which would not satisfy the declared type of the map.</p></div><p>The accumulated histogram might be displayed as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">booklist.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"> ..... </span><span class="es">&lt;</span><span class="en">h1</span><span class="scx">&gt;</span><span class="txt">Number of books, by publisher</span><span class="ez">&lt;/</span><span class="cl">h1</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">table</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">thead</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Publisher</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">th</span><span class="scx">&gt;</span><span class="txt">Number of books</span><span class="ez">&lt;/</span><span class="cl">th</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">thead</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tbody</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">histogram</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">accumulator-after</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">histogram</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">map:keys</span><span class="parenthesis">(</span><span class="variable">$histogram</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">tr</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">td</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">$histogram</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">td</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tr</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">tbody</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">table</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div2"><h3><a id="func-copy-of"></a>18.3 <a href="#func-copy-of" style="text-decoration: none">fn:copy-of</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns a deep copy of the sequence supplied as the <code>$input</code> argument, or of the context item if the argument is absent.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:copy-of</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$input</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td><td><code class="assign"><span class="deltaxml-old" style="background:#FF5555">:=&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">.</span></code></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-copy-of"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:copy-of</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$input</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></div></dd><dt class="label">Properties</dt><dd><p>The zero-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>. </p><p>The one-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The zero-argument form of this function is defined so that <code>copy-of()</code> returns the value of <code>internal:copy-item(.)</code>, where <code>internal:copy-item</code> (which exists only for the purpose of this exposition) is defined below. Informally, <code>copy-of()</code> copies the context item.</p><p>The single argument form of this function is defined in terms of the <code>internal:copy-item</code> as follows: <code>copy-of($input)</code> is equivalent to <code>$input ! internal:copy-item(.)</code>. Informally, <code>copy-of($input)</code> copies each item in the input sequence in turn.</p><p>The <code>internal:copy-item</code> function is defined as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">internal:copy-item</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">item()</span><span class="z">"</span><span class="z"></span><span class="atn">new-each-time</span><span class="atneq">=</span><span class="z">"</span><span class="av">maybe</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">item()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$input</span><span class="z">"</span><span class="z"></span><span class="atn">copy-namespaces</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">copy-accumulators</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">preserve</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The streamability analysis, however, is different: see <a href="#classifying-built-in-functions"><i>19.8.9 Classifying Calls to Built-In Functions</i></a>.</p><p>The use of <code>new-each-time="maybe"</code> in the above definition means that if the <code>internal:copy-item</code> function is called more than once with the same node as argument (whether or not these calls are part of the same call on <code>copy-of</code>), then it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether each call returns the same node, or whether multiple calls return different nodes. Returning the original node, however, is not allowed, except as an optimization when the processor can determine that this is equivalent.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>One case where such optimization might be possible is when the copy is immediately atomized.</p></div></dd><dt class="label">Notes</dt><dd><p class="note">The <a href="#func-copy-of"><code>copy-of</code></a> function is available for use (and is primarily intended for use) when a source document is processed using streaming. It can also be used when not streaming. The effect, when applied to element and document nodes, is to take a copy of the subtree rooted at the current node, and to make this available as a normal tree: one that can be processed without any of the restrictions that apply while streaming, for example only being able to process children once. The copy, of course, does not include siblings or ancestors of the context node, so any attempt to navigate to siblings or ancestors will result in an empty sequence being returned.</p><p class="note">All nodes in the result sequence will be parentless.</p><p class="note">If atomic values or functions (including maps and arrays) are present in the input sequence, they will be included unchanged at the corresponding position of the result sequence.</p><p class="note">Accumulator values are taken from the copied document as described in <a href="#copying-accumulators"><i>18.2.10 Copying Accumulator Values</i></a>.</p></dd><dt class="label">Examples</dt><dd><div class="example"><p>Using <code>copy-of()</code> while streaming:</p><p>This example copies from the source document all employees who work in marketing and are based in Dubai. Because there are two accesses using the child axis, it is not possible to do this without buffering each employee in memory, which can be achieved using the <a href="#func-copy-of"><code>copy-of</code></a> function.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">employees.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="qname">employees</span><span class="step">/</span><span class="qname">employee</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="filter">[</span><span class="qname">department</span><span class="op">=</span><span class="op">'</span><span class="literal">Marketing</span><span class="op">'</span><span class="whitespace"></span><span class="op">and</span><span class="whitespace"></span><span class="qname">location</span><span class="op">=</span><span class="op">'</span><span class="literal">Dubai</span><span class="op">'</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></dd></dl></div><div class="div2"><h3><a id="func-snapshot"></a>18.4 <a href="#func-snapshot" style="text-decoration: none">fn:snapshot</a></h3><dl><dt class="label">Summary</dt><dd><p>Returns a copy of a sequence, retaining copies of the ancestors and descendants of any node in the input sequence, together with their attributes and namespaces.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:snapshot</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$input</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td><td><code class="assign"><span class="deltaxml-old" style="background:#FF5555">:=&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">.</span></code></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">item()*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-snapshot"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:snapshot</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$input</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">item()*</span></code></div></dd><dt class="label">Properties</dt><dd><p>The zero-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>. </p><p>The one-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-nondeterministic">nondeterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The zero-argument form of this function is defined so that <code>snapshot()</code> returns the value of <code>internal:snaphot-item(.)</code>, where <code>internal:snapshot-item</code> (which exists only for the purpose of this exposition) is defined below. Informally, <code>snapshot()</code> takes a snapshot of the context item.</p><p>The single argument form of this function is defined in terms of the <code>internal:snapshot-item</code> as follows: <code>snapshot($input)</code> is equivalent to <code>$input ! internal:snapshot-item(.)</code>. Informally, <code>snapshot($input)</code> takes a snapshot of each item in the input sequence in turn.</p><p>The <code>internal:snapshot-item</code> function behaves as follows:</p><ul><li><p>If the supplied item is an atomic value or a function item (including maps and arrays), then it returns that item unchanged.</p></li><li><p>If the supplied item is a node, then it returns a <a title="snapshot" class="termref" href="#dt-snapshot">snapshot</a> of that node, as defined below.</p></li></ul><p><span class="definition">[Definition:&nbsp;</span><a id="dt-snapshot" title="snapshot"></a>A <b>snapshot</b> of a node <var>N</var> is a deep copy of <var>N</var>, as produced by the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with <code>copy-namespaces</code> set to <code>yes</code>, <code>copy-accumulators</code> set to <code>yes</code>, and <code>validation</code> set to <code>preserve</code>, with the additional property that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor whose name, node-kind, and base URI are the same as the corresponding ancestor of <var>N</var>, and that has copies of the attributes, namespaces and accumulator values of the corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of <code>xs:anyType</code>, has the properties <code>nilled</code>, <code>is-id</code>, and <code>is-idref</code> set to false, and has no children other than the child that is a copy of <var>N</var> or one of its ancestors.<span class="definition">]</span></p><p>If the function is called more than once with the same argument, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether each call returns the same node, or whether multiple calls return different nodes. That is, the result of the expression <code>snapshot($X) is snapshot($X)</code> is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>Except for the effect on accumulators, the <code>internal:snapshot-item</code> function can be expressed as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">internal:snapshot-item</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">item()</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">item()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$input</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">internal:snapshot</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> for atomic values and function items, return the item unchanged </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">internal:snapshot</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> for a document node, or any other root node, return a deep copy </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="function">root</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">internal:snapshot</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">5</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> for an element, comment, text node, or processing instruction: </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">internal:snapshot</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">3</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">internal:graft-to-parent</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="context">..</span><span class="op">,</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$n</span><span class="parenthesis">)</span><span class="op">{</span><span class="variable">$n</span><span class="step">/</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> for an attribute: </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">internal:snapshot</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">attribute()</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">3</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">name</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">node-name</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">internal:graft-to-parent</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="context">..</span><span class="op">,</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$n</span><span class="parenthesis">)</span><span class="op">{</span><span class="variable">$n</span><span class="step">/</span><span class="axis">@</span><span class="op">*</span><span class="filter">[</span><span class="function">node-name</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="variable">$name</span><span class="filter">]</span><span class="op">}</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> for a namespace node: </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="node-type">namespace-node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">internal:snapshot</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">namespace-node()</span><span class="z">"</span><span class="z"></span><span class="atn">priority</span><span class="atneq">=</span><span class="z">"</span><span class="av">3</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">name</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">local-name</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">internal:graft-to-parent</span><span class="parenthesis">(</span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="context">..</span><span class="op">,</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$n</span><span class="parenthesis">)</span><span class="op">{</span><span class="variable">$n</span><span class="step">/</span><span class="node-type">namespace-node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="filter">[</span><span class="function">local-name</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="variable">$name</span><span class="filter">]</span><span class="op">}</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> make a copy C of a supplied node N, grafting it to a shallow copy of C's original parent, and returning the copy C </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">internal:graft-to-parent</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">n</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">original-parent</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()?</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">down-function</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">function(node()) as node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">exists</span><span class="parenthesis">(</span><span class="variable">$original-parent</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">p</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$original-parent</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="op">*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$n</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:copy</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">copied-parent</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">internal:graft-to-parent</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="variable">$p</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$original-parent</span><span class="step">/</span><span class="context">..</span><span class="op">,</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$n</span><span class="parenthesis">)</span><span class="op">{</span><span class="variable">$n</span><span class="step">/</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">$down-function</span><span class="parenthesis">(</span><span class="variable">$copied-parent</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$n</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></dd><dt class="label">Notes</dt><dd><p class="note">The <a href="#func-snapshot"><code>snapshot</code></a> function is available for use (and is primarily intended for use) when a source document is processed using streaming. It can also be used when not streaming. The effect is to take a copy of the subtree rooted at the current node, along with copies of the ancestors and their attributes, and to make this available as a normal tree, that can be processed without any of the restrictions that apply while streaming, for example only being able to process children once. The copy, of course, does not include siblings of the context node or of its ancestors, so any attempt to navigate to these siblings will result in an empty sequence being returned.</p><p class="note">For parentless nodes, the effect of <code>snapshot($x)</code> is identical to the effect of <code>copy-of($x)</code>.</p></dd><dt class="label">Examples</dt><dd><div class="example"><p>Using <code>snapshot()</code> while streaming:</p><p>This example copies from the source document all employees who work in marketing and are based in Dubai. It assumes that employees are grouped by location. Because there are two accesses using the child axis (referencing <code>department</code> and <code>salary</code>), it is not possible to do this without buffering each employee in memory. The <a href="#func-snapshot"><code>snapshot</code></a> function is used in preference to the simpler <a href="#func-copy-of"><code>copy-of</code></a> so that access to attributes of the parent <code>location</code> element remains possible.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">employees.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">snapshot</span><span class="parenthesis">(</span><span class="qname">locations</span><span class="step">/</span><span class="qname">location</span><span class="filter">[</span><span class="axis">@</span><span class="qname">name</span><span class="op">=</span><span class="op">'</span><span class="literal">Dubai</span><span class="op">'</span><span class="filter">]</span><span class="whitespace"></span><span class="step">/</span><span class="qname">employee</span><span class="parenthesis">)</span><span class="filter">[</span><span class="qname">department</span><span class="op">=</span><span class="op">'</span><span class="literal">Marketing</span><span class="op">'</span><span class="filter">]</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">employee</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">location</span><span class="z"></span><span class="atn">code</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="context">..</span><span class="step">/</span><span class="axis">@</span><span class="qname">code</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">salary</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="qname">salary</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">employee</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></dd></dl></div></div><div class="div1"><h2><a id="streamability"></a>19 <a href="#streamability" style="text-decoration: none">Streamability</a></h2><p>This section contains rules that can be used to determine properties of <a title="construct" class="termref" href="#dt-construct">constructs</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> — specifically, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a construct — which enable the streamability of the stylesheet to be assessed.</p><p>These properties are used to determine the streamability of:</p><ul><li><p><a title="template rule" class="termref" href="#dt-template-rule">Template rules</a>: see <a href="#streamable-templates"><i>6.7.6 Streamable Templates</i></a></p></li><li><p>The <a href="#element-source-document"><code>xsl:source-document</code></a> instruction: see <a href="#source-document-instruction"><i>18.1 The xsl:source-document Instruction</i></a></p></li><li><p><a title="attribute set" class="termref" href="#dt-attribute-set">Attribute sets</a>: see <a href="#streamability-of-attribute-sets"><i>10.2.3 Streamability of Attribute Sets</i></a></p></li><li><p><a title="accumulator" class="termref" href="#dt-accumulator">Accumulators</a>: see <a href="#streamability-of-accumulators"><i>18.2.9 Streamability of Accumulators</i></a></p></li><li><p><a title="stylesheet function" class="termref" href="#dt-stylesheet-function">Stylesheet functions</a>: see <a href="#streamable-stylesheet-functions"><i>19.8.5 Classifying Stylesheet Functions</i></a></p></li><li><p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction: see <a href="#streamable-merging"><i>15.4 Streamable Merging</i></a></p></li></ul><p>In each case, the conditions for constructs to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> are defined in terms of these properties. The result of this analysis in turn (see <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>) imposes rules on how the constructs are handled by processors that implement the <a title="streaming feature" class="termref" href="#dt-streaming-feature">streaming feature</a>. The analysis has no effect on the behavior of processors that do not implement this feature.</p><p>The analysis is relevant to constructs such as streamable template rules and the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction that process a single streamed input document. The <a href="#element-merge"><code>xsl:merge</code></a> instruction, which processes multiple streamed inputs, has its own rules.</p><p>The rules in this section operate on the expression tree (more properly, construct tree) that is typically output by the XSLT and XPath parser. For the most part, the rules depend only on identifying the syntactic constructs that are present.</p><p>The rules in this section generally consider each <a title="component" class="termref" href="#dt-component">component</a> in the stylesheet (and in the case of <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>, each template rule) in isolation. The exception is that where a component contains references to other components (such as global variables, functions, or named templates), then information from the signature of the referenced component is sometimes used. This is invariably information that cannot be changed if a component is overridden in a different <a title="package" class="termref" href="#dt-package">package</a>. The analysis thus requires as a pre-condition that function calls and calls on named templates have been resolved to the extent that the corresponding function/template signature is known. </p><p>The detailed way in which the construct tree is derived from the lexical form of the stylesheet is not described in this specification. There are many ways in which the tree can be optimized without affecting the result of the rules in this section: for example, a sequence constructor containing a single instruction can be replaced by that instruction, and a parenthesized expression can be replaced by its content.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-construct" title="construct"></a>The term <b>construct</b> refers to the union of the following: a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="value template" class="termref" href="#dt-value-template">value template</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a>, or a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.<span class="definition">]</span></p><p>These <a title="construct" class="termref" href="#dt-construct">constructs</a> are classified into <b>construct kinds</b>: in particular, <a title="instruction" class="termref" href="#dt-instruction">instructions</a> are classified according to the name of the XSLT instruction, and <a title="expression" class="termref" href="#dt-expression">expressions</a> are classified according to the most specific production in the XPath grammar that the expression satisfies. (This means, for example, that <code>2+2</code> is classified as an <code>AdditiveExpr</code>, rather than say as a <code>UnionExpr</code>; although it also satisfies the production rule for <code>UnionExpr</code>, <code>AdditiveExpr</code> is more specific.)</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-operand-role" title="operand role"></a>For every construct kind, there is a set of zero or more <b>operand roles</b>.<span class="definition">]</span> For example, an <code>AdditiveExpr</code> has two operand roles, referred to as the left-hand operand and the right-hand operand, while an <code>IfExpr</code> has three, referred to as the condition, the then-clause, and the else-clause. A function call with three arguments has three operand roles, called the first, second, and third arguments. The names of the operand roles for each construct kind are not formally listed, but should be clear from the context.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-operand" title="operand"></a>In an actual instance of a construct, there will be a number of <b>operands</b>. Each operand is itself a <a title="construct" class="termref" href="#dt-construct">construct</a>; the construct tree can be defined as the transitive relation between constructs and their operands.<span class="definition">]</span> Each operand is associated with exactly one of the operand roles for the construct type. There may be operand roles where the operand is optional (for example, the <code>separator</code> attribute of the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction), and there may be operand roles that can be occupied by multiple operands (for example, the <code>xsl:when/@test</code> condition in <a href="#element-choose"><code>xsl:choose</code></a>, or the arguments of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-concat"><code>concat</code></a><sup><small>FO30</small></sup> function).</p><p>Operand roles have a number of properties used in the analysis:</p><ul><li><p>The <a title="required type" class="termref" href="#dt-required-type">required type</a> of the <a title="operand" class="termref" href="#dt-operand">operand</a>. This is explicit in the case of function calls (the required type is defined in the function signature of the corresponding function). In other cases it is implicit in the detailed rules for the construct in question. In practice streamability analysis makes only modest use of the required type; the main case where it is relevant is for a function or template call, where knowing that the required type is atomic enables the inference that the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> for a supplied node is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-operand-usage" title="operand usage"></a>The <b>operand usage</b>. This gives information, in the case where the operand value contains nodes, about how those nodes are used. The operand usage takes one of the values <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, or <a title="navigation" class="termref" href="#dt-navigation">navigation</a>.<span class="definition">]</span> The meanings of these terms are explained in <a href="#operand-roles"><i>19.3 Operand Roles</i></a>. If the required type of the <a title="operand" class="termref" href="#dt-operand">operand</a> does not permit nodes to be supplied (for example because the required type is a function item or a map), then the operand usage is <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, because the only run-time operation on a supplied node will be to inspect it, discover it is a node, and raise a type error.</p><p>In the particular case where the required type is atomic, and any supplied nodes are atomized, the operand usage will be <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, because <a title="atomize" class="termref" href="#dt-atomization">atomize</a> is a special case of absorption.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-higher-order-operand" title="higher-order operand"></a>Whether or not the <a title="operand" class="termref" href="#dt-operand">operand</a> is <b>higher-order</b>. For this purpose an operand <var>O</var> of a construct <var>C</var> is higher-order if the semantics of <var>C</var> potentially require <var>O</var> to be evaluated more than once during a single evaluation of <var>C</var>.<span class="definition">]</span> More specifically, <var>O</var> is a <b>higher-order</b> operand of <var>C</var> if any of the following conditions is true:</p><ul><li><p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> for evaluation of <var>O</var> is different from the context item for evaluation of <var>C</var>.</p></li><li><p><var>C</var> is an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> and <var>O</var> is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> (as with the <code>from</code> and <code>count</code> attributes of <a href="#element-number"><code>xsl:number</code></a>, and the <code>group-starting-with</code> and <code>group-ending-with</code> attributes of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>).</p></li><li><p><var>C</var> is an XPath <code>for</code>, <code>some</code>, or <code>every</code> expression and <var>O</var> is the expression in its <code>return</code> or <code>satisfies</code> clause.</p></li><li><p><var>C</var> is an inline function declaration and <var>O</var> is the expression in its body.</p></li></ul></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>There is one known case where this definition makes an operand higher-order even though it is only evaluated once: specifically, the sequence constructor contained in the body of an <a href="#element-copy"><code>xsl:copy</code></a> instruction that has a <code>select</code> attribute. See <a href="#streamability-xsl-copy"><i>19.8.4.12 Streamability of xsl:copy</i></a> for further details.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-choice-operand-group" title="choice operand group"></a>For some construct kinds, one or more operand roles may be defined to form a <b>choice operand group</b>. This concept is used where it is known that <a title="operand" class="termref" href="#dt-operand">operands</a> are mutually exclusive (for example the <code>then</code> and <code>else</code> clauses in a conditional expression).<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-combined-posture" title="combined posture"></a>The <b>combined posture</b> of a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a> is determined by the <a title="posture" class="termref" href="#dt-posture">postures</a> of the <a title="operand" class="termref" href="#dt-operand">operands</a> in the group (the <b>operand postures</b>), and is the first of the following that applies:</p><ol class="enumar"><li><p>If any of the operand postures is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, then the combined posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>.</p></li><li><p>If all of the operand postures are <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>If one or more of the operand postures is <a title="climbing" class="termref" href="#dt-climbing">climbing</a> and the remainder (if any) are <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="climbing" class="termref" href="#dt-climbing">climbing</a>.</p></li><li><p>If one or more of the operand postures is <a title="striding" class="termref" href="#dt-striding">striding</a> and the remainder (if any) are <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>If one or more of the operand postures is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and each of the remainder (if any) is either <a title="striding" class="termref" href="#dt-striding">striding</a> or <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="crawling" class="termref" href="#dt-crawling">crawling</a>.</p></li><li><p>Otherwise (for example, if the group includes both an operand with <a title="climbing" class="termref" href="#dt-climbing">climbing</a> posture and one with <a title="crawling" class="termref" href="#dt-crawling">crawling</a> posture), the combined posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>. </p></li></ol><p>]</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-type-determined-usage" title="type-determined usage"></a>The <b>type-determined usage</b> of an <a title="operand" class="termref" href="#dt-operand">operand</a> is as follows: if the required type (ignoring occurrence indicator) is <code>function(*)</code> or a subtype thereof, then <a title="inspection" class="termref" href="#dt-inspection">inspection</a>; if the required type (ignoring occurrence indicator) is an atomic or union type, then <a title="absorption" class="termref" href="#dt-absorption">absorption</a>; otherwise <a title="navigation" class="termref" href="#dt-navigation">navigation</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-type-adjusted-posture-and-sweep" title="type-adjusted posture and sweep"></a>The <b>type-adjusted posture and sweep</b> of a construct <var>C</var>, with respect to a type <var>T</var>, are the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> established by applying the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> to a construct <var>D</var> whose single operand is the construct <var>C</var>, where the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of <var>C</var> in <var>D</var> is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the required type <var>T</var>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>In effect, the type-adjusted posture and sweep are the posture and sweep of the implicit expression formed to apply the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to the argument of a function or template call, or to the result of a function or template, given knowledge of the required type. For example, an expression such as <code>discount</code> in the function call <code>abs(discount)</code>, which would otherwise be <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, becomes <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a> because of the implicit atomization triggered by the coercion rules.</p></div><p>The process of determining whether a construct is streamable reduces to determining properties of the constructs in the construct tree. The properties in question (which are described in greater detail in subsequent sections) are:</p><ol class="enumar"><li><p>The <b>static type</b> of the construct. When the construct is evaluated, its value will always be an instance of this type. The value is a <a title="U-type" class="termref" href="#dt-utype">U-type</a>; although type inferencing is capable of determining information about the cardinality as well as the item type, the streamability analysis makes no use of this.</p></li><li><p>The <b>context item type</b>: that is, the static type of the <a title="context item" class="termref" href="#dt-context-item">context item</a> potentially used as input to the construct. When the construct is evaluated, the context item used to evaluate the construct (if it is used at all) will be an instance of this type.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-posture" title="posture"></a>The <b>posture</b> of the expression. This captures information about the way in which the streamed input document is positioned on return from evaluating the construct. The posture takes one of the values <a title="climbing" class="termref" href="#dt-climbing">climbing</a>, <a title="striding" class="termref" href="#dt-striding">striding</a>, <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, or <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.<span class="definition">]</span> The meanings of these terms are explained in <a href="#posture"><i>19.4 Determining the Posture of a Construct</i></a>.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-posture" title="context posture"></a>The <b>context posture</b>. This captures information about how the <a title="context item" class="termref" href="#dt-context-item">context item</a> used as input to the construct is positioned relative to the streamed input. The <b>context posture</b> of a construct C is the posture of the expression whose value sets the focus for the evaluation of C.<span class="definition">]</span> Rules for determining the context posture of any construct are given in <a href="#determining-context-posture"><i>19.5 Determining the Context Posture</i></a>.</p></li><li><p>The <b>sweep</b> of the construct. The sweep of a construct gives information about whether and how the evaluation of the construct changes the current position in a streamed input document. The possible values are <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. These terms are explained in <a href="#sweep"><i>19.6 The Sweep of a Construct</i></a>.</p></li></ol><p>The values of these properties for a top-level construct such as the body of a template rule determine whether the construct is streamable.</p><p>The values of these properties are not independent. For example, if the static type is atomic, then the posture will always be grounded; if the sweep is free-ranging, then the posture will always be roaming.</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a <a title="construct" class="termref" href="#dt-construct">construct</a>, as defined above, are calculated in relation to a particular streamed input document. If there is more than one streamed input document, then a construct that is motionless with respect to one streamed input might be consuming with respect to another. In practice, though, the streamability analysis is only ever concerned with one particular streamed input at a time; constructs are analyzed in relation to the innermost containing <a href="#element-template"><code>xsl:template</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-accumulator"><code>xsl:accumulator</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, and this container implicitly defines the streamed input document that is relevant. The streamed input document affecting a construct is always the document that contains the context item for evaluation of that construct.</p><div class="div2"><h3><a id="determining-static-type"></a>19.1 <a href="#determining-static-type" style="text-decoration: none">Determining the Static Type of a Construct</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-static-type" title="static type"></a>The <b>static type</b> of a <a title="construct" class="termref" href="#dt-construct">construct</a> is such that all values produced by evaluating the construct will conform to that type. The static type of a construct is a <a title="U-type" class="termref" href="#dt-utype">U-type</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-utype" title="U-type"></a>A <b>U-type</b> is a set of <a title="fundamental item type" class="termref" href="#dt-fundamental-item-type">fundamental item types</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-fundamental-item-type" title="fundamental item type"></a>There are 28 <b>fundamental item types</b>: the 7 node kinds defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a> (element, attribute, etc.), the 19 primitive atomic types defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>, plus the types <code>function(*)</code> and <code>xs:untypedAtomic</code>. The fundamental item types are disjoint, and every item is an instance of exactly one of them.<span class="definition">]</span></p><p>More specifically, the fundamental item types are:</p><ul><li><p><code>document-node()</code>, <code>element()</code>, <code>attribute()</code>, <code>text()</code>, <code>comment()</code>, <code>processing-instruction()</code>, <code>namespace-node()</code>;</p></li><li><p><code>xs:boolean</code>, <code>xs:double</code>, <code>xs:decimal</code>, <code>xs:float</code>, <code>xs:string</code>, <code>xs:dateTime</code>, <code>xs:date</code>, <code>xs:time</code>, <code>xs:gYear</code>, <code>xs:gYearMonth</code>, <code>xs:gMonth</code>, <code>xs:gMonthDay</code>, <code>xs:gDay</code>, <code>xs:anyURI</code>, <code>xs:QName</code>, <code>xs:NOTATION</code>, <code>xs:base64Binary</code>, <code>xs:hexBinary</code>, <code>xs:duration</code></p></li><li><p><code>function(*)</code></p></li><li><p><code>xs:untypedAtomic</code></p></li></ul><p>A value <var>V</var> (in general, a sequence) is an instance of a <a title="U-type" class="termref" href="#dt-utype">U-type</a><var>U</var> if every item in <var>V</var> is an instance of one of the <a title="fundamental item type" class="termref" href="#dt-fundamental-item-type">fundamental item types</a> in <var>U</var>. For example, the sequence <code>(23, "Paris")</code> is an instance of the U-type <code>U{xs:string, xs:decimal, xs:date}</code> because both items in the sequence belong to item types in this U-type. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is a consequence of this rule that the empty sequence, <code>()</code>, is an instance of every U-type.</p></div><p>A <a title="U-type" class="termref" href="#dt-utype">U-type</a> is represented in this specification using the notation <var>U{t1, t2, t3, ...}</var> where <code>t1, t2, t3, ...</code> are the names of the fundamental item types making up the U-type. The item types are represented using the syntax of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP40</small></sup> production in XPath, for example <code>comment()</code> or <code>xs:date</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that the order of <code>t1, t2, t3, ...</code> has no significance: <var>U{A, B}</var> is the same U-type as <var>U{B, A}</var>.</p></div><p>The smallest U-type is denoted <var>U{}</var>. This is not an empty type; like every other U-type, it has the empty sequence <code>()</code> as an instance. For convenience, the universal U-type is represented as <var>U{*}</var>; the U-type corresponding to the set of 7 node kinds is written <var>U{N}</var>, and the U-type corresponding to all atomic values (that is, the 19 primitive atomic types plus <code>xs:untypedAtomic</code>) is written <var>U{A}</var>.</p><p>Because a <a title="U-type" class="termref" href="#dt-utype">U-type</a> is a set, the operations of union, intersection, and difference are defined over U-types, and the result is always a U-type. If one U-type <var>U</var> is a subset of another U-type <var>V</var>, then <var>U</var> is said to be a subtype of <var>V</var>, and <var>V</var> is said to be a supertype of <var>U</var>.</p><p>In some cases the inference of a <a title="static type" class="termref" href="#dt-static-type">static type</a> depends on the declared types of variables or functions. Since declared types use the <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> syntax, there is therefore a mapping defined from SequenceTypes to U-types. The mapping is as follows:</p><ul><li><p>The <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a><code>empty-sequence()</code> maps to <var>U{}</var></p></li><li><p>For every other <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>, the mapping depends only on the item type and ignores the occurrence indicator. The mapping from item types is as follows:</p><ul><li><p><code>item()</code> maps to <var>U{*}</var></p></li><li><p><code>AnyKindTest</code> (<code>node()</code>) maps to <var>U{N}</var></p></li><li><p><code>DocumentTest</code> maps to <var>U{document-node()}</var></p></li><li><p><code>ElementTest</code> and <code>SchemaElementTest</code> map to <var>U{element()}</var></p></li><li><p><code>AttributeTest</code> and <code>SchemaAttributeTest</code> map to <var>U{attribute()}</var></p></li><li><p><code>TextTest</code> maps to <var>U{text()}</var></p></li><li><p><code>CommentTest</code> maps to <var>U{comment()}</var></p></li><li><p><code>PITest</code> maps to <var>U{processing-instruction()}</var></p></li><li><p><code>NamespaceNodeTest</code> maps to <var>U{namespace-node()}</var></p></li><li><p><code>FunctionTest</code>, <code>MapTest</code>, and <code>ArrayTest</code> map to <var>U{function(*)}</var></p></li><li><p>The QName <code>xs:error</code> maps to <var>U{}</var></p></li><li><p>A QName <var>Q</var> representing an atomic type that is a fundamental item type maps to <var>U{Q}</var></p></li><li><p>A QName <var>Q</var> representing an atomic type derived from a fundamental item type <var>F</var> maps to <var>U{F}</var></p></li><li><p>A QName <var>Q</var> representing a pure union type maps to a U-type containing the fundamental item types present in the transitive membership of the union, or from which the transitive members of the union are derived.</p></li></ul></li></ul><p>Although all constructs have a <a title="static type" class="termref" href="#dt-static-type">static type</a>, the streamability analysis only needs to know the static type of XPath expressions, so the rules here are largely confined to that case. For <a title="pattern" class="termref" href="#dt-pattern">patterns</a>, the <a title="static type" class="termref" href="#dt-static-type">static type</a> is deemed to be <var>U{xs:boolean}</var>, reflecting the fact that a pattern is essentially a function that can be applied to items to deliver a true or false (matching or non-matching) result. For constructs other than <a title="expression" class="termref" href="#dt-expression">expressions</a> and <a title="pattern" class="termref" href="#dt-pattern">patterns</a>, the <a title="static type" class="termref" href="#dt-static-type">static type</a> for the purpose of streamability analysis is taken as <var>U{*}</var>.</p><p>The rules given here are deliberately simple. Implementations may well be able to compute a more precise <a title="static type" class="termref" href="#dt-static-type">static type</a>, but this will rarely be useful for streamability analysis. The item type for each kind of XPath expression is determined by the rules below. In the first column, numbers in square brackets are production numbers from the XPath 3.0 and XPath 3.1 specifications respectively. In the second column, the <b>Proforma</b> uses an informal notation used both to provide a reminder of the syntax of the construct in question, and to attach labels to its operand roles so that they can be referred to in the text of the third column.</p><table class="data"><caption>Inferring a Static Type for XPath 3.0 Expressions</caption><thead><tr><th style="text-align:left; vertical-align:top">Construct</th><th style="text-align:left; vertical-align:top">Proforma</th><th style="text-align:left; vertical-align:top">Static Type</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">Expr [6,6] </td><td style="text-align:left; vertical-align:top"><code>E,F</code></td><td style="text-align:left; vertical-align:top">the union of the static types of E and F</td></tr><tr><td style="text-align:left; vertical-align:top">ForExpr [8,8] </td><td style="text-align:left; vertical-align:top"><code>for $x in S return E</code></td><td style="text-align:left; vertical-align:top">the static type of E</td></tr><tr><td style="text-align:left; vertical-align:top">LetExpr [11,11] </td><td style="text-align:left; vertical-align:top"><code>let $x := S return E</code></td><td style="text-align:left; vertical-align:top">the static type of E</td></tr><tr><td style="text-align:left; vertical-align:top">QuantifiedExpr [14,14]</td><td style="text-align:left; vertical-align:top"><code>some|every $x in S satisfies C</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:boolean}</var></td></tr><tr><td style="text-align:left; vertical-align:top">IfExpr [15,15] </td><td style="text-align:left; vertical-align:top"><code>if (C) then T else E</code></td><td style="text-align:left; vertical-align:top">the union of the static types of T and E</td></tr><tr><td style="text-align:left; vertical-align:top">OrExpr [16,16]</td><td style="text-align:left; vertical-align:top"><code>E or F</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:boolean}</var></td></tr><tr><td style="text-align:left; vertical-align:top">AndExpr [17,17]</td><td style="text-align:left; vertical-align:top"><code>E and F</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:boolean}</var></td></tr><tr><td style="text-align:left; vertical-align:top">ComparisonExpr [18,18]</td><td style="text-align:left; vertical-align:top"><code>E = F, E eq F, E is F</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:boolean}</var></td></tr><tr><td style="text-align:left; vertical-align:top">StringConcatExpr [19,19]</td><td style="text-align:left; vertical-align:top"><code>E || F</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:string}</var></td></tr><tr><td style="text-align:left; vertical-align:top">RangeExpr [20,20]</td><td style="text-align:left; vertical-align:top"><code>E to F</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:decimal}</var></td></tr><tr><td style="text-align:left; vertical-align:top">AdditiveExpr [21,21]</td><td style="text-align:left; vertical-align:top"><code>E + F</code></td><td style="text-align:left; vertical-align:top"><var>U{A}</var>. But if the expression is a predicate (that is, if it appears between square brackets in a filter expression or axis step), then <var>U{xs:decimal, xs:double, xs:float}</var></td></tr><tr><td style="text-align:left; vertical-align:top">MultiplicativeExpr [22,22]</td><td style="text-align:left; vertical-align:top"><code>E * F</code></td><td style="text-align:left; vertical-align:top"><var>U{A}</var>. But if the expression is a predicate (that is, if it appears between square brackets in a filter expression or axis step), then <var>U{xs:decimal, xs:double, xs:float}</var></td></tr><tr><td style="text-align:left; vertical-align:top">UnionExpr [23,23] </td><td style="text-align:left; vertical-align:top"><code>E | F</code></td><td style="text-align:left; vertical-align:top">the union of the static types of E and F</td></tr><tr><td style="text-align:left; vertical-align:top" rowspan="2">IntersectExceptExpr [24,24] </td><td style="text-align:left; vertical-align:top"><code>E intersect F</code></td><td style="text-align:left; vertical-align:top">the intersection of the static types of E and F</td></tr><tr><td style="text-align:left; vertical-align:top"><code>E except F</code></td><td style="text-align:left; vertical-align:top">the static type of E</td></tr><tr><td style="text-align:left; vertical-align:top">InstanceOfExpr [25,25]</td><td style="text-align:left; vertical-align:top"><code>E instance of T</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:boolean}</var></td></tr><tr><td style="text-align:left; vertical-align:top">TreatExpr [26,26]</td><td style="text-align:left; vertical-align:top"><code>E treat as T</code></td><td style="text-align:left; vertical-align:top">the U-type corresponding to the SequenceType T</td></tr><tr><td style="text-align:left; vertical-align:top">CastableExpr [27,27]</td><td style="text-align:left; vertical-align:top"><code>E castable as T</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:boolean}</var></td></tr><tr><td style="text-align:left; vertical-align:top">CastExpr [28,28] </td><td style="text-align:left; vertical-align:top"><code>E cast as T</code></td><td style="text-align:left; vertical-align:top">if T is an atomic or pure union type, the corresponding U-type. Otherwise, for example if T is a list type, <var>U{A}</var>.</td></tr><tr><td style="text-align:left; vertical-align:top">UnaryExpr [29,30]</td><td style="text-align:left; vertical-align:top"><code>-N</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:decimal, xs:double, xs:float}</var></td></tr><tr><td style="text-align:left; vertical-align:top">SimpleMapExpr [34,35] </td><td style="text-align:left; vertical-align:top"><code>E ! F</code></td><td style="text-align:left; vertical-align:top">the static type of F</td></tr><tr><td style="text-align:left; vertical-align:top" rowspan="3">PathExpr [35,36] </td><td style="text-align:left; vertical-align:top"><code>/</code></td><td style="text-align:left; vertical-align:top"><var>U{document-node()}</var></td></tr><tr><td style="text-align:left; vertical-align:top"><code>/P</code></td><td style="text-align:left; vertical-align:top">the static type of P</td></tr><tr><td style="text-align:left; vertical-align:top"><code>//P</code></td><td style="text-align:left; vertical-align:top">the static type of P</td></tr><tr><td style="text-align:left; vertical-align:top">RelativePathExpr [36,37] </td><td style="text-align:left; vertical-align:top"><code>P/Q, P//Q</code></td><td style="text-align:left; vertical-align:top">the static type of Q</td></tr><tr><td style="text-align:left; vertical-align:top">AxisStep [38,39] </td><td style="text-align:left; vertical-align:top"><code>E[P]</code></td><td style="text-align:left; vertical-align:top">the static type of E: see <a href="#static-type-of-steps"><i>19.1.1 Static Type of an Axis Step</i></a></td></tr><tr><td style="text-align:left; vertical-align:top">ForwardStep [39,40], ReverseStep [42,43]</td><td style="text-align:left; vertical-align:top"><code>Axis::NodeTest</code></td><td style="text-align:left; vertical-align:top">See <a href="#static-type-of-steps"><i>19.1.1 Static Type of an Axis Step</i></a></td></tr><tr><td style="text-align:left; vertical-align:top" rowspan="2">PostfixExpr [48,49]</td><td style="text-align:left; vertical-align:top">Filter Expression <code>E[P]</code></td><td style="text-align:left; vertical-align:top">the static type of E</td></tr><tr><td style="text-align:left; vertical-align:top">Dynamic Function Call <code>F(X, Y)</code></td><td style="text-align:left; vertical-align:top"><var>U{*}</var>, unless ancillary information is available about the function signature of F: see below.</td></tr><tr><td style="text-align:left; vertical-align:top">Literal [53,57]</td><td style="text-align:left; vertical-align:top"><code>"pH"</code>, <code>93.7</code></td><td style="text-align:left; vertical-align:top"><var>U{xs:string}</var>, <var>U{xs:decimal}</var>, or <var>U{xs:double}</var>, depending on the form of the literal</td></tr><tr><td style="text-align:left; vertical-align:top">VarRef [55,59]</td><td style="text-align:left; vertical-align:top"><code>$V</code></td><td style="text-align:left; vertical-align:top">For a variable declared using <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a>, and for parameters of inline function expressions: the declared type of the variable, defaulting to <var>U{*}</var>. For variables declared using <code>for</code>, <code>let</code>, <code>some</code>, and <code>every</code> expressions: the static type of the expression to which the variable is bound.</td></tr><tr><td style="text-align:left; vertical-align:top" rowspan="2">ParenthesizedExpr [57,61]</td><td style="text-align:left; vertical-align:top"><code>(E)</code></td><td style="text-align:left; vertical-align:top">the type of E</td></tr><tr><td style="text-align:left; vertical-align:top"><code>()</code></td><td style="text-align:left; vertical-align:top"><var>U{}</var> (a type whose only instance is the empty sequence)</td></tr><tr><td style="text-align:left; vertical-align:top">ContextItemExpr [58,62]</td><td style="text-align:left; vertical-align:top"><code>.</code></td><td style="text-align:left; vertical-align:top">the context item type: see below</td></tr><tr><td style="text-align:left; vertical-align:top">FunctionCall [59,63]</td><td style="text-align:left; vertical-align:top"><code>F(X, Y)</code></td><td style="text-align:left; vertical-align:top">In general: the U-type corresponding to the declared result type of function <var>F</var>. But: <ul><li><p>If one or more of the arguments to the function have operand usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, then the intersection of the U-type corresponding to the declared result type with the union of the static types of the arguments having usage transmission. (For example, the static type of the function call <code>head(//text())</code> is <var>U{text()}</var>.)</p></li><li><p>Special rules apply to the <a href="#func-current"><code>current</code></a> function: see <a href="#static-type-of-current-function"><i>19.1.2 Static Type of a Call to current</i></a>.</p></li></ul></td></tr><tr><td style="text-align:left; vertical-align:top">NamedFunctionRef [63,67]</td><td style="text-align:left; vertical-align:top"><code>F#n</code></td><td style="text-align:left; vertical-align:top"><var>U{function(*)}</var></td></tr><tr><td style="text-align:left; vertical-align:top">InlineFunctionExpr [64,68] </td><td style="text-align:left; vertical-align:top"><code>function(P) {E}</code></td><td style="text-align:left; vertical-align:top"><var>U{function(*)}</var></td></tr><tr><td style="text-align:left; vertical-align:top">MapConstructor [,69]</td><td style="text-align:left; vertical-align:top"><code>map{"A":E, "B":F}</code></td><td style="text-align:left; vertical-align:top"><var>U{function(*)}</var></td></tr><tr><td style="text-align:left; vertical-align:top">Postfix Lookup [,49]</td><td style="text-align:left; vertical-align:top"><code>E ? K</code></td><td style="text-align:left; vertical-align:top">If the type of <var>E</var> is a map type <code>map(K, V)</code> or an array type <code>array(V)</code>, then the U-type corresponding to the item type of <var>V</var>; otherwise <var>U{*}</var></td></tr><tr><td style="text-align:left; vertical-align:top">(Unary) Lookup [,53]</td><td style="text-align:left; vertical-align:top"><code>? K</code></td><td style="text-align:left; vertical-align:top">If the context item type is a map type <code>map(K, V)</code> or an array type <code>array(V)</code>, then the U-type corresponding to the item type of <var>V</var>; otherwise <var>U{*}</var></td></tr><tr><td style="text-align:left; vertical-align:top">ArrowExpr [,29]</td><td style="text-align:left; vertical-align:top"><code>X =&gt; F(Y, Z)</code></td><td style="text-align:left; vertical-align:top">The static type of the equivalent static or dynamic function call <code>F(X, Y, Z)</code></td></tr><tr><td style="text-align:left; vertical-align:top">SquareArrayConstructor [,74]</td><td style="text-align:left; vertical-align:top"><code>[X, Y, ...]</code></td><td style="text-align:left; vertical-align:top"><var>U{function(*)}</var></td></tr><tr><td style="text-align:left; vertical-align:top">CurlyArrayConstructor [,75]</td><td style="text-align:left; vertical-align:top"><code>array{X, Y, ...}</code></td><td style="text-align:left; vertical-align:top"><var>U{function(*)}</var></td></tr></tbody></table><p>Where the <a title="static type" class="termref" href="#dt-static-type">static type</a> of an expression is <var>U{function(*)}</var>, it is useful to retain additional information: specifically, the signature of the function. This may be regarded as information ancillary to the U-type of the expression; it does not play any role in operations such as testing whether one U-type is a subtype of another, or forming the union of two U-types. This ancillary information is available for a <code>NamedFunctionRef</code>, for an <code>InlineFunctionExpr</code>, for a <code>MapConstructor</code>, for a <code>FunctionCall</code> whose static type is <var>U{function(*)}</var>, and for a <code>VarRef</code> if the variable is bound to any of the forgoing, or if it has a declared type corresponding to <var>U{function(*)}</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The special case type inference used for an <code>AdditiveExpr</code> or <code>MultiplicativeExpr</code> appearing as a predicate is possible because if an arithmetic operation within a predicate produces any other result, for example an <code>xs:duration</code> or <code>xs:dateTime</code>, this would cause a type error (on the grounds that an <code>xs:duration</code> or <code>xs:dateTime</code> has no effective boolean value), and static type inference only needs to consider the type of non-error results. The benefit of this special rule is that filter expressions such as <code>/descendant::section[$i + 1]</code> can be recognized as returning a singleton, and therefore as being <a title="striding" class="termref" href="#dt-striding">striding</a>, even if the type of <code>$i</code> is unknown.</p></div><div class="div3"><h4><a id="static-type-of-steps"></a>19.1.1 <a href="#static-type-of-steps" style="text-decoration: none">Static Type of an Axis Step</a></h4><p>An <code>AxisStep</code> consists of either a <code>ForwardStep</code> or <code>ReverseStep</code> followed by zero or more predicates. The predicates have no effect on the inferred type of the <code>AxisStep</code>.</p><p>The static type of an abbreviated step is the static type of its expansion, for example the static type of <code>@*</code> is the same as the static type of <code>attribute::*</code>.</p><p>Both the constructs <code>ForwardStep</code> or <code>ReverseStep</code>, in their unabbreviated form, are written as <code>Axis::NodeTest</code>. The static type depends on both the <code>Axis</code> and the <code>NodeTest</code>, and also on the <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a>, determined as described in <a href="#determining-context-item-type"><i>19.2 Determining the Context Item Type</i></a>.</p><p>If the <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> has an empty intersection with <code>U{N}</code> (that is, if the context item type cannot be a node), then evaluation of the <code>AxisStep</code> will always fail; it is permissible to raise a type error statically in this case, but for the sake of the analysis, the static type of the <code>AxisStep</code> can be taken as <code>U{}</code>. In other cases, let <var>CIT</var> be the intersection of the <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> with <code>U{N}</code>.</p><p>Let <var>K(A, CIT)</var> be the set of <b>reachable node kinds</b> given an axis <var>A</var> (a <a title="U-type" class="termref" href="#dt-utype">U-type</a>) as defined by the following table: </p><table style="border:1px solid; padding:5px; width:100%"><thead><tr><th style="text-align:left; vertical-align:top">Axis</th><th style="text-align:left; vertical-align:top">Reachable Node Kinds</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">self</td><td style="text-align:left; vertical-align:top"><var>CIT</var></td></tr><tr><td style="text-align:left; vertical-align:top">attribute</td><td style="text-align:left; vertical-align:top">if <var>CIT</var> includes <code>U{element()}</code> then <code>U{attribute()}</code> else <code>U{}</code></td></tr><tr><td style="text-align:left; vertical-align:top">namespace</td><td style="text-align:left; vertical-align:top">if <var>CIT</var> includes <code>U{element()}</code> then <code>U{namespace-node()}</code> else <code>U{}</code></td></tr><tr><td style="text-align:left; vertical-align:top">child, descendant</td><td style="text-align:left; vertical-align:top">if <var>CIT</var> includes <code>U{element()}</code> or <code>U{document-node()}</code> then <code>U{element(), text(), comment(), processing-instruction()}</code> else <code>U{}</code></td></tr><tr><td style="text-align:left; vertical-align:top">following-sibling, preceding-sibling, following, preceding</td><td style="text-align:left; vertical-align:top">if <var>CIT</var> is <code>U{document-node()}</code> then <code>U{}</code> else <code>U{element(), text(), comment(), processing-instruction()}</code></td></tr><tr><td style="text-align:left; vertical-align:top">parent, ancestor</td><td style="text-align:left; vertical-align:top">if <var>CIT</var> is <code>U{document-node()}</code> then <code>U{}</code> else <code>U{element(), document-node()}</code></td></tr><tr><td style="text-align:left; vertical-align:top">ancestor-or-self</td><td style="text-align:left; vertical-align:top">the union of <var>K(ancestor, CIT)</var> and <var>CIT</var></td></tr><tr><td style="text-align:left; vertical-align:top">descendant-or-self</td><td style="text-align:left; vertical-align:top">the union of <var>K(descendant, CIT)</var> and <var>CIT</var></td></tr></tbody></table><p>Let <code>T(NT)</code> be the set of node kinds that are capable of satisfying a <code>NodeTest</code><var>NT</var>, defined by the following table:</p><table style="border:1px solid; padding:5px; width:100%"><thead><tr><th style="text-align:left; vertical-align:top">NodeTest</th><th style="text-align:left; vertical-align:top">Possible Node Kinds</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top"><code>AnyKindTest</code> (that is, <code>node()</code>)</td><td style="text-align:left; vertical-align:top"><var>U{N}</var> (that is, any node)</td></tr><tr><td style="text-align:left; vertical-align:top">Any other <code>KindTest</code></td><td style="text-align:left; vertical-align:top">The corresponding <a title="U-type" class="termref" href="#dt-utype">U-type</a> (for example, <code>U{text()}</code> for the <code>KindTest</code><code>text()</code>)</td></tr><tr><td style="text-align:left; vertical-align:top">NameTest</td><td style="text-align:left; vertical-align:top">The <a title="U-type" class="termref" href="#dt-utype">U-type</a> corresponding to the principal node kind of the specified axis</td></tr></tbody></table><p>The static type of an <code>AxisStep</code> with axis <var>A</var> and node test <code>NT</code>, given a context item type <var>CIT</var>, is then defined to be the intersection of <code>K(A, CIT)</code> with <code>T(NT)</code>.</p></div><div class="div3"><h4><a id="static-type-of-current-function"></a>19.1.2 <a href="#static-type-of-current-function" style="text-decoration: none">Static Type of a Call to </a><code>current</code></h4><p>The rules in this section define the static type of a call to the <a href="#func-current"><code>current</code></a> function.</p><ol class="enumar"><li><p>If the call is within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, the static type of the function call is the <a title="match type" class="termref" href="#dt-match-type">match type</a> of the pattern.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no circularity in this definition: a call to <a href="#func-current"><code>current</code></a> in a pattern can only appear within a predicate, and the match type of a pattern never depends on anything appearing in a predicate.</p></div></li><li><p>Otherwise (the function call is within an XPath expression), the static type of the function call is the <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> that applies to the outermost containing XPath expression, determined by the rules in <a href="#determining-context-item-type"><i>19.2 Determining the Context Item Type</i></a>. </p></li></ol></div><div class="div3"><h4><a id="notes-on-schema-aware-analysis"></a>19.1.3 <a href="#notes-on-schema-aware-analysis" style="text-decoration: none">Schema-Aware Streamability Analysis</a></h4><div class="note"><p class="prefix"><b>Note:</b></p><p>The streamability analysis in this chapter is not schema-aware. There are cases where use of schema type information might enable a processor to determine that a construct is streamable when it would be unable to make this determination otherwise. Two examples:</p><ul><li><p>A processor might decide that a construct such as <code>price + salesTax</code> is streamable if both the child elements have a simple type such as <code>xs:decimal</code>, or if the order in which they appear in the input document is known.</p></li><li><p>A processor might decide that a step using the descendant axis, such as <code>.//title</code>, has <a title="striding" class="termref" href="#dt-striding">striding</a> rather than <a title="crawling" class="termref" href="#dt-crawling">crawling</a><a title="posture" class="termref" href="#dt-posture">posture</a> if it can establish that two <code>title</code> elements will never be nested (that is, a <code>title</code> cannot contain another <code>title</code>). This would allow the instruction <code>&lt;xsl:apply-templates select=".//title"/&gt;</code> to be used in a streaming template rule.</p></li></ul><p>Although such constructs are not guaranteed streamable according to this specification, there is nothing to prevent a processor providing a streamed implementation if it is able to do so.</p></div></div></div><div class="div2"><h3><a id="determining-context-item-type"></a>19.2 <a href="#determining-context-item-type" style="text-decoration: none">Determining the Context Item Type</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-item-type" title="context item type"></a>For every expression, it is possible to establish by static analysis, information about the item type of the context item for evaluation of that expression. This is called the <b>context item type</b> of the expression.<span class="definition">]</span></p><p>The <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> of an expression is a <a title="U-type" class="termref" href="#dt-utype">U-type</a>.</p><p>The semantics of every <a title="construct" class="termref" href="#dt-construct">construct</a>, defined in this specification or in the XPath specification, describe how the <a title="focus" class="termref" href="#dt-focus">focus</a> for evaluating each <a title="operand" class="termref" href="#dt-operand">operand</a> of the construct is determined. In most cases the focus is the same as that of the parent construct. In some cases the focus is determined by evaluating some other expression, for example in the expressions <code>A/B</code>, <code>A!B</code>, or <code>A[B]</code>, the focus for evaluating <var>B</var> is <var>A</var>. More generally:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-focus-changing-construct" title="focus-changing construct"></a>A <b>focus-changing construct</b> is a <a title="construct" class="termref" href="#dt-construct">construct</a> that has one or more <a title="operand" class="termref" href="#dt-operand">operands</a> that are evaluated with a different <a title="focus" class="termref" href="#dt-focus">focus</a> from the parent construct.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Examples of focus-changing constructs include the instructions <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a>, and <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>; path expressions, filter expressions, and simple mapping expressions; and all patterns.</p></div></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-controlling-operand" title="controlling operand"></a>Within a <a title="focus-changing construct" class="termref" href="#dt-focus-changing-construct">focus-changing construct</a> there is in many cases one <a title="operand" class="termref" href="#dt-operand">operand</a> whose value determines the <a title="focus" class="termref" href="#dt-focus">focus</a> for evaluating other operands; this is referred to as the <b>controlling operand</b>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, the controlling operand of an <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a>, or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is the expression in its <code>select</code> attribute; the controlling operand of a filter expression <code>E[P]</code> is <code>E</code>, and the controlling operand of a simple mapping expression <code>A!B</code> is <code>A</code>.</p></div></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-controlled-operand" title="controlled operand"></a>Within a <a title="focus-changing construct" class="termref" href="#dt-focus-changing-construct">focus-changing construct</a> there are one or more <a title="operand" class="termref" href="#dt-operand">operands</a> that are evaluated with a <a title="focus" class="termref" href="#dt-focus">focus</a> determined by the <a title="controlling operand" class="termref" href="#dt-controlling-operand">controlling operand</a> (or in some cases such as <a href="#element-on-completion"><code>xsl:on-completion</code></a>, with an <a title="absent" class="termref" href="#dt-absent">absent</a><a title="focus" class="termref" href="#dt-focus">focus</a>); these are referred to as <b>controlled operands</b>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, the main controlled operand of an <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a>, or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is the contained sequence constructor; the controlled operand of a filter expression <code>E[P]</code> is <code>P</code>, and the controlled operand of a simple mapping expression <code>A!B</code> is <code>B</code>.</p></div></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-focus-setting-container" title="focus-setting container"></a>The <b>focus-setting container</b> of a construct <var>C</var> is the innermost <a title="focus-changing construct" class="termref" href="#dt-focus-changing-construct">focus-changing construct</a><var>F</var> (if one exists) such that <var>C</var> is directly or indirectly contained in a <a title="controlled operand" class="termref" href="#dt-controlled-operand">controlled operand</a> of <var>F</var>. If there is no such construct <var>F</var>, then the focus-setting container is the containing <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, for example an <a href="#element-function"><code>xsl:function</code></a> or <a href="#element-template"><code>xsl:template</code></a> element.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, if an instruction appears as a child of <a href="#element-for-each"><code>xsl:for-each</code></a>, then its focus-setting container is the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction; if an expression appears within the predicate of a filter expression, its focus-setting container is the filter expression.</p></div></li></ul><p>The <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> of a construct <var>C</var> is the first of the following that applies:</p><ol class="enumar"><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is an <a href="#element-function"><code>xsl:function</code></a> element, an inline function declaration, or an <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, then the context item type is <code>U{}</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is essentially an error case; expressions that depend on the focus should not normally appear within a construct that sets the focus to <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></div></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, then the context item type is <code>U{document-node()}</code>.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, then the context item type is the <a title="match type" class="termref" href="#dt-match-type">match type</a> of the match pattern of the template rule, defined below.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is a <code>PredicatePattern</code>, then the context item type is <code>U{*}</code>.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> is a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> declaration, the context item type is determined by the <code>type</code> attribute of the <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration, defaulting to <code>U{*}</code>, or <code>U{}</code> if the <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration specifies <code>use="absent"</code>.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> is any other <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, for example <a href="#element-key"><code>xsl:key</code></a> or <a href="#element-accumulator"><code>xsl:accumulator</code></a>, the context item type is <code>U{*}</code>.</p></li><li><p>Otherwise, the context item type is the <a title="static type" class="termref" href="#dt-static-type">static type</a> (see <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>) of the <a title="controlling operand" class="termref" href="#dt-controlling-operand">controlling operand</a> of the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var>.</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-match-type" title="match type"></a>The <b>match type</b> of a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> is the most specific <a title="U-type" class="termref" href="#dt-utype">U-type</a> that is known to match all items that the pattern can match.<span class="definition">]</span> The match type of a pattern is the inferred <a title="static type" class="termref" href="#dt-static-type">static type</a> of the pattern’s equivalent expression, determined according to the rules in <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>. For example, the match type of the pattern <code>para[1]</code> is <code>U{element()}</code>, while that of the pattern <code>@code[.='x']</code> is <code>U{attribute()}</code></p></div><div class="div2"><h3><a id="operand-roles"></a>19.3 <a href="#operand-roles" style="text-decoration: none">Operand Roles</a></h3><p>An <a title="operand role" class="termref" href="#dt-operand-role">operand role</a> gives information about the <a title="operand" class="termref" href="#dt-operand">operands</a> of a particular kind of construct. The two important properties of an operand role are the required type and the operand usage.</p><p>The <a title="operand usage" class="termref" href="#dt-operand-usage">usage</a> of an operand role is relevant only when the value of an <a title="operand" class="termref" href="#dt-operand">operand</a> supplied in that role is a node, or a sequence that contains nodes. It is one of the following:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-absorption" title="absorption"></a>An operand usage of <b>absorption</b> indicates that the construct reads the subtree(s) rooted at a supplied node(s).<span class="definition">]</span> Examples are constructs that atomize their <a title="operand" class="termref" href="#dt-operand">operands</a>, or that obtain the string value of a supplied node, or that copy the supplied node to a new tree. Another example is the <a href="https://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup> function, which compares the subtrees rooted at the nodes supplied in its first two arguments.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-inspection" title="inspection"></a>An operand usage of <b>inspection</b> indicates that the construct accesses properties of a supplied node that are available without reading its subtree.<span class="definition">]</span> Examples are functions such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-name"><code>name</code></a><sup><small>FO30</small></sup> and <a href="https://www.w3.org/TR/xpath-functions-30/#func-base-uri"><code>base-uri</code></a><sup><small>FO30</small></sup>, and the <code>instance of</code> expression which tests the type of a node (or other item), or functions such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-boolean"><code>boolean</code></a><sup><small>FO30</small></sup> which are only interested in the existence of the node, and not in its properties.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-transmission" title="transmission"></a>An operand usage of <b>transmission</b> indicates that the construct will (potentially) return a supplied node as part of its result to the calling construct (that is, to its parent in the construct tree).<span class="definition">]</span> It also indicates that document order is preserved: if the input is in document order, then the result must be in document order. An example is a filter expression, where nodes in the base expression (the expression being filtered) will typically appear in the result of the filter expression, in their original order.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-navigation" title="navigation"></a>An operand usage of <b>navigation</b> indicates that the construct may navigate freely from the supplied node to other nodes in the same tree, in a way that is not constrained by the streamability rules.<span class="definition">]</span> This covers several cases: cases where it is known that the construct performs impermissible navigation (for example, the <a href="#element-number"><code>xsl:number</code></a> instruction) or reordering (the <a href="https://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup> function), or that require look-ahead (the <a href="https://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup> function) and also cases where the analysis is unable to determine what use is made of the node, for example because it is passed as an argument to a user-defined function, or retained in a variable.</p></li></ul><p>The concept of operand usage is not used for all constructs (for example, it is not used in the analysis of path expressions). Where it is used, the assignment of operand usages to each operand role of a construct is defined in <a href="#classifying-constructs"><i>19.8 Classifying Constructs</i></a>.</p><div class="div3"><h4><a id="operand-usage-examples"></a>19.3.1 <a href="#operand-usage-examples" style="text-decoration: none">Examples showing the Effect of Operand Usage</a></h4><div class="example"><div class="exampleHeader"><a id="d8e41371"></a><a id="d8e41480"></a>Example: The Effect of Operand Usage on the Streamability of a Context Item Expression</div><p>Consider the following construct:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">emps.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">*</span><span class="step">/</span><span class="qname">emp</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>To assess the streamability, we follow the following logic:</p><ol class="enumar"><li><p>The top-level construct is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. It is evaluated with a document node as the context item, and with a <a title="striding" class="termref" href="#dt-striding">striding</a> posture.</p></li><li><p>The sequence constructor has one child <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, which has an <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of <a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p></li><li><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction evaluates its <code>select</code> expression, with the context item and <a title="posture" class="termref" href="#dt-posture">posture</a> unchanged.</p></li><li><p>The step <code>child::*</code> is evaluated with this context item and posture. The posture transition rules permit this; we now have a sequence of child elements, and still a <a title="striding" class="termref" href="#dt-striding">striding</a> posture.</p></li><li><p>The same applies to the next step, <code>child::emp</code></p></li><li><p>The content of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> which itself has a single <a title="operand" class="termref" href="#dt-operand">operand</a>, the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction.</p></li><li><p>The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is evaluated once for each <code>emp</code> child, with that child as context item and in a <a title="striding" class="termref" href="#dt-striding">striding</a> posture. This instruction uses the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the <code>select</code> expression is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>. This means that the result of the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The result of the trivial sequence constructor contained in the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is therefore <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a></p></li><li><p>The result of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction (see <a href="#streamability-xsl-for-each"><i>19.8.4.18 Streamability of xsl:for-each</i></a>) is therefore <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a></p></li><li><p>The result of the trivial sequence constructor contained in the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is therefore <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a></p></li><li><p>The <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is therefore <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p></li></ol><p>Now consider a slightly different construct:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">emps.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">*</span><span class="step">/</span><span class="qname">emp</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>To assess the streamability, we follow the following logic:</p><ol class="enumar"><li><p>The top-level construct is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. It is evaluated with a document node as the context item, and with a <a title="striding" class="termref" href="#dt-striding">striding</a> posture.</p></li><li><p>The sequence constructor has one child <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, which has an <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of <a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p></li><li><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction evaluates its <code>select</code> expression, with the context item and <a title="posture" class="termref" href="#dt-posture">posture</a> unchanged.</p></li><li><p>The step <code>child::*</code> is evaluated with this context item and posture. The posture transition rules permit this; we now have a sequence of child elements, and still a <a title="striding" class="termref" href="#dt-striding">striding</a> posture.</p></li><li><p>The same applies to the next step, <code>child::emp</code></p></li><li><p>The content of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> which itself has a single operand, the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction.</p></li><li><p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is evaluated once for each <code>emp</code> child, with that child as context item and in a <a title="striding" class="termref" href="#dt-striding">striding</a> posture. This instruction uses the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the <code>select</code> expression is <a title="transmission" class="termref" href="#dt-transmission">transmission</a>. This means that the result of the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>The result of the trivial sequence constructor contained in the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is therefore also <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>The result of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction (see <a href="#streamability-xsl-for-each"><i>19.8.4.18 Streamability of xsl:for-each</i></a>) is therefore <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a> (the wider of the sweeps of the <code>select</code> expression and the sequence constructor).</p></li><li><p>The result of the trivial sequence constructor contained in the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is therefore <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>Since the result is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is therefore not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p></li></ol><p>Expressed informally, the result of a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a><a href="#element-source-document"><code>xsl:source-document</code></a> instruction (or of a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> template rule) must not contain streamed nodes. The reason for this is that once streamed nodes are returned to constructs that are not declared streamable and therefore have no streamability constraints, there is no way to analyze what happens to them, and thus to guarantee streamability.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e41604"></a><a id="d8e41713"></a>Example: The Effect of Operand Roles on the Streamability of Path Expressions</div><p>Consider the expression <code>.//chapter</code>.</p><p>When this appears as an argument to the function <a href="https://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>, it can be streamed (it is a <a title="consuming" class="termref" href="#dt-consuming">consuming</a> expression, meaning that the subtree rooted at the context item needs to be read in order to evaluate the expression). A possible strategy for performing a streamed evaluation is to read all descendants of the context item in document order, checking each one to see whether its name is <code>chapter</code>. The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the expression will be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, and its <a title="posture" class="termref" href="#dt-posture">posture</a> will be <a title="crawling" class="termref" href="#dt-crawling">crawling</a>.</p><p>The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> (the usage of the argument to <a href="https://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-exists"><code>exists</code></a><sup><small>FO30</small></sup>) is defined as <a title="inspection" class="termref" href="#dt-inspection">inspection</a>. The <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> show that when the posture of an <a title="operand" class="termref" href="#dt-operand">operand</a> is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, the resulting expression is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. This means that (in the absence of other consuming expressions) the containing template or function will generally be streamable.</p><p>In the expression <code>tail(.//chapter)</code>, the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is classified as <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, meaning that the nodes are simply passed up the tree to the next containing expression. In general, when a <a title="crawling" class="termref" href="#dt-crawling">crawling</a> expression is passed as an argument and the operand role is <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, the containing expression will also be <a title="crawling" class="termref" href="#dt-crawling">crawling</a>. However, there is an exception where the expression is known to deliver a singleton (for example, <code>head(.//chapter)</code>). In this case the returned sequence cannot contain any nested nodes, so it is <a title="crawling" class="termref" href="#dt-crawling">crawling</a>.</p><p>When the same expression appears as an argument to an atomizing function <a href="https://www.w3.org/TR/xpath-functions-30/#func-string-join"><code>string-join</code></a><sup><small>FO30</small></sup>, the processor knows that it will need to access the subtree of each selected <code>section</code> element in order to compute the result of the function (the argument to <a href="https://www.w3.org/TR/xpath-functions-30/#func-string-join"><code>string-join</code></a><sup><small>FO30</small></sup> is classified as having <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="absorption" class="termref" href="#dt-absorption">absorption</a>). The processor does not know whether these subtrees will be nested (one <code>section</code> might contain another). In most cases they will not be nested, because atomizing a sequence that contains nested nodes is not generally a useful thing to do. The streamability analysis therefore makes an optimistic assumption, by treating atomization of a <a title="crawling" class="termref" href="#dt-crawling">crawling</a> expression as a streamable operation. In the worst case, where it turns out that the selected nodes are indeed nested, the processor must handle this, typically by buffering the content of inner nodes until the end tag of the outer nodes is reached.</p><p>This treatment of nodes in a <a title="crawling" class="termref" href="#dt-crawling">crawling</a> expression applies to all cases in which the content of the nodes is handled in a way defined entirely by the rules of this specification: for example, operations such as atomization, obtaining the string value of nodes, deep copy of nodes, and the <a href="https://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup> function. It does not extend to cases where the processing applied to the nodes is user-defined: for example, operations such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>. In these cases, the nodes selected for processing must not be nested (a <a title="crawling" class="termref" href="#dt-crawling">crawling</a><a title="posture" class="termref" href="#dt-posture">posture</a> is not permitted in these contexts).</p><p>When a <a title="crawling" class="termref" href="#dt-crawling">crawling</a> expression appears as an argument to a call on a user-defined function, the effect depends on the <a title="streamability category" class="termref" href="#dt-streamability-category">streamability category</a> of the function, as described in <a href="#streamable-stylesheet-functions"><i>19.8.5 Classifying Stylesheet Functions</i></a>.</p></div></div></div><div class="div2"><h3><a id="posture"></a>19.4 <a href="#posture" style="text-decoration: none">Determining the Posture of a Construct</a></h3><p>The <b>posture</b> of a construct indicates the relationship of the nodes selected by the <a title="construct" class="termref" href="#dt-construct">construct</a> to a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed input document</a>. The value is one of the following:</p><ul><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-grounded" title="grounded"></a><b>Grounded</b>: indicates that the value returned by the construct does not contain nodes from the streamed input document<span class="definition">]</span>. Atomic values and function items are always grounded; nodes are grounded if it is known that they are in a non-streamed document. For example the expressions <code>doc('x')</code> and <code>copy-of(.)</code> both return grounded nodes.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-climbing" title="climbing"></a><b>Climbing</b>: indicates that streamed nodes returned by the construct are reached by navigating the parent, ancestor[-or-self], attribute, and/or namespace axes from the node at the current streaming position.<span class="definition">]</span> When the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is climbing, use of certain axes such as <code>parent</code> and <code>ancestor</code> is permitted, but use of other axes such as <code>child</code> or <code>descendant</code> violates the streamability rules.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-crawling" title="crawling"></a><b>Crawling</b>: typically indicates that streamed nodes returned by a construct are reached by navigating the descendant[-or-self] axis.<span class="definition">]</span> Nodes reached in this way are potentially nested (one might be an ancestor of another), so further downward navigation is not permitted. Expressions that can be statically determined to return a singleton node (for example <code>head(.//title)</code>) generate a result with no such nesting, so they are striding rather than crawling.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-striding" title="striding"></a><b>Striding</b>: indicates that the result of a construct contains a sequence of streamed nodes, in document order, that are peers in the sense that none of them is an ancestor or descendant of any other.<span class="definition">]</span> This is typically achieved by using one or more steps involving the child or attribute axes only. Use of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-outermost"><code>outermost</code></a><sup><small>FO30</small></sup> function can also result in a striding posture, as can functions such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-head"><code>head</code></a><sup><small>FO30</small></sup> or <a href="https://www.w3.org/TR/xpath-functions-30/#func-zero-or-one"><code>zero-or-one</code></a><sup><small>FO30</small></sup> that ensure the result will be a singleton node.</p></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-roaming" title="roaming"></a><b>Roaming</b>: indicates that the nodes returned by an expression could be anywhere in the tree, which inevitably means that the construct cannot be evaluated using streaming.<span class="definition">]</span> For example, the <a title="posture" class="termref" href="#dt-posture">posture</a> of an axis step using the <code>following</code> or <code>preceding</code> axis will typically be <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, which leads the analysis to conclude that the construct is not streamable.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>One way to think about the posture values is as labels for states in a finite state automaton, where the alphabet of symbols accepted by the automaton is the set of 13 XPath axes, and the sentence being parsed is a path expression containing a sequence of axis steps. For example, use of the <code>descendant</code> axis when the current state is <b>striding</b> moves the new state to <b>crawling</b>, and use of the <code>parent</code> axis then takes it to <b>climbing</b>. </p></div><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of a construct is determined in one of several ways:</p><ul><li><p>For axis steps, the posture of the expression is determined by the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> and the choice of axis. For example, an axis step using the ancestor axis always has a posture of <a title="climbing" class="termref" href="#dt-climbing">climbing</a>, while an axis step using the child axis, if the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>, will itself have a posture of <a title="striding" class="termref" href="#dt-striding">striding</a>. The rules for the posture transitions produced by axis steps are given in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>.</p></li><li><p>For many other constructs, the posture is determined by the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. These determine the result posture in terms of the <a title="operand" class="termref" href="#dt-operand">operands</a> of the construct and the way in which each operand is used. For example, a construct that accepts a streamed node as the value of an operand, and atomizes that node, will generally have a posture of <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>Other constructs have their own special rules, which are all listed in this chapter. For example, a call on the <a href="https://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup> function behaves analogously to an axis step, and is described in <a href="#streamability-fn-root"><i>19.8.9.18 Streamability of the root Function</i></a>. Special rules are needed for:</p><ul><li><p>Constructs that evaluate an <a title="operand" class="termref" href="#dt-operand">operand</a> more than once, such as an XPath <code>for</code> expression;</p></li><li><p>Constructs that have alternatives among their operands, such as an XPath <code>if</code> expression;</p></li><li><p>Constructs that navigate relative to the context item, such as axis steps;</p></li><li><p>Constructs with implicit inputs, such as the context item expression <code>.</code> (dot);</p></li><li><p>Constructs that change the focus, such as a filter expression;</p></li><li><p>Constructs that invoke functions or templates.</p></li></ul></li></ul><p>The characterization of an expression as striding, crawling, climbing, or roaming applies only to the streamed nodes in the result of the expression. The result of the expression may also contain non-streamed (grounded) nodes or atomic values. For example if <code>/x/y</code> is a striding expression, then <code>(/x/y | $doc//x)</code> is also striding, given that <code>$doc</code> contains non-streamed nodes. The assertion that the nodes in the result of a striding expression are in document order and are peers thus applies only to the subset of the nodes that are streamed.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A consequence of this is that when striding expressions are used in a context that requires sorting into document order, for example <code>(/x/y | $doc//x) / @price</code>, the fact that the expression is striding does not eliminate the need for the sequence to be re-ordered. However, there will never be a need for the relative order of the streamed nodes in the value to change.</p><p>Since the data model leaves the relative order of nodes in different trees implementation-defined, and since streamed and unstreamed nodes will necessarily be in different trees, a useful implementation strategy might be to arrange that streamed nodes always precede unstreamed nodes in document order (or vice versa). An operation that needs to process the result of a striding expression in document order can then first deliver all the streamed nodes (by consuming the input stream) in the order they arrive, and then deliver the unstreamed nodes, suitably sorted.</p></div></div><div class="div2"><h3><a id="determining-context-posture"></a>19.5 <a href="#determining-context-posture" style="text-decoration: none">Determining the Context Posture</a></h3><p>In the same way as the type of the context item can be determined for any construct C by reference to the type of the construct that establishes the context for the evaluation of C, so the posture of the context item C can be determined by reference to the posture of the construct that establishes the context.</p><p>The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of a construct <var>C</var> is the first of the following that applies:</p><ol class="enumar"><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is an <a href="#element-function"><code>xsl:function</code></a> declaration, an inline function declaration, or an <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, then the context posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is essentially an error case; expressions that depend on the context item should not normally appear within these constructs.</p></div></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, then the context posture is <a title="striding" class="termref" href="#dt-striding">striding</a> if the instruction is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>, or <a title="grounded" class="termref" href="#dt-grounded">grounded</a> otherwise.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> whose mode is declared with <code>streamable="yes"</code>, then the context posture is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, then the context posture is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is an <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration with the attribute <code>streamable="yes"</code>, then the context posture is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> is any other <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, for example a global variable declaration, a <a title="named template" class="termref" href="#dt-named-template">named template</a>, or a template rule or attribute set that does not specify <code>streamable="yes"</code>, then the context posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>.</p></li><li><p>Otherwise, the context posture is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <a title="controlling operand" class="termref" href="#dt-controlling-operand">controlling operand</a> of the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var>.</p></li></ol></div><div class="div2"><h3><a id="sweep"></a>19.6 <a href="#sweep" style="text-decoration: none">The Sweep of a Construct</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-sweep" title="sweep"></a>Every construct has a <b>sweep</b>, which is a measure of the extent to which the current position in the input stream moves during the evaluation of the expression. The sweep is one of: <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, or <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> .<span class="definition">]</span> This list of values is ordered: a <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> expression has <b>wider sweep</b> than a <a title="consuming" class="termref" href="#dt-consuming">consuming</a> expression, which has <b>wider sweep</b> than a <a title="motionless" class="termref" href="#dt-motionless">motionless</a> expression. </p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-motionless" title="motionless"></a>A <b>motionless</b> construct is any <a title="construct" class="termref" href="#dt-construct">construct</a> deemed motionless by the rules in this section (<a href="#streamability"><i>19 Streamability</i></a>).<span class="definition">]</span> Informally, a motionless construct is one that can be evaluated without changing the current position in the input stream.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The context item expression <code>.</code> is classified as motionless; however a construct that uses <code>.</code> as an <a title="operand" class="termref" href="#dt-operand">operand</a> (for example, <code>string(.)</code>) might be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. The streamability rules effectively consider expressions such as <code>.</code> within the context of the containing construct.</p></div><p><span class="definition">[Definition:&nbsp;</span><a id="dt-consuming" title="consuming"></a>A <b>consuming</b> construct is any <a title="construct" class="termref" href="#dt-construct">construct</a> deemed consuming by the rules in this section (<a href="#streamability"><i>19 Streamability</i></a>).<span class="definition">]</span> Informally, a consuming construct is one whose evaluation requires repositioning of the input stream from the start of the current node to the end of the current node.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-free-ranging" title="free-ranging"></a>A <b>free-ranging</b> construct is any <a title="construct" class="termref" href="#dt-construct">construct</a> deemed free-ranging by the rules in this section (<a href="#streamability"><i>19 Streamability</i></a>).<span class="definition">]</span> Informally, a free-ranging construct is one whose evaluation may require access to information that is not available from the subtree rooted at the current node, together with information about ancestors of the current node and their attributes.</p><p>The table below shows some examples of expressions having different combinations of <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a>.</p><table class="data"><caption>Combinations of Sweep and Posture</caption><thead><tr><th style="text-align:left; vertical-align:top"></th><th style="text-align:left; vertical-align:top">Motionless</th><th style="text-align:left; vertical-align:top">Consuming</th><th style="text-align:left; vertical-align:top">Free-Ranging</th></tr></thead><tbody><tr><th style="text-align:left; vertical-align:top">Grounded</th><td style="text-align:left; vertical-align:top"><code>name()</code></td><td style="text-align:left; vertical-align:top"><code>string(title)</code></td><td style="text-align:left; vertical-align:top">See Note</td></tr><tr><th style="text-align:left; vertical-align:top">Climbing</th><td style="text-align:left; vertical-align:top"><code>parent::*</code></td><td style="text-align:left; vertical-align:top"><code>child::x/ancestor::y</code></td><td style="text-align:left; vertical-align:top">See Note</td></tr><tr><th style="text-align:left; vertical-align:top">Striding</th><td style="text-align:left; vertical-align:top"><code>@status</code></td><td style="text-align:left; vertical-align:top"><code>child::*</code></td><td style="text-align:left; vertical-align:top">See Note</td></tr><tr><th style="text-align:left; vertical-align:top">Crawling</th><td style="text-align:left; vertical-align:top">The subexpression <code>.</code> in <code>//a/.</code></td><td style="text-align:left; vertical-align:top"><code>descendant::*</code></td><td style="text-align:left; vertical-align:top"><code>//x[child::y]</code></td></tr><tr><th style="text-align:left; vertical-align:top">Roaming</th><td style="text-align:left; vertical-align:top">See Note</td><td style="text-align:left; vertical-align:top">See Note</td><td style="text-align:left; vertical-align:top"><code>preceding::*</code></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><p>In all cases where either the <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, or the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, or both, the effect is to make an expression non-streamable. For convenience, therefore, evaluation of the streamability rules in most cases returns the values <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> only in combination with each other. In cases where the rules return a <a title="posture" class="termref" href="#dt-posture">posture</a> of <a title="roaming" class="termref" href="#dt-roaming">roaming</a> combined with some other <a title="sweep" class="termref" href="#dt-sweep">sweep</a>, or a <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> with some other <a title="posture" class="termref" href="#dt-posture">posture</a>, the final result of the analysis is always the same as if the expression were both <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><p>For an example of a case where an expression is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> but not <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, consider the right-hand operand of the relative path expression <code>(preceding::x/.)</code>. The rules for the streamability of a context item expression (see <a href="#streamability-of-context-item-expression"><i>19.8.8.13 Streamability of the Context Item Expression</i></a>) give "<code>.</code>" in this context a <a title="roaming" class="termref" href="#dt-roaming">roaming</a> posture, combined with <a title="motionless" class="termref" href="#dt-motionless">motionless</a> sweep. But the relative path expression as a whole is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> (see <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a>), so the apparent inconsistency is transient.</p></div></div><div class="div2"><h3><a id="grounded-consuming-constructs"></a>19.7 <a href="#grounded-consuming-constructs" style="text-decoration: none">Grounded Consuming Constructs</a></h3><p>A construct is grounded if the items it delivers do not include nodes from a streamed document; it is consuming if evaluation of the construct reads nodes from a streamed input in a way that requires advancing the current position in the input. </p><p>Grounded consuming constructs play an important role in streaming, and this section discusses some of their characteristics. </p><p>Examples of grounded consuming constructs (assuming the context item is a streamed node) include: </p><ul><li><p><code>sum(.//transaction/@value)</code></p></li><li><p><code>copy-of(./account/history/event)</code></p></li><li><p><code>distinct-values(./account/@account-nr)</code></p></li><li><p><code>&lt;xsl:for-each select="transaction"&gt;&lt;t&gt;&lt;xsl:value-of select="@value"/&gt;&lt;/t&gt;&lt;/xsl:for-each&gt;</code></p></li></ul><p>XSLT 3.0 provides the two functions <a href="#func-copy-of"><code>copy-of</code></a> and <code>snapshot</code> with the explicit purpose of creating a sequence of grounded nodes, that can be processed one-by-one without the usual restrictions that apply to streamed processing, such as the rule permitting at most one downward selection. The processing style that exploits these functions is often called “windowed streaming”.</p><p>In general the result of a grounded consuming construct is a sequence. Depending on how this sequence is used, it may or may not be necessary for the processor to allocate sufficient memory to hold the entire sequence. The streamability rules in this specification place few constraints on how a grounded sequence is used. This is deliberate, because it gives users control: by creating a grounded sequence (for example, by use of the copy-of function) stylesheet authors create the possibility to process data in arbitrary ways (for example, by sorting the sequence), and accept the possibility that this may consume memory. </p><p>Pipelined evaluation of a sequence is analogous to streamed processing of a source document. Pipelined evaluation occurs when the items in a sequence can be processed one-by-one, without materializing the entire sequence in memory. Pipelining is a common optimization technique in all functional programming languages. Operations for which pipelined evaluation is commonly performed include filtering (<code>$transactions[@value gt 1000]</code>), mapping (<code>$transactions!(@value - @processing-fee)</code>), and aggregation (<code>sum($transactions)</code>). Operations that cannot be pipelined (because, for example, the first item in the result sequence cannot be computed without knowing the last item in the input sequence) include those that change the order of items (<code>reverse()</code>, <code>sort()</code>). Other operations such as <code>distinct-values()</code> allow the input to be processed one item at a time, but require memory that potentially increases as the sequence length increases. Saving a grounded sequence in a variable is also likely in many cases to require allocation of memory to hold the entire sequence. </p><p>When the input to an operation is a grounded consuming sequence (more accurately, a sequence resulting from the evaluation of a grounded consuming construct), this specification does not attempt to dictate whether the operation is pipelined or not. The goal of interoperable streaming in finite memory can therefore only be achieved if stylesheet authors take care to avoid constructing grounded sequences that occupy large amounts of memory. In practice, however, users can expect that many grounded consuming constructs will be pipelined where the semantics permit this. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Some processors may recognize an opportunity for pipelining only if the expression is written in a particular way. For example the constructs <code>copy-of(/a/b/c)</code> and <code>/a/b/c/copy-of(.)</code> are to all intents and purposes equivalent, but some processors might recognize the second form more easily as suitable for pipelining.</p><p>(There is one minor difference between these expressions: the order of nodes in <code>copy-of(/a/b/c)</code> is required to reflect the document order of the nodes in <code>/a/b/c</code>, while the result of <code>/a/b/c/copy-of(.)</code> can be in any order, in consequence of the rule that document order for nodes in different trees is implementation-dependent.)</p></div><p>The use of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> function requires particular care because of its effect on pipelining. The streamability rules prevent the use of <code>last()</code> in conjunction with an expression that returns streamed nodes (because it would require look-ahead in the stream), but there is no similar constraint for grounded sequences. So for example it is not permitted (in a context that requires streaming) to write </p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transaction</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"> of </span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="function">last</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>but it is quite permissible to write</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transaction</span><span class="step">/</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"> of </span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="function">last</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>because the call on <a href="#func-copy-of"><code>copy-of</code></a> makes the sequence grounded. This construct cannot be pipelined because computing the first item in the result sequence depends on knowing the length of the input sequence; in consequence, a processor might be obliged to buffer all the transactions (or their copies) in memory. In this simple example the impact of the call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> is easily detected both by the human reader and by the XSLT processor, but there are other cases where the effect is less obvious. For example if the stylesheet executes the instruction </p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transaction</span><span class="step">/</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>then the presence of a call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> in one of the template rules that gets invoked might not be easily spotted; yet the effect is exactly the same in preventing the result being computed by processing input items strictly one at a time. Avoiding such effects is entirely the responsibility of the stylesheet author. </p><p>By contrast, there is no intrinsic reason why use of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup> should prevent pipelined processing: all it requires is for the processor to count how many items have been processed so far. Processors may also be able to handle the construct <code>position() = last()</code> without storing the entire sequence in memory; rather than actually evaluating the numeric values of <code>position()</code> and <code>last()</code>, this can be done by testing whether the context item is the last item in the sequence, which only requires a one-item lookahead.</p></div><div class="div2"><h3><a id="classifying-constructs"></a>19.8 <a href="#classifying-constructs" style="text-decoration: none">Classifying Constructs</a></h3><p>This section defines the properties of every kind of <a title="construct" class="termref" href="#dt-construct">construct</a> that may appear in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. It identifies the <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usage</a>, and it gives the rules that define the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the construct. In cases where the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply, there is still an entry for the construct in order to define its <a title="operand" class="termref" href="#dt-operand">operands</a> and their usages, since this information is needed by the general rules.</p><p>The following sections describe this categorization for each kind of construct:</p><ul><li><p>Sequence constructors: see <a href="#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence Constructors</i></a></p></li><li><p>Instructions: see <a href="#classifying-instructions"><i>19.8.4 Classifying Instructions</i></a></p></li><li><p>Stylesheet functions: see <a href="#streamable-stylesheet-functions"><i>19.8.5 Classifying Stylesheet Functions</i></a></p></li><li><p>Attribute sets: see <a href="#classifying-attribute-sets"><i>19.8.6 Classifying Attribute Sets</i></a></p></li><li><p>Value templates: see <a href="#classifying-vts"><i>19.8.7 Classifying Value Templates</i></a></p></li><li><p>Expressions: see <a href="#classifying-expressions"><i>19.8.8 Classifying Expressions</i></a></p></li><li><p>Patterns: see <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a></p></li><li><p>Calls to built-in functions: see <a href="#classifying-built-in-functions"><i>19.8.9 Classifying Calls to Built-In Functions</i></a></p></li></ul><div class="div3"><h4><a id="general-streamability-rules"></a>19.8.1 <a href="#general-streamability-rules" style="text-decoration: none">General Rules for Streamability</a></h4><p><span class="definition">[Definition:&nbsp;</span><a id="dt-general-streamability-rules" title="general streamability rules"></a>Many <a title="construct" class="termref" href="#dt-construct">constructs</a> share the same streamability rules. These rules, referred to as the <b>general streamability rules</b>, are defined here.<span class="definition">]</span></p><p>Examples of constructs that use these rules are: an arithmetic expression, an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction, and a call to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function.</p><p>The rules determine both the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a construct. To determine the posture and sweep of a construct <var>C</var>, assuming these general rules are applicable to that kind of construct:</p><ol class="enumar"><li><p>For each <a title="operand" class="termref" href="#dt-operand">operand</a> of <var>C</var>:</p><ol class="enumla"><li><p>Establish:</p><ol class="enumlr"><li><p>The <a title="static type" class="termref" href="#dt-static-type">static type</a><var>T</var> of the operand (see <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>). </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The static type is a <a title="U-type" class="termref" href="#dt-utype">U-type</a>. For example, the static type of the expression <code>(@*, *)</code> is <var>U{element(), attribute()}</var>.</p></div></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var> and <a title="posture" class="termref" href="#dt-posture">posture</a><var>P</var> of the operand (by applying the rules in this section <a href="#classifying-constructs"><i>19.8 Classifying Constructs</i></a> to that operand, recursively).</p></li><li><p>The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><var>U</var> corresponding to the <a title="operand role" class="termref" href="#dt-operand-role">role</a> of the operand within <var>C</var> (from the information in this section <a href="#classifying-constructs"><i>19.8 Classifying Constructs</i></a>).</p></li></ol></li><li><p>Compute the adjusted sweep <var>S′</var> of the <a title="operand" class="termref" href="#dt-operand">operand</a> by taking the first of the following that applies:</p><ol class="enumlr"><li><p>If <var>S</var> is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> or <var>P</var> is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, then <var>S′</var> is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. (In this case the posture and sweep of <var>C</var> are <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, regardless of any other operands.)</p></li><li><p>If <var>P</var> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then <var>S′</var> is <var>S</var>.</p></li><li><p>Otherwise (<var>P</var> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, which implies that the <a title="operand" class="termref" href="#dt-operand">operand</a> is capable of returning streamed nodes), compute <var>S′</var> as follows:</p><ol class="enumua"><li><p>Compute the adjusted usage <var>U′</var> as follows:</p><ol class="enumur"><li><p>If <var>U</var> is <a title="absorption" class="termref" href="#dt-absorption">absorption</a> and the intersection of <var>T</var> with <var>U{element(), document-node()}</var> is <var>U{}</var> (that is, if <var>T</var> is a type that does not allow nodes with children), then <var>U′</var> is <a title="inspection" class="termref" href="#dt-inspection">inspection</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is because the entire subtree of nodes such as text nodes is available without reading further data from the input stream.</p></div></li><li><p>Otherwise, <var>U′</var> is <var>U</var>.</p></li></ol></li><li><p>Compute the adjusted <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S′</var> from the table below:</p><table class="data"><caption>Computing the Adjusted Sweep of an Expression</caption><thead><tr><th style="text-align:left; vertical-align:top" rowspan="2">Posture (P)</th><th style="text-align:left; vertical-align:top" colspan="4">Adjusted Usage (U')</th></tr><tr><th style="text-align:left; vertical-align:top">Absorption</th><th style="text-align:left; vertical-align:top">Inspection</th><th style="text-align:left; vertical-align:top">Transmission</th><th style="text-align:left; vertical-align:top">Navigation</th></tr></thead><tbody><tr><th style="text-align:left; vertical-align:top">Climbing</th><td style="text-align:left; vertical-align:top">Free-ranging</td><td style="text-align:left; vertical-align:top"><var>S</var></td><td style="text-align:left; vertical-align:top"><var>S</var></td><td style="text-align:left; vertical-align:top">Free-ranging</td></tr><tr><th style="text-align:left; vertical-align:top">Striding</th><td style="text-align:left; vertical-align:top">Consuming</td><td style="text-align:left; vertical-align:top"><var>S</var></td><td style="text-align:left; vertical-align:top"><var>S</var></td><td style="text-align:left; vertical-align:top">Free-ranging</td></tr><tr><th style="text-align:left; vertical-align:top">Crawling</th><td style="text-align:left; vertical-align:top">Consuming</td><td style="text-align:left; vertical-align:top"><var>S</var></td><td style="text-align:left; vertical-align:top"><var>S</var></td><td style="text-align:left; vertical-align:top">Free-ranging</td></tr></tbody></table></li></ol></li></ol></li><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-potentially-consuming" title="potentially consuming"></a>An <a title="operand" class="termref" href="#dt-operand">operand</a> is <b>potentially consuming</b> if at least one of the following conditions applies:</p><ol class="enumlr"><li><p>The operand’s adjusted <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S′</var> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is <a title="transmission" class="termref" href="#dt-transmission">transmission</a> and the operand is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li></ol><p>]</p></li></ol></li><li><p>Having computed the adjusted sweep <var>S′(o)</var> of each <a title="operand" class="termref" href="#dt-operand">operand</a><var>o</var>, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>C</var> are the first of the following that applies:</p><ol class="enumla"><li><p>If <var>C</var> has no operands, then <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>If any operand <var>o</var> has an adjusted sweep <var>S′(o)</var> of <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If more than one operand is <a title="potentially consuming" class="termref" href="#dt-potentially-consuming">potentially consuming</a>, then:</p><ol class="enumlr"><li><p>If all these operands form part of a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> of <var>C</var> is the <a title="combined posture" class="termref" href="#dt-combined-posture">combined posture</a> of the operands in this group, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>C</var> is the widest <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the operands in this group</p></li><li><p>If all these operands have <var>S′</var> = <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, (which necessarily means they have <var>U′</var> = <var>U</var> = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>) and if they all have the same <a title="posture" class="termref" href="#dt-posture">posture</a><var>P<sub>0</sub></var>, then <a title="motionless" class="termref" href="#dt-motionless">motionless</a> with <a title="posture" class="termref" href="#dt-posture">posture</a><var>P<sub>0</sub></var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, the expression <code>(@a, @b)</code> is motionless and striding.</p></div></li><li><p>Otherwise, <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li></ol></li><li><p>If exactly one operand <var>o</var> is <a title="potentially consuming" class="termref" href="#dt-potentially-consuming">potentially consuming</a>, then:</p><ol class="enumlr"><li><p>If <var>o</var> is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of <var>C</var>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of <var>o</var> is <a title="absorption" class="termref" href="#dt-absorption">absorption</a> or <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, then <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>If the <a title="posture" class="termref" href="#dt-posture">posture</a> of <var>o</var> is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and <var>C</var> is a function call of a built-in function whose signature indicates a return type with a maximum cardinality of one then <a title="striding" class="termref" href="#dt-striding">striding</a> and the adjusted <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>o</var>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Although this rule is written in general terms, the only functions that it applies to (at the time of publication) are <a href="https://www.w3.org/TR/xpath-functions-30/#func-head"><code>head</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-exactly-one"><code>exactly-one</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-zero-or-one"><code>zero-or-one</code></a><sup><small>FO30</small></sup>. This rule only applies if the argument usage is transmission (other cases having been handled by earlier rules); of the built-in functions, the three functions listed are the only ones having an argument with usage transmission and a return type with maximum cardinality one.</p></div></li><li><p>Otherwise (the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of <var>o</var> is <a title="transmission" class="termref" href="#dt-transmission">transmission</a>), the <a title="posture" class="termref" href="#dt-posture">posture</a> and adjusted <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>o</var>.</p></li></ol></li><li><p>Otherwise (all operands are <a title="motionless" class="termref" href="#dt-motionless">motionless</a>) <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The rules ensure that if more than one <a title="operand" class="termref" href="#dt-operand">operand</a> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, that is, if more than one operand reads the subtree of the context node in a way that would cause the current position of the input stream to change, then the construct is not streamable.</p><p>The rules also prevent multiple streamed nodes being returned in the result of an expression if they are delivered by different operands. For example, the expression <code>count((.., *))</code> is not guaranteed streamable. This is to make static analysis possible: the posture needs to be statically determined to ensure that streaming does not fail at execution time. It is permitted, however, for streamed nodes to be mixed in a sequence with non-streamed nodes or with atomic values; in this case the posture of the result will be that of the streamed nodes. It is also permitted to have multiple operands delivering streamed nodes in different branches of a conditional, provided the sweep and posture are compatible: for example <code>if (X) then @name else name</code> is guaranteed streamable.</p><p>Expressions that have more than one operand with usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, for example <code>(A, B)</code>, or <code>(A | B)</code>, or <code>insert-before(A, n, B)</code>, generally allow only one of these operands to select streamed nodes. The result of the expression will contain a mixture of streamed and grounded nodes, but its posture and sweep will be that of the streamed operand. The nodes in the result will not necessarily be in document order, but the subset of the nodes that are streamed will always be in document order.</p></div></div><div class="div3"><h4><a id="general-streamability-examples"></a>19.8.2 <a href="#general-streamability-examples" style="text-decoration: none">Examples of the General Streamability Rules</a></h4><p>This section provides some examples of how the general streamability rules operate. In each example, the emphasis is on the outermost construct shown; explanations for how the sweep and posture of its operands are derived are not given, though in many cases they are explained in earlier examples.</p><p>The examples assume that the context item type for evaluation of the expression shown is an element node, and that its posture is striding.</p><ul><li><p><code>2 + 2</code> is grounded and motionless, because both the operands are grounded and motionless.</p></li><li><p><code>price * 2</code> is grounded and consuming, because one of the operands is consuming and the relevant operand usage is absorption.</p></li><li><p><code>price - discount</code> is roaming and free-ranging, because both the operands are consuming (and they are not members of a parallel operand group).</p></li><li><p><code>price * @discount</code> is grounded and consuming. The left-hand operand is consuming and the corresponding operand usage is absorption, while the right-hand operand is motionless, again with an operand usage of absorption, and its item type is <code>attribute()</code> which changes the effective usage to inspection.</p></li><li><p><code>a/b/c</code> is striding and consuming. This is determined not by the general streamability rules, but by the rules for path expressions in <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a>.</p></li><li><p><code>a//c</code> is crawling and consuming. This is similarly determined by the rules for path expressions in <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a>.</p></li><li><p><code>count(a/b/c)</code> is grounded and consuming, because the operand (the argument to the count function) is striding and consuming (see earlier example) and the operand usage is inspection.</p></li><li><p><code>sum(a/b/c)</code> is grounded and consuming, because the operand (the argument to the <code>sum</code> function) is striding and consuming (see earlier example) and the operand usage is absorption.</p></li><li><p><code>count(descendant::c)</code> is grounded and consuming, because the operand (the argument to the <code>count</code> function) is crawling and consuming (see earlier example) and the operand usage is inspection.</p></li><li><p><code>tail(descendant::c)</code> is crawling and consuming. The operand is crawling, the operand usage is transmission, so the posture and sweep of the result are the same as the posture and sweep of the consuming operand.</p></li><li><p><code>unordered(a|b)</code> is crawling and consuming. The operand (the argument to the <code>unordered</code> function) is crawling (see <a href="#streamability-of-union-expressions"><i>19.8.8.4 Streamability of union, intersect, and except Expressions</i></a>), and the operand usage is transmission, so the posture and sweep of the result are the same as the posture and sweep of the consuming operand.</p></li><li><p><code>zero-or-one(descendant::c)</code> is striding and consuming. Although the operand is crawling, the operand usage is transmission and the cardinality of the expression is zero or one, so the posture of the result is striding. The same analysis applies to <code>exactly-one(descendant::c)</code> and to <code>head(descendant::c)</code>.</p></li><li><p><code>sum(descendant::c)</code> is grounded and consuming, because the operand (the argument to the <code>sum</code> function) is crawling and consuming (see earlier example) and the operand usage is absorption. In theory (although it is unlikely in practice) the selected <code>c</code> elements might be nested one inside another. The processor is expected to handle this situation, which may require some buffering. For example, given the untyped source document <code>&lt;a&gt;&lt;c&gt;&lt;c&gt;1&lt;/c&gt;&lt;c&gt;2&lt;/c&gt;&lt;c&gt;3&lt;/c&gt;&lt;/c&gt;&lt;/a&gt;</code>, the result of the expression is <code>129</code> (123 + 1 + 2 + 3), and to evaluate this, a streaming processor will typically maintain a stack of buffers to accumulate the typed values of each of the four <code>c</code> elements during a single pass of the source document. </p></li><li><p><code>"Q{" || namespace-uri(.) || "}" || local-name(.)</code> is grounded and motionless. The two literal operands are grounded and motionless because they have no operands; the two function calls are grounded and motionless because they have a single operand that is striding and motionless, with an operand usage of inspection.</p></li><li><p><code>copy-of(.)/head/following-sibling::*</code> is grounded and consuming. The left-hand operand <code>copy-of(.)/head</code> is grounded and consuming because, under the rules in <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a>, its left-hand operand <code>copy-of(.)</code> is grounded and consuming. This in turn is because <code>.</code> is striding and motionless, and the operand usage is absorption.</p></li><li><p><code>if ($discounted) then price else discounted-price</code> is striding and consuming, because the two branches of the conditional are both striding and consuming, and they form a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a> with usage transmission.</p></li><li><p><code>if ($gratis) then 0 else price</code> is striding and consuming because there is only one consuming operand (the fact that it is part of a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a> does not affect the reasoning).</p></li><li><p><code>count((author, editor))</code> is roaming and free-ranging. The first argument to the <code>count</code> function is an expression with two operands, both having usage=transmission, and neither being grounded.</p></li><li><p><code>count((author | editor))</code> is grounded and consuming. A union expression is not subject to the general streamability rules; it has its own rules, defined in <a href="#streamability-of-union-expressions"><i>19.8.8.4 Streamability of union, intersect, and except Expressions</i></a>, which establish in this case that the argument to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup> is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. The <a href="https://www.w3.org/TR/xpath-functions-30/#func-count"><code>count</code></a><sup><small>FO30</small></sup> function does follow the general streamability rules, with an operand usage of <a title="inspection" class="termref" href="#dt-inspection">inspection</a>: under rule 1(b)(iii)(B) the adjusted sweep is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, and rule 2(d)(iii) then applies.</p></li><li><p><code>('{', author, '}')</code> is striding and consuming. Exactly one operand is consuming; it has usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, so the result has the posture and sweep of that operand. (The formal analysis treats comma as a binary operator, but the same result can be obtained by treating the content of the parenthesized expression as an expression with three operands.)</p></li></ul></div><div class="div3"><h4><a id="classifying-sequence-constructors"></a>19.8.3 <a href="#classifying-sequence-constructors" style="text-decoration: none">Classifying Sequence Constructors</a></h4><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are determined by the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>.</p><p>The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are:</p><ol class="enumar"><li><p>The immediately contained <a title="instruction" class="termref" href="#dt-instruction">instructions</a> and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, including any <a href="#element-on-empty"><code>xsl:on-empty</code></a> or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions. The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> for these operands is <a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p></li><li><p>Any <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a> appearing in text nodes within the sequence constructor, if text value templates are enabled. The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> for these operands is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Some consequences of these rules are:</p><ol class="enumar"><li><p>An empty sequence constructor is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, and its <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>A sequence constructor containing a single instruction has the same <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> as that instruction. (This means that sequence constructors containing a single instruction can usefully be dropped from the construct tree.)</p></li><li><p>Informally, a sequence constructor is not streamable if it contains more than one instruction that moves the position of the input stream.</p></li><li><p><a href="#element-on-empty"><code>xsl:on-empty</code></a> or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions are not treated specially. For example, there is no attempt to take into account that they are mutually exclusive: if one is evaluated, the other will not be evaluated. In most use cases for these instructions, they will be motionless, so the additional complexity of doing more advanced analysis would rarely be justified.</p></li></ol></div></div><div class="div3"><h4><a id="classifying-instructions"></a>19.8.4 <a href="#classifying-instructions" style="text-decoration: none">Classifying Instructions</a></h4><p>This section describes how <a title="instruction" class="termref" href="#dt-instruction">instructions</a> are classified with respect to their streamability. The criteria are given first for <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a> and <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, then for each XSLT instruction, listed alphabetically.</p><div class="div4"><h5><a id="streamability-literal-result-elements"></a>19.8.4.1 <a href="#streamability-literal-result-elements" style="text-decoration: none">Streamability of Literal Result Elements</a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are:</p><ol class="enumar"><li><p>The contained sequence constructor (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>Any expressions contained in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> among the literal result element’s attributes (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>Any <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a> named in the <code>xsl:use-attribute-sets</code> attribute (usage irrelevant, but can be taken as <a title="inspection" class="termref" href="#dt-inspection">inspection</a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, a reference to an attribute set that is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> does not affect the analysis, while a reference to any other attribute set makes the literal result element <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></div></li></ol></div><div class="div4"><h5><a id="streamability-extension-instructions"></a>19.8.4.2 <a href="#streamability-extension-instructions" style="text-decoration: none">Streamability of extension instructions</a></h5><p>For a processor that recognizes an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the instruction are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>For a processor that does not recognize an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the instruction are determined by applying the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are:</p><ol class="enumar"><li><p>The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a> contained in any <a href="#element-fallback"><code>xsl:fallback</code></a> children (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>)</p></li></ol><p>Instructions in the XSLT namespace that are present under the provisions for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> are treated in the same way as unrecognized extension instructions.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>These rules mean that if there is no <a href="#element-fallback"><code>xsl:fallback</code></a> child instruction, the containing construct will be classified as streamable. However, any attempt to execute the instruction will lead to a dynamic error, so in fact, neither streamed nor unstreamed evaluation is possible.</p></div></div><div class="div4"><h5><a id="streamability-xsl-analyze-string"></a>19.8.4.3 <a href="#streamability-xsl-analyze-string" style="text-decoration: none">Streamability of </a><a href="#element-analyze-string"><code>xsl:analyze-string</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are:</p><ol class="enumar"><li><p>the <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>);</p></li><li><p>the <code>regex</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>);</p></li><li><p>the sequence constructors contained in the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> elements. These have usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>, because they can be evaluated more than once. The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> for the two sequence constructors is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, reflecting the fact that their context item type is <code>xs:string</code>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the instruction will usually be the same as the sweep of the <code>select</code> expression, and its <a title="posture" class="termref" href="#dt-posture">posture</a> will be <a title="grounded" class="termref" href="#dt-grounded">grounded</a>. Exceptions occur for example if the <code>regex</code> attribute is not <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, or if the contained sequence constructors refer to a grouping variable bound in a contained <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction.</p></div></div><div class="div4"><h5><a id="streamability-xsl-apply-imports"></a>19.8.4.4 <a href="#streamability-xsl-apply-imports" style="text-decoration: none">Streamability of </a><a href="#element-apply-imports"><code>xsl:apply-imports</code></a></h5><p>The rules in this section apply also to <a href="#element-next-match"><code>xsl:next-match</code></a>.</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of these two instructions follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are:</p><ol class="enumar"><li><p>An implicit operand: a context item expression (<code>.</code>), with usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>;</p></li><li><p>The <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of each <a href="#element-with-param"><code>xsl:with-param</code></a> child element, with <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type declared in the <code>xsl:with-param/@as</code> attribute, or <code>item()*</code> if absent.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The instruction will normally be <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, provided that nodes in a streamed document are not passed as parameters to the called template rule.</p></div></div><div class="div4"><h5><a id="streamability-xsl-apply-templates"></a>19.8.4.5 <a href="#streamability-xsl-apply-templates" style="text-decoration: none">Streamability of </a><a href="#element-apply-templates"><code>xsl:apply-templates</code></a></h5><p>If there is no <code>select</code> attribute, the following analysis assumes the presence of an implicit operand <code>select="child::node()"</code>.</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction are the first of the following that apply:</p><ol class="enumar"><li><p>If the <code>select</code> expression is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> as follows:</p><ol class="enumla"><li><p>The <code>select</code> expression (the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is irrelevant, but can be taken as <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> expressions and contained sequence constructors of any child <a href="#element-with-param"><code>xsl:with-param</code></a> elements (usage <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined</a>, based on the type in the <code>xsl:with-param/@as</code> attribute, defaulting to <code>item()*</code>)</p></li><li><p>Any attribute value templates appearing in attributes of a child <a href="#element-sort"><code>xsl:sort</code></a> instruction (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> expression or contained sequence constructor of any <a href="#element-sort"><code>xsl:sort</code></a> children, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="grounded" class="termref" href="#dt-grounded">grounded</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol><p>For example, <code>&lt;xsl:apply-templates select="copy-of(.)"/&gt;</code> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>If there is an <a href="#element-sort"><code>xsl:sort</code></a> child element, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the implicit or explicit <code>mode</code> attribute identifies a <a title="mode" class="termref" href="#dt-mode">mode</a> that is not declared with <code>streamable="yes"</code>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>When <code>mode="#current"</code> is specified, this is treated as equivalent to specifying a streamable mode; although it is not known statically what the mode will be, it is always the case that if the template is invoked with a streamed node as the context item, then the current mode must be a streamable mode.</p></div></li><li><p>If the <code>select</code> expression is <a title="climbing" class="termref" href="#dt-climbing">climbing</a> or <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a></p></li><li><p>Otherwise, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumla"><li><p>The (explicit or implicit) <code>select</code> expression, with usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>; </p></li><li><p>The <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of each <a href="#element-with-param"><code>xsl:with-param</code></a> child element, with <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type declared in the <code>xsl:with-param/@as</code> attribute, or <code>item()*</code> if absent.</p></li></ol></li></ol></div><div class="div4"><h5><a id="streamability-xsl-assert"></a>19.8.4.6 <a href="#streamability-xsl-assert" style="text-decoration: none">Streamability of </a><a href="#element-assert"><code>xsl:assert</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-assert"><code>xsl:assert</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>test</code> expression (usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>)</p></li><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>error-code</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-attribute"></a>19.8.4.7 <a href="#streamability-xsl-attribute" style="text-decoration: none">Streamability of </a><a href="#element-attribute"><code>xsl:attribute</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-attribute"><code>xsl:attribute</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>name</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>namespace</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>separator</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-break"></a>19.8.4.8 <a href="#streamability-xsl-break" style="text-decoration: none">Streamability of </a><a href="#element-break"><code>xsl:break</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-break"><code>xsl:break</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> expression (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-call-template"></a>19.8.4.9 <a href="#streamability-xsl-call-template" style="text-decoration: none">Streamability of </a><a href="#element-call-template"><code>xsl:call-template</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-call-template"><code>xsl:call-template</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>Unless the referenced template has a child <a href="#element-context-item"><code>xsl:context-item</code></a> element with the attribute <code>use="prohibited"</code>, there is an implicit operand, a context item expression (<code>.</code>): its <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type declared in the <code>xsl:context-item/@as</code> attribute of the target named template, defaulting to <code>item()*</code> if absent.</p></li><li><p>The <code>select</code> expression or sequence constructor content of any contained <a href="#element-with-param"><code>xsl:with-param</code></a> child element: its <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type declared in the <code>xsl:with-param/@as</code> attribute, or the <code>xsl:param/@as</code> attribute of the corresponding parameter on the target named template, whichever is more restrictive, defaulting to <code>item()*</code> if both are absent.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Calling <a href="#element-call-template"><code>xsl:call-template</code></a> will usually make stylesheet code unstreamable if a streamed node is passed explicitly or implicitly to the called template, unless it is atomized by declaring the expected type to be atomic.</p></div></div><div class="div4"><h5><a id="streamability-xsl-choose"></a>19.8.4.10 <a href="#streamability-xsl-choose" style="text-decoration: none">Streamability of </a><a href="#element-choose"><code>xsl:choose</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-choose"><code>xsl:choose</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>test</code> attribute of contained <a href="#element-when"><code>xsl:when</code></a> elements (usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>).</p></li><li><p>The sequence constructors <span>and <code>select</code> expressions</span> contained within <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> child elements (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>). These operands form a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect is to allow either of the following:</p><ol class="enumar"><li><p>Any or all of the sequence constructors <span>and <code>select</code> expressions</span> in <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> branches may be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, in which case the <code>test</code> expressions must all be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>Any one of the <code>test</code> expressions may be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, in which case all the other <code>test</code> expressions, and all the sequence constructors <span>and <code>select</code> expressions</span>, must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></div></div><div class="div4"><h5><a id="streamability-xsl-comment"></a>19.8.4.11 <a href="#streamability-xsl-comment" style="text-decoration: none">Streamability of </a><a href="#element-comment"><code>xsl:comment</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-comment"><code>xsl:comment</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-copy"></a>19.8.4.12 <a href="#streamability-xsl-copy" style="text-decoration: none">Streamability of </a><a href="#element-copy"><code>xsl:copy</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-copy"><code>xsl:copy</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The expression in the <code>select</code> attribute, defaulting to a context item expression (<code>.</code>) (usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>)</p></li><li><p>The contained sequence constructor (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>), assessed with <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> and context item type based on the <code>select</code> expression if present, or the outer focus otherwise.</p></li><li><p>Any <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a> named in the <code>use-attribute-sets</code> attribute (usage irrelevant, but can be taken as <a title="inspection" class="termref" href="#dt-inspection">inspection</a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, a reference to an attribute set that is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> does not affect the analysis, while a reference to any other attribute set makes the <a href="#element-copy"><code>xsl:copy</code></a> instruction <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></div></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of these rules is that when a <code>select</code> attribute is present, the sequence constructor contained by the <a href="#element-copy"><code>xsl:copy</code></a> instruction is deemed to be a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of the instruction, even though it can only be evaluated once.</p><p>This has the practical consequence that the following example is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, even though it is possible to imagine a strategy for streamed evaluation:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">category</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">..</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:copy</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>A workaround in this case might be to rewrite the code as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">product</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">category</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:element</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">name</span><span class="parenthesis">(</span><span class="context">..</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">namespace</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">namespace-uri</span><span class="parenthesis">(</span><span class="context">..</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:element</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div4"><h5><a id="streamability-xsl-copy-of"></a>19.8.4.13 <a href="#streamability-xsl-copy-of" style="text-decoration: none">Streamability of </a><a href="#element-copy-of"><code>xsl:copy-of</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-copy-of"><code>xsl:copy-of</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-document"></a>19.8.4.14 <a href="#streamability-xsl-document" style="text-decoration: none">Streamability of </a><a href="#element-document"><code>xsl:document</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-document"><code>xsl:document</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-element"></a>19.8.4.15 <a href="#streamability-xsl-element" style="text-decoration: none">Streamability of </a><a href="#element-element"><code>xsl:element</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-element"><code>xsl:element</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>name</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>namespace</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>Any <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a> named in the <code>use-attribute-sets</code> attribute (usage irrelevant, but can be taken as <a title="inspection" class="termref" href="#dt-inspection">inspection</a>).</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, a reference to an attribute set that is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> does not affect the analysis, while a reference to any other attribute set makes the <a href="#element-element"><code>xsl:element</code></a> instruction <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></div></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-evaluate"></a>19.8.4.16 <a href="#streamability-xsl-evaluate" style="text-decoration: none">Streamability of </a><a href="#element-evaluate"><code>xsl:evaluate</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-evaluate"><code>xsl:evaluate</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>xpath</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>context-item</code> expression (usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>)</p></li><li><p>The <code>with-params</code> expression (usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>)</p></li><li><p>The <code>base-uri</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>namespace-context</code> expression (usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>)</p></li><li><p>The <code>schema-aware</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> attributes and contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a> of any <a href="#element-with-param"><code>xsl:with-param</code></a> child elements (usage <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined</a>, based on the type in the <code>xsl:with-param/@as</code> attribute, defaulting to <code>item()*</code>)</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, code containing an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction will usually be streamable provided that streamed nodes are not passed to the dynamic expression either as the context item or as the value of a parameter.</p></div></div><div class="div4"><h5><a id="streamability-xsl-fallback"></a>19.8.4.17 <a href="#streamability-xsl-fallback" style="text-decoration: none">Streamability of </a><a href="#element-fallback"><code>xsl:fallback</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction depend on whether the processor is performing fallback (which is known statically).</p><p>If the processor is performing fallback, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction are the posture and sweep of the contained sequence constructor.</p><p>If the processor is not performing fallback, then the instruction is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></div><div class="div4"><h5><a id="streamability-xsl-for-each"></a>19.8.4.18 <a href="#streamability-xsl-for-each" style="text-decoration: none">Streamability of </a><a href="#element-for-each"><code>xsl:for-each</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction are the first of the following that applies:</p><ol class="enumar"><li><p>If the <code>select</code> expression is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> as follows:</p><ol class="enumla"><li><p>The <code>select</code> expression (the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is irrelevant, but can be taken as <a title="inspection" class="termref" href="#dt-inspection">inspection</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>). This is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a>; its context posture is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>Any attribute value templates appearing in attributes of a child <a href="#element-sort"><code>xsl:sort</code></a> instruction (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> expression or contained sequence constructor of any <a href="#element-sort"><code>xsl:sort</code></a> children, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="grounded" class="termref" href="#dt-grounded">grounded</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>). These are <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operands</a>; their context posture is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li></ol></li><li><p>If there is an <a href="#element-sort"><code>xsl:sort</code></a> child element, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>select</code> expression is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. </p></li><li><p>Otherwise:</p><ol class="enumla"><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the instruction is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, assessed with the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> and context item type set to the <a title="posture" class="termref" href="#dt-posture">posture</a> and type of the <code>select</code> expression.</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the instruction is the wider of the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <code>select</code> expression and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The ordering of sweep values is in increasing order: <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></div></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Because the body of the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of the instruction, any variable reference within the body that is bound to a <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> of a containing <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> will not be singular, which in many cases will make the entire function non-streamable.</p></div></li></ol></div><div class="div4"><h5><a id="streamability-xsl-for-each-group"></a>19.8.4.19 <a href="#streamability-xsl-for-each-group" style="text-decoration: none">Streamability of </a><a href="#element-for-each-group"><code>xsl:for-each-group</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction are the first of the following that applies:</p><ol class="enumar"><li><p>If the <code>select</code> expression is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> as follows:</p><ol class="enumla"><li><p>The <code>select</code> expression (the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is irrelevant, but can be taken as <a title="inspection" class="termref" href="#dt-inspection">inspection</a>)</p></li><li><p>The <code>collation</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>Any attribute value templates appearing in attributes of a child <a href="#element-sort"><code>xsl:sort</code></a> instruction (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>group-by</code> or <code>group-adjacent</code> expression, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="grounded" class="termref" href="#dt-grounded">grounded</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li><li><p>The <code>select</code> expression or contained sequence constructor of any <a href="#element-sort"><code>xsl:sort</code></a> children, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="grounded" class="termref" href="#dt-grounded">grounded</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li><li><p>The <code>group-starting-with</code> or <code>group-ending-with</code> patterns if present; these are <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operands</a> with usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>.</p></li></ol></li><li><p>If there is a <code>group-by</code> attribute and the instruction is not a child of <a href="#element-fork"><code>xsl:fork</code></a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If there is a <code>group-by</code> or <code>group-adjacent</code> attribute that is not <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If there is an <a href="#element-sort"><code>xsl:sort</code></a> child element and the instruction is not a child of <a href="#element-fork"><code>xsl:fork</code></a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>select</code> expression is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Otherwise:</p><ol class="enumla"><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the instruction is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, assessed with the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> and context item type set to the <a title="posture" class="termref" href="#dt-posture">posture</a> and type of the <code>select</code> expression.</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the instruction is the wider of the <a title="sweep" class="termref" href="#dt-sweep">sweeps</a> of the <code>select</code> expression and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, where the ordering of increasing width is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Because the body of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of the instruction, any variable reference within the body that is bound to a <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> of a containing <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> will not be singular, which in many cases will make the entire function non-streamable.</p></div></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The above rules do not explicitly mention any constraints on the presence or absence of a call on the <a href="#func-current-group"><code>current-group</code></a> function. In practice, however, this plays an important role. In the most common case, the <code>select</code> expression of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> is likely to be striding, for example an expression such as <code>select="*"</code>. Any call on <a href="#func-current-group"><code>current-group</code></a> associated with this <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction will ordinarily be <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, which is consistent with streaming provided there is only one such call, and if it appears in a suitable context (for example, not within a predicate). If there is more than one call, or if it appears in an unsuitable context (for example, within a predicate), then this will have the same effect as multiple appearances of other consuming expressions: the construct as a whole will be free-ranging. These rules are not spelled out explicitly, but rather emerge as a consequence of the general streamability rules.</p></div></div><div class="div4"><h5><a id="streamability-xsl-fork"></a>19.8.4.20 <a href="#streamability-xsl-fork" style="text-decoration: none">Streamability of </a><a href="#element-fork"><code>xsl:fork</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-fork"><code>xsl:fork</code></a> are the first of the following that applies:</p><ol class="enumar"><li><p>If there is a child <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of that instruction.</p></li><li><p>If there are no child <a href="#element-sequence"><code>xsl:sequence</code></a> instructions (other than <a href="#element-fallback"><code>xsl:fallback</code></a>), then <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>If there is a child <a href="#element-sequence"><code>xsl:sequence</code></a> instruction whose <a title="posture" class="termref" href="#dt-posture">posture</a> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Otherwise, the <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is the widest sweep of the <a href="#element-sequence"><code>xsl:sequence</code></a> child instructions.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>None of the branches of <a href="#element-fork"><code>xsl:fork</code></a> can return streamed nodes. The reason for this is that <a href="#element-fork"><code>xsl:fork</code></a> has to assemble its results in the correct order, and streamed nodes cannot be re-ordered.</p><p>The effect of the rules is that each of the child <a href="#element-sequence"><code>xsl:sequence</code></a> instructions can independently consume the streamed input document, provided that the result of each child instruction is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p><p>Thus the following example is streamable:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:fork</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="qname">author</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="qname">editor</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fork</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>While the following is not streamable, because it returns streamed nodes in an order that might not be document order:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:fork</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">author</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">editor</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:fork</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div4"><h5><a id="streamability-xsl-if"></a>19.8.4.21 <a href="#streamability-xsl-if" style="text-decoration: none">Streamability of </a><a href="#element-if"><code>xsl:if</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-if"><code>xsl:if</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>test</code> expression (usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>)</p></li><li><p>The <code>then</code> and <code>else</code> expressions and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>). These operands form a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a></p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect is to allow either of the following:</p><ol class="enumar"><li><p>The <code>test</code> expression may be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, in which case any or all of the <code>then</code> and <code>else</code> expressions, and the containing sequence constructor, may be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The <code>test</code> expression may be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, in which case the <code>then</code> and <code>else</code> expressions, and the containing sequence constructor, must all be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></div></div><div class="div4"><h5><a id="streamability-xsl-iterate"></a>19.8.4.22 <a href="#streamability-xsl-iterate" style="text-decoration: none">Streamability of </a><a href="#element-iterate"><code>xsl:iterate</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction are the first of the following that applies:</p><ol class="enumar"><li><p>If the <code>select</code> expression is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> as follows:</p><ol class="enumla"><li><p>The <code>select</code> expression (the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is irrelevant, but can be taken as <a title="inspection" class="termref" href="#dt-inspection">inspection</a>)</p></li><li><p>The <code>select</code> expression or contained sequence constructor of any <a href="#element-param"><code>xsl:param</code></a> children (usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>)</p></li><li><p>The sequence constructor contained within the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction itself, assessed with its context item type and <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> based on the <code>select</code> expression (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>)</p></li><li><p>The <code>select</code> expression or contained sequence constructor of any child <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, assessed with a context item type of <code>xs:error</code> and a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="roaming" class="termref" href="#dt-roaming">roaming</a> to reflect the fact that any attempt to reference the context item within the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element is an error (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>on-completion</code> element can cause the instruction to become non-streamable if, for example, it contains a call on <a href="#func-current-group"><code>current-group</code></a> or a variable reference bound to a <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a>.</p></div></li></ol></li><li><p>If there is an <a href="#element-param"><code>xsl:param</code></a> child whose initializing <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If there is an <a href="#element-on-completion"><code>xsl:on-completion</code></a> child whose <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>select</code> expression is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Otherwise:</p><ol class="enumla"><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the instruction is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, assessed with the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> and context item type set to the <a title="posture" class="termref" href="#dt-posture">posture</a> and type of the <code>select</code> expression.</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the instruction is the wider of the <a title="sweep" class="termref" href="#dt-sweep">sweeps</a> of the <code>select</code> expression and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, where the ordering of increasing width is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>If any <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instructions appear within the sequence constructor, their <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> will be assessed in the course of evaluating the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the sequence constructor, by reference to the rules in <a href="#streamability-xsl-break"><i>19.8.4.8 Streamability of xsl:break</i></a> and <a href="#streamability-xsl-next-iteration"><i>19.8.4.28 Streamability of xsl:next-iteration</i></a> respectively.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Because the body of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of the instruction, any variable reference within the body that is bound to a <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> of a containing <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> will not be singular, which in many cases will make the entire function non-streamable.</p></div></div><div class="div4"><h5><a id="streamability-xsl-map"></a>19.8.4.23 <a href="#streamability-xsl-map" style="text-decoration: none">Streamability of </a><a href="#element-map"><code>xsl:map</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-map"><code>xsl:map</code></a> instruction are determined by the first of the following that applies:</p><ol class="enumar"><li><p>If the sequence constructor within the instruction consists exclusively of <a href="#element-map-entry"><code>xsl:map-entry</code></a> instructions (and <a href="#element-fallback"><code>xsl:fallback</code></a> instructions, which are ignored), then:</p><ol class="enumla"><li><p>If any of these <a href="#element-map-entry"><code>xsl:map-entry</code></a> children is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> or <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>;</p></li><li><p>Otherwise, <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and the widest sweep of the <a href="#element-map-entry"><code>xsl:map-entry</code></a> children.</p></li></ol></li><li><p>Otherwise, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-map"><code>xsl:map</code></a> instruction are the posture and sweep of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>See discussion in <a href="#maps-streaming"><i>21.4 Maps and Streaming</i></a>.</p><p>The effect of the rules is that it is possible to compute multiple map entries in a single pass of the streamed input document. For example, the following is streamable:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:map</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">authors</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="qname">author</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">editors</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="qname">editor</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The call on <a href="#func-copy-of"><code>copy-of</code></a> is necessary to ensure that the content of the map entry is grounded; it is not possible to create a map whose entries contain references to streamed nodes.</p></div></div><div class="div4"><h5><a id="streamability-xsl-map-entry"></a>19.8.4.24 <a href="#streamability-xsl-map-entry" style="text-decoration: none">Streamability of </a><a href="#element-map-entry"><code>xsl:map-entry</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-map-entry"><code>xsl:map-entry</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>key</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> expression (usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>)</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This effectively means that the <code>select</code> expression must not return nodes from a streamed input document.</p></div></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-merge"></a>19.8.4.25 <a href="#streamability-xsl-merge" style="text-decoration: none">Streamability of </a><a href="#element-merge"><code>xsl:merge</code></a></h5><div class="note"><p class="prefix"><b>Note:</b></p><p>This section is concerned with the (not very interesting) impact of the <a href="#element-merge"><code>xsl:merge</code></a> instruction on the streamability of its containing template rule or <a href="#element-source-document"><code>xsl:source-document</code></a> instruction.</p><p>For the (more important) rules concerning the way in which <a href="#element-merge"><code>xsl:merge</code></a> performs streamed processing of its own inputs, see <a href="#streamable-merging"><i>15.4 Streamable Merging</i></a>.</p></div><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-merge"><code>xsl:merge</code></a> are as follows:</p><ol class="enumar"><li><p>If every <a href="#element-merge-source"><code>xsl:merge-source</code></a> child element satisfies all the following conditions:</p><ol class="enumla"><li><p>The expression in the <code>for-each-item</code> attribute is either absent, or <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>;</p></li><li><p>The expression in the <code>for-each-source</code> attribute is either absent, or <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>;</p></li><li><p>Either at least one of the attributes <code>for-each-item</code> and <code>for-each-source</code> is present, or the expression in the <code>select</code> attribute is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a></p></li></ol><p>then the <a href="#element-merge"><code>xsl:merge</code></a> instruction is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>Otherwise, the <a href="#element-merge"><code>xsl:merge</code></a> instruction is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-message"></a>19.8.4.26 <a href="#streamability-xsl-message" style="text-decoration: none">Streamability of </a><a href="#element-message"><code>xsl:message</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-message"><code>xsl:message</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>terminate</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>error-code</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-namespace"></a>19.8.4.27 <a href="#streamability-xsl-namespace" style="text-decoration: none">Streamability of </a><a href="#element-namespace"><code>xsl:namespace</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-namespace"><code>xsl:namespace</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>name</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-next-iteration"></a>19.8.4.28 <a href="#streamability-xsl-next-iteration" style="text-decoration: none">Streamability of </a><a href="#element-next-iteration"><code>xsl:next-iteration</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> content of any contained <a href="#element-with-param"><code>xsl:with-param</code></a> child element: its <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type declared in the <code>xsl:with-param/@as</code> attribute, or the <code>xsl:param/@as</code> attribute of the corresponding parameter on the containing <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, whichever is more restrictive, defaulting to <code>item()*</code> if both are absent.</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-next-match"></a>19.8.4.29 <a href="#streamability-xsl-next-match" style="text-decoration: none">Streamability of </a><a href="#element-next-match"><code>xsl:next-match</code></a></h5><p>The rules are the same as for <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>: see <a href="#streamability-xsl-apply-imports"><i>19.8.4.4 Streamability of xsl:apply-imports</i></a>.</p></div><div class="div4"><h5><a id="streamability-xsl-number"></a>19.8.4.30 <a href="#streamability-xsl-number" style="text-decoration: none">Streamability of </a><a href="#element-number"><code>xsl:number</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-number"><code>xsl:number</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>value</code> attribute if present: usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a></p></li><li><p>The <code>select</code> attribute if there is no <code>value</code> attribute, defaulting to the context item expression (<code>.</code>) if the <code>select</code> attribute is also absent: usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a></p></li><li><p>The attribute value templates in the <code>format</code>, <code>lang</code>, <code>letter-value</code>, <code>ordinal</code>, <code>start-at</code>, <code>grouping-separator</code>, and <code>grouping-size</code> attributes (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>from</code> and <code>count</code> patterns if present. These can be treated as <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operands</a> with usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, though neither of these properties affects the outcome.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of these rules is that <a href="#element-number"><code>xsl:number</code></a> can be used for formatting of numbers supplied directly using the <code>value</code> attribute, and also for numbering of nodes in a non-streamed document, but it cannot be used for numbering streamed nodes.</p><p>In practice the rules depend very little on the <code>from</code> and <code>count</code> patterns. This is because when the instruction is applied to a streamed node, the instruction will be <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> regardless of these patterns; while if it is applied to a grounded node or atomic value, the instruction will normally be <a title="motionless" class="termref" href="#dt-motionless">motionless</a> regardless of the values of these patterns. The pattern does matter, however, if it contains a variable reference bound to a <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a>; because such a reference occurs within a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of the <a href="#element-number"><code>xsl:number</code></a> instruction, its presence automatically makes the variable reference <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, which in turn ensures that the containing stylesheet function is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p></div></div><div class="div4"><h5><a id="streamability-xsl-on-empty"></a>19.8.4.31 <a href="#streamability-xsl-on-empty" style="text-decoration: none">Streamability of </a><a href="#element-on-empty"><code>xsl:on-empty</code></a></h5><p>The streamability rules for the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction are the same as the rules for <a href="#element-sequence"><code>xsl:sequence</code></a>: see <a href="#streamability-xsl-sequence"><i>19.8.4.36 Streamability of xsl:sequence</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The streamability rules for a sequence constructor containing an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction are given in <a href="#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence Constructors</i></a>.</p></div></div><div class="div4"><h5><a id="streamability-xsl-on-non-empty"></a>19.8.4.32 <a href="#streamability-xsl-on-non-empty" style="text-decoration: none">Streamability of </a><a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a></h5><p>The streamability rules for the <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction are the same as the rules for <a href="#element-sequence"><code>xsl:sequence</code></a>: see <a href="#streamability-xsl-sequence"><i>19.8.4.36 Streamability of xsl:sequence</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The streamability rules for a sequence constructor containing an <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction are given in <a href="#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence Constructors</i></a>.</p></div></div><div class="div4"><h5><a id="streamability-xsl-perform-sort"></a>19.8.4.33 <a href="#streamability-xsl-perform-sort" style="text-decoration: none">Streamability of </a><a href="#element-perform-sort"><code>xsl:perform-sort</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The expression in the <code>select</code> attribute: usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a> (because order is not preserved)</p></li><li><p>The expressions in the attribute value templates of <a href="#element-sort"><code>xsl:sort</code></a> child elements: usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a></p></li><li><p>The expression in the <code>select</code> attribute or contained sequence constructor in child <a href="#element-sort"><code>xsl:sort</code></a> child elements, with usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, assessed with <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> based on the expression in the <code>xsl:perform-sort/@select</code> attribute.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, the <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction cannot be used to sort nodes from the streamed input document, but it can be used to sort atomic values or <a title="grounded" class="termref" href="#dt-grounded">grounded</a> nodes, for example a copy of nodes from the streamed document made using the <a href="#func-copy-of"><code>copy-of</code></a> function.</p></div></div><div class="div4"><h5><a id="streamability-xsl-processing-instruction"></a>19.8.4.34 <a href="#streamability-xsl-processing-instruction" style="text-decoration: none">Streamability of </a><a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>name</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-result-document"></a>19.8.4.35 <a href="#streamability-xsl-result-document" style="text-decoration: none">Streamability of </a><a href="#element-result-document"><code>xsl:result-document</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-result-document"><code>xsl:result-document</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>href</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The attribute value templates containing serialization properties (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-sequence"></a>19.8.4.36 <a href="#streamability-xsl-sequence" style="text-decoration: none">Streamability of </a><a href="#element-sequence"><code>xsl:sequence</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-sequence"><code>xsl:sequence</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> attribute value template (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-stream"></a>19.8.4.37 <a href="#streamability-xsl-stream" style="text-decoration: none">Streamability of </a><a href="#element-source-document"><code>xsl:source-document</code></a></h5><div class="note"><p class="prefix"><b>Note:</b></p><p>The concern here is with the impact of <a href="#element-source-document"><code>xsl:source-document</code></a> on any streaming template, or ancestor <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, and not with the streamed processing of the document accessed using the <code>xsl:source-document/@href</code> attribute.</p><p>The streamability of the document opened by the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is not assessed using the rules in this section; it depends only on the streamability properties of the contained sequence constructor, as described in <a href="#source-document-instruction"><i>18.1 The xsl:source-document Instruction</i></a></p></div><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-source-document"><code>xsl:source-document</code></a> are the first of the following that applies:</p><ol class="enumar"><li><p>If the contained sequence constructor contains, at any depth, a call on the <a href="#func-current-group"><code>current-group</code></a> function whose nearest containing <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction exists and is an ancestor of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the contained sequence constructor contains, at any depth, a call on the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function whose nearest containing <a href="#element-merge"><code>xsl:merge</code></a> instruction exists and is an ancestor of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Otherwise, the <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <code>href</code> attribute value template.</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-switch"></a>19.8.4.38 <a href="#streamability-xsl-switch" style="text-decoration: none">Streamability of </a><a href="#element-switch"><code>xsl:switch</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-switch"><code>xsl:switch</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> attribute of the <a href="#element-switch"><code>xsl:switch</code></a> elements (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li><li><p>The <code>test</code> attribute of contained <a href="#element-when"><code>xsl:when</code></a> elements (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li><li><p>The sequence constructors and <code>select</code> expressions contained within <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> child elements (usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>). These operands form a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect is to allow any of the following:</p><ol class="enumar"><li><p>The <code>select</code> expression of the <a href="#element-switch"><code>xsl:switch</code></a> instruction may be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, in which case all the other operands must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>Any one of the <code>test</code> expressions may be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, in which case all the other operands must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>Any or all of the sequence constructors and <code>select</code> expressions in <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> branches may be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, in which case the <code>test</code> expressions and the <code>select</code> of the <a href="#element-switch"><code>xsl:switch</code></a> instruction must all be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></div></div><div class="div4"><h5><a id="streamability-xsl-text"></a>19.8.4.39 <a href="#streamability-xsl-text" style="text-decoration: none">Streamability of </a><a href="#element-text"><code>xsl:text</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-text"><code>xsl:text</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. There are no operands.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The instruction is therefore <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></div></div><div class="div4"><h5><a id="streamability-xsl-try"></a>19.8.4.40 <a href="#streamability-xsl-try" style="text-decoration: none">Streamability of </a><a href="#element-try"><code>xsl:try</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-try"><code>xsl:try</code></a> instruction follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> expression or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <a href="#element-try"><code>xsl:try</code></a> element. This has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="transmission" class="termref" href="#dt-transmission">transmission</a>. (Note that the <a href="#element-catch"><code>xsl:catch</code></a> children of <a href="#element-try"><code>xsl:try</code></a> are not part of the sequence constructor and therefore not part of this operand.)</p></li><li><p>The <code>select</code> expressions and/or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <a href="#element-catch"><code>xsl:catch</code></a> child elements. These form a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a> with <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The overall effect of these rules is that either the <a href="#element-try"><code>xsl:try</code></a> branch or the <a href="#element-catch"><code>xsl:catch</code></a> branch may consume the streamed input, but not both. If there is more than one <a href="#element-catch"><code>xsl:catch</code></a> branch then they may all consume the input, since only one of these branches can be evaluated.</p></div></div><div class="div4"><h5><a id="streamability-xsl-value-of"></a>19.8.4.41 <a href="#streamability-xsl-value-of" style="text-decoration: none">Streamability of </a><a href="#element-value-of"><code>xsl:value-of</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-value-of"><code>xsl:value-of</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> are as follows:</p><ol class="enumar"><li><p>The <code>select</code> expression (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The <code>separator</code> attribute value template (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>)</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></div><div class="div4"><h5><a id="streamability-xsl-variable"></a>19.8.4.42 <a href="#streamability-xsl-variable" style="text-decoration: none">Streamability of </a><a href="#element-variable"><code>xsl:variable</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a href="#element-variable"><code>xsl:variable</code></a> follow the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> and their <a title="operand usage" class="termref" href="#dt-operand-usage">usages</a> depend on the <code>as</code> attribute, as follows:</p><ol class="enumar"><li><p>If there is an <code>as</code> attribute, then:</p><ol class="enumla"><li><p>The <code>select</code> expression (with <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the <code>as</code> attribute).</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (with <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the <code>as</code> attribute).</p></li></ol></li><li><p>If there is no <code>as</code> attribute, then:</p><ol class="enumla"><li><p>The <code>select</code> expression (usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>).</p></li><li><p>The contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>).</p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The effect of the initialization expression having usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a> is that it is not possible in streamable constructs to bind a variable to a node in a streamed document.</p></div></div><div class="div4"><h5><a id="streamability-xsl-where-populated"></a>19.8.4.43 <a href="#streamability-xsl-where-populated" style="text-decoration: none">Streamability of </a><a href="#element-where-populated"><code>xsl:where-populated</code></a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of an <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction are the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p></div></div><div class="div3"><h4><a id="streamable-stylesheet-functions"></a>19.8.5 <a href="#streamable-stylesheet-functions" style="text-decoration: none">Classifying Stylesheet Functions</a></h4><p>Under specific conditions, described in this section, a stylesheet function can be used to process nodes from a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed input document</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streamability-category" title="streamability category"></a>Stylesheet functions belong to one of a number of <b>streamability categories</b>: the choice of category characterizes the way in which the function handles streamed input.<span class="definition">]</span></p><p>The <a title="streamability category" class="termref" href="#dt-streamability-category">category</a> to which a function belongs is declared in the <code>streamability</code> attribute of the <a href="#element-function"><code>xsl:function</code></a> declaration, and defaults to <code>unclassified</code>.</p><p>The streamability categories defined in this specification are: <code>unclassified</code>, <code>absorbing</code>, <code>inspection</code>, <code>filter</code>, <code>shallow-descent</code>, <code>deep-descent</code>, and <code>ascent</code>. It is also possible to specify the streamability category as a QName in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> namespace, in which case the streamability rules are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>; a processor that does not recognize a category defined in this way <span class="verb">must</span> analyze the function as if <code>streamability="unclassified"</code> were specified. </p><p>A stylesheet function is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> if the <a href="#element-function"><code>xsl:function</code></a> declaration has a <code>streamability</code> attribute with a value other than <code>unclassified</code>.</p><p>The only <a title="streamability category" class="termref" href="#dt-streamability-category">category</a> permitted for a zero-arity function (one with no arguments) is <code>unclassified</code>. All function calls to zero-arity stylesheet functions are <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p>In general (subject to more detailed rules below), a node belonging to a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a> can be present within the value of an argument of a call on a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> only if one of the following conditions is true:</p><ol class="enumar"><li><p>The stylesheet function is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>, and the argument in question is the first argument of the function call.</p></li><li><p>The corresponding <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a> is declared with a <a title="required type" class="termref" href="#dt-required-type">required type</a> that triggers <a title="atomize" class="termref" href="#dt-atomization">atomization</a> of any supplied node.</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streaming-parameter" title="streaming parameter"></a>The first <a title="function parameter" class="termref" href="#dt-function-parameter">parameter</a> of a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a><a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> is referred to as a <b>streaming parameter</b>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>If a stylesheet function returns streamed nodes, then these nodes can only derive from streamed nodes passed in an argument to the function. This is because streamed nodes cannot be bound to global variables, and they cannot be returned by an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction within the function body (the result of <a href="#element-source-document"><code>xsl:source-document</code></a> is always grounded).</p></div><p>The choice of <a title="streamability category" class="termref" href="#dt-streamability-category">category</a> places constraints on the function body, and also on calls to the function. These constraints are defined below, separately for each category. A function is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> only if the constraints are satisfied, and a static function call is guaranteed-streamable only if the function is guaranteed-streamable and the function call itself satisfies the constraints for the chosen category.</p><p>Dynamic function calls are <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> only in trivial cases, for example where the function signature indicates that an argument is required to be a text node or an attribute node. For details, see <a href="#streamability-of-dynamic-function-calls"><i>19.8.8.11 Streamability of Dynamic Function Calls</i></a>.</p><p>The constraints on the function body are expressed in terms of the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function result. The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function result are the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture and sweep</a> of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained within the <a href="#element-function"><code>xsl:function</code></a> element, given the declared return type of the function, which defaults to <code>item()*</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Determining the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function result requires first determining the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, which is done according to the rules in <a href="#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence Constructors</i></a>. This in turn will usually involve examination of variable references that are bound to the function’s parameters. The analysis of these variable references is described in <a href="#streamability-of-variable-references"><i>19.8.8.12 Streamability of Variable References</i></a>.</p></div><p>If the function is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> but does not satisfy the constraints that make it <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, the consequences are explained in <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>.</p><p>If a stylesheet function is overridden in another package (using <a href="#element-override"><code>xsl:override</code></a>), then the overriding stylesheet function must belong to the same <a title="streamability category" class="termref" href="#dt-streamability-category">streamability category</a> as the function that it overrides. This ensures that overriding a function cannot affect the streamability of calls to that function.</p><p>The rules for each <a title="streamability category" class="termref" href="#dt-streamability-category">streamability category</a> are given in the following sections.</p><div class="div4"><h5><a id="category-unclassified"></a>19.8.5.1 <a href="#category-unclassified" style="text-decoration: none">Streamability Category: unclassified</a></h5><p><b>Informal description:</b> Functions in this category cannot be called with streamed nodes supplied in an argument, unless the function signature causes such nodes to be atomized.</p><p><b>Rules for the function signature:</b> there are no constraints.</p><p><b>Rules for the function body:</b> there are no constraints.</p><p><b>Rules for references to the streaming parameter:</b> not applicable, because there is no streaming parameter.</p><p><b>Rules for function calls:</b> the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. The operands are the expressions appearing in the argument list of the function call, with the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of each operand being the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the declared type of the corresponding parameter in the function signature. </p><div class="example"><div class="exampleHeader"><a id="d8e46080"></a><a id="d8e46189"></a>Example: An unclassified stylesheet function that accepts nodes</div><p>The <a title="streamability category" class="termref" href="#dt-streamability-category">streamability category</a> is <code>unclassified</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:exclude-first</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">nodes</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$nodes</span><span class="filter">[</span><span class="function">not</span><span class="parenthesis">(</span><span class="function">node-name</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="axis">preceding-sibling::</span><span class="op">*</span><span class="step">/</span><span class="function">node-name</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is guaranteed streamable if and only if the sequence supplied as the value of the <code>$nodes</code> argument is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> (that is, it contains no streamed nodes).</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e46096"></a><a id="d8e46205"></a>Example: An unclassified stylesheet function that accepts atomic values</div><p>The <a title="streamability category" class="termref" href="#dt-streamability-category">streamability category</a> is <code>unclassified</code>.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:min</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg0</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg1</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">min</span><span class="parenthesis">(</span><span class="parenthesis">(</span><span class="variable">$arg0</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$arg1</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is streamable under similar circumstances to those that apply to a binary operator such as <code>+</code>. For example, a call is streamable if two atomic values are supplied, or if two attribute nodes are supplied, whether from streamed or unstreamed documents. The main constraint is that it is not permitted for both arguments to be consuming; for example, if the context node is a node in a streamed document, then the function call <code>f:min((price, discount))</code> would not be guaranteed streamable.</p></div></div><div class="div4"><h5><a id="category-absorbing"></a>19.8.5.2 <a href="#category-absorbing" style="text-decoration: none">Streamability Category: absorbing</a></h5><p><b>Informal description:</b> Functions in this category typically read the subtrees rooted at the node or nodes supplied in the first argument. These subtrees must not overlap each other. The function must not return any streamed nodes.</p><p><b>Rules for the function signature:</b> there are no constraints.</p><p><b>Rules for the function body:</b> For the function to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture</a> of the function body with respect to the declared return type must be <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted sweep</a> of the function body with respect to the declared return type must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p><p><b>Rules for references to the streaming parameter:</b> If the declared type of the <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> permits more than one node, then a variable reference referring to the streaming parameter is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. Otherwise such a variable reference is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for function calls:</b> If the first argument is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> then the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>; otherwise the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. The operands are the expressions appearing in the argument list of the function call. The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the first argument is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>; the operand usage of other arguments is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the declared type of the corresponding <a title="parameter" class="termref" href="#dt-parameter">parameter</a> in the function signature. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Absorbing functions perform an operation analogous to atomization on their supplied arguments, in that they typically use information from the subtree rooted at a node to compute atomic values. Atomization can be seen as a special case of absorption. Calls on absorbing functions are therefore, from a streamability point of view, equivalent to calls on functions that implicitly atomize the supplied nodes.</p><p>An important difference, however, is that whereas atomization can be applied to any argument of a function call, absorption applies only to the first argument.</p><p>Another difference is that atomization is allowed on a sequence of nodes in <a title="crawling" class="termref" href="#dt-crawling">crawling</a> posture, whereas generalized absorption is not. Within a sequence, there may be nodes whose subtrees overlap, and the code for atomization is expected to handle this, but more general absorption operations are not. To write a function that accepts streamed nodes and atomizes them, it is better to use the streamability category <code>unclassified</code>, and to declare the first argument with an atomic type, rather than using the category <code>absorbing</code> which allows more general processing, but restricts what can be supplied in the argument to the function call.</p></div><div class="example"><div class="exampleHeader"><a id="d8e46182"></a><a id="d8e46291"></a>Example: An absorbing stylesheet function</div><p>The following function is declared as absorbing, and the function body meets the rules for this category because it makes downward selections only, and returns an atomic value.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:count-descendants</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">absorbing</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="step">//</span><span class="op">*</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> provided that the sequence supplied as the value of the <code>$input</code> argument is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, and is either <a title="grounded" class="termref" href="#dt-grounded">grounded</a> or <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e46202"></a><a id="d8e46311"></a>Example: An absorbing stylesheet function with two arguments</div><p>The following function is declared as absorbing, and the function body meets the rules for this category because it makes downward selections only from the node supplied as the first argument, and returns an atomic value.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:compare-size</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">absorbing</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input0</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input1</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="variable">$input0</span><span class="step">//</span><span class="op">*</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">-</span><span class="whitespace"></span><span class="function">count</span><span class="parenthesis">(</span><span class="variable">$input1</span><span class="step">//</span><span class="op">*</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>This function takes two nodes as its arguments. Some examples of function calls include: </p><ul><li><p>Streamable: <code>f:compare-size(a, b)</code> where <code>a</code> is an element in a streamed document and <code>b</code> is an element in an unstreamed document</p></li><li><p>Streamable: <code>f:compare-size(a, b)</code> where <code>a</code> and <code>b</code> are both elements in unstreamed documents</p></li><li><p>Not streamable: <code>f:compare-size(a, b)</code> where <code>a</code> is an element in an unstreamed document and <code>b</code> is an element in a streamed document</p></li></ul><p>The reason for the asymmetry is that for the first argument the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, while for the second argument it is <a title="navigation" class="termref" href="#dt-navigation">navigation</a>. It is a consequence of the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> that when streamed nodes are supplied to an operand with usage navigation, the resulting expression is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e46251"></a><a id="d8e46360"></a>Example: A recursive absorbing stylesheet function</div><p>The following function is declared as absorbing, and the function body meets the rules for this category. Analysis of the function body reveals that it is grounded and consuming; to establish this, it is necessary to analyze the recursive call <code>f:outline(*)</code>, and this is possible because it is known to be a call on an absorbing stylesheet function.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:outline</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">absorbing</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element()*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$input</span><span class="whitespace"></span><span class="op">!</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="function">name</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">(</span><span class="op">'</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="function">f:outline</span><span class="parenthesis">(</span><span class="op">*</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">||</span><span class="whitespace"></span><span class="op">'</span><span class="literal">)</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">separator</span><span class="atneq">=</span><span class="z">"</span><span class="av">, </span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is guaranteed streamable in the typical case where the sequence supplied as the value of the <code>$input</code> argument is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></div></div><div class="div4"><h5><a id="category-inspection"></a>19.8.5.3 <a href="#category-inspection" style="text-decoration: none">Streamability Category: inspection</a></h5><p><b>Informal description:</b> Functions in this category typically return properties of the node supplied in the first argument, where these properties can be determined without advancing the input stream. This allows access to properties such as the name and type of each node, and also to its ancestors, attributes, and namespaces. </p><p><b>Rules for the function signature:</b> If the declared type of the streaming parameter permits more than one node, the function is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p><p><b>Rules for the function body:</b> For the function to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture</a> of the function body with respect to the declared return type must be <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted sweep</a> of the function body with respect to the declared return type must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for references to the streaming parameter:</b> Such a variable reference is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for function calls:</b> the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. The operands are the expressions appearing in the argument list of the function call. The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the first argument is <a title="inspection" class="termref" href="#dt-inspection">inspection</a>; the operand usage of other arguments is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the declared type of the corresponding argument in the function signature. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> is restricted to be a single node because if <code>$input</code> were a sequence of nodes, then an expression such as <code>($input/name(), $input/@id)</code> would not be streamable.</p></div><div class="example"><div class="exampleHeader"><a id="d8e46319"></a><a id="d8e46428"></a>Example: Example of an inspection stylesheet function</div><p>The following function is declared with category <code>inspection</code>, and the function body meets the rules for this category because all references to the supplied node are motionless.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:depth</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">inspection</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="step">/</span><span class="axis">ancestor-or-self::</span><span class="op">*</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is guaranteed streamable provided that the expression supplied as the value of the <code>$input</code> argument is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e46335"></a><a id="d8e46444"></a>Example: Example of an inspection stylesheet function with two arguments</div><p>The following function is declared with category <code>inspection</code>, and the function body meets the rules for this category because the function signature ensures that the second argument cannot be a node.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:get-attribute-value</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">element</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">attribute-name</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:string</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string</span><span class="parenthesis">(</span><span class="variable">$element</span><span class="step">/</span><span class="axis">@</span><span class="op">*</span><span class="filter">[</span><span class="function">local-name</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="variable">$attribute-name</span><span class="filter">]</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Although the normal usage of this function might be to supply an element from a streamed document as the first argument, and a literal string as the second, it is also permissible (and guaranteed streamable) to supply an unstreamed element as the first argument, and an element node from a streamed document as the second. When applying the general streamability rules in this case, the first operand is grounded and motionless, while the second is grounded and consuming (by virtue of the rules for type-determined usage), and this makes the function call grounded and consuming.</p></div></div><div class="div4"><h5><a id="category-filter"></a>19.8.5.4 <a href="#category-filter" style="text-decoration: none">Streamability Category: filter</a></h5><p><b>Informal description:</b> Functions in this category typically return either the node supplied in the first argument or nothing, depending on the values of properties that can be determined without advancing the input stream. This allows access to properties such as the name and type of each node, and also to its ancestors, attributes, and namespaces. </p><p><b>Rules for the function signature:</b> If the declared type of the streaming parameter permits more than one node, the function is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p><p><b>Rules for the function body:</b> For the function to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture</a> of the function body with respect to the declared return type must be <a title="striding" class="termref" href="#dt-striding">striding</a>, and the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted sweep</a> of the function body with respect to the declared return type must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for references to the streaming parameter:</b> Such a variable reference is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for function calls:</b> The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a call to a function in this category are determined by applying the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. The operands are the expressions supplied as arguments to the function call. The first argument has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="transmission" class="termref" href="#dt-transmission">transmission</a>; any further arguments have <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the declared type of the corresponding parameter in the function signature.</p><div class="example"><div class="exampleHeader"><a id="d8e46393"></a><a id="d8e46502"></a>Example: Example of a filtering stylesheet function</div><p>The following function is declared as filtering, and the function body meets the rules for this category because it selects nodes from the input based on motionless properties (namely, the existence of attributes).</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:large-regions</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(region)</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">filter</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(region)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$input</span><span class="filter">[</span><span class="axis">@</span><span class="qname">size</span><span class="whitespace"></span><span class="op">gt</span><span class="whitespace"></span><span class="numeric">1000</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that the posture and sweep of a function call <code>f:large-regions(EXPR)</code> are the same as the posture and sweep of <code>EXPR</code>.</p><p>Although the name <code>filter</code> suggests that the result must always be a subset of the input, this is not strictly required by the rules. The function can also return atomic values, as well as attribute and namespace nodes.</p></div></div><div class="div4"><h5><a id="category-shallow-descent"></a>19.8.5.5 <a href="#category-shallow-descent" style="text-decoration: none">Streamability Category: shallow-descent</a></h5><p><b>Informal description:</b> Functions in this category typically return children of the nodes supplied in the first argument. They may also select deeper in the subtrees of these nodes, provided that no node in the result can possibly be an ancestor of any other node in the result. </p><p><b>Rules for the function signature:</b> If the declared type of the streaming parameter permits more than one node, the function is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p><p><b>Rules for the function body:</b> For the function to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture</a> of the function body with respect to the declared return type must be <a title="striding" class="termref" href="#dt-striding">striding</a>, and the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted sweep</a> of the function body with respect to the declared return type must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p><p><b>Rules for references to the streaming parameter:</b> Such a variable reference is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for function calls:</b> The rules are as follows, in order:</p><ol class="enumar"><li><p>Let <var>T<sub>0</sub></var> be the <a title="U-type" class="termref" href="#dt-utype">U-type</a> corresponding to the declared type of the <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> in the function signature (defaulting to <var>U{*}</var>).</p></li><li><p>Let <var>P<sub>0</sub></var> and <var>S<sub>0</sub></var> be the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture and sweep</a> of the first argument expression, based on type <var>T<sub>0</sub></var>.</p></li><li><p>If <var>P<sub>0</sub></var> is not <a title="striding" class="termref" href="#dt-striding">striding</a> or <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Consider a construct <var>C</var> whose operands are the argument expressions other than the first argument, with <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined operand usage</a> based on the declared type of the corresponding parameter in the function signature. Let <var>P<sub>1</sub></var> and <var>S<sub>1</sub></var> be the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>C</var>, assessed using the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>If there is only one argument, then <var>P<sub>1</sub></var> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <var>S<sub>1</sub></var> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></div></li><li><p>If <var>P<sub>1</sub></var> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If <var>S<sub>0</sub></var> and <var>S<sub>1</sub></var> are both <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, or if either is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, then the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If <var>P<sub>0</sub></var> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> of the function call is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function call is the wider of <var>S<sub>0</sub></var> and <var>S<sub>1</sub></var>.</p></li><li><p>Otherwise, the <a title="posture" class="termref" href="#dt-posture">posture</a> of the function call is <var>P<sub>0</sub></var>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function call is as follows:</p><ol class="enumla"><li><p>If the intersection of <var>T<sub>0</sub></var> with <var>U{document-node(), element()}</var> is empty (that is, the declared type of the first argument does not permit document or element nodes) then <var>S<sub>0</sub></var>.</p></li><li><p>Let <var>A</var> be the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the expression supplied as the first argument. If the intersection of <var>A</var> with <var>U{document-node(), element()}</var> is empty (that is, the inferred type of the expression supplied as the first argument does not permit document or element nodes) then <var>S<sub>0</sub></var>.</p></li><li><p>Otherwise, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li></ol><div class="example"><div class="exampleHeader"><a id="d8e46596"></a><a id="d8e46705"></a>Example: A shallow-descent stylesheet function</div><p>The following function is declared as shallow-descent, and the function body meets the rules for this category because it selects children of the supplied input node.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:alternate-children</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">node()*</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">shallow-descent</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$input</span><span class="step">/</span><span class="node-type">node</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="filter">[</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">mod</span><span class="whitespace"></span><span class="numeric">2</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="numeric">1</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is guaranteed streamable in the typical case where the node supplied as the value of the <code>$input</code> argument is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></div></div><div class="div4"><h5><a id="category-deep-descent"></a>19.8.5.6 <a href="#category-deep-descent" style="text-decoration: none">Streamability Category: deep-descent</a></h5><p><b>Informal description:</b> Functions in this category typically return descendants of the nodes supplied in the first argument. </p><p><b>Rules for the function signature:</b> If the declared type of the streaming parameter permits more than one node, the function is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p><p><b>Rules for the function body:</b> For the function to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture</a> of the function body with respect to the declared return type must be <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, and the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted sweep</a> of the function body with respect to the declared return type must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p><p><b>Rules for references to the streaming parameter:</b> Such a variable reference is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for function calls:</b> The rules are as follows, in order:</p><ol class="enumar"><li><p>Let <var>T<sub>0</sub></var> be the <a title="U-type" class="termref" href="#dt-utype">U-type</a> corresponding to the declared type of the <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> in the function signature (defaulting to <var>U{*}</var>).</p></li><li><p>Let <var>P<sub>0</sub></var> and <var>S<sub>0</sub></var> be the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture and sweep</a> of the first argument expression, based on type <var>T<sub>0</sub></var>.</p></li><li><p>If <var>P<sub>0</sub></var> is not <a title="striding" class="termref" href="#dt-striding">striding</a> or <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Consider a construct <var>C</var> whose operands are the argument expressions other than the first argument, with <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined operand usage</a> based on the declared type of the corresponding parameter in the function signature. Let <var>P<sub>1</sub></var> and <var>S<sub>1</sub></var> be the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>C</var>, assessed using the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a></p><div class="note"><p class="prefix"><b>Note:</b></p><p>If there is only one argument, then <var>P<sub>1</sub></var> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <var>S<sub>1</sub></var> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></div></li><li><p>If <var>P<sub>1</sub></var> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If <var>S<sub>0</sub></var> and <var>S<sub>1</sub></var> are both <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, or if either is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If <var>P<sub>0</sub></var> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> of the function call is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function call is the wider of <var>S<sub>0</sub></var> and <var>S<sub>1</sub></var>.</p></li><li><p>Otherwise, the <a title="posture" class="termref" href="#dt-posture">posture</a> of the function call is <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function call is as follows:</p><ol class="enumla"><li><p>If the intersection of <var>T<sub>0</sub></var> with <var>U{document-node(), element()}</var> is empty (that is, the declared type of the first argument does not permit document or element nodes) then <var>S<sub>0</sub></var>.</p></li><li><p>Let <var>A</var> be the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the expression supplied as the first argument. If the intersection of <var>A</var> with <var>U{document-node(), element()}</var> is empty (that is, the inferred type of the expression supplied as the first argument does not permit document or element nodes) then <var>S<sub>0</sub></var>.</p></li><li><p>Otherwise, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li></ol><div class="example"><div class="exampleHeader"><a id="d8e46796"></a><a id="d8e46905"></a>Example: A deep-descent stylesheet function</div><p>The following function is declared as deep-descent, and the function body meets the rules for this category because it selects descendants of the supplied input node.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:all-comments</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">comment()*</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">deep-descent</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element()</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$input</span><span class="step">//</span><span class="node-type">comment</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is guaranteed streamable in the typical case where the node supplied as the value of the <code>$input</code> argument is <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></div></div><div class="div4"><h5><a id="category-ascent"></a>19.8.5.7 <a href="#category-ascent" style="text-decoration: none">Streamability Category: ascent</a></h5><p><b>Informal description:</b> Functions in this category typically return ancestors of the nodes supplied in the first argument. </p><p><b>Rules for the function signature:</b> If the declared type of the streaming parameter permits more than one node, the function is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p><p><b>Rules for the function body:</b> For the function to be <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture</a> of the function body with respect to the declared return type must be either <a title="climbing" class="termref" href="#dt-climbing">climbing</a> or <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and the <a title="type-adjusted posture and sweep" class="termref" href="#dt-type-adjusted-posture-and-sweep">type-adjusted sweep</a> of the function body with respect to the declared return type must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for references to the streaming parameter:</b> Such a variable reference is <a title="climbing" class="termref" href="#dt-climbing">climbing</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p><b>Rules for function calls:</b> The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a call to a function in this category are determined as follows:</p><ol class="enumar"><li><p>Let <var>P<sub>0</sub></var> and <var>S<sub>0</sub></var> be the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> obtained by assessing the function call using the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, where the operands are the arguments to the function call, with an <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> for the first argument of <span><a title="transmission" class="termref" href="#dt-transmission">transmission</a></span>, and an <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> for arguments after the first being the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the declared type of the corresponding <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>. <span>[XSLT 3.0 Erratum E31, bug 30289]</span></p></li><li><p>If <var>P<sub>0</sub></var> is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> or <var>S<sub>0</sub></var> is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, then the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If <var>S<sub>0</sub></var> is not <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, then the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If <var>P<sub>0</sub></var> is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, then the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If <var>P<sub>0</sub></var> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the function call is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>If the declared return type of the function does not permit nodes, then the function call is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. [XSLT 3.0 Erratum E31, bug 30289].</p></li><li><p>Otherwise, the function call is <a title="climbing" class="termref" href="#dt-climbing">climbing</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol><div class="example"><div class="exampleHeader"><a id="d8e46942"></a><a id="d8e47051"></a>Example: An ascending stylesheet function</div><p>The following function is declared with category <code>ascent</code>, and the function body meets the rules for this category because it selects ancestors of the supplied node.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:containing-section</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(section)</span><span class="z">"</span><span class="z"></span><span class="atn">streamability</span><span class="atneq">=</span><span class="z">"</span><span class="av">ascent</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">input</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(para)*</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$input</span><span class="step">/</span><span class="axis">ancestor::</span><span class="qname">section</span><span class="filter">[</span><span class="function">last</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The effect of the rules is that a call to this function is guaranteed streamable provided that the node supplied as the value of the <code>input</code> argument is not <a title="roaming" class="termref" href="#dt-roaming">roaming</a> or <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. There are no other constraints on the node supplied in the input sequence.</p></div></div></div><div class="div3"><h4><a id="classifying-attribute-sets"></a>19.8.6 <a href="#classifying-attribute-sets" style="text-decoration: none">Classifying Attribute Sets</a></h4><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is always <a title="grounded" class="termref" href="#dt-grounded">grounded</a> (its result can never return streamed nodes).</p><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> if all the following conditions hold:</p><ol class="enumar"><li><p>Every <a href="#element-attribute"><code>xsl:attribute</code></a> instruction within the declarations comprising the attribute set is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> when assessed as described in <a href="#streamability-of-attribute-sets"><i>10.2.3 Streamability of Attribute Sets</i></a>, using a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>Every attribute set referenced in the <code>use-attribute-sets</code> attribute of an <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration of the attribute set has the attribute <code>streamable="yes"</code>.</p></li><li><p></p></li></ol><p>If the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is not <a title="motionless" class="termref" href="#dt-motionless">motionless</a> then it is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Attribute sets will always be <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, because they return newly constructed attribute nodes.</p><p>Attribute sets will very often be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, but if they access the context item, they may be <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. Although some attribute sets could theoretically be classified as <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, this option has been excluded because it is unlikely to be useful; given the requirement to create attributes whose values are obtained by reading a streamed input document, use of a streamable <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is a more versatile approach.</p><p>Because attribute sets can be overridden in another <a title="package" class="termref" href="#dt-package">package</a>, the streamability of a construct such as an <a href="#element-element"><code>xsl:element</code></a> instruction containing a <code>use-attribute-sets</code> attribute is based on the declared streamability of the named attribute sets, as defined by the <code>streamable</code> attribute of the <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element. If <code>streamable="yes"</code> is specified, then there is a requirement that any overriding attribute set should also specify <code>streamable="yes"</code>, and a streaming processor is required to check that an attribute set containing such a declaration does in fact satisfy the streamability rules.</p></div></div><div class="div3"><h4><a id="classifying-vts"></a>19.8.7 <a href="#classifying-vts" style="text-decoration: none">Classifying Value Templates</a></h4><p>A <a title="value template" class="termref" href="#dt-value-template">value template</a> (that is, an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> or <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a>) is a <a title="construct" class="termref" href="#dt-construct">construct</a> whose operands are the expressions contained within curly brackets. The required type for this operand role is <code>xs:string</code> and the <a title="operand usage" class="termref" href="#dt-operand-usage">usage</a> is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of a value template are determined using the general rules in <a href="#general-streamability-rules"><i>19.8.1 General Rules for Streamability</i></a>.</p><p>If there are no expressions contained within curly brackets, the value template is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></div><div class="div3"><h4><a id="classifying-expressions"></a>19.8.8 <a href="#classifying-expressions" style="text-decoration: none">Classifying Expressions</a></h4><p>XPath expressions are classified using the rules in this section.</p><p>In the analysis that follows, <a title="expression" class="termref" href="#dt-expression">expressions</a> are classified according to the most specific production rule that they match for which there is an entry in this section. A production <var>P</var> is considered more specific than a production <var>Q</var> (<var>Q</var> ≠ <var>P</var>) if every expression that matches <var>P</var> also matches <var>Q</var>. For example:</p><ul><li><p>The expression <code>3</code> satisfies the productions <code>NumericLiteral</code>, <code>Literal</code>, and <code>ArithmeticExpression</code>; the most specific of these for which there is an entry in this section is <code>Literal</code>.</p></li><li><p>The expression <code>text()</code> (appearing as an expression) is a <code>TextTest</code>, and therefore a <code>KindTest</code>, which is itself a <code>NodeTest</code>, and therefore an <code>AxisStep</code> with a defaulted <code>ForwardAxis</code>. The most specific of these for which there is an entry in this section is <code>AxisStep</code>. Although the expression is also a <code>RelativePathExpr</code>, that production is less specific than <code>AxisStep</code> so its rules do not apply.</p></li><li><p>The expression <code>section/title</code> is a <code>RelativePathExpr</code>, for which there is an entry in this section. Although the expression is also a <code>PathExpr</code>, that production is less specific than <code>RelativePathExpr</code> so its rules do not apply.</p></li></ul><p>The production rules for different kinds of expression are listed (with their names and numbers) in the order in which they appear in Appendix A.1 of the XPath 3.0 specification; rules are also given for new constructs introduced by XPath 3.1. Where two numbers are given, they are the production rule numbers in XPath 3.0 and XPath 3.1 respectively; where there is a single number, it is the production rule number in XPath 3.1.</p><p>Many expressions can be analyzed using the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. These are indicated in the table below by means of a simple proforma in which the <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> are represented by a short code (A = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, I = <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, T = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, N = <a title="navigation" class="termref" href="#dt-navigation">navigation</a>). For example the proforma <code>A + A</code> indicates that for an arithmetic expression, both operands have <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="absorption" class="termref" href="#dt-absorption">absorption</a>, while <code>I or I</code> indicates that for an <code>or</code> expression, both operands have <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="inspection" class="termref" href="#dt-inspection">inspection</a>. For expressions where further explanation is needed, the table contains a link to the relevant section.</p><table class="data"><caption>Operand Roles for XPath Expressions</caption><thead><tr><th style="text-align:left; vertical-align:top">Construct</th><th style="text-align:left; vertical-align:top">Proforma or Reference to Detailed Rules</th><th style="text-align:left; vertical-align:top">Further Information</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">Expr [6,6] </td><td style="text-align:left; vertical-align:top"><code>T, T</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">ForExpr [8,8] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-for-expressions"><i>19.8.8.1 Streamability of for Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">LetExpr [11,11] </td><td style="text-align:left; vertical-align:top"><code>let $var := N return T</code></td><td style="text-align:left; vertical-align:top">Binding of variables to streamed nodes is not allowed.</td></tr><tr><td style="text-align:left; vertical-align:top">QuantifiedExpr [14,14]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-quantified-expressions"><i>19.8.8.2 Streamability of Quantified Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">IfExpr [15,15] </td><td style="text-align:left; vertical-align:top"><code>if (I) then T else T</code></td><td style="text-align:left; vertical-align:top">The then-clause and else-clause form a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a> with usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a></td></tr><tr><td style="text-align:left; vertical-align:top">OrExpr [16,16]</td><td style="text-align:left; vertical-align:top"><code>I or I</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">AndExpr [17,17]</td><td style="text-align:left; vertical-align:top"><code>I and I</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">StringConcatExpr [19,19]</td><td style="text-align:left; vertical-align:top"><code>A || A</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">RangeExpr [20,20]</td><td style="text-align:left; vertical-align:top"><code>A to A</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">AdditiveExpr [21,21]</td><td style="text-align:left; vertical-align:top"><code>A + A</code>, <code>A - A</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">MultiplicativeExpr [22,22]</td><td style="text-align:left; vertical-align:top"><code>A * A</code>, <code>A div A</code>, etc.</td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">UnionExpr [23,23] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-union-expressions"><i>19.8.8.4 Streamability of union, intersect, and except Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">IntersectExceptExpr [24,24] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-union-expressions"><i>19.8.8.4 Streamability of union, intersect, and except Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">InstanceOfExpr [25,25]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-instance-of-expressions"><i>19.8.8.5 Streamability of instance of Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">TreatExpr [26,26]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-treat-as-expressions"><i>19.8.8.6 Streamability of treat as Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">CastableExpr [27,27]</td><td style="text-align:left; vertical-align:top"><code>A castable as TYPE</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">CastExpr [28,28] </td><td style="text-align:left; vertical-align:top"><code>A cast as TYPE</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">UnaryExpr [29,30]</td><td style="text-align:left; vertical-align:top"><code>+A</code>, <code>-A</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">GeneralComp [31,32]</td><td style="text-align:left; vertical-align:top"><code>A = A</code>, <code>A &lt; A</code>, <code>A != A</code>, etc.</td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">ValueComp [32,33]</td><td style="text-align:left; vertical-align:top"><code>A eq A</code>, <code>A lt A</code>, <code>A ne A</code>, etc.</td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">NodeComp [33,34]</td><td style="text-align:left; vertical-align:top"><code>I is I</code>, <code>I &lt;&lt; I</code>, <code>I &gt;&gt; I</code></td><td style="text-align:left; vertical-align:top">See Note 1 below</td></tr><tr><td style="text-align:left; vertical-align:top">SimpleMapExpr [34,35] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-simple-mapping-expressions"><i>19.8.8.7 Streamability of Simple Mapping Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">PathExpr [35,36] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">RelativePathExpr [36,37] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">AxisStep [38,39] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">ForwardStep [39,40], ReverseStep [42,43]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">PostfixExpr [48,49]: Filter Expression</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-filter-expressions"><i>19.8.8.10 Streamability of Filter Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">PostfixExpr [48,49]: Dynamic Function Call</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-dynamic-function-calls"><i>19.8.8.11 Streamability of Dynamic Function Calls</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">Literal [53,57]</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">There are no operands, so the construct is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a></td></tr><tr><td style="text-align:left; vertical-align:top">VarRef [55,59]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-variable-references"><i>19.8.8.12 Streamability of Variable References</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top" rowspan="2">ParenthesizedExpr [57,61]</td><td style="text-align:left; vertical-align:top"><code>(T)</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top"><code>()</code></td><td style="text-align:left; vertical-align:top">There are no operands, so the construct is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a></td></tr><tr><td style="text-align:left; vertical-align:top">ContextItemExpr [58,62]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-context-item-expression"><i>19.8.8.13 Streamability of the Context Item Expression</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">FunctionCall [59,63]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-function-calls"><i>19.8.8.14 Streamability of Static Function Calls</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">NamedFunctionRef [63,67]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-named-function-ref"><i>19.8.8.15 Streamability of Named Function References</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">InlineFunctionExpr [64,68] </td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-inline-functions"><i>19.8.8.16 Streamability of Inline Function Declarations</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">MapConstructor [,69]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-map-constructors"><i>19.8.8.17 Streamability of Map Constructors</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">Lookup (Postfix [,49] and Unary [,53])</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-lookup-expressions"><i>19.8.8.18 Streamability of Lookup Expressions</i></a></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">ArrowExpr [,29]</td><td style="text-align:left; vertical-align:top">See <a href="#streamability-of-function-calls"><i>19.8.8.14 Streamability of Static Function Calls</i></a> and <a href="#streamability-of-dynamic-function-calls"><i>19.8.8.11 Streamability of Dynamic Function Calls</i></a>: the rules for <code>X =&gt; F(Y, Z)</code> are the same as the rules for <code>F(X, Y, Z)</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">SquareArrayConstructor [,74]</td><td style="text-align:left; vertical-align:top"><code>[N, N, ...]</code></td><td style="text-align:left; vertical-align:top"></td></tr><tr><td style="text-align:left; vertical-align:top">CurlyArrayConstructor [,75]</td><td style="text-align:left; vertical-align:top"><code>array{N, N, ...}</code></td><td style="text-align:left; vertical-align:top"></td></tr></tbody></table><div class="note"><p class="prefix"><b>Note:</b></p><ol class="enumar"><li><p> The operators <code>is</code>, <code>&lt;&lt;</code>, and <code>&gt;&gt;</code> apply to streamed nodes just as to any other nodes, though there are few practical situations where they will be useful. A streamed document conforms to the rules of the XDM data model, and its nodes are therefore distinct and ordered. They follow the usual rules, for example that a parent node precedes its children in document order. Expressions such as <code>.. is parent::X</code> or <code>ancestor::x[1] &lt;&lt; ancestor::y[1]</code> are therefore perfectly meaningful. The usefulness of the operators is limited by the fact that variables cannot be bound to nodes in a streamed document. It is permitted, though perhaps not useful, for one of the operands to be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>: one can write <code>. &lt;&lt; child::x</code>, and the resulting expression is (by applying the general rules) <a title="consuming" class="termref" href="#dt-consuming">consuming</a> and grounded.</p><p>The restriction that variables cannot be bound to streamed nodes prevents writing of expressions such as <code>let $x := . return descendant::x[ancestor::y[1] is $x]</code>. As a workaround, the intended effect can be achieved by comparing node identity using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-generate-id"><code>generate-id</code></a><sup><small>FO30</small></sup> function: <code>let $x := generate-id(.) return descendant::x[generate-id(ancestor::y[1]) = $x]</code></p></li></ol></div><div class="div4"><h5><a id="streamability-of-for-expressions"></a>19.8.8.1 <a href="#streamability-of-for-expressions" style="text-decoration: none">Streamability of </a><code>for</code><a href="#streamability-of-for-expressions" style="text-decoration: none"> Expressions</a></h5><p>Writing the expression as <code>for $v in S return R</code>, the two operand roles are <var>S</var> and <var>R</var>.</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are determined by the first of the following that applies:</p><ol class="enumar"><li><p>If <var>S</var> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Otherwise, the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. The operand roles are:</p><ol class="enumla"><li><p>The <code>in</code> expression (<code>S</code>). This has <a title="operand usage" class="termref" href="#dt-operand-usage">usage</a><a title="navigation" class="termref" href="#dt-navigation">navigation</a>.</p></li><li><p>The <code>return</code> expression (<code>R</code>). This is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> with <a title="operand usage" class="termref" href="#dt-operand-usage">usage</a><a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p></li></ol></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Expressions of the form <code>for $i in 1 to 3 return $i*2</code>, where there is no reference to a streamed node, are clearly streamable.</p><p>The <code>in</code> expression can also be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, for example <code>for $e in copy-of(emp) return $e/salary</code>.</p><p>The rule that <var>S</var> must be grounded prevents the variable being bound to a node in a streamed document. This disallows expressions of the form <code>for $x in child::section return $x/para</code>, because this requires data flow analysis (tracing from the binding of a variable to its usages), rather than purely syntactic analysis. Some implementations may be able to stream such constructs.</p><p>The fact that the return clause is a higher-order operand prevents it from being a <a title="consuming" class="termref" href="#dt-consuming">consuming</a> expression, for example <code>for $i in 1 to 3 return salary</code>. Use of a motionless expression that accesses streamed nodes is however allowed, for example <code>for $i in 1 to 3 return name(ancestor::x[$i])</code>.</p></div></div><div class="div4"><h5><a id="streamability-of-quantified-expressions"></a>19.8.8.2 <a href="#streamability-of-quantified-expressions" style="text-decoration: none">Streamability of Quantified Expressions</a></h5><p>An expression with multiple in-clauses is first rewritten using nested quantified expressions: for example <code>some $i in X, $j in Y satisfies $i eq $j</code> can be rewritten as <code>some $i in X satisfies (some $j in Y satisfies $i eq $j)</code>. The analysis therefore only needs to consider expressions with a single in-clause.</p><p>Writing such an expression as <code>some|every $v in S satisfies C</code>, the two operand roles are <var>S</var> and <var>C</var>.</p><p>The <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. The <a title="operand role" class="termref" href="#dt-operand-role">operand roles</a> are:</p><ol class="enumar"><li><p>The <code>in</code> expression (<var>S</var>). This has usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>.</p></li><li><p>The <code>satisfies</code> expression (<var>C</var>). This is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> with usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Expressions of the form some <code>$i in 1 to 3 satisfies $i lt 2</code>, where there is no reference to a streamed node, are clearly streamable. </p><p>The expression <var>S</var> can be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, so long as it is grounded: for example <code>some $e in emp/salary/number(.) satisfies $e gt 10000</code>. </p><p>The rule that <var>S</var> has usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a> prevents the variable being bound to a node in a streamed document. This disallows expressions of the form <code>some $x in child::section satisfies has-children($x)</code>, because this requires data flow analysis (tracing from the binding of a variable to its usages), rather than purely syntactic analysis. Some implementations may be able to stream such constructs. </p><p>The fact that <var>C</var> is a higher-order operand prevents it from being a <a title="consuming" class="termref" href="#dt-consuming">consuming</a> expression: for example <code>some $i in 1 to 3 satisfies author[$i] eq "Kay"</code> is not streamable. Use of a motionless expression that accesses streamed nodes is however allowed, for example <code>some $i in 1 to 3 satisfies @grade = $i</code>. </p><p>Quantified expressions that fail the streamability rules can often be rewritten as filter expressions. For example, the expression <code>some $x in child::section satisfies has-children($x)</code> can be rewritten as <code>exists(child::section[has-children(.)])</code>, which is grounded and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. </p></div></div><div class="div4"><h5><a id="streamability-of-if-expressions"></a>19.8.8.3 <a href="#streamability-of-if-expressions" style="text-decoration: none">Streamability of </a><code>if</code><a href="#streamability-of-if-expressions" style="text-decoration: none"> expressions</a></h5><p>Writing the expression as <code>if (C) then T else E</code>, there are three operand roles: <var>C</var>, <var>T</var>, and <var>E</var>. The <a title="operand usage" class="termref" href="#dt-operand-usage">usage</a> of <var>C</var> is <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, while the <a title="operand usage" class="termref" href="#dt-operand-usage">usage</a> of <var>T</var> and <var>E</var> is <a title="transmission" class="termref" href="#dt-transmission">transmission</a>. Operands <var>T</var> and <var>E</var> form a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a>, meaning that they can both consume the input stream, provided they have consistent <a title="posture" class="termref" href="#dt-posture">posture</a>. The <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply.</p></div><div class="div4"><h5><a id="streamability-of-union-expressions"></a>19.8.8.4 <a href="#streamability-of-union-expressions" style="text-decoration: none">Streamability of </a><code>union</code><a href="#streamability-of-union-expressions" style="text-decoration: none">, </a><code>intersect</code><a href="#streamability-of-union-expressions" style="text-decoration: none">, and </a><code>except</code><a href="#streamability-of-union-expressions" style="text-decoration: none"> Expressions</a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are the first of the following that applies:</p><ol class="enumar"><li><p>If either of the two operands is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> (Example: <code>. | following-sibling::*</code>).</p></li><li><p>If either of the two operands is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the other operand (Example: <code>. | doc('abc.com')//x</code>)</p></li><li><p>If both operands are <a title="climbing" class="termref" href="#dt-climbing">climbing</a>, then <a title="climbing" class="termref" href="#dt-climbing">climbing</a> and the wider of the sweeps of the two operands (Example: <code>parent::A | */ancestor::B</code>).</p></li><li><p>If the left-hand operand is <a title="striding" class="termref" href="#dt-striding">striding</a> or <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and the right-hand operand is also <a title="striding" class="termref" href="#dt-striding">striding</a> or <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, then <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and the wider of the sweeps of the two operands (Example: <code>* | */*</code>).</p></li><li><p>Otherwise, <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> (Example: <code>child::div | parent::div</code>).</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Essentially the principle is that if both operands are streamable, then the result is streamable (this assumes an evaluation strategy where both operands are evaluated during the same pass of the streamed input document, and the results merged). But there are caveats because of the need for static streamability analysis of the result. This prevents constructs such as <code>.. | *</code> that have heterogeneous <a title="posture" class="termref" href="#dt-posture">posture</a>.</p><p>Where the two operands are both <a title="striding" class="termref" href="#dt-striding">striding</a>, there are cases where an implementation could determine that the result is also <a title="striding" class="termref" href="#dt-striding">striding</a>: for example <code>(author | editor)</code>. In general, however, the combination of two striding operands may produce a sequence of nodes that have nested subtrees (consider <code>author | author/name</code>), so the result is classified as <a title="crawling" class="termref" href="#dt-crawling">crawling</a>.</p><p>The expression <code>(author | editor)</code>, although it is not <a title="striding" class="termref" href="#dt-striding">striding</a>, can be rewritten in the form <code>*[self::author or self::editor]</code>, which is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></div></div><div class="div4"><h5><a id="streamability-of-instance-of-expressions"></a>19.8.8.5 <a href="#streamability-of-instance-of-expressions" style="text-decoration: none">Streamability of </a><code>instance of</code><a href="#streamability-of-instance-of-expressions" style="text-decoration: none"> Expressions</a></h5><p>For an expression of the form <var>X</var> instance of <var>ST</var> (where <var>X</var> is an expression and <var>ST</var> is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>), the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are determined by the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. There is a single operand <var>X</var>, whose <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is as follows:</p><ol class="enumar"><li><p>If the <code>ItemType</code> of <var>ST</var> is a <code>DocumentTest</code>, optionally parenthesized, that contains an <code>ElementTest</code> or <code>SchemaElementTest</code> then absorption</p></li><li><p>Otherwise, inspection.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>In general, it is possible to determine whether a node matches an <code>ItemType</code> without consuming the node. For example it can be established whether an element matches the test <code>element(para)</code> when positioned at the start tag.</p><p>An <code>ItemType</code> of the form <code>document-node(element(X))</code> is an exception to this rule because it matches a document node only if it has exactly one element node child, and this cannot be determined without consuming the document. </p><p>A processor may have knowledge that the document node cannot contain multiple element nodes, for example because it knows that the source of the streamed document is an XML parser that is not capable of generating such a stream. In such cases the processor may make a different assessment of the streamability of this construct. This comes under the general provision that a processor is always at liberty to use streaming even when the stylesheet is not guaranteed streamable. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>As with other constructs that are evaluated with inspection usage, for example the <a href="https://www.w3.org/TR/xpath-functions-30/#func-name"><code>name</code></a><sup><small>FO30</small></sup> function or access to an attribute node, evaluation of a construct such as <code>$X instance of schema-element(E)</code> as true or false may be invalidated if reading of the input stream subsequently fails. Dynamic errors during streamed processing of an input document invalidate all output generated prior to the failure, and this case is no different. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Given an expression such as <code>child::* instance of element(E)*</code>, the expression as a whole is <a title="consuming" class="termref" href="#dt-consuming">consuming</a> and grounded. By contrast, the expression <code>. instance of element(E)*</code> is motionless and grounded. This can be verified by applying the general streamability rules to these cases. </p></div></div><div class="div4"><h5><a id="streamability-of-treat-as-expressions"></a>19.8.8.6 <a href="#streamability-of-treat-as-expressions" style="text-decoration: none">Streamability of </a><code>treat as</code><a href="#streamability-of-treat-as-expressions" style="text-decoration: none"> Expressions</a></h5><p></p><p>For an expression of the form <var>X</var> treat as <var>ST</var> (where <var>X</var> is an expression and <var>ST</var> is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>), the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are determined as follows: </p><ol class="enumar"><li><p>If the <code>ItemType</code> of <var>ST</var> is a <code>DocumentTest</code>, optionally parenthesized, that contains an <code>ElementTest</code> or <code>SchemaElementTest</code> then <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>Otherwise, the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. There is a single operand <var>X</var>, whose <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is <a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>See the notes in <a href="#streamability-of-instance-of-expressions"><i>19.8.8.5 Streamability of instance of Expressions</i></a> for a discussion of the streamability difficulties associated with <code>document-node()</code> tests.</p></div></div><div class="div4"><h5><a id="streamability-of-simple-mapping-expressions"></a>19.8.8.7 <a href="#streamability-of-simple-mapping-expressions" style="text-decoration: none">Streamability of Simple Mapping Expressions</a></h5><p>The mapping operator <code>!</code> is treated as a left-associative binary operator, so the expression <code>a!b!c</code> is processed as <code>(a!b)!c</code>.</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the expression is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the right-hand operand, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> and type set to the <a title="posture" class="termref" href="#dt-posture">posture</a> and type of the left-hand operand.</p><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the expression is the wider of the <a title="sweep" class="termref" href="#dt-sweep">sweeps</a> of the two operands.</p></div><div class="div4"><h5><a id="streamability-of-path-expressions"></a>19.8.8.8 <a href="#streamability-of-path-expressions" style="text-decoration: none">Streamability of Path Expressions</a></h5><p>The streamability analysis applies after the expansion of the <code>//</code> pseudo-operator to <code>/descendant-or-self::node()/</code>, and after expanding <code>..</code> to <code>parent::node()</code>, <code>@X</code> to <code>attribute::X</code>, and an omitted axis to the default axis for the node kind.</p><p>Following the rules in XPath, a leading <code>"/"</code> is converted to <code>(root(self::node()) treat as document-node())/</code> (with the final <code>"/"</code> omitted for the expression <code>"/"</code> on its own). This is followed by a rewrite of the call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup>, as described in <a href="#streamability-fn-root"><i>19.8.9.18 Streamability of the root Function</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Taken together, these rewrites have the effect that a path expression such as <code>//a</code> is streamable only if the statically determined context item type is <code>document-node()</code>, which will be the case for example immediately within <a href="#element-source-document"><code>xsl:source-document</code></a>, or in a template rule with <code>match="/"</code>.</p></div><p>A <code>RelativePathExpr</code> with more than two operands (such as <code>a/b/c</code>) is taken as a tree of binary expressions (that is, <code>(a/b)/c</code>).</p><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a relative path expression is the wider <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the two operands, where the ordering of increasing width is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Examples:</p><ul><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <code>a/@code</code> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a> (the wider of <a title="consuming" class="termref" href="#dt-consuming">consuming</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>).</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <code>a/descendant::b</code> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a> (the wider of <a title="consuming" class="termref" href="#dt-consuming">consuming</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>).</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <code>./@code</code> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> (the wider of <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>).</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <code>./a</code> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a> (the wider of <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>).</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <code>a/following::b</code> is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> (the wider of <a title="consuming" class="termref" href="#dt-consuming">consuming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>).</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <code>./.</code> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> (the wider of <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>).</p></li></ul></div><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of a relative path expression is assessed in two phases, as follows:</p><ol class="enumar"><li><p>First, the provisional <a title="posture" class="termref" href="#dt-posture">posture</a> is determined as follows: The provisional <a title="posture" class="termref" href="#dt-posture">posture</a> of the expression is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the right-hand operand, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> and type set to the <a title="posture" class="termref" href="#dt-posture">posture</a> and type of the left-hand operand; and the provisional sweep is the wider of the sweeps of the two operands.</p></li><li><p>If the provisional <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, then it is reassessed as follows:</p><ol class="enumla"><li><p><span class="definition">[Definition:&nbsp;</span><a id="dt-scanning-expression" title="scanning expression"></a>A <code>RelativePathExpr</code> is a <b>scanning expression</b> if and only if it is syntactically equivalent to some <a title="motionless" class="termref" href="#dt-motionless">motionless</a><a title="pattern" class="termref" href="#dt-pattern">pattern</a>.<span class="definition">]</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that a <code>RelativePathExpr</code> is a <b>scanning expression</b> if it conforms to the grammar for a <code>RelativePathExprP</code> in the grammar for patterns (see <a href="#pattern-syntax"><i>5.4.2 Syntax of Patterns</i></a>), and if, when considered as a pattern, the pattern is motionless according to the rules in <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a>.</p><p>In practice, the test as to whether the construct is equivalent to a pattern is likely to be made by examining the structure of the expression tree, rather than by re-parsing the lexical form of the expression against the grammar for patterns; but the outcome is the same.</p></div></li><li><p>If the expression is a <b>scanning expression</b> then:</p><ol class="enumlr"><li><p>If the static type of the expression contains <code>U{element}</code> then its <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="crawling" class="termref" href="#dt-crawling">crawling</a>.</p></li><li><p>Otherwise, its <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a></p></li></ol></li></ol></li><li><p>Otherwise (if the provisional <a title="posture" class="termref" href="#dt-posture">posture</a> is not <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, or the expression is not a <b>scanning expression</b>), the <a title="posture" class="termref" href="#dt-posture">posture</a> of the expression is the provisional <a title="posture" class="termref" href="#dt-posture">posture</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The special rules for scanning expressions are designed to ensure that expressions such as <code>//section/head</code> are streamable. The problem with such an expression is that it is possible to have two nested sections <var>A</var> and <var>B</var>, where <var>A</var> is the parent of <var>B</var> and thus precedes <var>B</var> in document order, but where there are children of <var>A</var> that come <em>after</em> children of <var>B</var> in document order. This means that a nested-loop strategy for the evaluation of <code>/descendant::section/child::head</code> is not guaranteed to deliver nodes in document order without a sort, and is therefore not a viable strategy for streaming.</p><p>However, there is a different strategy for evaluating such an expression, which is in effect to rewrite the expression as <code>/descendant::head[parent::section]</code>; specifically, it is possible to scan all descendants in document order, looking for a <code>head</code> element that has a <code>section</code> parent. Hence the term <b>scanning expressions</b>.</p><p>The expressions that qualify as scanning expressions are paths that can be evaluated by scanning all descendants and testing each one (independently) to see whether the elements on its ancestor axis match the specified path. The subset of expressions that qualify as scanning expressions is therefore the same as the subset that qualify as motionless patterns.</p><p>Scanning expressions cannot use positional predicates: for example <code>//section/head[1]</code> is not recognized as a scanning expression because this would require information about a streamed node (specifically, about its preceding siblings) that is not retained during streaming. </p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Perhaps surprisingly, the expression <code>.//section/head</code> is not a scanning expression and is therefore not guaranteed streamable. This is because it does not take the syntactic form of a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>. To make it streamable, it can be rewritten as <code>descendant::section/head</code> or as <code>self::node()//section/head</code>.</p><p>Similarly, within a streamable stylesheet function whose <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> is <code>$node</code>, the expression <code>$node//section/head</code> is not a scanning expression. In this case the expression does have the syntactic form of a pattern, but the pattern is not classified as motionless. (See <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a> — a motionless pattern cannot contain a <code>RootedPath</code>.) A workaround in this case is to rewrite the expression as <code>$node/(descendant::section/head)</code>. Assuming that the function in question declares <code>streamability="absorbing"</code>, the analysis here is that the left-hand operand (<code>$node</code>) is striding and consuming, while the right hand operand (<code>descendant::section/head</code>) is crawling and consuming (because it is a scanning expression). The expression as a whole is therefore crawling and consuming.</p><p>These are cases where an implementation might reasonably choose to relax the rules, insofar as this is permitted by <a href="#streamability-guarantees"><i>19.10 Streamability Guarantees</i></a>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Examples:</p><p>In each of the following cases, assume that the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is striding.</p><ul><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the expression <code>a/b/c</code> is striding, because (under the rules for AxisStep [38]) a child axis step evaluated with striding context <a title="posture" class="termref" href="#dt-posture">posture</a> creates a new striding posture.</p></li><li><p>The posture of the expression <code>a/descendant::c</code> is crawling, because a descendant axis step evaluated with striding context posture creates a new crawling posture.</p></li><li><p>The posture of the expression <code>../@status</code> is striding, because a parent axis step evaluated with striding context posture creates a new climbing posture, and an attribute axis step evaluated with climbing context posture creates a new striding posture.</p></li><li><p>The posture of the expression <code>copy-of(.)//a/following-sibling::*</code> is grounded, because the <a href="#func-copy-of"><code>copy-of</code></a> evaluated with striding posture creates a grounded posture, and all subsequent axis steps leave this posture unchanged.</p></li><li><p>The expression <code>section//head</code> expands to <code>(section/descendant-or-self::node())/child::head</code>. The posture of the left-hand operand <code>section/descendant-or-self::node()</code> is crawling, because a descendant axis step evaluated with striding context posture creates a new crawling posture. The provisional posture of the expression as a whole is therefore <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, because a child axis step evaluated with crawling context posture gives a resulting roaming posture. However, the expression is a scanning expression (both <code>section//head</code> and its expansion are motionless patterns), so the expression as a whole has crawling posture. </p></li><li><p>The expression <code>section//head[1]</code> is free-ranging: unlike the previous example, it contains a positional predicate, which means that the operands do not satisfy the rules for scanning expressions. </p></li></ul></div></div><div class="div4"><h5><a id="streamability-of-axis-steps"></a>19.8.8.9 <a href="#streamability-of-axis-steps" style="text-decoration: none">Streamability of Axis Steps</a></h5><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of an AxisStep <var>S</var> are determined by the first of the following rules that applies:</p><ol class="enumar"><li><p>If the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the sweep is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and the posture is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>;</p></li><li><p>If the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, then the sweep is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> and the posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>;</p></li><li><p>If the statically inferred <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> is such that the axis will always be empty (for example, applying the child axis to a text node or the parent axis to a document node), or if the <code>NodeTest</code> is one that can never select nodes on the chosen axis (for example, selecting attribute nodes on the child axis), then the sweep is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and the posture is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> (because the expression is statically known to return an empty sequence);</p></li><li><p>If all the following conditions are satisfied:</p><ol class="enumla"><li><p>The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a></p></li><li><p>The axis is <code>descendant</code> or <code>descendant-or-self</code></p></li><li><p>There is a predicate <var>P</var> in the <code>PredicateList</code> that satisfies all the following conditions:</p><ol class="enumlr"><li><p>The static type of <var>P</var> is a subtype of <code>U{xs:decimal, xs:double, xs:float}</code></p></li><li><p>Neither <var>P</var>, nor any operand of <var>P</var>, at any depth provided it has the AxisStep <var>S</var> as its <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a>, is a context item expression, an axis expression, or a call on a focus-dependent function;</p></li></ol></li></ol><p>then <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a></p><div class="note"><p class="prefix"><b>Note:</b></p><p>Examples are <code>descendant::section[1]</code>, <code>descendant::section[$i+1]</code>, <code>descendant::section[count($x)]</code>. The significance of this rule is that it detects cases where the descendant axis selects a singleton, and where the posture of the result can therefore be <a title="striding" class="termref" href="#dt-striding">striding</a> rather than <a title="crawling" class="termref" href="#dt-crawling">crawling</a>.</p></div></li><li><p>If the <code>PredicateList</code> contains a <code>Predicate</code> that is not <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, then the sweep is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> and the posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>;</p></li><li><p>Otherwise, the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of the expression are as determined by the table below, based on the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a>, the choice of axis, and the node test. The condition “Selects elements?” is true if the <a title="U-type" class="termref" href="#dt-utype">U-type</a> of <var>S</var> has a non-empty intersection with <var>U{element()}</var>.</p><table class="data"><caption>Streamability of Axis Steps Based on Context Posture</caption><thead><tr><th style="text-align:left; vertical-align:top">Context posture</th><th style="text-align:left; vertical-align:top">Axis</th><th style="text-align:left; vertical-align:top">Selects elements?</th><th style="text-align:left; vertical-align:top">Result posture</th><th style="text-align:left; vertical-align:top">Sweep</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">Grounded</td><td style="text-align:left; vertical-align:top">any</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Grounded</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Climbing</td><td style="text-align:left; vertical-align:top">self, parent, ancestor-or-self, ancestor</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Climbing</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Climbing</td><td style="text-align:left; vertical-align:top">attribute, namespace</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">parent, ancestor-or-self, ancestor</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Climbing</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">self, attribute, namespace</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">child</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">Consuming</td></tr><tr><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">descendant, descendant-or-self</td><td style="text-align:left; vertical-align:top">Yes</td><td style="text-align:left; vertical-align:top">Crawling</td><td style="text-align:left; vertical-align:top">Consuming</td></tr><tr><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">descendant, descendant-or-self</td><td style="text-align:left; vertical-align:top">No</td><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">Consuming</td></tr><tr><td style="text-align:left; vertical-align:top">Crawling</td><td style="text-align:left; vertical-align:top">parent, ancestor-or-self, ancestor</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Climbing</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Crawling</td><td style="text-align:left; vertical-align:top">attribute, namespace</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Crawling</td><td style="text-align:left; vertical-align:top">self</td><td style="text-align:left; vertical-align:top">Yes</td><td style="text-align:left; vertical-align:top">Crawling</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top">Crawling</td><td style="text-align:left; vertical-align:top">self</td><td style="text-align:left; vertical-align:top">No</td><td style="text-align:left; vertical-align:top">Striding</td><td style="text-align:left; vertical-align:top">Motionless</td></tr><tr><td style="text-align:left; vertical-align:top" colspan="2">Any other combination</td><td style="text-align:left; vertical-align:top"></td><td style="text-align:left; vertical-align:top">Roaming</td><td style="text-align:left; vertical-align:top">Free-ranging</td></tr></tbody></table></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>This analysis does not attempt to classify <code>para[title]</code> as a <a title="consuming" class="termref" href="#dt-consuming">consuming</a> expression; an implementation might choose to do so.</p></div></div><div class="div4"><h5><a id="streamability-of-filter-expressions"></a>19.8.8.10 <a href="#streamability-of-filter-expressions" style="text-decoration: none">Streamability of Filter Expressions</a></h5><p>For a filter expression <var>F</var> of the form <code>B[P]</code> (where <var>B</var> might itself be a filter expression), the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are the first of the following that applies:</p><ol class="enumar"><li><p>If all the following conditions are satisfied:</p><ol class="enumla"><li><p><var>B</var> is crawling;</p></li><li><p>The static type of <var>P</var> is a subtype of <code>U{xs:decimal, xs:double, xs:float}</code>, and</p></li><li><p>Neither <var>P</var>, nor any operand of <var>P</var>, at any depth provided it has <var>F</var> as its focus-setting container, is a context item expression, an axis expression, or a call on a focus-dependent function</p></li></ol><p>then the <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is the sweep of <var>B</var>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This rule captures cases where it can be statically determined that the predicate is numeric and is independent of the focus. In such cases, the filter expression selects at most one node, and the posture can therefore be changed from crawling to striding (if there is only one node, there can be no overlapping trees). Examples of filter expressions that satisfy this test are <code>(//x)[3]</code>, <code>(//x)[$i+1]</code>, <code>(//x)[index-of($a, $b)[last()]]</code>, and <code>(//x)[1 to 5]</code>. The last example will actually raise a type error because <code>1 to 5</code> has no effective boolean value; but if expressions are going to fail, it does not matter what their streamability properties are.</p></div></li><li><p>If <var>P</var> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>B</var>;</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This includes the case where <var>B</var> is grounded. The predicate <var>P</var> is assessed with the posture of <var>B</var> as its context posture, and if this is grounded, then <var>P</var> will almost invariably be motionless, making the filter expression as a whole grounded and motionless. For example if <code>$s</code> is grounded, then <code>$s[child::*]</code> is also grounded. A counter-example is the expression <code>$s[$n = 2]</code> where <code>$n</code> is a reference to the first argument of a stylesheet function that is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>: here the predicate is not motionless, so the filter expression is roaming and free-ranging.</p></div></li><li><p>Otherwise, <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The first rule allows a construct such as <code>&lt;xsl:apply-templates select="(//title)[1]"/&gt;</code>, where a <a title="crawling" class="termref" href="#dt-crawling">crawling</a> operand would not be guaranteed streamable.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This section is not applicable to predicates forming part of an axis step, such as <code>//title[1]</code>, as these are not technically filter expressions. See <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>.</p></div></div><div class="div4"><h5><a id="streamability-of-dynamic-function-calls"></a>19.8.8.11 <a href="#streamability-of-dynamic-function-calls" style="text-decoration: none">Streamability of Dynamic Function Calls</a></h5><div class="note"><p class="prefix"><b>Note:</b></p><p>This section applies to dynamic function calls written using the traditional syntax <code>$F(X, Y, Z)</code> and equally to those using the syntax <code>X =&gt; $F(Y, Z)</code></p></div><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a dynamic function call such as <code>$F(X, Y)</code> are determined by the <a href="#general-streamability-rules"><i>19.8.1 General Rules for Streamability</i></a>. The operands and their usages are as follows:</p><ol class="enumar"><li><p>The base expression that computes the function value itself (here <code>$F</code>). This has usage <a title="inspection" class="termref" href="#dt-inspection">inspection</a>.</p></li><li><p>The argument expressions excluding any <code>?</code> placeholders (here <code>X</code> and <code>Y</code>). These have <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> dependent on ancillary information associated with the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the base expression, where available (see <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>). If this information indicates that the base expression is a function with signature <code>function(A, B, ...) as R</code>, then the first argument <code>X</code> has <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the first argument type <code>A</code>, the second argument <code>Y</code> has <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the second argument type <code>B</code>, and so on. If no function signature is available, then the usage of each of the argument expressions is <a title="navigation" class="termref" href="#dt-navigation">navigation</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>As explained in <a href="#function-lookup"><i>10.3.6 Dynamic Access to Functions</i></a>, use of a dynamic function call where the function value is bound to a focus-dependent function such as <code>name#0</code>, <code>lang#1</code>, or <code>last#0</code> is likely to lead to a dynamic error if the context item is a node in a streamed document, but this does not affect the static streamability analysis.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Maps and arrays are functions, and it is possible to look up a value in a map or array using a dynamic function call of the form <code>$map($key)</code> or <code>$array($index)</code>. If it is statically known that the function in question is a map or array, then it is also known that the argument type is <code>xs:anyAtomicType</code>, and that the operand usage is therefore <a title="absorption" class="termref" href="#dt-absorption">absorption</a>. A call that passes a streamed node will therefore be <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. However, if it is not known statically that the function is a map or array, then the expression will generally be <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><p>This means it is desirable to declare the type of any variable holding a map or array. If streamable nodes are used to lookup a value in a map or array, then it may be advisable to use the <code>map:get</code> or <code>array:get</code> functions explicitly; or the lookup operator (<code>?</code>).</p></div></div><div class="div4"><h5><a id="streamability-of-variable-references"></a>19.8.8.12 <a href="#streamability-of-variable-references" style="text-decoration: none">Streamability of Variable References</a></h5><p>For variable references that are bound to the <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> of a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a><a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, see the rules for the <a title="streamability category" class="termref" href="#dt-streamability-category">streamability category</a> of the containing function, under <a href="#streamable-stylesheet-functions"><i>19.8.5 Classifying Stylesheet Functions</i></a>.</p><p>In all other cases, variable references are <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></div><div class="div4"><h5><a id="streamability-of-context-item-expression"></a>19.8.8.13 <a href="#streamability-of-context-item-expression" style="text-decoration: none">Streamability of the Context Item Expression</a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the expression is the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Although <code>.</code> is intrinsically motionless, when used in certain contexts (such as <code>data(.)</code>) the containing expression will be <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. This arises because of the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a>: the argument to <a href="https://www.w3.org/TR/xpath-functions-30/#func-data"><code>data</code></a><sup><small>FO30</small></sup> has usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, and the combination of a <a title="motionless" class="termref" href="#dt-motionless">motionless</a> operand with usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a> leads to the containing expression being <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p><p>Similarly, if <code>.</code> is used where the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is <a title="navigation" class="termref" href="#dt-navigation">navigation</a>, the containing expression will be <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></div></div><div class="div4"><h5><a id="streamability-of-function-calls"></a>19.8.8.14 <a href="#streamability-of-function-calls" style="text-decoration: none">Streamability of Static Function Calls</a></h5><div class="note"><p class="prefix"><b>Note:</b></p><p>This section applies to static function calls written using the traditional syntax <code>F(X, Y, Z)</code> and equally to those using the syntax <code>X =&gt; F(Y, Z)</code></p></div><p>For calls to built-in functions, see <a href="#classifying-built-in-functions"><i>19.8.9 Classifying Calls to Built-In Functions</i></a>.</p><p>For calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, see <a href="#streamable-stylesheet-functions"><i>19.8.5 Classifying Stylesheet Functions</i></a>.</p><p>For partial function applications (where one or more of the arguments is supplied as a <code>?</code> placeholder), see the rules at the end of this section.</p><p>For a call to a constructor function, the <a href="#general-streamability-rules"><i>19.8.1 General Rules for Streamability</i></a> apply. There is a single operand role (the argument to the function), with <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p><p>For a call to an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>If the function call is a partial function application (that is, if one or more of the arguments is given as a <code>?</code> placeholder), then:</p><ol class="enumar"><li><p>If the function is focus-dependent and the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the target of the function call is a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> that is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>, and if the first argument is actually supplied (that is, this argument is not supplied as a <code>?</code> placeholder), and if the expression that is supplied as the first argument is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the target is an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></li><li><p>Otherwise, the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. The operands of a partial function application are the expressions actually supplied as arguments to the function, ignoring <code>?</code> place-holders; the corresponding <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the declared type of that argument.</p></li></ol></div><div class="div4"><h5><a id="streamability-of-named-function-ref"></a>19.8.8.15 <a href="#streamability-of-named-function-ref" style="text-decoration: none">Streamability of Named Function References</a></h5><p>Let <var>F</var> be the function to which the <code>NamedFunctionRef</code> refers.</p><p>If <var>F</var> is focus-dependent and the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the <code>NamedFunctionRef</code> is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><p>If <var>F</var> is an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>Otherwise, the <code>NamedFunctionRef</code> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The main intent behind these rules is to ensure that the function item returned by a named function reference does not encapsulate a reference to a streamed node.</p><p>In the case of an expression such as <code>local-name#0</code>, implementations might be able to do better by pre-evaluating the function at the point where the named function reference occurs.</p><p>In the case of extension functions, implementations may be able to distinguish whether the function is focus-dependent, and decide the streamability of the named function reference accordingly.</p></div></div><div class="div4"><h5><a id="streamability-of-inline-functions"></a>19.8.8.16 <a href="#streamability-of-inline-functions" style="text-decoration: none">Streamability of Inline Function Declarations</a></h5><p>An inline function declaration that textually contains a variable reference bound to a <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a> (of some containing stylesheet function) is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><p>All other inline function declarations are <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not possible to pass a streamed node as an argument to a call to an inline function unless the declared type of the corresponding function parameter causes the node to be atomized: see <a href="#streamability-of-dynamic-function-calls"><i>19.8.8.11 Streamability of Dynamic Function Calls</i></a>. The only other way an inline function could access a streamed node is by having the streamed node in its closure, and this is prevented by the rule above.</p></div></div><div class="div4"><h5><a id="streamability-of-map-constructors"></a>19.8.8.17 <a href="#streamability-of-map-constructors" style="text-decoration: none">Streamability of Map Constructors</a></h5><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a map constructor (see <a href="#map-constructors"><i>21.3 Map Constructors</i></a>) are the same as the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the equivalent <a href="#element-map"><code>xsl:map</code></a> instruction. The equivalent <a href="#element-map"><code>xsl:map</code></a> instruction is formed by creating a sequence of <a href="#element-map-entry"><code>xsl:map-entry</code></a> instructions, one for each key/value pair in the map expression, where the key expression becomes the value of <code>xsl:map-entry/@key</code>, and the value expression becomes the value of <code>xsl:map-entry/@select</code>; this sequence of <a href="#element-map-entry"><code>xsl:map-entry</code></a> instructions is then wrapped in an <a href="#element-map"><code>xsl:map</code></a> parent instruction.</p><p>For example, the map constructor <code>map{'red':false(), 'green':true()}</code> translates to the instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:map</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">red</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">false</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">green</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">true</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The rules for the streamability of <a href="#element-map"><code>xsl:map</code></a> appear in <a href="#streamability-xsl-map"><i>19.8.4.23 Streamability of xsl:map</i></a>.</p><p>See also <a href="#maps-streaming"><i>21.4 Maps and Streaming</i></a>.</p></div><div class="div4"><h5><a id="streamability-of-lookup-expressions"></a>19.8.8.18 <a href="#streamability-of-lookup-expressions" style="text-decoration: none">Streamability of Lookup Expressions</a></h5><p>For the unary lookup operator, the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the expression <code>?X</code> are defined to be the same as the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the postfix lookup expression <code>.?X</code>.</p><p>For the postfix lookup expression <code>E?K</code>, the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply as follows:</p><ol class="enumar"><li><p>In the wildcard form of the expression, <code>E?*</code>, there is only one operand, <code>E</code>. This has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="inspection" class="termref" href="#dt-inspection">inspection</a>.</p></li><li><p>Where the construct <code>K</code> is an NCName, the expression <code>E?NAME</code> is treated as equivalent to <code>E?("NAME")</code>.</p></li><li><p>Where the construct <code>K</code> is an integer, the expression <code>E?N</code> is treated as equivalent to <code>E?(N)</code>.</p></li><li><p>In the general case where <code>K</code> is a parenthesized expression, the lookup expression <code>E?(K)</code> has two operands. The first operand <code>E</code> has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="inspection" class="termref" href="#dt-inspection">inspection</a>, while the second operand <code>K</code> has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li></ol></div></div><div class="div3"><h4><a id="classifying-built-in-functions"></a>19.8.9 <a href="#classifying-built-in-functions" style="text-decoration: none">Classifying Calls to Built-In Functions</a></h4><p>This section describes the rules that determine the streamability of calls to built-in functions. These differ from user-written functions because it is known (defined in the specification) how nodes supplied as operands are used. Knowledge of the usage of each operand, together with the <a title="posture" class="termref" href="#dt-posture">posture</a> of the actual operands, is in most cases enough to determine the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function result.</p><p>All the built-in functions are listed below. For most functions, a simple proforma is shown that indicates the operand usage of each argument, using the code (A = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, I = <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, T = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, N = <a title="navigation" class="termref" href="#dt-navigation">navigation</a>). So, for example, the entry <code>fn:remove(T, A)</code> means that for the function <code>fn:remove#2</code>, the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the first argument is <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, and the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the second argument is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>. By reference to the general rules in <a href="#general-streamability-rules"><i>19.8.1 General Rules for Streamability</i></a>, this demonstrates that if the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>, the posture and sweep of the expression <code>sum(remove(*,1))</code> will be <code>grounded</code> and <code>consuming</code> respectively. </p><p>For functions that default one of their arguments (typically to the context item), the relevant entry shows the equivalence, and the posture and sweep can in these cases be computed by filling in the default value for the relevant argument.</p><p>Some functions do not follow the general rules, and these are listed with a link to the section where the particular rules for that function are described.</p><ul><li><p><code>array:append(I, N)</code></p></li><li><p><code>array:build(I, I)</code></p></li><li><p><code>array:empty(I)</code></p></li><li><p><code>array:exists(I)</code></p></li><li><p><code>array:filter(I, I)</code></p></li><li><p><code>array:flatten(A)</code></p></li><li><p><code>array:fold-left(I, N, I)</code></p></li><li><p><code>array:fold-right(I, N, I)</code></p></li><li><p><code>array:foot(I)</code></p></li><li><p><code>array:for-each(I, I)</code></p></li><li><p><code>array:for-each-pair(I, I, I)</code></p></li><li><p><code>array:get(I, A, A)</code></p></li><li><p><code>array:head(I)</code></p></li><li><p><code>array:index-where(A, A)</code></p></li><li><p><code>array:insert-before(I, A, N)</code></p></li><li><p><code>array:join(I)</code></p></li><li><p><code>array:members(I)</code></p></li><li><p><code>array:of(I)</code></p></li><li><p><code>array:partition(A, A)</code></p></li><li><p><code>array:put(I, I, N)</code></p></li><li><p><code>array:remove(I, A)</code></p></li><li><p><code>array:replace(I, I, N)</code></p></li><li><p><code>array:reverse(I)</code></p></li><li><p><code>array:size(I)</code></p></li><li><p><code>array:slice(T, A, A, A)</code></p></li><li><p><code>array:sort(I, A, I)</code></p></li><li><p><code>array:subarray(I, A, A)</code></p></li><li><p><code>array:tail(I)</code></p></li><li><p><code>array:trunk(I)</code></p></li><li><p><code>fn:abs(A)</code></p></li><li><p><code>fn:accumulator-after</code> – See <a href="#streamability-fn-accumulator-after"><i>19.8.9.1 Streamability of the accumulator-after Function</i></a></p></li><li><p><code>fn:accumulator-before</code> – See <a href="#streamability-fn-accumulator-before"><i>19.8.9.2 Streamability of the accumulator-before Function</i></a></p></li><li><p><code>fn:adjust-date-to-timezone(A, A)</code></p></li><li><p><code>fn:adjust-dateTime-to-timezone(A, A)</code></p></li><li><p><code>fn:adjust-time-to-timezone(A, A)</code></p></li><li><p><code>fn:all(A, A)</code></p></li><li><p><code>fn:all-different(N, A)</code></p></li><li><p><code>fn:all-equal(N, A)</code></p></li><li><p><code>fn:analyze-string(A, A, A)</code></p></li><li><p><code>fn:apply(A, I)</code></p></li><li><p><code>fn:atomic-equal(A, A)</code></p></li><li><p><code>fn:available-environment-variables()</code></p></li><li><p><code>fn:available-system-properties()</code></p></li><li><p><code>fn:avg(A)</code></p></li><li><p><code>fn:base-uri(I)</code></p></li><li><p><code>fn:boolean(I)</code></p></li><li><p><code>fn:build-uri(A, A)</code></p></li><li><p><code>fn:ceiling(A)</code></p></li><li><p><code>fn:char(A)</code></p></li><li><p><code>fn:characters(A)</code></p></li><li><p><code>fn:codepoint-equal(A, A)</code></p></li><li><p><code>fn:codepoints-to-string(A)</code></p></li><li><p><code>fn:collation-key(A, A)</code></p></li><li><p><code>fn:collection(A)</code></p></li><li><p><code>fn:compare(A, A, A)</code></p></li><li><p><code>fn:concat(A, A, A)</code></p></li><li><p><code>fn:contains(A, A, A)</code></p></li><li><p><code>fn:contains-sequence(T, T, A)</code></p></li><li><p><code>fn:contains-token(A, A, A)</code></p></li><li><p><code>fn:copy-of(A)</code></p></li><li><p><code>fn:count(I)</code></p></li><li><p><code>fn:current</code> – See <a href="#streamability-fn-current"><i>19.8.9.3 Streamability of the current Function</i></a></p></li><li><p><code>fn:current-date()</code></p></li><li><p><code>fn:current-dateTime()</code></p></li><li><p><code>fn:current-group</code> – See <a href="#streamability-fn-current-group"><i>19.8.9.4 Streamability of the current-group Function</i></a></p></li><li><p><code>fn:current-grouping-key</code> – See <a href="#streamability-fn-current-grouping-key"><i>19.8.9.5 Streamability of the current-grouping-key Function</i></a></p></li><li><p><code>fn:current-merge-group</code> – See <a href="#streamability-fn-current-merge-group"><i>19.8.9.6 Streamability of the current-merge-group Function</i></a></p></li><li><p><code>fn:current-merge-key</code> – See <a href="#streamability-fn-current-merge-key"><i>19.8.9.7 Streamability of the current-merge-key Function</i></a></p></li><li><p><code>fn:current-mode()</code></p></li><li><p><code>fn:current-output-uri()</code></p></li><li><p><code>fn:current-time()</code></p></li><li><p><code>fn:data(A)</code></p></li><li><p><code>fn:dateTime(A, A)</code></p></li><li><p><code>fn:day-from-date(A)</code></p></li><li><p><code>fn:day-from-dateTime(A)</code></p></li><li><p><code>fn:days-from-duration(A)</code></p></li><li><p><code>fn:deep-equal(A, A, A, A)</code></p></li><li><p><code>fn:default-collation()</code></p></li><li><p><code>fn:default-language()</code></p></li><li><p><code>fn:differences(A, A, A, A)</code></p></li><li><p><code>fn:distinct-values(A, A)</code></p></li><li><p><code>fn:doc(A)</code></p></li><li><p><code>fn:doc-available(A)</code></p></li><li><p><code>fn:document(A, I)</code></p></li><li><p><code>fn:document-uri(I)</code></p></li><li><p><code>fn:element-available(A)</code></p></li><li><p><code>fn:element-with-id(A, N)</code></p></li><li><p><code>fn:empty(I)</code></p></li><li><p><code>fn:encode-for-uri(A)</code></p></li><li><p><code>fn:ends-with(A, A, A)</code></p></li><li><p><code>fn:ends-with-sequence(T, T, A)</code></p></li><li><p><code>fn:environment-variable(A)</code></p></li><li><p><code>fn:error(A, A, N)</code></p></li><li><p><code>fn:escape-html-uri(A)</code></p></li><li><p><code>fn:exactly-one(T)</code></p></li><li><p><code>fn:exists(I)</code></p></li><li><p><code>fn:expanded-QName(A)</code></p></li><li><p><code>fn:false()</code></p></li><li><p><code>fn:filter(N, I)</code></p></li><li><p><code>fn:floor(A)</code></p></li><li><p><code>fn:fold-left(N, A, I)</code></p></li><li><p><code>fn:fold-right</code> – See <a href="#streamability-fn-fold-right"><i>19.8.9.9 Streamability of the fold-right Function</i></a></p></li><li><p><code>fn:foot(T)</code></p></li><li><p><code>fn:for-each(N, I)</code></p></li><li><p><code>fn:for-each-pair(N, N, I)</code></p></li><li><p><code>fn:format-date(A, A, A, A, A)</code></p></li><li><p><code>fn:format-dateTime(A, A, A, A, A)</code></p></li><li><p><code>fn:format-integer(A, A, A)</code></p></li><li><p><code>fn:format-number(A, A, A)</code></p></li><li><p><code>fn:format-time(A, A, A, A, A)</code></p></li><li><p><code>fn:function-arity(A)</code></p></li><li><p><code>fn:function-available(A, A)</code></p></li><li><p><code>fn:function-lookup</code> – See <a href="#streamability-fn-function-lookup"><i>19.8.9.12 Streamability of the function-lookup Function</i></a></p></li><li><p><code>fn:function-name(A)</code></p></li><li><p><code>fn:generate-id(I)</code></p></li><li><p><code>fn:has-children(I)</code></p></li><li><p><code>fn:head(T)</code></p></li><li><p><code>fn:highest(N, A, I)</code></p></li><li><p><code>fn:hours-from-dateTime(A)</code></p></li><li><p><code>fn:hours-from-duration(A)</code></p></li><li><p><code>fn:hours-from-time(A)</code></p></li><li><p><code>fn:id(A, N)</code></p></li><li><p><code>fn:identity(N)</code></p></li><li><p><code>fn:idref(A, N)</code></p></li><li><p><code>fn:implicit-timezone()</code></p></li><li><p><code>fn:in-scope-namespaces(I)</code></p></li><li><p><code>fn:in-scope-prefixes(I)</code></p></li><li><p><code>fn:index-of(A, A, A)</code></p></li><li><p><code>fn:index-where(A, A)</code></p></li><li><p><code>fn:innermost</code> – See <a href="#streamability-fn-innermost"><i>19.8.9.13 Streamability of the innermost Function</i></a></p></li><li><p><code>fn:insert-before(T, A, T)</code></p></li><li><p><code>fn:intersperse(N, N)</code></p></li><li><p><code>fn:iri-to-uri(A)</code></p></li><li><p><code>fn:is-NaN(A)</code></p></li><li><p><code>fn:items-after(A, A)</code></p></li><li><p><code>fn:items-at(T, A)</code></p></li><li><p><code>fn:items-before(A, A)</code></p></li><li><p><code>fn:items-ending-where(A, A)</code></p></li><li><p><code>fn:items-starting-where(A, A)</code></p></li><li><p><code>fn:iterate-while(A, A, A)</code></p></li><li><p><code>fn:json(A, I)</code></p></li><li><p><code>fn:json-doc(A, I)</code></p></li><li><p><code>fn:json-to-xml(A, I)</code></p></li><li><p><code>fn:key(A, A, N)</code></p></li><li><p><code>fn:lang(A, I)</code></p></li><li><p><code>fn:last</code> – See <a href="#streamability-fn-last"><i>19.8.9.14 Streamability of the last Function</i></a></p></li><li><p><code>fn:load-xquery-module(A, I)</code></p></li><li><p><code>fn:local-name(I)</code></p></li><li><p><code>fn:local-name-from-QName(A)</code></p></li><li><p><code>fn:lower-case(A)</code></p></li><li><p><code>fn:lowest(N, A, I)</code></p></li><li><p><code>fn:matches(A, A, A)</code></p></li><li><p><code>fn:max(A, A)</code></p></li><li><p><code>fn:min(A, A)</code></p></li><li><p><code>fn:minutes-from-dateTime(A)</code></p></li><li><p><code>fn:minutes-from-duration(A)</code></p></li><li><p><code>fn:minutes-from-time(A)</code></p></li><li><p><code>fn:month-from-date(A)</code></p></li><li><p><code>fn:month-from-dateTime(A)</code></p></li><li><p><code>fn:months-from-duration(A)</code></p></li><li><p><code>fn:name(I)</code></p></li><li><p><code>fn:namespace-uri(I)</code></p></li><li><p><code>fn:namespace-uri-for-prefix(A, I)</code></p></li><li><p><code>fn:namespace-uri-from-QName(A)</code></p></li><li><p><code>fn:nilled(I)</code></p></li><li><p><code>fn:node-name(I)</code></p></li><li><p><code>fn:normalize-space(A)</code></p></li><li><p><code>fn:normalize-unicode(A, A)</code></p></li><li><p><code>fn:not(I)</code></p></li><li><p><code>fn:number(A)</code></p></li><li><p><code>fn:one-or-more(T)</code></p></li><li><p><code>fn:op(A)</code></p></li><li><p><code>fn:outermost</code> – See <a href="#streamability-fn-outermost"><i>19.8.9.15 Streamability of the outermost Function</i></a></p></li><li><p><code>fn:parse-html(A, A)</code></p></li><li><p><code>fn:parse-ietf-date(A)</code></p></li><li><p><code>fn:parse-json(A, I)</code></p></li><li><p><code>fn:parse-QName(A)</code></p></li><li><p><code>fn:parse-uri(A, A)</code></p></li><li><p><code>fn:parse-xml(A)</code></p></li><li><p><code>fn:parse-xml-fragment(A)</code></p></li><li><p><code>fn:path(N)</code></p></li><li><p><code>fn:position</code> – See <a href="#streamability-fn-position"><i>19.8.9.16 Streamability of the position Function</i></a></p></li><li><p><code>fn:prefix-from-QName(A)</code></p></li><li><p><code>fn:QName(A, A)</code></p></li><li><p><code>fn:random-number-generator(A)</code></p></li><li><p><code>fn:regex-group(A)</code></p></li><li><p><code>fn:remove(T, A)</code></p></li><li><p><code>fn:replace(A, A, A, A, A)</code></p></li><li><p><code>fn:replicate(N, A)</code></p></li><li><p><code>fn:resolve-QName(A, I)</code></p></li><li><p><code>fn:resolve-uri(A, A)</code></p></li><li><p><code>fn:reverse</code> – See <a href="#streamability-fn-reverse"><i>19.8.9.17 Streamability of the reverse Function</i></a></p></li><li><p><code>fn:root</code> – See <a href="#streamability-fn-root"><i>19.8.9.18 Streamability of the root Function</i></a></p></li><li><p><code>fn:round(A, A)</code></p></li><li><p><code>fn:round-half-to-even(A, A)</code></p></li><li><p><code>fn:seconds-from-dateTime(A)</code></p></li><li><p><code>fn:seconds-from-duration(A)</code></p></li><li><p><code>fn:seconds-from-time(A)</code></p></li><li><p><code>fn:serialize(A, A)</code></p></li><li><p><code>fn:slice(T, A, A, A)</code></p></li><li><p><code>fn:snapshot(A)</code></p></li><li><p><code>fn:some(A, A)</code></p></li><li><p><code>fn:sort(N, A, I)</code></p></li><li><p><code>fn:stack-trace()</code></p></li><li><p><code>fn:starts-with(A, A, A)</code></p></li><li><p><code>fn:starts-with-sequence(T, T, A)</code></p></li><li><p><code>fn:static-base-uri()</code></p></li><li><p><code>fn:stream-available(A)</code></p></li><li><p><code>fn:string(A)</code></p></li><li><p><code>fn:string-join(A, A)</code></p></li><li><p><code>fn:string-length(A)</code></p></li><li><p><code>fn:string-to-codepoints(A)</code></p></li><li><p><code>fn:subsequence(T, A, A)</code></p></li><li><p><code>fn:substring(A, A, A)</code></p></li><li><p><code>fn:substring-after(A, A, A)</code></p></li><li><p><code>fn:substring-before(A, A, A)</code></p></li><li><p><code>fn:sum(A, A)</code></p></li><li><p><code>fn:system-property(A)</code></p></li><li><p><code>fn:tail(T)</code></p></li><li><p><code>fn:timezone-from-date(A)</code></p></li><li><p><code>fn:timezone-from-dateTime(A)</code></p></li><li><p><code>fn:timezone-from-time(A)</code></p></li><li><p><code>fn:tokenize(A, A, A)</code></p></li><li><p><code>fn:trace(T, A)</code></p></li><li><p><code>fn:transform(I)</code></p></li><li><p><code>fn:translate(A, A, A)</code></p></li><li><p><code>fn:true()</code></p></li><li><p><code>fn:trunk(T)</code></p></li><li><p><code>fn:type-available(A)</code></p></li><li><p><code>fn:unordered(T)</code></p></li><li><p><code>fn:unparsed-entity-public-id(A, I)</code></p></li><li><p><code>fn:unparsed-entity-uri(A, I)</code></p></li><li><p><code>fn:unparsed-text(A, A)</code></p></li><li><p><code>fn:unparsed-text-available(A, A)</code></p></li><li><p><code>fn:unparsed-text-lines(A, A)</code></p></li><li><p><code>fn:upper-case(A)</code></p></li><li><p><code>fn:uri-collection(A)</code></p></li><li><p><code>fn:xml-to-json(A, I)</code></p></li><li><p><code>fn:year-from-date(A)</code></p></li><li><p><code>fn:year-from-dateTime(A)</code></p></li><li><p><code>fn:years-from-duration(A)</code></p></li><li><p><code>fn:zero-or-one(T)</code></p></li><li><p><code>map:build(A, A, A, A)</code></p></li><li><p><code>map:contains(I, A)</code></p></li><li><p><code>map:entry(A, N)</code></p></li><li><p><code>map:filter(I, I)</code></p></li><li><p><code>map:find(I, A)</code></p></li><li><p><code>map:for-each(I, I)</code></p></li><li><p><code>map:get(I, A, A)</code></p></li><li><p><code>map:keys(I)</code></p></li><li><p><code>map:merge(I, I)</code></p></li><li><p><code>map:put(I, A, N)</code></p></li><li><p><code>map:remove(I, A)</code></p></li><li><p><code>map:replace(I, I, I)</code></p></li><li><p><code>map:size(I)</code></p></li><li><p><code>map:substitute(I, I)</code></p></li><li><p><code>math:acos(A)</code></p></li><li><p><code>math:asin(A)</code></p></li><li><p><code>math:atan(A)</code></p></li><li><p><code>math:atan2(A, A)</code></p></li><li><p><code>math:cos(A)</code></p></li><li><p><code>math:exp(A)</code></p></li><li><p><code>math:exp10(A)</code></p></li><li><p><code>math:log(A)</code></p></li><li><p><code>math:log10(A)</code></p></li><li><p><code>math:pi()</code></p></li><li><p><code>math:pow(A, A)</code></p></li><li><p><code>math:sin(A)</code></p></li><li><p><code>math:sqrt(A)</code></p></li><li><p><code>math:tan(A)</code></p></li></ul><div class="div4"><h5><a id="streamability-fn-accumulator-after"></a>19.8.9.1 <a href="#streamability-fn-accumulator-after" style="text-decoration: none">Streamability of the </a><a href="#func-accumulator-after"><code>accumulator-after</code></a><a href="#streamability-fn-accumulator-after" style="text-decoration: none"> Function</a></h5><p>See also <a href="#streamability-of-accumulators"><i>18.2.9 Streamability of Accumulators</i></a>.</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the function call is in all cases <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is determined by applying the following rules, in order:</p><ol class="enumar"><li><p>If the first argument (the accumulator name) is not <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, the function is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. </p></li><li><p>If the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, the function is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. </p></li><li><p>If the <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> has an empty intersection with <var>U{document-node(), element()}</var> (that is, if the context item cannot have children), the function is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. </p></li><li><p>If the function call is contained in the <code>select</code> expression or contained sequence constructor of an <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> specifying <code>phase="start"</code>, then it is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li><li><p>If the function call is contained in the <code>select</code> expression or contained sequence constructor of an <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> specifying <code>phase="end"</code>, then it is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>If no enclosing node of the function call is part of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then it is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. For this purpose, the <b>enclosing nodes</b> of a function call are the attribute or text node that immediately contains the XPath expression in which the function call appears, and its ancestors. </p></li><li><p>If the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of the function call is different from the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of the innermost containing <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, then the function is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. </p></li><li><p>If no enclosing node <var>N</var> of the function call has a preceding sibling node <var>P</var> such that (a) <var>N</var> and <var>P</var> are part of the same <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and (b) the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <var>P</var> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, then the function call is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. (The term <b>enclosing node</b> is defined above.)</p></li><li><p>Otherwise, the function call is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The following notes apply to the above rules with matching numbers:</p><ol class="enumar"><li><p>This rule prevents the accumulator name being computed by reading the streamed source document. This is disallowed primarily because there is no conceivable use case for doing it.</p></li><li><p>If the context posture is grounded, then the target of the accumulator is not a streamed node, so no streaming restrictions apply.</p></li><li><p>If the context item is a childless node (such as a text node), then both the pre-descent and post-descent values of the accumulator can be computed before evaluating any user-written constructs that access this node; there are therefore no constraints on where a call to <a href="#func-accumulator-after"><code>accumulator-after</code></a> can appear.</p></li><li><p>This rule ensures that when computing the pre-descent value of an accumulator for a particular streamed node, the post-descent values of accumulators for that node are not available.</p></li><li><p>This rule states that the post-descent value of an accumulator is allowed to depend on the post-descent values of other accumulators for the same node. There is a rule preventing cycles <span class="error">[see <a href="#err-XTDE3400">ERR XTDE3400</a>]</span>.</p></li><li><p>This rule prevents the use of the function (when applied to a streamed node) in contexts like the <code>use</code> attribute of <a href="#element-key"><code>xsl:key</code></a>. It allows its use in the attributes of an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> or <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or in a <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a>. It does not allow use in an <a href="#element-sort"><code>xsl:sort</code></a> or <a href="#element-param"><code>xsl:param</code></a> element, as these elements do not form part of a sequence constructor (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>).</p></li><li><p>This rule prevents the use of the function (when applied to a streamed node) in contexts such as predicates, or the right-hand side of the <code>/</code> operator. The focus for evaluation of the function must be the same as the focus for a containing sequence constructor. Sequence constructors are treated differently from all other constructs for this purpose in that their operands (the contained instructions) are treated as ordered: in conjunction with the next rule, this rule is assuming that instructions in a sequence constructor that follow a <a title="consuming" class="termref" href="#dt-consuming">consuming</a> instruction are evaluated after the <a title="consuming" class="termref" href="#dt-consuming">consuming</a> instruction and therefore have access to the post-descent accumulator value.</p></li><li><p>This rule is subtle, and has a number of consequences. In these notes, the term <b>instruction</b> should be read as including all nodes making up a sequence constructor, including XSLT instructions, extension instructions, literal result elements, and text nodes containing text value templates.</p><ul><li><p>In a sequence constructor that contains a <a title="consuming" class="termref" href="#dt-consuming">consuming</a> instruction such as <code>&lt;xsl:apply-templates/&gt;</code>, it allows any number of calls on <a href="#func-accumulator-after"><code>accumulator-after</code></a> to appear in instructions that follow the call on <code>&lt;xsl:apply-templates/&gt;</code>.</p></li><li><p>In such a sequence constructor it prevents a call on <a href="#func-accumulator-after"><code>accumulator-after</code></a> from appearing in an instruction that precedes the <code>&lt;xsl:apply-templates/&gt;</code>, because there would then be two <a title="consuming" class="termref" href="#dt-consuming">consuming</a> instructions.</p></li><li><p>In a sequence constructor that contains calls on <a href="#func-accumulator-after"><code>accumulator-after</code></a>, and contains no other <a title="consuming" class="termref" href="#dt-consuming">consuming</a> construct, the first instruction that contains a call on <a href="#func-accumulator-after"><code>accumulator-after</code></a> is consuming (unless it contains more than one such call, in which case it is free-ranging), and subsequent instructions containing such a call are motionless. So it is possible to have two or more calls on <a href="#func-accumulator-after"><code>accumulator-after</code></a> provided they appear in different instructions, which allows the analysis to assume an order of execution.</p></li><li><p>It prevents a call on <a href="#func-accumulator-after"><code>accumulator-after</code></a> from appearing in the same instruction as another consuming construct: for example it disallows <code>concat(child::p, accumulator-after('a'))</code>. This rule preserves the ability to evaluate the arguments of the <code>concat</code> function in any order.</p></li><li><p>It disallows a call on <a href="#func-accumulator-after"><code>accumulator-after</code></a> from appearing in a sequence constructor that is required to be motionless, for example within <a href="#element-sort"><code>xsl:sort</code></a>.</p></li><li><p>The reference to a “preceding sibling node within the same sequence constructor” is carefully worded to ensure that preceding siblings among the children of <a href="#element-fork"><code>xsl:fork</code></a> are not taken into account; the children of <a href="#element-fork"><code>xsl:fork</code></a> are sibling instructions, but do not constitute a sequence constructor. The term also excludes elements such as <a href="#element-param"><code>xsl:param</code></a> and <a href="#element-sort"><code>xsl:sort</code></a> that may precede a sequence constructor but are not part of it.</p></li></ul></li><li><p>The final rule states that if none of the previous rules apply, the function is considered motionless. This applies when the <a href="#func-accumulator-after"><code>accumulator-after</code></a> appears after a consuming instruction within the same sequence constructor.</p><p>Note also that a call to <a href="#func-accumulator-after"><code>accumulator-after</code></a> can safely appear within a construct such as a named template or (non-streamable) stylesheet function; this is safe because the rules ensure that in such situations, the context item cannot be a streamed node.</p></li></ol></div><p>Dynamic invocation of <a href="#func-accumulator-after"><code>accumulator-after</code></a> is covered by the rules in <a href="#function-lookup"><i>10.3.6 Dynamic Access to Functions</i></a>. These rules ensure that a function item cannot include a streamed node in its closure; circumventing the streamability rules for <a href="#func-accumulator-after"><code>accumulator-after</code></a> by making a dynamic call is therefore not possible.</p></div><div class="div4"><h5><a id="streamability-fn-accumulator-before"></a>19.8.9.2 <a href="#streamability-fn-accumulator-before" style="text-decoration: none">Streamability of the </a><a href="#func-accumulator-before"><code>accumulator-before</code></a><a href="#streamability-fn-accumulator-before" style="text-decoration: none"> Function</a></h5><p>See also <a href="#streamability-of-accumulators"><i>18.2.9 Streamability of Accumulators</i></a>.</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the function call are assessed as follows:</p><ol class="enumar"><li><p>If the argument to <a href="#func-accumulator-before"><code>accumulator-before</code></a> is motionless, the function call is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>Otherwise, the function call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li></ol></div><div class="div4"><h5><a id="streamability-fn-current"></a>19.8.9.3 <a href="#streamability-fn-current" style="text-decoration: none">Streamability of the </a><a href="#func-current"><code>current</code></a><a href="#streamability-fn-current" style="text-decoration: none"> Function</a></h5><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of a call to the <a href="#func-current"><code>current</code></a> function are determined as follows:</p><ol class="enumar"><li><p>If the call appears within a pattern, then climbing and motionless.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The call to <a href="#func-current"><code>current</code></a> will always be within a predicate of the pattern. The use of climbing posture here allows predicates such as <code>[@class = current()/@class]</code>, while disallowing downwards navigation from the node returned by the function.</p></div></li><li><p>Otherwise, let <var>E</var> be the outermost containing XPath expression of the call to the <a href="#func-current"><code>current</code></a> function.</p></li><li><p>If the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <var>E</var> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>If the path in the expression tree that connects the call on <a href="#func-current"><code>current</code></a> to <var>E</var> (excluding <var>E</var> itself) contains an expression that is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of its parent expression, then <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and <a title="climbing" class="termref" href="#dt-climbing">climbing</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Many common uses of the <a href="#func-current"><code>current</code></a>, such as <code>//p[@class=current()/@class]</code>, fall into this category: a predicate is a higher-order operand of its containing filter expression.</p><p>The use of <a title="climbing" class="termref" href="#dt-climbing">climbing</a> posture here might seem unrelated to its usual connection with the ancestor axis. The explanation (apart from the fact that it happens to produce the right results) lies in the fact that at the point where the <a href="#func-current"><code>current</code></a> call is evaluated, the node it returns will always be an ancestor-or-self of the context node, as a consequence of the fact that the containing XPath expression is required to be either <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p><p>The effect of the rule is to allow expressions such as <code>//*[name() = name(current())]</code> or <code>//*[@ref = current()/@id]</code>.</p></div></li><li><p>Otherwise, the <a title="posture" class="termref" href="#dt-posture">posture</a> is the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></div><div class="div4"><h5><a id="streamability-fn-current-group"></a>19.8.9.4 <a href="#streamability-fn-current-group" style="text-decoration: none">Streamability of the </a><a href="#func-current-group"><code>current-group</code></a><a href="#streamability-fn-current-group" style="text-decoration: none"> Function</a></h5><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of a call <var>C</var> to the <a href="#func-current-group"><code>current-group</code></a> function are as follows:</p><ol class="enumar"><li><p>If all the following conditions are true:</p><ol class="enumla"><li><p><var>C</var> has a containing <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction (call it <var>F</var>)</p></li><li><p>The path in the construct tree that connects <var>C</var> to the sequence constructor forming the body of <var>F</var> is such that no child construct is a <a title="higher-order operand" class="termref" href="#dt-higher-order-operand">higher-order operand</a> of its parent</p></li><li><p>The <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> of <var>C</var> is <var>F</var></p></li></ol><p>then the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of <var>C</var> are the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>select</code> expression of <var>F</var>.</p></li><li><p>Otherwise, <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>Informally, for streamed evaluation to be possible, a call to <a href="#func-current-group"><code>current-group</code></a> must not appear in a construct that is evaluated repeatedly. For example, the expression <code>for $i in 1 to 10 return current-group()</code> would not be streamable.</p></div></div><div class="div4"><h5><a id="streamability-fn-current-grouping-key"></a>19.8.9.5 <a href="#streamability-fn-current-grouping-key" style="text-decoration: none">Streamability of the </a><a href="#func-current-grouping-key"><code>current-grouping-key</code></a><a href="#streamability-fn-current-grouping-key" style="text-decoration: none"> Function</a></h5><p>A call to the <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is grounded and motionless.</p></div><div class="div4"><h5><a id="streamability-fn-current-merge-group"></a>19.8.9.6 <a href="#streamability-fn-current-merge-group" style="text-decoration: none">Streamability of the </a><a href="#func-current-merge-group"><code>current-merge-group</code></a><a href="#streamability-fn-current-merge-group" style="text-decoration: none"> Function</a></h5><p>A call to the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is because the nodes to be merged are always snapshots, and therefore <a title="grounded" class="termref" href="#dt-grounded">grounded</a>: see <a href="#streamable-merging"><i>15.4 Streamable Merging</i></a>.</p></div></div><div class="div4"><h5><a id="streamability-fn-current-merge-key"></a>19.8.9.7 <a href="#streamability-fn-current-merge-key" style="text-decoration: none">Streamability of the </a><a href="#func-current-merge-key"><code>current-merge-key</code></a><a href="#streamability-fn-current-merge-key" style="text-decoration: none"> Function</a></h5><p>A call to the <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></div><div class="div4"><h5><a id="streamability-fn-fold-left"></a>19.8.9.8 <a href="#streamability-fn-fold-left" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-fold-left"><code>fold-left</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-fold-left" style="text-decoration: none"> Function</a></h5><p>The function call <code>fold-left($seq, $zero, $f)</code>, follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the first argument <code>$seq</code> having <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type of the second argument of the function supplied as <code>$f</code>.</p><p>For example, given the call <code>fold-left(/*/transaction, 0, function($x as xs:decimal, $y as xs:decimal) as xs:decimal {$x+$y})</code>, the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the argument <code>/*/transaction</code> is determined by the declared type of <code>$y</code>, namely <code>xs:decimal</code>. Since this is an atomic type, the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>. Applying this to the general streamability rules, the function call is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></div><div class="div4"><h5><a id="streamability-fn-fold-right"></a>19.8.9.9 <a href="#streamability-fn-fold-right" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-fold-right"><code>fold-right</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-fold-right" style="text-decoration: none"> Function</a></h5><p>The function follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the first argument having <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="navigation" class="termref" href="#dt-navigation">navigation</a> to reflect the fact that the supplied sequence is processed in reverse order.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The same considerations apply as for the <a href="https://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup> function: see <a href="#streamability-fn-reverse"><i>19.8.9.17 Streamability of the reverse Function</i></a>.</p></div></div><div class="div4"><h5><a id="streamability-fn-for-each"></a>19.8.9.10 <a href="#streamability-fn-for-each" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-for-each"><code>for-each</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-for-each" style="text-decoration: none"> Function</a></h5><p>The function call <code>for-each($seq, $f)</code>, follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the first argument <code>$seq</code> having <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type of the (single) argument of the function supplied as <code>$f</code>.</p><p>For example, given the call <code>for-each(/*/transaction, function($x as xs:decimal) as xs:decimal {abs($x)})</code>, the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the argument <code>/*/transaction</code> is determined by the declared type of <code>$x</code>, namely <code>xs:decimal</code>. Since this is an atomic type, the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>. Applying this to the general streamability rules, the function call is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, the <a href="https://www.w3.org/TR/xpath-functions-30/#func-filter"><code>filter</code></a><sup><small>FO30</small></sup> function is streamable if either (a) the supplied sequence is grounded, or (b) the supplied function is statically known to atomize its argument.</p></div></div><div class="div4"><h5><a id="streamability-fn-for-each-pair"></a>19.8.9.11 <a href="#streamability-fn-for-each-pair" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-for-each-pair"><code>for-each-pair</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-for-each-pair" style="text-decoration: none"> Function</a></h5><p>The function call <code>for-each($seq1, $seq2, $f)</code>, follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, where:</p><ol class="enumar"><li><p>The first argument <code>$seq1</code> has <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type of the first argument of the function supplied as <code>$f</code>.</p></li><li><p>The second argument <code>$seq2</code> has <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the type of the second argument of the function supplied as <code>$f</code></p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, the <a href="https://www.w3.org/TR/xpath-functions-30/#func-for-each-pair"><code>for-each-pair</code></a><sup><small>FO30</small></sup> function is streamable provided (a) at most one of the input sequences is consuming, and (b) either (i) that input sequence is grounded, or (ii) the supplied function is statically known to atomize the relevant argument.</p><p>If it is necessary to combine two sequences that are both streamed, consider using <a href="#element-merge"><code>xsl:merge</code></a>.</p></div></div><div class="div4"><h5><a id="streamability-fn-function-lookup"></a>19.8.9.12 <a href="#streamability-fn-function-lookup" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-function-lookup" style="text-decoration: none"> Function</a></h5><p>See <a href="#function-lookup"><i>10.3.6 Dynamic Access to Functions</i></a> for special rules that relate to streamability of calls to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> function.</p><p>With the caveats given there, the function follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, for a function with two arguments that both have <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></div><div class="div4"><h5><a id="streamability-fn-innermost"></a>19.8.9.13 <a href="#streamability-fn-innermost" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-innermost" style="text-decoration: none"> Function</a></h5><p>The function follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with the first argument having <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="navigation" class="termref" href="#dt-navigation">navigation</a>. This is to reflect the fact that the processing is not strictly sequential: it cannot be determined that a node is part of the result sequence of <a href="https://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup> until all its descendants have been read.</p></div><div class="div4"><h5><a id="streamability-fn-last"></a>19.8.9.14 <a href="#streamability-fn-last" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-last" style="text-decoration: none"> Function</a></h5><p>If the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> for a call on the <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> function is <a title="striding" class="termref" href="#dt-striding">striding</a>, <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, or <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, then the <a title="posture" class="termref" href="#dt-posture">posture</a> of the function is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><p>In all other cases the function is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The cases where <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> can be used without affecting streamability are where the context item is either <a title="grounded" class="termref" href="#dt-grounded">grounded</a> or <a title="climbing" class="termref" href="#dt-climbing">climbing</a>. The latter condition makes expressions like <code>ancestor::*[@xml:space][last()]</code> streamable.</p><p>There are special rules restricting the use of <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup> in the predicate of a pattern: see <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a>.</p><p>Note that there are no restrictions preventing the use of <code>last()</code> when the context posture is grounded. The implications of this are discussed in <a href="#grounded-consuming-constructs"><i>19.7 Grounded Consuming Constructs</i></a>. In the case where the sequence being processed is delivered by a consuming expression, using <code>last()</code> may result in this sequence being buffered in memory.</p></div></div><div class="div4"><h5><a id="streamability-fn-outermost"></a>19.8.9.15 <a href="#streamability-fn-outermost" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-outermost"><code>outermost</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-outermost" style="text-decoration: none"> Function</a></h5><p>The single argument to this function has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p><p>The streamability of the function call follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> with one exception: if the <a title="posture" class="termref" href="#dt-posture">posture</a> of the argument is <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, then the posture of the result is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are cases where the streaming rules allow the construct <code>outermost(//para)</code> but do not allow <code>//para</code>; the function can therefore be useful in cases where it is known that <code>para</code> elements will not be nested, as well as cases where the application actually wishes to process all <code>para</code> elements except those that are nested within another.</p><p>By contrast, the <a href="https://www.w3.org/TR/xpath-functions-30/#func-innermost"><code>innermost</code></a><sup><small>FO30</small></sup> function offers no streaming benefits. Although it delivers a subset of the input nodes as its result, in the correct order, it is classed as navigational because it needs to look ahead in the input stream before deciding whether a node can be included in the result.</p></div></div><div class="div4"><h5><a id="streamability-fn-position"></a>19.8.9.16 <a href="#streamability-fn-position" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-position" style="text-decoration: none"> Function</a></h5><p>The <a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup> function follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. Since it has no operands, this means it is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Within an expression, there are no special difficulties in evaluating the <a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup> function.</p><p>It does have special treatment within a predicate of a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, however: a pattern is not motionless if it contains a call to <a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>, as explained in <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a>. </p></div></div><div class="div4"><h5><a id="streamability-fn-reverse"></a>19.8.9.17 <a href="#streamability-fn-reverse" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-reverse" style="text-decoration: none"> Function</a></h5><p>The <a href="https://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup> function follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, with its operand classified as having <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><a title="navigation" class="termref" href="#dt-navigation">navigation</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means in effect that a call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-reverse"><code>reverse</code></a><sup><small>FO30</small></sup> is not streamable unless the operand is grounded. This may cause few surprises:</p><ul><li><p>The expression <code>reverse(/*/emp/copy-of())</code> is considered streamable, although all the <code>emp</code> elements will typically need to be in memory at the same time. The explanation here is that the streamability rules do not attempt to restrict the amount of memory used for data that is explicitly copied by use of a function such as <a href="#func-copy-of"><code>copy-of</code></a>.</p></li><li><p>The expression <code>reverse(ancestor::*)/name()</code> is considered non-streamable, because the operand is not grounded. This problem can be circumvented by rewriting the expression as <code>reverse(ancestor::*/name())</code></p></li></ul></div></div><div class="div4"><h5><a id="streamability-fn-root"></a>19.8.9.18 <a href="#streamability-fn-root" style="text-decoration: none">Streamability of the </a><a href="https://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup><a href="#streamability-fn-root" style="text-decoration: none"> Function</a></h5><p>The zero-argument function <code>root()</code> is equivalent to <code>root(.)</code>.</p><p>Given the expression <code>root(X)</code>, if the <a title="static type" class="termref" href="#dt-static-type">static type</a> of <code>X</code> is <var>U{document-node()}</var>, and if its <a title="posture" class="termref" href="#dt-posture">posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>, then <code>root(X)</code> is rewritten as <code>X</code>. Otherwise, it is rewritten as <code>head((X)/ancestor-or-self::node())</code>. Streamability analysis is then applied to the rewritten expression.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Because path expressions starting with <code>/</code> are rewritten to use the <a href="https://www.w3.org/TR/xpath-functions-30/#func-root"><code>root</code></a><sup><small>FO30</small></sup> function, this ensures that a leading slash is ignored if the context item is a document node, for example within a template rule with <code>match="/"</code>. This improves streamability, because upwards navigation followed by downward navigation is disallowed.</p></div></div></div><div class="div3"><h4><a id="classifying-patterns"></a>19.8.10 <a href="#classifying-patterns" style="text-decoration: none">Classifying Patterns</a></h4><div class="note"><p class="prefix"><b>Note:</b></p><p>Patterns differ from other kinds of construct in that they are not composable in the same way. It is best to think of a pattern as specialized syntax for a function that takes an item as its argument and returns a boolean: true if the pattern matches the item, otherwise false. The <a title="static type" class="termref" href="#dt-static-type">static type</a> of a pattern is therefore taken as <var>U{xs:boolean}</var> (this is not to be confused with the type of the items that the pattern is capable of matching).</p></div><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> is either <a title="motionless" class="termref" href="#dt-motionless">motionless</a> or <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>. (Although there are patterns that could in principle be evaluated by consuming the element node that they match, these are of no interest in the analysis, so they are classified as free-ranging.)</p><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> if the pattern is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, or <a title="roaming" class="termref" href="#dt-roaming">roaming</a> otherwise. (This reflects the fact that a pattern always returns a boolean result; it never returns a node in a streamed document.)</p><p>Informally, a <a title="motionless" class="termref" href="#dt-motionless">motionless</a> pattern is one that can be evaluated by a streaming processor when the input stream is positioned at the start of the node being matched, without advancing the input stream.</p><p>A pattern is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> if and only if it satisfies all the following conditions:</p><ol class="enumar"><li><p>The pattern does not contain a <a href="#doc-xslt40-patterns-RootedPath">RootedPath</a>.</p></li><li><p>If the pattern contains predicates, then every top-level <code>Predicate</code> in the pattern satisfies all the following conditions:</p><ol class="enumla"><li><p>The expression immediately contained in the predicate is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, when assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="striding" class="termref" href="#dt-striding">striding</a>, and a context item type set to the <a title="static type" class="termref" href="#dt-static-type">static type</a> of the expression to which the predicate applies, determined using the rules in <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>.</p></li><li><p>The predicate is a <a title="non-positional predicate" class="termref" href="#dt-non-positional-predicate">non-positional predicate</a>.</p></li></ol><p>The use of the term <b>top-level</b> in this rule means that predicates that are nested within other predicates do not themselves have to be non-positional, though they may play a role in the analysis of top-level predicates.</p></li><li><p>The pattern does not contain (at any depth) a variable reference that is bound to a <a title="streaming parameter" class="termref" href="#dt-streaming-parameter">streaming parameter</a>. (See <a href="#streamability-of-function-calls"><i>19.8.8.14 Streamability of Static Function Calls</i></a>).</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-non-positional-predicate" title="non-positional predicate"></a>A predicate is a <b>non-positional predicate</b> if it satisfies both of the following conditions:</p><ol class="enumar"><li><p>The predicate does not contain a function call or named function reference to any of the following functions, unless that call or reference occurs within a nested predicate:</p><ol class="enumla"><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup></p></li><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup></p></li><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The exception for nested predicates is there to ensure that patterns such as <code>match="p[@code = $status[last()]]</code> are not disqualified.</p></div></li><li><p>The expression immediately contained in the predicate is a non-numeric expression. An expression is non-numeric if the intersection of its <a title="static type" class="termref" href="#dt-static-type">static type</a> (see <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>) with <var>U{xs:decimal, xs:double, xs:float}</var> is <var>U{}</var>.</p></li></ol><p>]</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A non-positional predicate can be evaluated by considering each item in the filtered sequence independently; the result never depends on the position of other items in the sequence or the length of the sequence.</p></div><p>A pattern that is not <a title="motionless" class="termref" href="#dt-motionless">motionless</a> is classified as <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>.</p><p>The following list shows examples of motionless patterns:</p><ul><li><p><code>/</code></p></li><li><p><code>*</code></p></li><li><p><code>/*</code></p></li><li><p><code>p</code></p></li><li><p><code>p|q</code></p></li><li><p><code>p/q</code></p></li><li><p><code>p[@status='red']</code></p></li><li><p><code>p[base-uri()]</code></p></li><li><p><code>p[@class or @style]</code></p></li><li><p><code>p[@status]</code></p></li><li><p><code>p[@status = $status-codes[1]]</code></p></li><li><p><code>p[@class | @style]</code></p></li><li><p><code>p[contains(@class, ':')]</code></p></li><li><p><code>p[substring-after(@class, ':')]</code></p></li><li><p><code>p[ancestor::*[@xml:lang]]</code></p></li><li><p><code>text()[starts-with(., '$')]</code></p></li><li><p><code>@price</code></p></li><li><p><code>@price[starts-with(., '$')]</code></p></li><li><p><code>//p/text()[. = 'Introduction']</code></p></li><li><p><code>document-node(element(html))</code> (Note: this is classified as motionless even though testing a document node against the pattern might require a small amount of look-ahead.)</p></li></ul><p>The following list shows examples of patterns that are not motionless, explaining why not:</p><ul><li><p><code>id('abc')</code> (contains a <code>RootedPath</code>)</p></li><li><p><code>$doc//p</code> (contains a <code>RootedPath</code>)</p></li><li><p><code>p[b]</code> (the predicate is not motionless)</p></li><li><p><code>p[. = 'Introduction']</code> (the predicate is not motionless)</p></li><li><p><code>p[starts-with(., '$')]</code> (the predicate is not motionless)</p></li><li><p><code>p[preceding-sibling::p[1] = '']</code> (the predicate is not motionless)</p></li><li><p><code>p[1]</code> (contains a positional predicate: return type is numeric)</p></li><li><p><code>p[$pnum + 1]</code> (contains a positional predicate: return type is numeric)</p></li><li><p><code>p[data(@status)]</code> (contains a positional predicate: return type is potentially numeric)</p></li><li><p><code>p[position() gt 2]</code> (contains a positional predicate: calls <code>position()</code>)</p></li><li><p><code>p[last()]</code> (contains a positional predicate: calls <code>last()</code>)</p></li></ul></div></div><div class="div2"><h3><a id="streamability-analysis-examples"></a>19.9 <a href="#streamability-analysis-examples" style="text-decoration: none">Examples of Streamability Analysis</a></h3><p>The examples in this section are intended to illustrate how the streamability rules are applied “top down” to establish whether template rules are guaranteed streamable.</p><div class="example"><div class="exampleHeader"><a id="d8e51781"></a><a id="d8e51890"></a>Example: A recursive-descent template rule</div><p>Consider the following template rule, where mode <code>s</code> is defined with <code>streamable="yes"</code>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">para</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">s</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">div</span><span class="z"></span><span class="atn">class</span><span class="atneq">=</span><span class="z">"</span><span class="av">para</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">s</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">div</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The processor is required to establish that this template meets the streamability rules. Specifically, as stated in <a href="#streamable-templates"><i>6.7.6 Streamable Templates</i></a>, it must satisfy three conditions:</p><ol class="enumar"><li><p>The match pattern must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>The body of the template rule must be <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>The initializers of any template parameters must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol><p>The third condition is satisfied trivially because there are no parameters.</p><p>The first rule depends on the rules for assessing patterns, which are given in <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a>. This pattern is motionless because (a) it does not contain a <code>RootedPath</code>, and (b) it contains no predicates.</p><p>So it remains to determine that the body of the template is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>. The proof of this is as follows:</p><ol class="enumar"><li><p>The sequence constructor forming the body of the template is assessed according to the rules in <a href="#classifying-sequence-constructors"><i>19.8.3 Classifying Sequence Constructors</i></a>, which tell us that there is a single operand (the <code>&lt;div&gt;</code><a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>) which has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><var>U</var> = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>. </p></li><li><p>The assessment of the sequence constructor uses the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. These rules require us to determine the type <var>T</var>, sweep <var>S</var>, posture <var>P</var>, and usage <var>U</var> of each operand. We have already established that there is a single operand, with <var>U</var> = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>. Section <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a> tells us that for all instructions, we can take <var>T</var> = <var>U{*}</var>. The <a title="posture" class="termref" href="#dt-posture">posture</a><var>P</var> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var> of the literal result element are established as follows:</p><ol class="enumla"><li><p>The rules for literal result elements (specifically the <code>&lt;div&gt;</code> element) are given in <a href="#streamability-literal-result-elements"><i>19.8.4.1 Streamability of Literal Result Elements</i></a>. This particular literal result element has only one operand (its contained sequence constructor), with <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>The <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> again apply. Again the <a title="static type" class="termref" href="#dt-static-type">static type</a><var>T</var> of the operand is <code>U{*}</code>, and we need to determine the <a title="posture" class="termref" href="#dt-posture">posture</a><var>P</var> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var>.</p></li><li><p>To determine the posture and sweep of this sequence constructor (the one that contains the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction) we refer again to the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>.</p><ol class="enumlr"><li><p>The sequence constructor has a single operand (the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction); again <var>U</var> = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, <var>T</var> = <var>U{*}</var>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a><var>P</var> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var> of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction are established as follows:</p><ol class="enumua"><li><p>The rules that apply are in <a href="#streamability-xsl-apply-templates"><i>19.8.4.5 Streamability of xsl:apply-templates</i></a>.</p></li><li><p>Rule 1 does not apply because the <code>select</code> expression (which defaults to <code>child::node()</code>) is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>. This is a consequence of the rules in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>, specifically:</p><ol class="enumur"><li><p>The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of the axis step is established by the template rule as a whole, as <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>Therefore rules 1 and 2 do not apply.</p></li><li><p>The statically inferred context item type is derived from the match pattern (<code>match="para"</code>). This gives a type of <var>U{element()}</var>. The child axis for element nodes is not necessarily empty, so rule 3 does not apply.</p></li><li><p>Rule 4 does not apply because there are no predicates.</p></li><li><p>So the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the axis step <code>child::node()</code> are given by the table in rule 5. The entry for (context posture = striding, axis = child) gives a posture of <a title="striding" class="termref" href="#dt-striding">striding</a> and a <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>So the <code>select</code> expression is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>. (The same result can be reached intuitively: an expression that selects streamed nodes will never be <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.)</p></li></ol></li><li><p>Rule 2 does not apply because there is no <a href="#element-sort"><code>xsl:sort</code></a> element.</p></li><li><p>Rule 3 does not apply because the mode is declared with <code>streamable="yes"</code>.</p></li><li><p>So the <a title="posture" class="termref" href="#dt-posture">posture</a><var>P</var> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var> of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction are established by the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, as follows:</p><ol class="enumur"><li><p>There is a single operand, the implicit <code>select="child::node()"</code> expression, with usage <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>We have already established that for this operand, the posture <var>P</var> = <a title="striding" class="termref" href="#dt-striding">striding</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>By the rules in <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>, the type <var>T</var> of the <code>select</code> expression is <code>node()</code>.</p></li><li><p>In the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, the adjusted sweep <var>S′</var> for an operand with (<var>P</var> = <a title="striding" class="termref" href="#dt-striding">striding</a>, <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>) is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, </p></li><li><p>Rule 2(d) then applies, so the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is <a title="consuming" class="termref" href="#dt-consuming">consuming</a> and <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li></ol></li></ol></li><li><p>So the sequence constructor that contains the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction has one operand with <var>U</var> = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, <var>T</var> = <code>item()</code>, <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. Rule 2(d) of the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> applies, so the sequence constructor itself has <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li><li><p>So the literal result element has one operand with <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <var>T</var> = <code>item()</code>, <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. Rule 2(d) of the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> applies, so the literal result element has <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li><li><p>So the sequence constructor containing the literal result element has one operand with <var>U</var> = <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, <var>T</var> = <code>item()</code>, <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. Rule 2(d) of the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> applies, so this sequence constructor itself has <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>So we have established that the sequence constructor forming the body of the template rule is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li></ol><p>Therefore, since the other conditions are also satisfied, the template is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p><p>The analysis presented above could have been simplified by taking into account the fact that the streamability properties of a sequence constructor containing a single instruction are identical to the properties of that instruction. This simplification will be exploited in the next example.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e52193"></a><a id="d8e52302"></a>Example: An aggregating template rule</div><p>Consider the following template rule, where mode <code>s</code> is defined with <code>streamable="yes"</code>:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">transactions</span><span class="filter">[</span><span class="axis">@</span><span class="qname">currency</span><span class="op">=</span><span class="op">'</span><span class="literal">USD</span><span class="op">'</span><span class="filter">]</span><span class="z">"</span><span class="z"></span><span class="atn">mode</span><span class="atneq">=</span><span class="z">"</span><span class="av">s</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">total</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">sum</span><span class="parenthesis">(</span><span class="qname">transaction</span><span class="step">/</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">total</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Again, as stated in <a href="#streamable-templates"><i>6.7.6 Streamable Templates</i></a>, it must satisfy three conditions:</p><ol class="enumar"><li><p>The match pattern must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>The body of the template rule must be <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>The initializers of any template parameters must be <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol><p>The third condition is satisfied trivially because there are no parameters.</p><p>The first rule depends on the rules for assessing patterns, which are given in <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a>. This pattern is motionless because (a) it is not a <code>RootedPath</code>, and (b) every predicate is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and <a title="non-positional predicate" class="termref" href="#dt-non-positional-predicate">non-positional</a>. The analysis that proves the predicate is motionless and non-positional proceeds as follows:</p><ol class="enumar"><li><p>First establish that the expression <code>@currency='USD'</code> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, as follows:</p><ol class="enumla"><li><p>The predicate is a general comparison (<code>GeneralComp</code>) which follows the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>.</p></li><li><p>There are two operands: an <code>AxisStep</code> with a defaulted <code>ForwardAxis</code>, and a <code>Literal</code>. Both operand roles are <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>The left-hand operand has type <var>T</var> = <code>attribute()</code>. Its <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are determined by the rules in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>. The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>, so the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> are determined by the entry in the table (rule 5) with context posture = <a title="striding" class="termref" href="#dt-striding">striding</a>, axis = <code>attribute</code>: that is, the result posture is <a title="striding" class="termref" href="#dt-striding">striding</a> and the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>The right-hand operand, being a literal, is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>In the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, rule 2(e) applies, so the predicate is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a></p></li></ol></li><li><p>Now establish that the expression <code>@currency='USD'</code> is <a title="non-positional predicate" class="termref" href="#dt-non-positional-predicate">non-positional</a>, as follows:</p><ol class="enumla"><li><p>Rule 1 is satisfied: the predicate does not call <a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup>, or <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>.</p></li><li><p>Rule 2 is satisfied: the expression <code>@currency='USD'</code> is non-numeric. The <a title="static type" class="termref" href="#dt-static-type">static type</a> of the expression is determined using the rules in <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a> as <var>U{xs:boolean}</var>, and this has no intersection with <var>U{xs:decimal, xs:double, xs:float}</var>.</p></li></ol></li></ol><p>So both conditions in <a href="#classifying-patterns"><i>19.8.10 Classifying Patterns</i></a> are satisfied, and the pattern is therefore <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p><p>It remains to show that the body of the template rule is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>. The proof of this is as follows. Unlike the previous example, the analysis is shown in simplified form; in particular the two sequence constructors which each contain a single instruction are ignored, and replaced in the construct tree by their contained instruction.</p><ol class="enumar"><li><p>We need to show that the <code>&lt;total&gt;</code><a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>The rules that apply are in <a href="#streamability-literal-result-elements"><i>19.8.4.1 Streamability of Literal Result Elements</i></a>.</p></li><li><p>These rules refer to the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>. There is one operand, the <a href="#element-value-of"><code>xsl:value-of</code></a> child element, which has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, and type <var>T</var> = <code>item()</code>.</p></li><li><p>So we need to determine the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction.</p><ol class="enumla"><li><p>The rules are given in <a href="#streamability-xsl-value-of"><i>19.8.4.41 Streamability of xsl:value-of</i></a>.</p></li><li><p>The <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply. There is one operand, the expression <code>sum(transaction/@value)</code>, which has <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>The type <var>T</var> of this operand is the return type defined in the signature of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup> function, that is, <code>xs:anyAtomicType</code>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a><var>P</var> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var> are established as follows:</p><ol class="enumlr"><li><p>The rules that apply to the call on <a href="https://www.w3.org/TR/xpath-functions-30/#func-sum"><code>sum</code></a><sup><small>FO30</small></sup> are given in <a href="#classifying-built-in-functions"><i>19.8.9 Classifying Calls to Built-In Functions</i></a>.</p></li><li><p>The relevant proforma is <code>fn:sum(A)</code>, indicating that the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply, and that there is a single operand with usage <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>The type <var>T</var> of the operand <code>transaction/@value</code> is determined (by the rules in <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>) as <code>attribute()</code>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a><var>P</var> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S</var> of the operand <code>transaction/@value</code> are determined by the rules in <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a>, as follows:</p><ol class="enumua"><li><p>The expression is expanded to <code>child::transaction/attribute::value</code>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the left-hand operand <code>child::transaction</code> are determined by the rules in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>, as follows:</p><ol class="enumur"><li><p>The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>, because the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a> is the template rule itself.</p></li><li><p>The <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> is <code>element()</code>, based on the <a title="match type" class="termref" href="#dt-match-type">match type</a> of the pattern <code>match="transactions[@currency='USD']"</code>.</p></li><li><p>Rules 1 and 2 do not apply because the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>Rule 3 does not apply because the <code>child</code> axis applied to an element node is not necessarily empty.</p></li><li><p>Rule 4 does not apply because there are no predicates.</p></li><li><p>Rule 5 applies, and the table entry with context posture = <a title="striding" class="termref" href="#dt-striding">striding</a>, axis = <code>child</code> gives a result <a title="posture" class="termref" href="#dt-posture">posture</a> of <a title="striding" class="termref" href="#dt-striding">striding</a> and a <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the relative path expression <code>child::transaction/attribute::value</code> is therefore the <a title="posture" class="termref" href="#dt-posture">posture</a> of its right-hand operand <code>attribute::value</code>, assessed with a <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> of <a title="striding" class="termref" href="#dt-striding">striding</a>. This is determined by the rules in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>, as follows:</p><ol class="enumur"><li><p>The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a>, as we have seen, is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>The <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> is <code>element()</code>, based on the type of the left-hand operand <code>child::transaction</code>.</p></li><li><p>Rules 1 and 2 do not apply because the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>Rule 3 does not apply because the <code>attribute</code> axis applied to an element node is not necessarily empty.</p></li><li><p>Rule 4 does not apply because there are no predicates.</p></li><li><p>Rule 5 applies, and the table entry with context posture = <a title="striding" class="termref" href="#dt-striding">striding</a>, axis = <code>attribute</code> gives a result <a title="posture" class="termref" href="#dt-posture">posture</a> of <a title="striding" class="termref" href="#dt-striding">striding</a> and a <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the relative path expression <code>child::transaction/attribute::value</code> is therefore <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the relative path expression <code>child::transaction/attribute::value</code> is the wider of the sweeps of its two operands, namely <a title="consuming" class="termref" href="#dt-consuming">consuming</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. That is, it is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li><li><p>So the first and only operand to the call on <code>sum()</code> has <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <var>T</var> = <code>attribute()</code>, <var>P</var> = <a title="climbing" class="termref" href="#dt-climbing">climbing</a>, and <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a></p></li><li><p>Rule 1(b) of the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> computes the adjusted sweep <var>S′</var>. Rule 1(b)(iii)(A) applies, so the effective <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><var>U′</var> is <a title="inspection" class="termref" href="#dt-inspection">inspection</a>. Rule 1(b)(iii)(A) then computes the adjusted sweep from the table entry for <var>P</var> = <a title="climbing" class="termref" href="#dt-climbing">climbing</a>, <var>U′</var> = <a title="inspection" class="termref" href="#dt-inspection">inspection</a>; this shows <var>S′</var> = <var>S</var>, that is, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>Rule 2(d) now applies, so the call on <code>sum()</code> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li><li><p>Since the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction has one operand with <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <var>T</var> = <code>xs:anyAtomicType</code>, <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, rule 2(d) again applies, and the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li><li><p>Since the literal result element has one operand with <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <var>T</var> = <code>item()</code>, <var>P</var> = <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, rule 2(d) again applies, and the literal result element is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>Therefore the body of the template rule is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and since the other conditions are also satisfied, it is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p></li></ol></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e52752"></a><a id="d8e52861"></a>Example: Streamed Grouping</div><p>Consider the following code, which is designed to process a transaction file containing transactions in chronological order, and output the total value of the transactions for each day.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">go</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">out</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">transactions.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="qname">account</span><span class="step">/</span><span class="qname">transaction</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="function">xs:date</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">timestamp</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">total</span><span class="z"></span><span class="atn">date</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">current-grouping-key</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">sum</span><span class="parenthesis">(</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">out</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The rules for <a href="#element-source-document"><code>xsl:source-document</code></a> say that the instruction is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> if the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and the task of streamability analysis is to prove that this is the case. As in the previous example, we will take a short-cut by making the assumption that a sequence constructor containing a single instruction can be replaced by that instruction in the construct tree.</p><p>So the task is to show that the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, which we can do as follows:</p><ol class="enumar"><li><p>The relevant rules are to be found in <a href="#streamability-xsl-for-each-group"><i>19.8.4.19 Streamability of xsl:for-each-group</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Rule numbers may be different in a version of the specification with change markings.</p></div></li><li><p>Rule 1 applies only if the <code>select</code> expression is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>. It is easy to see informally that this is not the case (an expression that returns streamed nodes is never grounded). More formally:</p><ol class="enumla"><li><p>The <code>select</code> expression is a path expression; the rules in <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a> apply.</p></li><li><p>The expression is rewritten as <code>((root(.) treat as document-node())/child::account)/child::transaction</code></p></li><li><p>The left-hand operand <code>(root(.) treat as document-node())/child::account</code> is also a path expression, so the rules in <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a> apply recursively:</p><ol class="enumlr"><li><p>The left-hand operand <code>root(.) treat as document-node()</code> follows the rules for a <code>TreatExpr</code> in <a href="#classifying-expressions"><i>19.8.8 Classifying Expressions</i></a>; the proforma <code>T treat as TYPE</code> indicates that the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply with a single operand having usage <a title="transmission" class="termref" href="#dt-transmission">transmission</a>.</p></li><li><p>This single operand <code>root(.)</code> follows the rules in <a href="#streamability-fn-root"><i>19.8.9.18 Streamability of the root Function</i></a>. The item type of the operand <code>.</code> is the <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a>, which is the type established by the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, namely <code>document-node()</code>. Under these conditions <code>root(.)</code> is rewritten as <code>.</code>, so the <a title="posture" class="termref" href="#dt-posture">posture</a> is the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> established by the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, namely <a title="striding" class="termref" href="#dt-striding">striding</a>. The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the expression <code>root(.) treat as document-node()</code> are the same as the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <code>root(.)</code>, namely <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a></p></li><li><p>The right-hand operand <code>child::account</code> is governed by the rules in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>. The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>, and the axis is <code>child</code>, so the result posture is <a title="striding" class="termref" href="#dt-striding">striding</a> and the sweep is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the path expression is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the right-hand operand, that is <a title="striding" class="termref" href="#dt-striding">striding</a>, and its sweep is the wider sweep of the two operands, that is <a title="consuming" class="termref" href="#dt-consuming">consuming</a></p></li></ol></li><li><p>Returning to the outer path expression, the <a title="posture" class="termref" href="#dt-posture">posture</a> of the right hand operand <code>child::transaction</code> is <a title="striding" class="termref" href="#dt-striding">striding</a>, and its sweep is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>So the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>select</code> expression as a whole is the posture of the right hand operand, that is <a title="striding" class="termref" href="#dt-striding">striding</a>; and its sweep is the wider of the sweeps of the operands, which is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol></li><li><p>Rule 2 does not apply: there is no <code>group-by</code> attribute.</p></li><li><p>Rule 3 does not apply: there is a <code>group-adjacent</code> attribute, but it is <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. The reasoning is as follows:</p><ol class="enumla"><li><p>The value is a call to the constructor function <code>xs:date</code>. The rules in <a href="#streamability-of-function-calls"><i>19.8.8.14 Streamability of Static Function Calls</i></a> apply. There is a single operand, whose required type is atomic, so the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>These rules refer to the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, so we need to determine the <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a>, <a title="posture" class="termref" href="#dt-posture">posture</a>, and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the operand expression <code>@timestamp</code>. This is done as follows:</p><ol class="enumlr"><li><p>The expression is an <code>AxisStep</code>, so the relevant rules are in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>.</p></li><li><p>The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <a title="controlling operand" class="termref" href="#dt-controlling-operand">controlling operand</a> of the <a title="focus-setting container" class="termref" href="#dt-focus-setting-container">focus-setting container</a>, that is, is the <code>select</code> expression of the containing <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction, which as established above is <a title="striding" class="termref" href="#dt-striding">striding</a>. The <a title="context item type" class="termref" href="#dt-context-item-type">context item type</a> is similarly the inferred type of the <code>select</code> expression, and is <code>element()</code>.</p></li><li><p>Rules 1 and 2 do not apply because the <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>Rule 3 does not apply because the attribute axis for an element node is not necessarily empty.</p></li><li><p>Rule 4 does not apply because there is no predicate.</p></li><li><p>So the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> and <a title="posture" class="termref" href="#dt-posture">posture</a> of the expression <code>@timestamp</code> are given by the table in Rule 5 as <a title="striding" class="termref" href="#dt-striding">striding</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></li><li><p>Returning to the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> for the expression <code>xs:date(@timestamp)</code>, the operand <code>@timestamp</code> has <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <var>T</var> = <code>attribute()</code>, <var>P</var> = <a title="striding" class="termref" href="#dt-striding">striding</a>, <var>S</var> = <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. </p></li><li><p>Under Rule 1(b)(iii)(A), because <var>T</var> = <code>attribute()</code>, the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a><var>U′</var> becomes <a title="inspection" class="termref" href="#dt-inspection">inspection</a>.</p></li><li><p>Under Rule 1(b)(iii)(A), <var>S′</var> = <var>S</var> = <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>Under Rule 2(e), the expression <code>xs:date(@timestamp)</code> is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></li><li><p>Rule 4 (under <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>) does not apply, because there is no <a href="#element-sort"><code>xsl:sort</code></a> child.</p></li><li><p>So Rule 5 applies. This relies on knowing the <a title="posture" class="termref" href="#dt-posture">posture</a> of the sequence constructor contained in the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction: that is, the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>total</code><a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. This is calculated as follows:</p><ol class="enumla"><li><p>The rules that apply are in <a href="#streamability-literal-result-elements"><i>19.8.4.1 Streamability of Literal Result Elements</i></a>. The <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply; there are two operands, the attribute value templates <code>{current-grouping-key()}</code> and <code>{sum(current-group()/@value)}</code>, and in each case the usage is <a title="absorption" class="termref" href="#dt-absorption">absorption</a>. We can simplify the analysis by observing that the empty <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the literal result element can be ignored, since it is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>. </p></li><li><p>Consider first the operand <code>{current-grouping-key()}</code>.</p><ol class="enumlr"><li><p>Section <a href="#classifying-vts"><i>19.8.7 Classifying Value Templates</i></a> applies. This refers to the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>; there is a single operand, the expression <code>current-grouping-key()</code>, with usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>Section <a href="#streamability-fn-current-grouping-key"><i>19.8.9.5 Streamability of the current-grouping-key Function</i></a> applies. This establishes that the expression is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li><li><p>It follows that the operand <code>{current-grouping-key()}</code> expression is also <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>.</p></li></ol></li><li><p>Now consider the operand <code>{sum(current-group()/@value)}</code>.</p></li><li><p>Section <a href="#classifying-vts"><i>19.8.7 Classifying Value Templates</i></a> applies. This refers to the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>; there is a single operand, the expression <code>sum(current-group()/@value)</code>, with usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>.</p></li><li><p>The rules for the <code>sum</code> function appear in <a href="#classifying-built-in-functions"><i>19.8.9 Classifying Calls to Built-In Functions</i></a>. The proforma is given there as <code>fn:sum(A)</code>, which means that the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> apply, and that the single operand <code>current-group()/@value</code> has usage <a title="absorption" class="termref" href="#dt-absorption">absorption</a>. So we need to establish the <a title="posture" class="termref" href="#dt-posture">posture</a>, <a title="sweep" class="termref" href="#dt-sweep">sweep</a>, and type of this expression, which we can do as follows:</p><ol class="enumlr"><li><p>The expression is a <code>RelativePathExpr</code>, so section <a href="#streamability-of-path-expressions"><i>19.8.8.8 Streamability of Path Expressions</i></a> applies.</p></li><li><p>The expression is expanded to <code>current-group()/attribute::value</code>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the left-hand operand <code>current-group()</code> are defined in <a href="#streamability-fn-current-group"><i>19.8.9.4 Streamability of the current-group Function</i></a>. Since all the required conditions are satisfied, the <a title="posture" class="termref" href="#dt-posture">posture</a> of <code>current-group()</code> is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>select</code> expression, that is <a title="striding" class="termref" href="#dt-striding">striding</a>, and its <a title="sweep" class="termref" href="#dt-sweep">sweep</a> is the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <code>select</code> expression, that is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the right hand operand <code>@value</code> are defined in <a href="#streamability-of-axis-steps"><i>19.8.8.9 Streamability of Axis Steps</i></a>. The <a title="context posture" class="termref" href="#dt-context-posture">context posture</a> is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the left-hand operand <code>current-group()</code>, namely <a title="striding" class="termref" href="#dt-striding">striding</a>; the table in Rule 5 applies, giving the result <a title="climbing" class="termref" href="#dt-climbing">climbing</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a></p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> of the <code>RelativePathExpr</code> is the <a title="posture" class="termref" href="#dt-posture">posture</a> of the right hand operand, namely <a title="striding" class="termref" href="#dt-striding">striding</a>. The <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <code>RelativePathExpr</code> is the wider of the <a title="sweep" class="termref" href="#dt-sweep">sweeps</a> of its operands, which is <a title="consuming" class="termref" href="#dt-consuming">consuming</a></p></li><li><p>The type of the expression <code>current-group()/@value</code> is determined using the rules in <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a> as <code>attribute()</code>.</p></li></ol></li><li><p>So the <code>sum</code> function has a single operand with <var>U</var> = <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <var>P</var> = <a title="striding" class="termref" href="#dt-striding">striding</a>, <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, <var>T</var> = <code>attribute()</code>.</p></li><li><p>In the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a>, Rule 1(b)(iii)(A) gives the adjusted usage as <var>U′</var> = <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, and Rule 1(b)(iii)(B) gives the adjusted sweep as <var>S′</var> = <var>S</var> = <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. Rule 2(d) gives the posture and sweep of the call to <code>sum</code> as <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. </p></li></ol></li><li><p>So the literal result element has two operands, one of which is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, the other <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>. Rule 2(d) of the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> determines that the literal result element is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>So the content of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, which means that the instruction is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p></li></ol></div></div><div class="div2"><h3><a id="streamability-guarantees"></a>19.10 <a href="#streamability-guarantees" style="text-decoration: none">Streamability Guarantees</a></h3><p>Certain constructs allow a stylesheet author to declare that a construct is streamable. Specifically:</p><ul><li><p>Specifying <code>streamable="yes"</code> on <a href="#element-mode"><code>xsl:mode</code></a> declares that all template rules in that mode (and all template rules that specify <code>mode="#all"</code>) are streamable;</p></li><li><p>Specifying <code>streamable="yes"</code> on <a href="#element-source-document"><code>xsl:source-document</code></a> declares that its contained sequence constructor is streamable;</p></li><li><p>Specifying <code>streamable="yes"</code> on <a href="#element-function"><code>xsl:function</code></a> declares that the <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> in question is streamable;</p></li><li><p>Specifying <code>streamable="yes"</code> on <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declares that the attribute set in question is streamable;</p></li><li><p>Specifying <code>streamable="yes"</code> (explicitly or implicitly) on <a href="#element-merge-source"><code>xsl:merge-source</code></a> declares that the merging process is streamable with respect to that particular input.</p></li><li><p>Specifying <code>streamable="yes"</code> on <a href="#element-accumulator"><code>xsl:accumulator</code></a> declares that the accumulator can be evaluated on a streamed document.</p></li></ul><p><span class="definition">[Definition:&nbsp;</span><a id="dt-declared-streamable" title="declared-streamable"></a>The above constructs (template rules belonging to a mode declared with <code>streamable="yes"</code>; and <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>, <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-merge-source"><code>xsl:merge-source</code></a>, and <a href="#element-accumulator"><code>xsl:accumulator</code></a> elements specifying <code>streamable="yes"</code>) are said to be <b>declared-streamable</b>.<span class="definition">]</span></p><p>In each case the construct in question is said to be <b>guaranteed-streamable</b> if it satisfies two conditions:</p><ol class="enumar"><li><p>The construct is <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a>.</p></li><li><p>Streamability analysis following the rules defined in this specification determines that streamed processing is possible (the detailed conditions vary from one construct to another).</p></li></ol><p><span class="definition">[Definition:&nbsp;</span><a id="dt-guaranteed-streamable" title="guaranteed-streamable"></a>A <b>guaranteed-streamable</b> construct is a <a title="construct" class="termref" href="#dt-construct">construct</a> that is declared to be streamable and that follows the particular rules for that construct to make streaming possible, as defined by the analysis in this specification.<span class="definition">]</span></p><p>For a streaming processor, that is, a processor that claims conformance with the <a title="streaming feature" class="termref" href="#dt-streaming-feature">streaming feature</a>:</p><ol class="enumar"><li><p>If a construct is <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> and the input is provided in streamable form, then the input <span class="verb">must</span> be processed using streaming.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The requirement to process the input using streaming does not apply if the processor is able to determine that this would convey no benefit: for example, if the input is supplied as a tree in memory. However, this does not remove the requirement to verify that the relevant stylesheet constructs are <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>.</p></div></li><li><p>If a construct is declared as streamable but is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> (that is, if it fails to satisfy the conditions for streamability defined in this specification), then the processor <span class="verb">must</span> be prepared to do any one of the following at user option:</p><ol class="enumla"><li><p>Signal a static error <span class="error">[see <a href="#err-XTSE3430">ERR XTSE3430</a>]</span></p></li><li><p>Process the stylesheet as if it were a non-streaming processor (see below)</p></li><li><p>Process the stylesheet with streaming if it is able to do so, or signal a static error <span class="error">[see <a href="#err-XTSE3430">ERR XTSE3430</a>]</span> if it is not able to do so.</p></li></ol></li></ol><p><a id="err-XTSE3430"><span class="error">[ERR XTSE3430] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains a construct that is declared to be streamable but which is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, unless the user has indicated that the processor is to handle this situation by processing the stylesheet without streaming or by making use of processor extensions to the streamability rules where available.</p><p>For a non-streaming processor, the processor <span class="verb">must</span> evaluate the construct delivering the same results as if execution used streaming, but with no constraints on the evaluation strategy. (Processing <span class="verb">may</span>, of course, fail due to insufficient memory being available, or for other reasons.) A non-streaming processor is <span class="verb">not required</span> to assess whether constructs are <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, or to apply restrictions such as the rules for where calls on the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a> may appear. However, a non-streaming processor <span class="verb">must</span> enforce the constraint implied by a <code>use-accumulators</code> attribute restricting which accumulators can be used with a particular document.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This specification does not attempt to legislate precisely what constitutes evaluation “using streaming”. The most important test is that the amount of memory needed should be for practical purposes independent of the size of the source document, and in particular that the finite size of memory available should not impose a limit on the size of source document that can be processed.</p><p>The rules are designed to ensure that streaming processors can analyze streamability using rules different from those in this specification, provided that all constructs that are <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> according to this specification are actually streamable by the implementation. Furthermore, non-streaming processors are not required to analyze streamability at all.</p></div></div></div><div class="div1"><h2><a id="add-func"></a>20 <a href="#add-func" style="text-decoration: none">Additional Functions</a></h2><p>This section describes XSLT-specific additions to the XPath function library. Some of these additional functions also make use of information specified by <a title="declaration" class="termref" href="#dt-declaration">declarations</a> in the stylesheet; this section also describes these declarations.</p><div class="div2"><h3><a id="func-document"></a>20.1 <a href="#func-document" style="text-decoration: none">fn:document</a></h3><dl><dt class="label">Summary</dt><dd><p>Provides access to XML documents identified by a URI.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><a id="function-document"></a><table style="border:0; border-spacing:0"><tbody><tr class="delete_version" style="display: none;"><td colspan="3"><code class="function">fn:document</code>(</td></tr><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:document</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td style="padding:0; vertical-align:top" rowspan="2"><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:document</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td><td><span style="display: none;" class="delete_version"><code>$uri-sequence</code></span><span style="display: none;" class="add_version"><code class="arg">$uri-sequence</code></span><span class="modify_version"><code class="arg">$uri-sequence</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">item()*</code>,</span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">item()*</code>,</span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">item()*</code>,</span></td><td></td></tr><tr class="arg"><td><span style="display: none;" class="delete_version"><code>$base-node</code></span><span style="display: none;" class="add_version"><code class="arg">$base-node</code></span><span class="modify_version"><code class="arg">$base-node</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">node()?</code></span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">node()?</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">node()*</code></span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">node()?</code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">node()*</span></code></span></td><td><code class="assign"><span class="deltaxml-old" style="background:#FF5555">:=&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">()</span></code></td></tr><tr class="delete_version" style="display: none;"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>node()*</code></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">node()*</span></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>The one-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>. It depends on static base URI. </p><p>The two-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The <a href="#func-document"><code>document</code></a> function allows access to XML documents identified by a URI.</p><p>The first argument contains a sequence of URI references. The second argument, if present, is a node whose base URI is used to resolve any relative URI references contained in the first argument.</p><p>A sequence of absolute URI references is obtained as follows.</p><ul><li><p>For an item in <code>$uri-sequence</code> that is an instance of <code>xs:string</code>, <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>, the value is cast to <code>xs:anyURI</code>. If the resulting URI reference is an absolute URI reference then it is used <em>as is</em>. If it is a relative URI reference, then it is resolved as follows:</p><ol class="enumar"><li><p>If <code>$base-node</code> is supplied <span>(that is, if the argument is present and non-empty)</span>, then it is resolved against the base URI of <code>$base-node</code>.</p></li><li><p>Otherwise it is resolved against the static base URI from the static context of the expression containing the call to the <a href="#func-document"><code>document</code></a> function. In cases where the source code of the stylesheet is available at execution time, this will typically be the location of the relevant stylesheet module.</p></li></ol></li><li><p>For an item in <code>$uri-sequence</code> that is a node, the node is <a title="atomize" class="termref" href="#dt-atomization">atomized</a>. The result <span class="verb">must</span> be a sequence whose items are all instances of <code>xs:string</code>, <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>. Each of these values is cast to <code>xs:anyURI</code>, and if the resulting URI reference is an absolute URI reference then it is used <em>as is</em>. If it is a relative URI reference, then it is resolved against the base URI of <code>$base-node</code> if supplied, or against the base URI of the node that contained it otherwise.</p></li><li><p>A relative URI is resolved against a base URI using the rules of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-resolve-uri"><code>resolve-uri</code></a><sup><small>FO30</small></sup> function. A dynamic error occurs (see below) if no base URI is available.</p></li><li><p> If <code>$uri-sequence</code> (after atomizing any nodes) contains an item other than an atomic value of type <code>xs:string</code>, <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code> then a type error is raised <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPTY0004" title="XPTY0004"><span class="error">[ERR XPTY0004] </span></a><sup><small>XP40</small></sup>. </p></li></ul><p>Each of these absolute URI references is then processed as follows. Any fragment identifier that is present in the URI reference is removed, and the resulting absolute URI is cast to a string and then passed to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function defined in <a href="#xpath-functions-30">[Functions and Operators 3.0]</a>. This returns a document node. If an error occurs during evaluation of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> function, the processor <span class="verb">may</span> either signal this error in the normal way, or <span class="verb">may</span> recover by ignoring the failure, in which case the failing URI will not contribute any nodes to the result of the <a href="#func-document"><code>document</code></a> function.</p><p>If the URI reference contained no fragment identifier, then this document node is included in the sequence of nodes returned by the <a href="#func-document"><code>document</code></a> function.</p><p>If the URI reference contained a fragment identifier, then the fragment identifier is interpreted according to the rules for the media type of the resource representation identified by the URI, and is used to select zero or more nodes that are descendant-or-self nodes of the returned document node. As described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>, the media type is available as part of the evaluation context for a transformation.</p><p>The sequence of nodes returned by the function is in document order, with no duplicates. This order has no necessary relationship to the order in which URIs were supplied in the <code>$uri-sequence</code> argument.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1160"><span class="error">[ERR XTDE1160] </span></a>When a URI reference contains a fragment identifier, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the media type is not one that is recognized by the processor, or if the fragment identifier does not conform to the rules for fragment identifiers for that media type, or if the fragment identifier selects something other than a sequence of nodes (for example, if it selects a range of characters within a text node). </p><p>A processor <span class="verb">may</span> provide an option which, if selected, causes the processor instead of signaling this error, to ignore the fragment identifier and return the document node.</p><p>The set of media types recognized by a processor is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p><a id="err-XTDE1162"><span class="error">[ERR XTDE1162] </span></a>When a URI reference is a relative reference, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if no base URI is available to resolve the relative reference. This can arise for example when the URI is contained in a node that has no base URI (for example a parentless text node), or when the second argument to the function is a node that has no base URI, or when the base URI from the static context is undefined. </p></dd><dt class="label">Notes</dt><dd><p class="note">One effect of these rules is that in an interpreted environment where the source code of the stylesheet is available and its base URI is known, then unless XML entities or <code>xml:base</code> are used, the expression <code>document("")</code> refers to the document node of the containing stylesheet module (the definitive rules are in <a href="#RFC3986">[RFC3986]</a>). The XML resource containing the stylesheet module is then processed exactly as if it were any other XML document, for example there is no special recognition of <a href="#element-text"><code>xsl:text</code></a> elements, and no special treatment of comments and processing instructions.</p><p class="note">The XPath rules for function calling ensure that it is a type error if the supplied value of the second argument is anything other than a single node. If <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is enabled, then a sequence of nodes may be supplied, and the first node in the sequence will be used.</p></dd></dl></div><div class="div2"><h3><a id="key"></a>20.2 <a href="#key" style="text-decoration: none">Keys</a></h3><p>Keys provide a way to work with documents that contain an implicit cross-reference structure. They make it easier to locate the nodes within a document that have a given value for a given attribute or child element, and they provide a hint to the implementation that certain access paths in the document need to be efficient.</p><div class="div3"><h4><a id="xsl-key"></a>20.2.1 <a href="#xsl-key" style="text-decoration: none">The </a><a href="#element-key"><code>xsl:key</code></a><a href="#xsl-key" style="text-decoration: none"> Declaration</a></h4><p class="element-syntax"><a id="element-key"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:key<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;use? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var><br>&nbsp;&nbsp;collation? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:key&gt;</code></p><p>The <a href="#element-key"><code>xsl:key</code></a><a title="declaration" class="termref" href="#dt-declaration">declaration</a> is used to declare <a title="key" class="termref" href="#dt-key">keys</a>. The <code>name</code> attribute specifies the name of the key. The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>. The <code>match</code> attribute is a <a href="#doc-xslt40-patterns-Pattern40">Pattern</a>; an <a href="#element-key"><code>xsl:key</code></a> element applies to all nodes that match the pattern specified in the <code>match</code> attribute.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-key" title="key"></a>A <b>key</b> is defined as a set of <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same name.<span class="definition">]</span></p><p>The key name is scoped to the containing <a title="package" class="termref" href="#dt-package">package</a>, and is available for use in calls to the <a href="#func-key"><code>key</code></a> function within that package.</p><p>The value of the key may be specified either using the <code>use</code> attribute or by means of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p><a id="err-XTSE1205"><span class="error">[ERR XTSE1205] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>use</code> attribute and has non-empty content, or if it has empty content and no <code>use</code> attribute. </p><p>If the <code>use</code> attribute is present, its value is an <a title="expression" class="termref" href="#dt-expression">expression</a> specifying the values of the key. The expression will be evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on the node that matches the pattern. The result of evaluating the expression is <a title="atomize" class="termref" href="#dt-atomization">atomized</a>. </p><p>Similarly, if a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is present, it is used to determine the values of the key. The sequence constructor will be evaluated with the node that matches the pattern as the context node. The result of evaluating the sequence constructor is <a title="atomize" class="termref" href="#dt-atomization">atomized</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-key-specifier" title="key specifier"></a>The expression in the <code>use</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> within an <a href="#element-key"><code>xsl:key</code></a> declaration are referred to collectively as the <b>key specifier</b>. The key specifier determines the values that may be used to find a node using this <a title="key" class="termref" href="#dt-key">key</a>.<span class="definition">]</span></p><p>When evaluation of the <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> results in a sequence (after atomization) containing more than one atomic value, the effect depends on the value of the <code>composite</code> attribute:</p><ul><li><p>When the attribute is absent or has the value <code>no</code>, each atomic value in the sequence acts as an individual key. For example, if <code>match="book" use="author" composite="no"</code> is specified, then a <code>book</code> element may be located using the value of any <code>author</code> element.</p></li><li><p>When the attribute is present and has the value <code>yes</code>, the sequence of atomic values is treated as a composite key that must be matched in its entirety. For example, if <code>match="book" use="author" composite="yes"</code> is specified, then a <code>book</code> element may be located using the value of all its <code>author</code> elements, supplied in the correct order.</p></li></ul><p><span style="display: none;" class="delete_version">If there are several <a href="#element-key"><code>xsl:key</code></a> declarations in the same package with the same key name, then they must all have the same effective value for their <code>composite</code> attribute. The effective value is the actual value of the attribute if present, or <code>"no"</code> if the attribute is absent.</span><span style="display: none;" class="add_version">If there are several <a href="#element-key"><code>xsl:key</code></a> declarations in the same package with the same key name, then they must all have the same <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> for their <code>composite</code> attribute. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is the actual value of the attribute if present, or <code>"no"</code> if the attribute is absent.</span><span class="modify_version">If there are several <a href="#element-key"><code>xsl:key</code></a> declarations in the same package with the same key name, then they must all have the same <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>for their <code>composite</code> attribute. The <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>is the actual value of the attribute if present, or <code>"no"</code> if the attribute is absent.</span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no requirement that all the values of a key should have the same type.</p></div><p>The presence of an <a href="#element-key"><code>xsl:key</code></a> declaration makes it easy to find a node that matches the <code>match</code> pattern if the values of the <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> (when applied to that node) are known. It also provides a hint to the implementation that access to the nodes by means of these values needs to be efficient (many implementations are likely to construct an index or hash table to achieve this). </p><div class="note"><p class="prefix"><b>Note:</b></p><p>An <a href="#element-key"><code>xsl:key</code></a> declaration is not bound to a specific source document. The source document to which it applies is determined only when the <a href="#func-key"><code>key</code></a> function is used to locate nodes using the key. Keys can be used to locate nodes within any source document (including temporary trees), but each use of the <a href="#func-key"><code>key</code></a> function searches one document only.</p><p>Keys can only be used to search within a tree that is rooted at a document node.</p></div><p>The optional <code>collation</code> attribute is used only when deciding whether two strings are equal for the purposes of key matching. Specifically, two key values <code>$a</code> and <code>$b</code> are considered equal if the result of the function call <code>deep-equal($a, $b, $collation)</code> is true. The effective collation for an <a href="#element-key"><code>xsl:key</code></a> declaration is the collation specified in its <code>collation</code> attribute if present, resolved against the base URI of the <a href="#element-key"><code>xsl:key</code></a> element, or the <a title="default collation" class="termref" href="#dt-default-collation">default collation</a> that is in scope for the <a href="#element-key"><code>xsl:key</code></a> declaration otherwise; the effective collation must be the same for all the <a href="#element-key"><code>xsl:key</code></a> declarations making up a <a title="key" class="termref" href="#dt-key">key</a>.</p><p><a id="err-XTSE1210"><span class="error">[ERR XTSE1210] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>collation</code> attribute whose value (after resolving against the base URI) is not a URI recognized by the implementation as referring to a collation. </p><p><a id="err-XTSE1220"><span class="error">[ERR XTSE1220] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different effective collations. Two collations are the same if their URIs are equal under the rules for comparing <code>xs:anyURI</code> values, or if the implementation can determine that they are different URIs referring to the same collation. </p><p><span style="display: none;" class="delete_version"><a id="err-XTSE1222"><span class="error">[ERR XTSE1222] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different effective values for the <code>composite</code> attribute. </span><span style="display: none;" class="add_version"><a id="err-XTSE1222"><span class="error">[ERR XTSE1222] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for the <code>composite</code> attribute. </span><span class="modify_version"><a id="err-XTSE1222"><span class="error">[ERR XTSE1222] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective values</span></a> <span class="deltaxml-old" style="background:#FF5555">values </span>for the <code>composite</code> attribute. </span></p><p>It is possible to have:</p><ul><li><p>multiple <a href="#element-key"><code>xsl:key</code></a> declarations with the same name;</p></li><li><p>a node that matches the <code>match</code> patterns of several different <a href="#element-key"><code>xsl:key</code></a> declarations, whether these have the same key name or different key names;</p></li><li><p>a node that returns more than one value from its <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> (which can be treated either as separate individual key values, or as a single composite key value);</p></li><li><p>a key value that identifies more than one node (the key values for different nodes do not need to be unique).</p></li></ul><p>An <a href="#element-key"><code>xsl:key</code></a> declaration with higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> does not override another of lower import precedence; all the <a href="#element-key"><code>xsl:key</code></a> declarations in the stylesheet are effective regardless of their import precedence.</p></div><div class="div3"><h4><a id="func-key"></a>20.2.2 <a href="#func-key" style="text-decoration: none">fn:key</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the nodes that match a supplied key value.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><a id="function-key"></a><table style="border:0; border-spacing:0"><tbody><tr class="delete_version" style="display: none;"><td colspan="3"><code class="function">fn:key</code>(</td></tr><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:key</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td style="padding:0; vertical-align:top" rowspan="3"><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:key</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td><td><span style="display: none;" class="delete_version"><code>$key-name</code></span><span style="display: none;" class="add_version"><code class="arg">$key-name</code></span><span class="modify_version"><code class="arg">$key-name</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">union(xs:string, xs:QName)</code>,</span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">union(xs:string, xs:QName)</code>,</span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">union(xs:string, xs:QName)</code>,</span></td><td></td></tr><tr class="arg"><td><span style="display: none;" class="delete_version"><code>$key-value</code></span><span style="display: none;" class="add_version"><code class="arg">$key-value</code></span><span class="modify_version"><code class="arg">$key-value</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">xs:anyAtomicType*</code>,</span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:anyAtomicType*</code>,</span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">xs:anyAtomicType*</code>,</span></td><td></td></tr><tr class="delete_version" style="display: none;"><td><code>$top</code></td><td><code class="as">as&nbsp;</code><code class="type">node()</code></td><td><code class="assign">:=&nbsp;</code><code>/</code></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$top</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">node()</span></code></td><td><code class="assign"><span class="deltaxml-old" style="background:#FF5555">:=&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">/</span></code></td></tr><tr class="return-type"><td><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$top</span></code></td><td><span style="display: none;" class="delete_version" colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>node()*</code></span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">node()</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">node()*</code></span><span class="modify_version" colspan="3"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">node(</span>)</code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as">&nbsp;as&nbsp;</code><code class="return-type">node()*</code></span></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>The two-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>. </p><p>The three-argument form of this function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The <a href="#func-key"><code>key</code></a> function does for keys what the <a href="https://www.w3.org/TR/xpath-functions-30/#func-element-with-id"><code>element-with-id</code></a><sup><small>FO30</small></sup> function does for IDs.</p><p>The <code>$key-name</code> argument specifies the name of the <a title="key" class="termref" href="#dt-key">key</a>. The value of the argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or </span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then it is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> (no prefix means no namespace).</p><p>The <code>$key-value</code> argument to the <a href="#func-key"><code>key</code></a> function is considered as a sequence. The effect depends on the value of the <code>composite</code> attribute of the corresponding <code>xsl:key</code> declaration.</p><ul><li><p>If <code>composite</code> is <code>no</code> or absent, the set of requested key values is formed by atomizing the supplied value of the argument, using the standard <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. Each of the resulting atomic values is considered as a requested key value. The result of the function is a sequence of nodes, in document order and with duplicates removed, comprising those nodes in the selected subtree (see below) that are matched by an <a href="#element-key"><code>xsl:key</code></a> declaration whose name is the same as the supplied key name, where the result of evaluating the <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> contains a value that is equal to one of these requested key values, under the rules appropriate to the XPath <code>eq</code> operator for the two values in question, using the <code>collation</code> attributes of the <a href="#element-key"><code>xsl:key</code></a> declaration when comparing strings. No error is reported if two values are encountered that are not comparable; they are regarded for the purposes of this function as being not equal. </p><p>If the second argument is an empty sequence, the result of the function will be an empty sequence.</p></li><li><p>If <code>composite</code> is <code>yes</code>, the requested key value is the sequence formed by atomizing the supplied value of the argument, using the standard <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. The result of the function is a sequence of nodes, in document order and with duplicates removed, comprising those nodes in the selected subtree (see below) that are matched by an <a href="#element-key"><code>xsl:key</code></a> declaration whose name is the same as the supplied key name, where the result of evaluating the <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> is deep-equal to the requested key value, under the rules appropriate to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup> function applied to the two values in question, using the <code>collation</code> attributes of the <a href="#element-key"><code>xsl:key</code></a> declaration when comparing strings. Note that the <a href="https://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup> function reports no error if two values are encountered that are not comparable; they are regarded for the purposes of this function as being not equal.</p><p>If the second argument is an empty sequence, the result of the function will be the set of nodes having an empty sequence as the value of the key specifier.</p></li></ul><p>Different rules apply when <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 compatible behavior</a> is enabled.</p><p>A key (that is, a set of <a href="#element-key"><code>xsl:key</code></a> declarations sharing the same key name) is processed in backwards compatible mode if (a) at least one of the xsl:key elements in the definition of the key enables backwards compatible behavior, and (b) the effective value of the <code>composite</code> attribute is <code>no</code>.</p><p>When a key is processed in backwards compatible mode, then:</p><ul><li><p>The result of evaluating the key specifier in any <a href="#element-key"><code>xsl:key</code></a> declaration having this key name is converted after atomization to a sequence of strings, by applying a cast to each item in the sequence.</p></li><li><p>When the first argument to the <a href="#func-key"><code>key</code></a> function specifies this key name, then the value of the second argument is converted after atomization to a sequence of strings, by applying a cast to each item in the sequence. The values are then compared as strings.</p></li></ul><p>The third argument is used to identify the selected subtree. If the argument is present, the selected subtree is the set of nodes that have <var>$top</var> as an ancestor-or-self node. If the argument is omitted, the selected subtree is the document containing the context node. This means that the third argument effectively defaults to <code>/</code>.</p><p>The result of the <a href="#func-key"><code>key</code></a> function can be described more specifically as follows. The result is a sequence containing every node <var>$N</var> that satisfies the following conditions:</p><ul><li><p><code>$N/ancestor-or-self::node() intersect $top</code> is non-empty. (If the third argument is omitted, <code>$top</code> defaults to <code>/</code>)</p></li><li><p><var>$N</var> matches the pattern specified in the <code>match</code> attribute of an <a href="#element-key"><code>xsl:key</code></a> declaration whose <code>name</code> attribute matches the name specified in the <code>$key-name</code> argument.</p></li><li><p>When <code>composite="no"</code>, and the <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> of that <a href="#element-key"><code>xsl:key</code></a> declaration is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>$N</var>, the <a title="atomize" class="termref" href="#dt-atomization">atomized</a> value of the resulting sequence includes a value that compares equal to at least one item in the atomized value of the sequence supplied as <code>$key-value</code>, under the rules of the <code>eq</code> operator with the collation selected as described above.</p><p>When <code>composite="yes"</code>, and the <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> of that <a href="#element-key"><code>xsl:key</code></a> declaration is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>$N</var>, the <a title="atomize" class="termref" href="#dt-atomization">atomized</a> value of the resulting sequence compares equal to the atomized value of the sequence supplied as <code>$key-value</code>, under the rules of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-deep-equal"><code>deep-equal</code></a><sup><small>FO30</small></sup> function with the collation selected as described above.</p></li></ul><p>The sequence returned by the <a href="#func-key"><code>key</code></a> function will be in document order, with duplicates (that is, nodes having the same identity) removed. </p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1260"><span class="error">[ERR XTDE1260] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value is not a valid QName, or if there is no namespace declaration in scope for the prefix of the QName, or if the name obtained by expanding the QName is not the same as the expanded name of any <a href="#element-key"><code>xsl:key</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><p><a id="err-XTDE1270"><span class="error">[ERR XTDE1270] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-key"><code>key</code></a> function with two arguments if there is no <a title="context node" class="termref" href="#dt-context-node">context node</a>, or if the root of the tree containing the context node is not a document node; or to call the function with three arguments if the root of the tree containing the node supplied in the third argument is not a document node. </p></dd><dt class="label">Notes</dt><dd><p class="note">Untyped atomic values are converted to strings, not to the type of the other operand. This means, for example, that if the expression in the <code>use</code> attribute returns a date, supplying an untyped atomic value in the call to the <a href="#func-key"><code>key</code></a> function will return an empty sequence.</p></dd><dt class="label">Examples</dt><dd><div class="example"><div class="example"><div class="exampleHeader"><a id="d8e54326"></a><a id="d8e54442"></a>Example: Using a Key to Follow Cross-References</div><p>Given a declaration</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:key</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">idkey</span><span class="z">"</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">div</span><span class="z">"</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">id</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>an expression <code>key("idkey",@ref)</code> will return the same nodes as <code>id(@ref)</code>, assuming that the only ID attribute declared in the XML source document is:</p><div class="exampleInner"><pre class="spectrum"><span class="z">&lt;!</span><span class="dt">ATTLIST div id ID #IMPLIED</span><span class="z">&gt;</span><span class="txt"></span></pre></div><p>and that the <code>ref</code> attribute of the context node contains no whitespace.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e54343"></a><a id="d8e54459"></a>Example: Using a Key to Generate Hyperlinks</div><p>Suppose a document describing a function library uses a <code>prototype</code> element to define functions</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">prototype</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">sqrt</span><span class="z">"</span><span class="z"></span><span class="atn">return-type</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">arg</span><span class="z"></span><span class="atn">type</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">prototype</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>and a <code>function</code> element to refer to function names</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">function</span><span class="scx">&gt;</span><span class="txt">sqrt</span><span class="ez">&lt;/</span><span class="cl">function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Then the stylesheet could generate hyperlinks between the references and definitions as follows:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:key</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">func</span><span class="z">"</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">prototype</span><span class="z">"</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">function</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">b</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">a</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">#</span><span class="op">{</span><span class="function">generate-id</span><span class="parenthesis">(</span><span class="function">key</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">func</span><span class="op">'</span><span class="op">,</span><span class="context">.</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">a</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">b</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">prototype</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">a</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="function">generate-id</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">b</span><span class="scx">&gt;</span><span class="txt">Function: </span><span class="ez">&lt;/</span><span class="cl">b</span><span class="ec">&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="cl">a</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>When called with two arguments, the <a href="#func-key"><code>key</code></a> function always returns nodes that are in the same document as the context node. To retrieve a node from any other document, it is necessary either to change the context node, or to supply a third argument.</p><div class="example"><div class="exampleHeader"><a id="d8e54364"></a><a id="d8e54480"></a>Example: Using Keys to Reference other Documents</div><p>For example, suppose a document contains bibliographic references in the form <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a separate XML document <code>bib.xml</code> containing a bibliographic database with entries in the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">entry</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">XSLT</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">entry</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Then the stylesheet could use the following to transform the <code>bibref</code> elements:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:key</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">bib</span><span class="z">"</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">entry</span><span class="z">"</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">bibref</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">name</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="type">document</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">bib.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="step">/</span><span class="function">key</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">bib</span><span class="op">'</span><span class="op">,</span><span class="variable">$name</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>This relies on the ability in XPath 2.0 to have a function call on the right-hand side of the <code>/</code> operator in a path expression.</p></div><p>The following code would also work:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:key</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">bib</span><span class="z">"</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">entry</span><span class="z">"</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">bibref</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">key</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">bib</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="context">.</span><span class="op">,</span><span class="whitespace"></span><span class="type">document</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">bib.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e54388"></a><a id="d8e54504"></a>Example: Using a Composite Key</div><p>This example uses a composite key consisting of first name and last name to locate employees in an employee file.</p><p>The key can be defined like this:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:key</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">emp-name-key</span><span class="z">"</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">employee</span><span class="z">"</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="qname">name</span><span class="step">/</span><span class="qname">first</span><span class="op">,</span><span class="whitespace"></span><span class="qname">name</span><span class="step">/</span><span class="qname">last</span><span class="z">"</span><span class="z"></span><span class="atn">composite</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>A particular employee can then be located using the function call:</p><div class="exampleInner"><pre>key('emp-name-key', ('Tim', 'Berners-Lee'), doc('employees.xml'))</pre></div></div></div></dd></dl></div></div><div class="div2"><h3><a id="keys-and-streaming"></a>20.3 <a href="#keys-and-streaming" style="text-decoration: none">Keys and Streaming</a></h3><p>Keys are not applicable to streamed documents.</p><p>This is ensured by the rules for the streamability of the <a href="#func-key"><code>key</code></a> function (see <a href="#classifying-built-in-functions"><i>19.8.9 Classifying Calls to Built-In Functions</i></a>). These rules make the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of the third argument <a title="navigation" class="termref" href="#dt-navigation">navigation</a>, which has the consequence that when the <a href="#func-key"><code>key</code></a> function is applied to a streamed input document, the call is <a title="roaming" class="termref" href="#dt-roaming">roaming</a> and <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a>, which effectively makes the containing construct non-streamable.</p></div><div class="div2"><h3><a id="misc-func"></a>20.4 <a href="#misc-func" style="text-decoration: none">Miscellaneous Additional Functions</a></h3><div class="div3"><h4><a id="func-current"></a>20.4.1 <a href="#func-current" style="text-decoration: none">fn:current</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the item that is the context item for the evaluation of the containing XPath expression</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:current</span></code><span class="deltaxml-old" style="background:#FF5555">()</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-old" style="background:#FF5555">item()</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-current"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:current</span></code><span class="deltaxml-new" style="background:#90EE90">()</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">item()</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The <a href="#func-current"><code>current</code></a> function, used within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>, returns the item that was the <a title="context item" class="termref" href="#dt-context-item">context item</a> at the point where the expression was invoked from the XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This is referred to as the current item. For an outermost expression (an expression not occurring within another expression), the current item is always the same as the context item. Thus,</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>means the same as</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>However, within square brackets, or on the right-hand side of the <code>/</code> operator, the current item is generally different from the context item.</p><p>If the <a href="#func-current"><code>current</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, its value is the item that is being matched against the pattern.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1360"><span class="error">[ERR XTDE1360] </span></a>If the <a href="#func-current"><code>current</code></a> function is evaluated within an expression that is evaluated when the context item is absent, a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs. </p><p>When the <a href="#func-current"><code>current</code></a> is called by means of a dynamic function call (for example, <code>current#0()</code>), it is evaluated as if the context item is absent (<span class="error">[see <a href="#err-XTDE1360">ERR XTDE1360</a>]</span>).</p></dd><dt class="label">Examples</dt><dd><div class="example"><p>The instruction:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">//</span><span class="qname">glossary</span><span class="step">/</span><span class="qname">entry</span><span class="filter">[</span><span class="axis">@</span><span class="qname">name</span><span class="op">=</span><span class="function">current</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="step">/</span><span class="axis">@</span><span class="qname">ref</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>will process all <code>entry</code> elements that have a <code>glossary</code> parent element and that have a <code>name</code> attribute with value equal to the value of the current item's <code>ref</code> attribute. This is different from</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">//</span><span class="qname">glossary</span><span class="step">/</span><span class="qname">entry</span><span class="filter">[</span><span class="axis">@</span><span class="qname">name</span><span class="op">=</span><span class="context">.</span><span class="step">/</span><span class="axis">@</span><span class="qname">ref</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>which means the same as</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:apply-templates</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">//</span><span class="qname">glossary</span><span class="step">/</span><span class="qname">entry</span><span class="filter">[</span><span class="axis">@</span><span class="qname">name</span><span class="op">=</span><span class="axis">@</span><span class="qname">ref</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>and so would process all <code>entry</code> elements that have a <code>glossary</code> parent element and that have a <code>name</code> attribute and a <code>ref</code> attribute with the same value.</p></div></dd></dl></div><div class="div3"><h4><a id="func-unparsed-entity-uri"></a>20.4.2 <a href="#func-unparsed-entity-uri" style="text-decoration: none">fn:unparsed-entity-uri</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the URI (system identifier) of an unparsed entity</p></dd><dt class="label">Signature</dt><dd><div class="proto"><a id="function-unparsed-entity-uri"></a><table style="border:0; border-spacing:0"><tbody><tr class="delete_version" style="display: none;"><td colspan="3"><code class="function">fn:unparsed-entity-uri</code>(</td></tr><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:unparsed-entity-uri</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td style="padding:0; vertical-align:top" rowspan="2"><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:unparsed-entity-uri</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td><td><span style="display: none;" class="delete_version"><code>$entity-name</code></span><span style="display: none;" class="add_version"><code class="arg">$entity-name</code></span><span class="modify_version"><code class="arg">$entity-name</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">xs:string</code>,</span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:string</code>,</span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">xs:string</code>,</span></td><td></td></tr><tr class="arg"><td><span style="display: none;" class="delete_version"><code>$doc</code></span><span style="display: none;" class="add_version"><code class="arg">$doc</code></span><span class="modify_version"><code class="arg">$doc</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">node()</code></span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">node()</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:anyURI</code></span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">node()</code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:anyURI</span></code></span></td><td><code class="assign"><span class="deltaxml-old" style="background:#FF5555">:=&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">.</span></code></td></tr><tr class="delete_version" style="display: none;"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:anyURI</code></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:anyURI</span></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>Calling the single-argument form of this function has the same effect as calling the two-argument form with the context item as the second argument.</p><p>The two-argument <a href="#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a> function returns the URI of the unparsed entity whose name is given by the value of the <code>$entity-name</code> argument, in the document containing the node supplied as the value of the <code>$doc</code> argument. It returns the zero-length <code>xs:anyURI</code> if there is no such entity. This function maps to the <code>dm:unparsed-entity-system-id</code> accessor defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1370"><span class="error">[ERR XTDE1370] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node. </p><p>The following errors may be raised when <code>$node</code> is omitted:</p><ul><li><p>If the context item is absent, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.</p></li><li><p>If the context item is not a node, <a title="type error" class="termref" href="#dt-type-error">type error</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPTY0004" title="XPTY0004"><span class="error">[ERR XPTY0004] </span></a><sup><small>XP40</small></sup>.</p></li></ul></dd><dt class="label">Notes</dt><dd><p class="note">The XDM accessor <code>dm:unparsed-entity-system-id</code> is defined to return an absolute URI, obtained by resolving the system identifier as written against the base URI of the document. If no base URI is available for the document, the <a href="#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a> function <span class="verb">should</span> return the system identifier as written, without any attempt to make it absolute.</p><p class="note">XML permits more than one unparsed entity declaration with the same name to appear, and says that the first declaration is the one that should be used. This rule <span class="verb">should</span> be respected during construction of the data model; the data model instance should not contain more than one unparsed entity with the same name.</p></dd></dl></div><div class="div3"><h4><a id="func-unparsed-entity-public-id"></a>20.4.3 <a href="#func-unparsed-entity-public-id" style="text-decoration: none">fn:unparsed-entity-public-id</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the public identifier of an unparsed entity</p></dd><dt class="label">Signature</dt><dd><div class="proto"><a id="function-unparsed-entity-public-id"></a><table style="border:0; border-spacing:0"><tbody><tr class="name"><td><span style="display: none;" class="delete_version" colspan="3"><code class="function">fn:unparsed-entity-public-id</code>(</span><span style="padding:0; vertical-align:top" class="add_version" rowspan="2"><code class="function">fn:unparsed-entity-public-id</code>(</span><span class="modify_version" style="padding:0; vertical-align:top" rowspan="2"><code class="function">fn:unparsed-entity-public-id</code>(</span></td><td><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$entity-name</span></code></td><td><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code><span class="deltaxml-new" style="background:#90EE90">,</span></td></tr><tr class="delete_version" style="display: none;"><td><code>$entity-name</code></td><td><code class="as">as&nbsp;</code><code class="type">xs:string</code>,</td><td></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$entity-name</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">xs:string</span></code><span class="deltaxml-old" style="background:#FF5555">,</span></td><td></td></tr><tr class="arg"><td><span style="display: none;" class="delete_version"><code>$doc</code></span><span style="display: none;" class="add_version"><code class="arg">$doc</code></span><span class="modify_version"><code class="arg">$doc</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">node()</code></span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">node()</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:string</code></span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">node()</code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code></span></td><td><code class="assign"><span class="deltaxml-old" style="background:#FF5555">:=&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">.</span></code></td></tr><tr class="delete_version" style="display: none;"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:string</code></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:string</span></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-dependent">focus-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>Calling the single-argument form of this function has the same effect as calling the two-argument form with the context item as the second argument.</p><p>The two-argument <a href="#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a> function returns the public identifier of the unparsed entity whose name is given by the value of the <code>$entity-name</code> argument, in the document containing the node supplied as the value of the <code>$doc</code> argument. It returns the zero-length string if there is no such entity, or if the entity has no public identifier. This function maps to the <code>dm:unparsed-entity-public-id</code> accessor defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1380"><span class="error">[ERR XTDE1380] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node. </p><p>The following errors may be raised when <code>$node</code> is omitted:</p><ul><li><p>If the context item is absent, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.</p></li><li><p>If the context item is not a node, <a title="type error" class="termref" href="#dt-type-error">type error</a><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPTY0004" title="XPTY0004"><span class="error">[ERR XPTY0004] </span></a><sup><small>XP40</small></sup>.</p></li></ul></dd><dt class="label">Notes</dt><dd><p class="note">XML permits more than one unparsed entity declaration with the same name to appear, and says that the first declaration is the one that should be used. This rule <span class="verb">should</span> be respected during construction of the data model; the data model instance should not contain more than one unparsed entity with the same name.</p></dd></dl></div><div class="div3"><h4><a id="func-system-property"></a>20.4.4 <a href="#func-system-property" style="text-decoration: none">fn:system-property</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the value of a system property</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:system-property</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$name</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">union(xs:QName, xs:string)</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:string</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-system-property"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:system-property</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$name</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">union(xs:QName, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:string</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>. It depends on namespaces. </p></dd><dt class="label">Rules</dt><dd><p>The value of the <code>$name</code> argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or </span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix, then it is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in the static context of the <a title="expression" class="termref" href="#dt-expression">expression</a>. If there is no prefix, the name is taken as being in no namespace.</p><p>The <a href="#func-system-property"><code>system-property</code></a> function returns a string representing the value of the system property identified by the name. If there is no such system property, the zero-length string is returned.</p><p>Implementations <span class="verb">must</span> provide the following system properties, which are all in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>:</p><ul><li><p><code>xsl:version</code>, a number giving the version of XSLT implemented by the <a title="processor" class="termref" href="#dt-processor">processor</a>; for implementations conforming to the version of XSLT specified by this document, this is the string <code>"3.0"</code>. The value will always be a string in the lexical space of the decimal datatype defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>). This allows the value to be converted to a number for the purpose of magnitude comparisons.</p></li><li><p><code>xsl:vendor</code>, a string identifying the implementer of the <a title="processor" class="termref" href="#dt-processor">processor</a></p></li><li><p><code>xsl:vendor-url</code>, a string containing a URL identifying the implementer of the <a title="processor" class="termref" href="#dt-processor">processor</a>; typically this is the host page (home page) of the implementer's Web site.</p></li><li><p><code>xsl:product-name</code>, a string containing the name of the implementation, as defined by the implementer. This <span class="verb">should</span> normally remain constant from one release of the product to the next. It <span class="verb">should</span> also be constant across platforms in cases where the same source code is used to produce compatible products for multiple execution platforms.</p></li><li><p><code>xsl:product-version</code>, a string identifying the version of the implementation, as defined by the implementer. This <span class="verb">should</span> normally vary from one release of the product to the next, and at the discretion of the implementer it <span class="verb">may</span> also vary across different execution platforms.</p></li><li><p><code>xsl:is-schema-aware</code>, returns the string <code>"yes"</code> in the case of a processor that claims conformance as a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>, or <code>"no"</code> in the case of a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a>.</p></li><li><p><code>xsl:supports-serialization</code>, returns the string <code>"yes"</code> in the case of a processor that offers the <a title="serialization feature" class="termref" href="#dt-serialization-feature">serialization feature</a>, or <code>"no"</code> otherwise.</p></li><li><p><code>xsl:supports-backwards-compatibility</code>, returns the string <code>"yes"</code> in the case of a processor that offers the <a title="XSLT 1.0 compatibility feature" class="termref" href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>, or <code>"no"</code> otherwise.</p></li><li><p><code>xsl:supports-namespace-axis</code>, returns the string <code>"yes"</code> in the case of a processor that offers the XPath namespace axis even when not in backwards compatible mode, or <code>"no"</code> otherwise. Note that a processor that supports backwards compatible mode must support the namespace axis when in that mode, so this property is not relevant to that case.</p></li><li><p><code>xsl:supports-streaming</code>, returns the string <code>"yes"</code> in the case of a processor that offers the streaming feature (see <a href="#streaming-feature"><i>28.5 Streaming Feature</i></a>), or <code>"no"</code> otherwise.</p></li><li><p><code>xsl:supports-dynamic-evaluation</code>, returns the string <code>"yes"</code> in the case of a processor that offers the dynamic evaluation feature (see <a href="#dynamic-evaluation-feature"><i>28.6 Dynamic Evaluation Feature</i></a>), or <code>"no"</code> otherwise.</p></li><li><p><code>xsl:supports-higher-order-functions</code>, always returns the string <code>"yes"</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p>In XSLT 4.0, support for higher-order functions is no longer an optional feature.</div></li><li><p><code>xsl:xpath-version</code>, a number giving the version of XPath implemented by the <a title="processor" class="termref" href="#dt-processor">processor</a>. The value will always be a string in the lexical space of the decimal datatype defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>). This allows the value to be converted to a number for the purpose of magnitude comparisons. Typical values are <code>"3.0"</code> or <code>"3.1"</code>. The value <code>"3.0"</code> indicates that the processor implements XPath 3.0 plus the extensions defined in <a href="#map"><i>21 Maps</i></a> and <a href="#json"><i>23 Processing JSON Data</i></a>. </p></li><li><p><code>xsl:xsd-version</code>, a number giving the version of XSD (XML Schema) implemented by the <a title="processor" class="termref" href="#dt-processor">processor</a>. The value will always be a string in the lexical space of the decimal datatype defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>). This allows the value to be converted to a number for the purpose of magnitude comparisons. Typical values are <code>"1.0"</code> or <code>"1.1"</code>. This property is relevant even when the processor is not schema-aware, since the built-in datatypes for XSD 1.1 differ from those in XSD 1.0. </p></li></ul><p>Some of these properties relate to the conformance levels and features offered by the <a title="processor" class="termref" href="#dt-processor">processor</a>: these options are described in <a href="#conformance"><i>28 Conformance</i></a>.</p><p>The actual values returned for the above properties are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>The set of system properties that are supported, in addition to those listed above, is also <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Implementations <span class="verb">must not</span> define additional system properties in the XSLT namespace.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1390"><span class="error">[ERR XTDE1390] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value supplied as the <code>$property-name</code> argument is not a valid QName, or if there is no namespace declaration in scope for the prefix of the QName. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt class="label">Notes</dt><dd><p class="note">An implementation must not return the value <code> 3.0 </code> as the value of the <code>xsl:version</code> system property unless it is conformant to XSLT 3.0.</p><p class="note">It is recognized that vendors who are enhancing XSLT 1.0 or 2.0 processors may wish to release interim implementations before all the mandatory features of this specification are implemented. Since such products are not conformant to XSLT 3.0, this specification cannot define their behavior. However, implementers of such products are encouraged to return a value for the <code>xsl:version</code> system property that is intermediate between 1.0 and 3.0, and to provide the <a href="#func-element-available"><code>element-available</code></a> and <a href="#func-function-available"><code>function-available</code></a> functions to allow users to test which features have been fully implemented.</p></dd></dl></div><div class="div3"><h4><a id="func-available-system-properties"></a>20.4.5 <a href="#func-available-system-properties" style="text-decoration: none">fn:available-system-properties</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns a list of system property names that are suitable for passing to the <a href="#func-system-property"><code>system-property</code></a> function, as a sequence of QNames.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:available-system-properties</span></code><span class="deltaxml-old" style="background:#FF5555">()</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-old" style="background:#FF5555">xs:QName*</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-available-system-properties"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:available-system-properties</span></code><span class="deltaxml-new" style="background:#90EE90">()</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:QName*</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-independent">context-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>The function returns a sequence of QNames, being the names of the system properties recognized by the processor, in some <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</p><p>The prefix part of a returned QName is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><p>The function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>: that is, the set of available system properties does not vary during the course of a transformation.</p></dd><dt class="label">Notes</dt><dd><p class="note">The function returns a list of QNames, containing no duplicates.</p><p class="note">The QNames in this list are suitable for passing to the <a href="#func-system-property"><code>system-property</code></a> function.</p></dd></dl></div></div></div><div class="div1"><h2><a id="map"></a>21 <a href="#map" style="text-decoration: none">Maps</a></h2><p>Maps are defined in the XDM Data Model.</p><div class="div2"><h3><a id="map-instructions"></a>21.2 <a href="#map-instructions" style="text-decoration: none">Map Instructions</a></h3><p>Two instructions are added to XSLT to facilitate the construction of maps.</p><p class="element-syntax"><a id="element-map"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:map<br>&nbsp;&nbsp;on-duplicates? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map&gt;</code></p><p>The instruction <a href="#element-map"><code>xsl:map</code></a> constructs and returns a new map.</p><p>The contained sequence constructor <span class="verb">must</span> evaluate to a sequence of maps: call this <code>$maps</code>.</p><p><span>In the absense of duplicate keys,</span> the result of the instruction is then given by the XPath 3.1 expression:</p><div class="exampleInner"><pre>map:merge($maps)</pre></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Informally: <span>in the absence of duplicate keys</span> the resulting map contains the union of the map entries from the supplied sequence of maps.</p></div><p>The handling of duplicate keys is described in <a href="#duplicate-keys"><i>21.2.1 Handling of duplicate keys</i></a> below.</p><p>There is no requirement that the supplied input maps should have the same or compatible types. The type of a map (for example <code>map(xs:integer, xs:string)</code>) is descriptive of the entries it currently contains, but is not a constraint on how the map may be combined with other maps.</p><p><a id="err-XTTE3375"><span class="error">[ERR XTTE3375] </span></a>A type error occurs if the result of evaluating the sequence constructor is not an instance of the required type <code>map(*)*</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In practice, the effect of this rule is that the sequence constructor contained in the <a href="#element-map"><code>xsl:map</code></a> instruction is severely constrained: it doesn’t make sense, for example, for it to contain instructions such as <a href="#element-element"><code>xsl:element</code></a> that create new nodes. As with other type errors, processors are free to signal the error statically if they are able to determine that the sequence constructor would always fail when evaluated.</p></div><p class="element-syntax"><a id="element-map-entry"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:map-entry<br>&nbsp;&nbsp;<b>key</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map-entry&gt;</code></p><p>The instruction <a href="#element-map-entry"><code>xsl:map-entry</code></a> constructs and returns a singleton map: that is, a map which contains one key and one value. Such a map is primarily used as a building block when constructing maps using the <a href="#element-map"><code>xsl:map</code></a> instruction.</p><p>The <code>select</code> attribute and the contained sequence constructor are mutually exclusive: if a <code>select</code> attribute is present, then the content <span class="verb">must</span> be empty except optionally for <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p><p><a id="err-XTSE3280"><span class="error">[ERR XTSE3280] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-map-entry"><code>xsl:map-entry</code></a> element is present unless the element has no children other than <a href="#element-fallback"><code>xsl:fallback</code></a> elements. </p><p>The key of the entry in the new map is the value obtained by evaluating the expression in the <code>key</code> attribute, converted to the required type <code>xs:anyAtomicType</code> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If the supplied key (after conversion) is of type <code>xs:untypedAtomic</code>, it is cast to <code>xs:string</code>.</p><p>The associated value is the value obtained by evaluating the expression in the <code>select</code> attribute, or the contained sequence constructor, with no conversion. If there is no <code>select</code> attribute and the sequence constructor is empty, the associated value is the empty sequence.</p><div class="example"><div class="exampleHeader"><a id="d8e55386"></a><a id="d8e55502"></a>Example: Using XSLT instructions to create a fixed map</div><p>The following example binds a variable to a map whose content is statically known:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">week</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:string, xs:string)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Mo</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Monday</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Tu</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Tuesday</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">We</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Wednesday</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Th</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Thursday</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Fr</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Friday</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Sa</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Saturday</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Su</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">Sunday</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e55391"></a><a id="d8e55507"></a>Example: Using XSLT instructions to create a computed map</div><p>The following example binds a variable to a map acting as an index into a source document:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">index</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:string, element(employee))</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">//</span><span class="qname">employee</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">empNr</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:variable</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="div3"><h4><a id="duplicate-keys"></a>21.2.1 <a href="#duplicate-keys" style="text-decoration: none">Handling of duplicate keys</a></h4><p>This section describes what happens when two or more maps returned by the sequence constructor within an <a href="#element-map"><code>xsl:map</code></a> instruction contain duplicate keys: that is, when one of these maps contains an entry with key <var>K</var>, and another contains an entry with key <var>L</var>, and <code>fn:atomic-equal(K, L)</code> is true.</p><p><a id="err-XTDE3365"><span class="error">[ERR XTDE3365] </span></a>In the absence of the <code>on-duplicates</code> attribute, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs if the set of keys in the maps resulting from evaluating the sequence constructor contains duplicates.</p><p>The result of evaluating the <code>on-duplicates</code> attribute, if present, <span class="verb">must</span> be a function with arity 2. When the <a href="#element-map"><code>xsl:map</code></a> instruction encounters two map entries having the same key, the two values associated with this key are passed as arguments to this function, and the function returns the value that should be associated with this key in the final map.</p><p>The order of the arguments passed to the function reflects the order of the maps in which the duplicate entries appear: if map <var>M</var> and map <var>N</var> contain values <var>V<sub>M</sub></var> and <var>V<sub>N</sub></var> for the same key, and <var>M</var> precedes <var>N</var> in the sequence of maps returned by the sequence constructor, then the callback function is called with arguments <var>V<sub>M</sub></var> and <var>V<sub>N</sub></var> in that order. </p><p>If more than two maps contain values for the same key, then the callback function is invoked repeatedly. Let <var>F</var> be the callback function. Then if (for example) four maps supply the values <var>A</var>, <var>B</var>, <var>C</var>, and <var>D</var> for a given key <var>K</var>, in that order, the evaluation is as follows:</p><ol class="enumar"><li><p><code>F(A, B)</code> is called; let its return value be <var>X</var>.</p></li><li><p><code>F(X, C)</code> is called; let its return value be <var>Y</var>.</p></li><li><p><code>F(Y, D)</code> is called; let its return value be <var>Z</var>.</p></li><li><p>The value that is associated with key <var>K</var> in the final map will be <var>Z</var>.</p></li></ol><p>Thus, if the values are all singleton items (which is not necessarily the case), and if the sequence of values is <var>S</var>, then the final result is <code>fold-left(tail(S), head(S), F)</code>.</p><p>For example, the following table shows some useful callback functions that might be supplied, and explains their effect:</p><table style="border:1px solid; padding:5px; width:100%"><thead><tr><th style="text-align:left; vertical-align:top">Function</th><th style="text-align:left; vertical-align:top">Effect</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top"><code>function($a, $b){$a}</code></td><td style="text-align:left; vertical-align:top">The first of the duplicate values is used.</td></tr><tr><td style="text-align:left; vertical-align:top"><code>function($a, $b){$b}</code></td><td style="text-align:left; vertical-align:top">The last of the duplicate values is used.</td></tr><tr><td style="text-align:left; vertical-align:top"><code>function($a, $b){$a, $b}</code></td><td style="text-align:left; vertical-align:top">The sequence-concatenation of the duplicate values is used.</td></tr><tr><td style="text-align:left; vertical-align:top"><code>function($a, $b){max(($a, $b))}</code></td><td style="text-align:left; vertical-align:top">The highest of the duplicate values is used.</td></tr><tr><td style="text-align:left; vertical-align:top"><code>function($a, $b){min(($a, $b))}</code></td><td style="text-align:left; vertical-align:top">The lowest of the duplicate values is used.</td></tr><tr><td style="text-align:left; vertical-align:top"><code>function($a, $b){string-join(($a, $b), ', ')}</code></td><td style="text-align:left; vertical-align:top">The comma-separated string concatenation of the duplicate values is used.</td></tr><tr><td style="text-align:left; vertical-align:top"><code>function($a, $b){error()}</code></td><td style="text-align:left; vertical-align:top">Duplicates are rejected as an error (this is the default in the absence of a callback function).</td></tr></tbody></table><div class="example"><div class="exampleHeader"><a id="map-with-duplicates-into-array"></a>Example: Combining Duplicates into an Array</div><p>This example takes as input an XML document such as:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">data</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">A23</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">12</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">A24</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">5</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">A25</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">9</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">event</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">A23</span><span class="z">"</span><span class="z"></span><span class="atn">value</span><span class="atneq">=</span><span class="z">"</span><span class="av">2</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">data</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>and constructs a map whose JSON representation is:</p><div class="exampleInner"><pre>{"A23": [12, 2], "A24": [5], "A23": [9]}</pre></div><p>The logic is:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="qname">data</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map</span><span class="z"></span><span class="atn">on-duplicates</span><span class="atneq">=</span><span class="z">"</span><span class="av">function($a, $b)</span><span class="op">{</span><span class="function">array:join</span><span class="parenthesis">(</span><span class="parenthesis">(</span><span class="variable">$a</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$b</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">event</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="axis">@</span><span class="qname">id</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="filter">[</span><span class="function">xs:integer</span><span class="parenthesis">(</span><span class="axis">@</span><span class="qname">value</span><span class="parenthesis">)</span><span class="filter">]</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:map</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div2"><h3><a id="maps-streaming"></a>21.4 <a href="#maps-streaming" style="text-decoration: none">Maps and Streaming</a></h3><p>Maps have many uses, but their introduction to XSLT 3.0 was strongly motivated by streaming use cases. In essence, when a source document is processed in streaming mode, data that is encountered in the course of processing may need to be retained in variables for subsequent use, because the nodes cannot be revisited. This creates a need for a flexible data structure to accommodate such temporary data, and maps were designed to fulfil this need.</p><p>The entries in a map are not allowed to contain references to <a title="streamed node" class="termref" href="#dt-streamed-node">streamed nodes</a>. This is achieved by ensuring that for all constructs that supply content to be included in a map (for example the third argument of <a href="#func-map-put"><code>map:put</code></a>, and the <code>select</code> attribute of <a href="#element-map-entry"><code>xsl:map-entry</code></a>), the relevant operand is defined to have operand usage <a title="navigation" class="termref" href="#dt-navigation">navigation</a>. Because maps cannot contain references to streamed nodes, they are effectively <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, and can therefore be used freely in contexts (such as parameters to functions or templates) where only grounded operands are permitted.</p><p>The <a href="#element-map"><code>xsl:map</code></a> instruction, and the XPath <code>MapConstructor</code> construct, are exceptions to the general rule that during streaming, only one downward selection (one consuming subexpression) is permitted. They share this characteristic with <a href="#element-fork"><code>xsl:fork</code></a>. As with <a href="#element-fork"><code>xsl:fork</code></a>, a streaming processor is expected to be able to construct the map during a single pass of the streamed input document, which may require multiple expressions to be evaluated in parallel.</p><p>In the case of the <a href="#element-map"><code>xsl:map</code></a> instruction, this exemption applies only in the case where the instruction consists exclusively of <a href="#element-map-entry"><code>xsl:map-entry</code></a> (and <a href="#element-fallback"><code>xsl:fallback</code></a>) children, and not in more complex cases where the map entries are constructed dynamically (for example using a control flow implemented using <a href="#element-choose"><code>xsl:choose</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>, or <a href="#element-call-template"><code>xsl:call-template</code></a>). Such cases may, of course, be streamable if they only have a single consuming subexpression.</p><p>For example, the following XPath expression is streamable, despite making two downward selections:</p><div class="exampleInner"><pre>let $m := map{'price':xs:decimal(price), 'discount':xs:decimal(discount)} return ($m?price - $m?discount)</pre></div><p>Analysis:</p><ol class="enumar"><li><p>Because the <code>return</code> clause is motionless, the <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of the <code>let</code> expression is the sweep of the map expression (the expression in curly brackets).</p></li><li><p>The sweep of a map expression is the maximum sweep of its key/value pairs.</p></li><li><p>For both key/value pairs, the key is <a title="motionless" class="termref" href="#dt-motionless">motionless</a> and the value is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The expression carefully atomizes both values, because retaining references to streamed nodes in a map is not permitted.</p></li><li><p>Therefore the map expression, and hence the expression as a whole, is <a title="grounded" class="termref" href="#dt-grounded">grounded</a> and <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li></ol><p>See also: <a href="#streamability-of-map-constructors"><i>19.8.8.17 Streamability of Map Constructors</i></a>, <a href="#streamability-xsl-map"><i>19.8.4.23 Streamability of xsl:map</i></a>, <a href="#streamability-xsl-map-entry"><i>19.8.4.24 Streamability of xsl:map-entry</i></a></p></div><div class="div2"><h3><a id="map-examples"></a>21.5 <a href="#map-examples" style="text-decoration: none">Examples using Maps</a></h3><p>This section gives some examples of where maps can be useful.</p><div class="example"><div class="exampleHeader"><a id="maps-with-iterate"></a>Example: Using Maps with xsl:iterate</div><p>This example uses maps in conjunction with the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction to find the highest-earning employee in each department, in a single streaming pass of an input document containing employee records.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:source-document</span><span class="z"></span><span class="atn">streamable</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">employees.xml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:iterate</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">*</span><span class="step">/</span><span class="qname">employee</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">highest-earners</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:string, element(employee))</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:on-completion</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">map:keys</span><span class="parenthesis">(</span><span class="variable">$highest-earners</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">department</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="op">{</span><span class="context">.</span><span class="op">}</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">$highest-earners</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">department</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:on-completion</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">this</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">copy-of</span><span class="parenthesis">(</span><span class="context">.</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">element(employee)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:next-iteration</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">highest-earners</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="higher">let</span><span class="whitespace"></span><span class="variable">$existing</span><span class="whitespace"></span><span class="op">:=</span><span class="whitespace"></span><span class="function">$highest-earners</span><span class="parenthesis">(</span><span class="variable">$this</span><span class="step">/</span><span class="qname">department</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">return</span><span class="whitespace"></span><span class="if">if</span><span class="whitespace"></span><span class="parenthesis">(</span><span class="variable">$existing</span><span class="step">/</span><span class="qname">salary</span><span class="whitespace"></span><span class="op">gt</span><span class="whitespace"></span><span class="variable">$this</span><span class="step">/</span><span class="qname">salary</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">then</span><span class="whitespace"></span><span class="variable">$highest-earners</span><span class="whitespace"></span><span class="op">else</span><span class="whitespace"></span><span class="function">map:put</span><span class="parenthesis">(</span><span class="variable">$highest-earners</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$this</span><span class="step">/</span><span class="qname">department</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$this</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:next-iteration</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:iterate</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:source-document</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="example-complex-numbers"></a>Example: Using Maps to Implement Complex Numbers</div><p>A complex number might be represented as a map with two entries, the keys being the <code>xs:boolean</code> value <code>true</code> for the real part, and the <code>xs:boolean</code> value <code>false</code> for the imaginary part. A library for manipulation of complex numbers might include functions such as the following:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">REAL</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:int</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">IMAG</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:int</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">i:complex</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:int, xs:double)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">real</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">imaginary</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="whitespace"></span><span class="variable">$REAL</span><span class="whitespace"></span><span class="op">:</span><span class="whitespace"></span><span class="variable">$real</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$IMAG</span><span class="whitespace"></span><span class="op">:</span><span class="whitespace"></span><span class="variable">$imaginary</span><span class="whitespace"></span><span class="op">}</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">i:real</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">complex</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:int, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">$complex</span><span class="parenthesis">(</span><span class="variable">$REAL</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">i:imaginary</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:double</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">complex</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:int, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">$complex</span><span class="parenthesis">(</span><span class="variable">$IMAG</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">i:add</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:int, xs:double)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg1</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:int, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg2</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:int, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">i:complex</span><span class="parenthesis">(</span><span class="function">i:real</span><span class="parenthesis">(</span><span class="variable">$arg1</span><span class="parenthesis">)</span><span class="quantifier">+</span><span class="function">i:real</span><span class="parenthesis">(</span><span class="variable">$arg2</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="function">i:imaginary</span><span class="parenthesis">(</span><span class="variable">$arg1</span><span class="parenthesis">)</span><span class="quantifier">+</span><span class="function">i:imaginary</span><span class="parenthesis">(</span><span class="variable">$arg2</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">i:multiply</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:boolean, xs:double)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg1</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:boolean, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">arg2</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:boolean, xs:double)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">i:complex</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="function">i:real</span><span class="parenthesis">(</span><span class="variable">$arg1</span><span class="parenthesis">)</span><span class="function">*i:real</span><span class="parenthesis">(</span><span class="variable">$arg2</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">-</span><span class="whitespace"></span><span class="function">i:imaginary</span><span class="parenthesis">(</span><span class="variable">$arg1</span><span class="parenthesis">)</span><span class="function">*i:imaginary</span><span class="parenthesis">(</span><span class="variable">$arg2</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="function">i:real</span><span class="parenthesis">(</span><span class="variable">$arg1</span><span class="parenthesis">)</span><span class="function">*i:imaginary</span><span class="parenthesis">(</span><span class="variable">$arg2</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">+</span><span class="whitespace"></span><span class="function">i:imaginary</span><span class="parenthesis">(</span><span class="variable">$arg1</span><span class="parenthesis">)</span><span class="function">*i:real</span><span class="parenthesis">(</span><span class="variable">$arg2</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="map-as-index"></a>Example: Using a Map as an Index</div><p>Given a set of <code>book</code> elements, it is possible to construct an index in the form of a map allowing the books to be retrieved by ISBN number.</p><p>Assume the book elements have the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">book</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">isbn</span><span class="scx">&gt;</span><span class="txt">0470192747</span><span class="ez">&lt;/</span><span class="cl">isbn</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">author</span><span class="scx">&gt;</span><span class="txt">Michael H. Kay</span><span class="ez">&lt;/</span><span class="cl">author</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">publisher</span><span class="scx">&gt;</span><span class="txt">Wiley</span><span class="ez">&lt;/</span><span class="cl">publisher</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">XSLT 2.0 and XPath 2.0 Programmer's Reference</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">book</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>An index may be constructed as follows: </p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">isbn-index</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:string, element(book))</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">map:merge</span><span class="parenthesis">(</span><span class="higher">for</span><span class="whitespace"></span><span class="variable">$b</span><span class="whitespace"></span><span class="op">in</span><span class="whitespace"></span><span class="step">//</span><span class="qname">book</span><span class="whitespace"></span><span class="op">return</span><span class="whitespace"></span><span class="qname">map</span><span class="op">{</span><span class="variable">$b</span><span class="step">/</span><span class="qname">isbn</span><span class="whitespace"></span><span class="op">:</span><span class="whitespace"></span><span class="variable">$b</span><span class="op">}</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>This index may then be used to retrieve the book for a given ISBN using either of the expressions <code>map:get($isbn-index, "0470192747")</code> or <code>$isbn-index("0470192747")</code>.</p><p>In this simple form, this replicates the functionality available using <a href="#element-key"><code>xsl:key</code></a> and the <a href="#func-key"><code>key</code></a> function. However, it also provides capabilities not directly available using the <a href="#func-key"><code>key</code></a> function: for example, the index can include <code>book</code> elements in multiple source documents. It also allows processing of all the books using a construct such as <code>&lt;xsl:for-each select="map:keys($isbn-index)"&gt;</code></p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="map-as-class"></a>Example: A Map containing Named Functions</div><p>As in JavaScript, a map whose keys are strings and whose associated values are function items can be used in a similar way to a class in object-oriented programming languages.</p><p>Suppose an application needs to handle customer order information that may arrive in three different formats, with different hierarchic arrangements:</p><ol class="enumar"><li><p>Flat structure:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">customer</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">c123</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">customer</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">product</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">p789</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">product</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">order</span><span class="z"></span><span class="atn">customer</span><span class="atneq">=</span><span class="z">"</span><span class="av">c123</span><span class="z">"</span><span class="z"></span><span class="atn">product</span><span class="atneq">=</span><span class="z">"</span><span class="av">p789</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">order</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></li><li><p>Orders within customer elements:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">customer</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">c123</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">order</span><span class="z"></span><span class="atn">product</span><span class="atneq">=</span><span class="z">"</span><span class="av">p789</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">order</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">customer</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">product</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">p789</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">product</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></li><li><p>Orders within product elements:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">customer</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">c123</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">customer</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">product</span><span class="z"></span><span class="atn">id</span><span class="atneq">=</span><span class="z">"</span><span class="av">p789</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">order</span><span class="z"></span><span class="atn">customer</span><span class="atneq">=</span><span class="z">"</span><span class="av">c123</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">...</span><span class="ez">&lt;/</span><span class="cl">order</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">product</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></li></ol><p>An application can isolate itself from these differences by defining a set of functions to navigate the relationships between customers, orders, and products: <code>orders-for-customer</code>, <code>orders-for-product</code>, <code>customer-for-order</code>, <code>product-for-order</code>. These functions can be implemented in different ways for the three different input formats. For example, with the first format the implementation might be:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">flat-input-functions</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">map(xs:string, function(*))*</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">map</span><span class="op">{</span><span class="whitespace"></span><span class="op">'</span><span class="property">orders-for-customer</span><span class="op">'</span><span class="whitespace"></span><span class="op">:</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$c</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">customer</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">order</span><span class="parenthesis">)</span><span class="quantifier">*</span><span class="whitespace"></span><span class="op">{</span><span class="variable">$c</span><span class="step">/</span><span class="context">..</span><span class="step">/</span><span class="qname">order</span><span class="filter">[</span><span class="axis">@</span><span class="qname">customer</span><span class="op">=</span><span class="variable">$c</span><span class="step">/</span><span class="axis">@</span><span class="qname">id</span><span class="filter">]</span><span class="op">}</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="property">orders-for-product</span><span class="op">'</span><span class="whitespace"></span><span class="op">:</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$p</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">product</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">order</span><span class="parenthesis">)</span><span class="quantifier">*</span><span class="whitespace"></span><span class="op">{</span><span class="variable">$p</span><span class="step">/</span><span class="context">..</span><span class="step">/</span><span class="qname">order</span><span class="filter">[</span><span class="axis">@</span><span class="qname">product</span><span class="op">=</span><span class="variable">$p</span><span class="step">/</span><span class="axis">@</span><span class="qname">id</span><span class="filter">]</span><span class="op">}</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="property">customer-for-order</span><span class="op">'</span><span class="whitespace"></span><span class="op">:</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$o</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">order</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">customer</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">{</span><span class="variable">$o</span><span class="step">/</span><span class="context">..</span><span class="step">/</span><span class="qname">customer</span><span class="filter">[</span><span class="axis">@</span><span class="qname">id</span><span class="op">=</span><span class="variable">$o</span><span class="step">/</span><span class="axis">@</span><span class="qname">customer</span><span class="filter">]</span><span class="op">}</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="property">product-for-order</span><span class="op">'</span><span class="whitespace"></span><span class="op">:</span><span class="whitespace"></span><span class="type">function</span><span class="parenthesis">(</span><span class="variable">$o</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">order</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">as</span><span class="whitespace"></span><span class="node-type">element</span><span class="parenthesis">(</span><span class="qname">product</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">{</span><span class="variable">$o</span><span class="step">/</span><span class="context">..</span><span class="step">/</span><span class="qname">product</span><span class="filter">[</span><span class="axis">@</span><span class="qname">id</span><span class="op">=</span><span class="variable">$o</span><span class="step">/</span><span class="axis">@</span><span class="qname">product</span><span class="filter">]</span><span class="op">}</span><span class="whitespace"></span><span class="op">}</span><span class="whitespace"></span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>Having established which input format is in use, the application can bind the appropriate implementation of these functions to a variable such as <code>$input-navigator</code>, and can then process the input using XPath expressions such as the following, which selects all products for which there is no order: <code>//product[empty($input-navigator("orders-for-product")(.))]</code></p></div></div></div><div class="div1"><h2><a id="arrays"></a>22 <a href="#arrays" style="text-decoration: none">Arrays</a></h2><p>Arrays are defined in the XDM Data Model.</p><div class="div2"><h3><a id="array-construction"></a>22.1 <a href="#array-construction" style="text-decoration: none">Array Construction</a></h3><p>The instruction <a href="#element-array"><code>xsl:array</code></a> constructs and returns a new array.</p><p class="element-syntax"><a id="element-array"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:array<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;use? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:array&gt;</code></p><p>If the <code>use</code> attribute is omitted, the resulting array has one singleton member for each item returned by the <code>select</code> attribute or sequence constructor. For example <code>&lt;xsl:array select="1 to 5"/&gt;</code> returns an array with five members: <code>[1, 2, 3, 4, 5]</code>.</p><p>If the <code>use</code> attribute is present then it is evaluated once for each item in the sequence returned by the <code>select</code> attribute or sequence constructor, with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on that item, to produce the value of the corresponding array member.</p><p>For example, <code>&lt;xsl:array select="'red', 'green', 'blue'" use="characters(.)"/&gt;</code> returns an array with three members: <code>[("r", "e", "d"), ("g", "r", "e", "e", "n"), ("b", "l", "u", "e")] </code>.</p><p>A useful convention is to construct each array member as a <b>value record</b> (a singleton map whose single entry has the key <code>"value"</code>): <code>&lt;xsl:array select="map:entry('value', 1 to 3), map:entry('value': 8 to 10)" use="?value"/&gt;</code> returns an array with two members: <code>[(1,2,3), (8,9,10)]</code>. This is essentially equivalent to the effect of the <a href="#func-array-of"><code>array:of</code></a> function.</p><p>The <code>select</code> attribute and the contained sequence constructor are mutually exclusive: if the <code>select</code> attribute is present, then the only permitted child element is <a href="#element-fallback"><code>xsl:fallback</code></a>.</p><div class="example"><div class="exampleHeader"><a id="d8e55867"></a><a id="d8e55983"></a>Example: Constructing an array whose members are single items</div><p>The following example constructs an array by tokenizing a string:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">tokenize</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">The cat sat on the mat</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>The result is the array <code>["The", "cat", "sat", "on", "the", "mat"]</code>.</p><p>The following example constructs an array containing items computed using nested instructions:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">19</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="whitespace"></span><span class="op">idiv</span><span class="whitespace"></span><span class="numeric">4</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string-join</span><span class="parenthesis">(</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">-</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:array</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The result is the array <code>["0-1-2-3", "4-5-6-7", "8-9-10-11", "12-13-14-15", "16-17-18-19"]</code>.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e55883"></a><a id="d8e55999"></a>Example: Constructing an array whose members are arbitrary sequences</div><p>The following example constructs an array whose members are sequences:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="qname">value</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">19</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="whitespace"></span><span class="op">idiv</span><span class="whitespace"></span><span class="numeric">4</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:map-entry</span><span class="z"></span><span class="atn">key</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">value</span><span class="op">'</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:array</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The result is the array <code>[(0,1,2,3), (4,5,6,7), (8,9,10,11), (12,13,14,15), (16,17,18,19)]</code>.</p><p>The technique used here is to capture each member sequence in a singleton map (known as a <b>value record</b>) with the conventional key <code>"value"</code>.</p><p>The following example delivers the same result in a different way:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">19</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="whitespace"></span><span class="op">idiv</span><span class="whitespace"></span><span class="numeric">4</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="qname">current-group#0</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:array</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>In this approach, the member sequence is captured in the value of the zero-arity function <code>current-group#0</code>, which is then applied using the expression <code>.()</code> to yield the actual value. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>TODO: this example only works if we fix issue #407. Without that fix, calling <code>current-group#0</code> raises XTDE1061.</p></div><p>A third approach would be to capture the member sequences as arrays:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="op">*</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">0</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">19</span><span class="z">"</span><span class="z"></span><span class="atn">group-adjacent</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="whitespace"></span><span class="op">idiv</span><span class="whitespace"></span><span class="numeric">4</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:array</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e55916"></a><a id="d8e56032"></a>Example: Constructing an array based on an existing array</div><p>The <a href="#element-array"><code>xsl:array</code></a> instruction can be used in conjunction with the <a href="https://www.w3.org/TR/xpath-functions-30/#func-array-members"><code>array:members</code></a><sup><small>FO30</small></sup> function to construct an array from the members of an existing array. For example, the following code combines two arrays and sorts the result:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="z"></span><span class="atn">use</span><span class="atneq">=</span><span class="z">"</span><span class="op">?</span><span class="qname">value</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:perform-sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">array:members</span><span class="parenthesis">(</span><span class="variable">$input-1</span><span class="parenthesis">)</span><span class="op">,</span><span class="whitespace"></span><span class="function">array:members</span><span class="parenthesis">(</span><span class="variable">$input-2</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sort</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">count</span><span class="parenthesis">(</span><span class="op">?</span><span class="qname">value</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:perform-sort</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:array</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>The following code inverts a nested array (such as <code>[[1,2,3], [4,5,6], [7,8,9]]</code>) so the result is organized by columns rather than rows (<code>[[1,4,7], [2,5,8], [3,6,9]]</code>):</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="function">array:size</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="op">?</span><span class="numeric">1</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">index</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:array</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">array:members</span><span class="parenthesis">(</span><span class="variable">$input</span><span class="parenthesis">)</span><span class="quantifier">?</span><span class="qname">value</span><span class="op">?</span><span class="parenthesis">(</span><span class="variable">$index</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:array</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div></div><div class="div1"><h2><a id="json"></a>23 <a href="#json" style="text-decoration: none">Processing JSON Data</a></h2><p>JSON is a popular format for exchange of structured data on the web: it is specified in <a href="#rfc7159">[RFC 7159]</a>. This section describes facilities allowing JSON data to be processed using XSLT.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>RFC7159 is taken as the definitive specification of JSON for the purposes of this document. The RFC explains its relationship with other JSON specifications such as <a href="#ECMA-404">[ECMA-404]</a>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>XPath 3.1 incorporates the functions defined in this section. It also provides additional JSON capability, in the form of functions <code>parse-json</code>, <code>json-doc</code>, and extensions to the <a href="https://www.w3.org/TR/xpath-functions-30/#func-serialize"><code>serialize</code></a><sup><small>FO30</small></sup> function. These facilities are incorporated in XSLT 3.0 only if the XPath 3.1 feature is supported. They depend on support for arrays.</p></div><div class="div2"><h3><a id="xml-to-json-transformation"></a>23.3 <a href="#xml-to-json-transformation" style="text-decoration: none">Transforming XML to JSON</a></h3><p>Given an XML structure that does not use the XML representation of JSON defined in <a href="#json-to-xml-mapping"><i>23.1 XML Representation of JSON</i></a>, there are two practical ways to convert it to JSON: either perform a transformation to the XML representation of JSON and then call the <a href="#func-xml-to-json"><code>xml-to-json</code></a> function; or transform it to JSON directly by using custom template rules.</p><p>To assist with the second approach, a stylesheet is provided in <a href="#xml-to-json-stylesheet"><i>B.2 Stylesheet for converting XML to JSON</i></a>. This stylesheet includes a function <code>j:xml-to-json</code> which, apart from being in a different namespace, is functionally very similar to the <a href="#func-xml-to-json"><code>xml-to-json</code></a> function described in the previous section. (It differs in doing less validation of the input than the function specification requires, and in the details of how special characters are escaped.) The implementation of the function is exposed, using template rules to perform a recursive descent of the supplied input, and the behavior of the function can therefore be customized (typically by importing the stylesheet and adding additional template rules) to handle arbitrary XML input.</p><p>The stylesheet is provided under the W3C software license for the convenience of users. There is no requirement for any conformant XSLT processor to make this stylesheet available. Processors <span class="verb">may</span> implement the <a href="#func-xml-to-json"><code>xml-to-json</code></a> function by invoking this stylesheet (adapted to achieve full conformance), but there is no requirement to do so.</p></div></div><div class="div1"><h2><a id="diagnostics"></a>24 <a href="#diagnostics" style="text-decoration: none">Diagnostics</a></h2><div class="div2"><h3><a id="message"></a>24.1 <a href="#message" style="text-decoration: none">Messages</a></h3><p class="element-syntax"><a id="element-message"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:message<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;terminate? = { <var>boolean</var> }<br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:message&gt;</code></p><p>The <a href="#element-message"><code>xsl:message</code></a> instruction sends a message in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. The <a href="#element-message"><code>xsl:message</code></a> instruction causes the creation of a new document, which is typically serialized and output to an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> destination. The result of the <a href="#element-message"><code>xsl:message</code></a> instruction is an empty sequence.</p><p>The content of the message may be specified by using either or both of the optional <code>select</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the <a href="#element-message"><code>xsl:message</code></a> instruction.</p><p>If the <a href="#element-message"><code>xsl:message</code></a> instruction contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the sequence obtained by evaluating this sequence constructor is used to construct the content of the new document node, as described in <a href="#constructing-complex-content"><i>5.8.1 Constructing Complex Content</i></a>.</p><p>If the <a href="#element-message"><code>xsl:message</code></a> instruction has a <code>select</code> attribute, then the value of the attribute <span class="verb">must</span> be an XPath expression. The effect of the <a href="#element-message"><code>xsl:message</code></a> instruction is then the same as if a single <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with this <code>select</code> attribute were added to the start of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p><p>If the <a href="#element-message"><code>xsl:message</code></a> instruction has no content and no <code>select</code> attribute, then an empty message is produced.</p><p>The tree produced by the <a href="#element-message"><code>xsl:message</code></a> instruction is not technically a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. The tree has no URI and processors are not <span class="verb">required</span> to make the tree accessible to applications.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>In many cases, the XML document produced using <a href="#element-message"><code>xsl:message</code></a> will consist of a document node owning a single text node. However, it may contain a more complex structure.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>An implementation might implement <a href="#element-message"><code>xsl:message</code></a> by popping up an alert box or by writing to a log file. Because the order of execution of instructions is implementation-defined, the order in which such messages appear is not predictable.</p></div><p>The <code>terminate</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>.</p><p>If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>terminate</code> attribute is <code>yes</code>, then the <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">must</span> signal a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> after sending the message. This error may be caught in the same way as any other dynamic error using <a href="#element-catch"><code>xsl:catch</code></a>. The default value is <code>no</code>. Note that because the order of evaluation of instructions is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, this gives no guarantee that any particular instruction will or will not be evaluated before processing terminates.</p><p><span style="display: none;" class="delete_version">The optional <code>error-code</code> attribute (also interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>) may be used to indicate the error code associated with the message. This may be used irrespective of the value of <code>terminate</code>. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the error code attribute is expected to be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If no error code is specified, or if the effective value is not a valid EQName, the error code will have local part <code>XTMM9000</code> and namespace URI <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes <span class="verb">should</span> be in a namespace other than <code>http://www.w3.org/2005/xqt-errors</code>. When the value of <code>terminate</code> is <code>yes</code>, the error code may be matched in an <a href="#element-catch"><code>xsl:catch</code></a> element to catch the error and cause processing to continue normally.</span><span style="display: none;" class="add_version">The optional <code>error-code</code> attribute (also interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>) may be used to indicate the error code associated with the message. This may be used irrespective of the value of <code>terminate</code>. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the error code attribute is expected to be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If no error code is specified, or if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is not a valid EQName, the error code will have local part <code>XTMM9000</code> and namespace URI <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes <span class="verb">should</span> be in a namespace other than <code>http://www.w3.org/2005/xqt-errors</code>. When the value of <code>terminate</code> is <code>yes</code>, the error code may be matched in an <a href="#element-catch"><code>xsl:catch</code></a> element to catch the error and cause processing to continue normally.</span><span class="modify_version">The optional <code>error-code</code> attribute (also interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>) may be used to indicate the error code associated with the message. This may be used irrespective of the value of <code>terminate</code>. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the error code attribute is expected to be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If no error code is specified, or if the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>is not a valid EQName, the error code will have local part <code>XTMM9000</code> and namespace URI <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes <span class="verb">should</span> be in a namespace other than <code>http://www.w3.org/2005/xqt-errors</code>. When the value of <code>terminate</code> is <code>yes</code>, the error code may be matched in an <a href="#element-catch"><code>xsl:catch</code></a> element to catch the error and cause processing to continue normally.</span></p><p><a id="err-XTMM9000"><span class="error">[ERR XTMM9000] </span></a>When a transformation is terminated by use of <code>&lt;xsl:message terminate="yes"/&gt;</code>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-message"><code>xsl:message</code></a> instruction. </p><div class="example"><div class="exampleHeader"><a id="d8e56400"></a><a id="d8e56516"></a>Example: Localizing Messages</div><p>One convenient way to do localization is to put the localized information (message text, etc.) in an XML document, which becomes an additional input file to the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example, suppose messages for a language <code><var>L</var></code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">messages</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">message</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">problem</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">A problem was detected.</span><span class="ez">&lt;/</span><span class="cl">message</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">message</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">error</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">An error was detected.</span><span class="ez">&lt;/</span><span class="cl">message</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">messages</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Then a stylesheet could use the following approach to localize messages:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">lang</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="op">'</span><span class="literal">en</span><span class="op">'</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:variable</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="vname">messages</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="type">document</span><span class="parenthesis">(</span><span class="function">concat</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">resources/</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="variable">$lang</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">.xml</span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="step">/</span><span class="qname">messages</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">localized-message</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">name</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:message</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string</span><span class="parenthesis">(</span><span class="variable">$messages</span><span class="step">/</span><span class="qname">message</span><span class="filter">[</span><span class="axis">@</span><span class="qname">name</span><span class="op">=</span><span class="variable">$name</span><span class="filter">]</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tname">problem</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:call-template</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="tcall">localized-message</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:with-param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">name</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">problem</span><span class="ez">&lt;/</span><span class="clxsl">xsl:with-param</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:call-template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>Any <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> that occurs while evaluating the <code>select</code> expression or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and any <a title="serialization error" class="termref" href="#dt-serialization-error">serialization error</a> that occurs while processing the result, does not cause the transformation to fail; at worst, it means that no message is output, or that the only message that is output is one that relates to the error that occurred.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>An example of such an error is the serialization error that occurs when processing the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds that free-standing attributes cannot be serialized). Making such errors recoverable means that it is implementation-defined whether or not they are signaled to the user and whether they cause termination of the transformation. If the processor chooses to recover from the error, the content of any resulting message is implementation-dependent.</p><p>One possible recovery action is to include a description of the error in the generated message text.</p></div></div><div class="div2"><h3><a id="assertions"></a>24.2 <a href="#assertions" style="text-decoration: none">Assertions</a></h3><p>The <a href="#element-assert"><code>xsl:assert</code></a> instruction is used to assert that the value of a particular expression is true; if the value of the expression is false, and assertions are enabled, then a dynamic error occurs.</p><p class="element-syntax"><a id="element-assert"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:assert<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:assert&gt;</code></p><p>By default, assertions are disabled.</p><p>An implementation <span class="verb">must</span> provide an external mechanism to enable or disable assertion checking. This may work either statically or dynamically, and may be at the level of the stylesheet as a whole, or at the level of an individual package, or otherwise. The detail of such mechanisms is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>If assertion checking is enabled, the instruction is evaluated as follows:</p><ol class="enumar"><li><p>The expression in the <code>test</code> attribute is evaluated. If the effective boolean value of the result is <code>true</code>, the assertion succeeds, and no further action is taken. If the effective boolean value is false, or if a dynamic error occurs during evaluation of the expression, then the assertion fails.</p></li><li><p>If the assertion fails, then the effect of the instruction is governed by the rules for evaluation of an <a href="#element-message"><code>xsl:message</code></a> instruction with the same <code>select</code> attribute, <code>error-code</code> attribute, and contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and with the value <code>terminate="yes"</code>. However, the default error code if the <code>error-code</code> attribute is omitted is <code>XTMM9001</code> rather than <code>XTMM9000</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>To the extent that the behavior of <a href="#element-message"><code>xsl:message</code></a> is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, this rule does not prevent an implementation treating <a href="#element-assert"><code>xsl:assert</code></a> and <a href="#element-message"><code>xsl:message</code></a> differently.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If evaluation of the <code>test</code> expression fails with a dynamic error, the effect is exactly the same as if the evaluation returns <code>false</code>, including the fact that the instruction fails with error code <code>XTMM9001</code>.</p></div></li><li><p>If an assertion fails, then the following sibling instructions of the <a href="#element-assert"><code>xsl:assert</code></a> instruction are not evaluated.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>This means that <a href="#element-assert"><code>xsl:assert</code></a> can be used (rather like <a href="#element-if"><code>xsl:if</code></a> and <a href="#element-choose"><code>xsl:choose</code></a>) to prevent subsequent instructions from executing if a particular precondition is not true, which might be useful if the subsequent instructions have side-effects (for example, by calling extension functions) or if they can fail in uncatchable ways (for example, non-terminating recursion). It is worth noting that there are limits to this guarantee. It does not ensure, for example, that when an assertion within a template fails, the following siblings of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction that invokes that template will not be evaluated; nor does it ensure that if an assertion fails while processing the first item of a sequence using <a href="#element-for-each"><code>xsl:for-each</code></a>, then subsequent items in the sequence will not be processed. </p></div></li></ol><p><a id="err-XTMM9001"><span class="error">[ERR XTMM9001] </span></a>When a transformation is terminated by use of <a href="#element-assert"><code>xsl:assert</code></a>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9001</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-assert"><code>xsl:assert</code></a> instruction. </p><p>As with any other dynamic error, an error caused by an assertion failing may be trapped using <a href="#element-try"><code>xsl:try</code></a>: see <a href="#try-catch"><i>8.4 Try/Catch</i></a>.</p><p>The result of the <a href="#element-assert"><code>xsl:assert</code></a> instruction is an empty sequence.</p><div class="example"><div class="exampleHeader"><a id="d8e56565"></a><a id="d8e56681"></a>Example: Using Assertions with Static Parameters</div><p>The following example shows a stylesheet function that checks that the value of its supplied argument is in range. The check is performed only if the <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a><code>$DEBUG</code> is set to true.</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">DEBUG</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:boolean</span><span class="z">"</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">false</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">static</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">required</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:function</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="fname">f:days-elapsed</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:integer</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:param</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="pname">date</span><span class="z">"</span><span class="z"></span><span class="atn">as</span><span class="atneq">=</span><span class="z">"</span><span class="av">xs:date</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:assert</span><span class="z"></span><span class="atn">use-when</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$DEBUG</span><span class="z">"</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="variable">$date</span><span class="whitespace"></span><span class="op">lt</span><span class="whitespace"></span><span class="function">current-date</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:sequence</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="parenthesis">(</span><span class="function">current-date</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">-</span><span class="whitespace"></span><span class="variable">$since</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">div</span><span class="whitespace"></span><span class="function">xs:dayTimeDuration</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">PT1D</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:function</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations should avoid optimizing <a href="#element-assert"><code>xsl:assert</code></a> instructions away. As a guideline, if the result of a sequence constructor is required by the transformation, the implementation should ensure that all <a href="#element-assert"><code>xsl:assert</code></a> instructions in that sequence constructor are evaluated. Conversely, if the result of a sequence constructor is not required by the transformation, its <a href="#element-assert"><code>xsl:assert</code></a> instructions should not be evaluated.</p><p>This guidance is not intended to prevent optimizations such as lazy evaluation, where evaluation of a sequence constructor may finish early, as soon as enough information is available to evaluate the containing instruction.</p></div><p>An implementation <span class="verb">may</span> provide a user option allowing a processor to treat assertions as being true without explicit checking. This option <span class="verb">must not</span> be enabled by default. If such an option is in force, the effect of any assertion not being true is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>For example, given the assertion <code>&lt;xsl:assert test="count(//title)=1"/&gt;</code>, a processor might generate code for the expression <code>&lt;xsl:value-of select="//title"/&gt;</code> that stops searching for <code>title</code> elements after finding the first one. In the event that the source document contains more than one <code>title</code>, execution of the stylesheet may fail in arbitrary ways, or it may produce incorrect output.</p></div></div></div><div class="div1"><h2><a id="extension"></a>25 <a href="#extension" style="text-decoration: none">Extensibility and Fallback</a></h2><p>XSLT allows two kinds of extension, extension instructions and extension functions.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-instruction" title="extension instruction"></a>An <b>extension instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension namespace.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-function" title="extension function"></a>An <b>extension function</b> is a named function introduced to the static or dynamic context by mechanisms outside the scope of this specification.<span class="definition">]</span></p><p>This specification does not define any mechanism for creating or binding implementations of <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a> or <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>, and it is not <span class="verb">required</span> that implementations support any such mechanism. Such mechanisms, if they exist, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Therefore, an XSLT stylesheet that must be portable between XSLT implementations cannot rely on particular extensions being available. XSLT provides mechanisms that allow an XSLT stylesheet to determine whether the implementation makes particular extensions available, and to specify what happens if those extensions are not available. If an XSLT stylesheet is careful to make use of these mechanisms, it is possible for it to take advantage of extensions and still retain portability.</p><p><a id="err-XTSE0085"><span class="error">[ERR XTSE0085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of any <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>, other than a function or instruction defined in this specification or in a normatively referenced specification. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a prefix bound to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute. </p><div class="div2"><h3><a id="extension-functions"></a>25.1 <a href="#extension-functions" style="text-decoration: none">Extension Functions</a></h3><p>The set of functions that can be called from a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP40</small></sup> within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> may include one or more <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an extension function always has a non-null namespace URI, which <span class="verb">must not</span> be the URI of a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The definition of the term <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is written to exclude user-written <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, constructor functions for built-in and user-defined types, functions in the <code>fn</code>, <code>math</code>, <code>map</code>, and <code>array</code> namespaces, anonymous XPath inline functions, maps and arrays, and partial function applications (including partial applications of extension functions). It also excludes functions obtained by invoking XPath-defined functions such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-load-xquery-module"><code>load-xquery-module</code></a><sup><small>FO40</small></sup>. The definition allows extension functions to be discovered at evaluation time (typically using <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>) rather than necessarily being known statically. </p><p>Technically, the definition of extension functions excludes anonymous functions obtained by calling or partially applying other extension functions. Since such functions are by their nature implementation-defined, they may however share some of the characteristics of extension functions.</p></div><div class="div3"><h4><a id="func-function-available"></a>25.1.1 <a href="#func-function-available" style="text-decoration: none">fn:function-available</a></h4><dl><dt class="label">Summary</dt><dd><p>Determines whether a particular function is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>) to test whether a particular <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is available.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><a id="function-function-available"></a><table style="border:0; border-spacing:0"><tbody><tr class="delete_version" style="display: none;"><td colspan="3"><code class="function">fn:function-available</code>(</td></tr><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:function-available</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td style="padding:0; vertical-align:top" rowspan="2"><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:function-available</span></code><span class="deltaxml-new" style="background:#90EE90">(</span></td><td><span style="display: none;" class="delete_version"><code>$name</code></span><span style="display: none;" class="add_version"><code class="arg">$name</code></span><span class="modify_version"><code class="arg">$name</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">union(xs:QName, xs:string)</code>,</span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">union(xs:QName, xs:string)</code>,</span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">union(xs:QName, xs:string)</code>,</span></td><td></td></tr><tr class="arg"><td><span style="display: none;" class="delete_version"><code>$arity</code></span><span style="display: none;" class="add_version"><code class="arg">$arity</code></span><span class="modify_version"><code class="arg">$arity</code></span></td><td><span style="display: none;" class="delete_version"><code class="as">as&nbsp;</code><code class="type">xs:integer?</code></span><span style="display: none;" class="add_version"><code class="as">&nbsp;as&nbsp;</code><code class="type">xs:integer?</code>)<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:boolean</code></span><span class="modify_version"><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;</span>as&nbsp;</code><code class="type">xs:integer?</code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></span></td><td><code class="assign"><span class="deltaxml-old" style="background:#FF5555">:=&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">()</span></code></td></tr><tr class="delete_version" style="display: none;"><td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:boolean</code></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:boolean</span></code></td></tr></tbody></table></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. It depends on namespaces, and known function signatures. </p></dd><dt class="label">Rules</dt><dd><p>A function is said to be available within an XPath expression if it is present in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known function definitions</a><sup><small>XP40</small></sup> for that expression (see <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a>). <span>Function definitions</span> in the static context are uniquely identified by the name of the function (a QName) in combination with its <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>.</p><p>The value of <code>$name</code><span class="verb">must</span> be <span>either an <code>xs:QName</code>, or </span>a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. A lexical QName is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in scope for the <a title="expression" class="termref" href="#dt-expression">expression</a>. If the value is an unprefixed lexical QName, then the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a> is used in the expanded QName.</p><p><span>When the <code>$arity</code> argument is present and non-empty,</span> the <a href="#func-function-available"><code>function-available</code></a> function returns true if and only if there is an available function whose name matches the value of the <code>$function-name</code> argument and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> includes the value of the <code>$arity</code> argument. </p><p><span>When the <code>$arity</code> argument is omitted or empty,</span> the <a href="#func-function-available"><code>function-available</code></a> function returns true if and only if there is at least one available function (with some arity) whose name matches the value of the <code>$name</code> argument. </p><p>When the containing expression is evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to true, the <a href="#func-function-available"><code>function-available</code></a> function returns false in respect of a function name and arity for which no implementation is available (other than the fallback error function that raises a dynamic error whenever it is called). This means that it is possible (as in XSLT 1.0) to use logic such as the following to test whether a function is available before calling it:</p><div class="example"><div class="exampleHeader"><a id="d8e56809"></a><a id="d8e56925"></a>Example: Calling an extension function with backwards compatibility enabled</div><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">summary</span><span class="z"></span><span class="atn">xsl:version</span><span class="atneq">=</span><span class="z">"</span><span class="av">1.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">function-available</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">my:summary</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">my:summary</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="scx">&gt;</span><span class="txt">Summary not available</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">summary</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1400"><span class="error">[ERR XTDE1400] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <code>$name</code> argument <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt class="label">Notes</dt><dd><p class="note">The fact that a function with a given name is available gives no guarantee that any particular call on the function will be successful. For example, it is not possible to determine the types of the arguments expected.</p><p class="note">The introduction of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> function in XPath 3.0 reduces the need for <a href="#func-function-available"><code>function-available</code></a>, since <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> not only tests whether a function is available, but also returns a function item that enables it to be dynamically called.</p><p class="note">If a function is present in the static context but with no useful functionality (for example, if the system has been configured for security reasons so that <a href="https://www.w3.org/TR/xpath-functions-30/#func-available-environment-variables"><code>available-environment-variables</code></a><sup><small>FO30</small></sup> returns no information), then <a href="#func-function-available"><code>function-available</code></a> when applied to that function should return false.</p><p class="note">It is not necessary that there be a direct equivalence between the results of <a href="#func-function-available"><code>function-available</code></a> and <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> in all cases. For example, there may be <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> whose side-effects are such that for security reasons, dynamic calls to the function are disallowed; <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup> might then not provide access to the function. The main use-case for <a href="#func-function-available"><code>function-available</code></a>, by contrast, is for use in <code>[xsl:]use-when</code> conditions to test whether static calls on the function are possible.</p></dd><dt class="label">Examples</dt><dd><div class="example"><div class="example"><div class="exampleHeader"><a id="d8e56885"></a><a id="d8e57001"></a>Example: Stylesheet portable between XSLT 1.0, XSLT 2.0, and XSLT 3.0</div><p>A stylesheet that is designed to use XSLT 2.0 facilities when running under an XSLT 2.0 or XSLT 3.0 processor, but to fall back to XSLT 1.0 capabilities when not, might be written using the code:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">out</span><span class="z"></span><span class="atn">xsl:version</span><span class="atneq">=</span><span class="z">"</span><span class="av">2.0</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:choose</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:when</span><span class="z"></span><span class="atn">test</span><span class="atneq">=</span><span class="z">"</span><span class="function">function-available</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">matches</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">matches</span><span class="parenthesis">(</span><span class="step">/</span><span class="qname">doc</span><span class="step">/</span><span class="qname">title</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">[a-z]*</span><span class="op">'</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:when</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:otherwise</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">string-length</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="function">translate</span><span class="parenthesis">(</span><span class="step">/</span><span class="qname">doc</span><span class="step">/</span><span class="qname">title</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal">abcdefghijklmnopqrstuvwxyz</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">=</span><span class="whitespace"></span><span class="numeric">0</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:otherwise</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:choose</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">out</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>Here an XSLT 2.0 or XSLT 3.0 processor will always take the <a href="#element-when"><code>xsl:when</code></a> branch, while a 1.0 processor will follow the <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch. The single-argument version of the <a href="#func-function-available"><code>function-available</code></a> function is used here, because that is the only version available in XSLT 1.0. Under the rules of XSLT 1.0, the call on the <code>matches</code> function is not an error, because it is never evaluated.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e56900"></a><a id="d8e57016"></a>Example: Stylesheet portable between XSLT 3.0 and a future version of XSLT</div><p>A stylesheet that is designed to use facilities in some future XSLT version when they are available, but to fall back to XSLT 2.0 or XSLT 3.0 capabilities when not, might be written using code such as the following. This hypothesizes the availability in some future version of a function <code>pad</code> which pads a string to a fixed length with spaces:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">pad</span><span class="parenthesis">(</span><span class="step">/</span><span class="qname">doc</span><span class="step">/</span><span class="qname">title</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">10</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">use-when</span><span class="atneq">=</span><span class="z">"</span><span class="function">function-available</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">pad</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">2</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">concat</span><span class="parenthesis">(</span><span class="step">/</span><span class="qname">doc</span><span class="step">/</span><span class="qname">title</span><span class="op">,</span><span class="whitespace"></span><span class="function">string-join</span><span class="parenthesis">(</span><span class="whitespace"></span><span class="higher">for</span><span class="whitespace"></span><span class="variable">$i</span><span class="whitespace"></span><span class="op">in</span><span class="whitespace"></span><span class="numeric">1</span><span class="whitespace"></span><span class="op">to</span><span class="whitespace"></span><span class="numeric">10</span><span class="whitespace"></span><span class="op">-</span><span class="whitespace"></span><span class="function">string-length</span><span class="parenthesis">(</span><span class="step">/</span><span class="qname">doc</span><span class="step">/</span><span class="qname">title</span><span class="parenthesis">)</span><span class="whitespace"></span><span class="op">return</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="op">'</span><span class="literal"></span><span class="op">'</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="z"></span><span class="atn">use-when</span><span class="atneq">=</span><span class="z">"</span><span class="function">not</span><span class="parenthesis">(</span><span class="function">function-available</span><span class="parenthesis">(</span><span class="op">'</span><span class="literal">pad</span><span class="op">'</span><span class="op">,</span><span class="whitespace"></span><span class="numeric">2</span><span class="parenthesis">)</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span></pre></div><p>In this case the two-argument version of <a href="#func-function-available"><code>function-available</code></a> is used, because there is no requirement for this code to run under XSLT 1.0.</p></div></div></dd></dl></div><div class="div3"><h4><a id="calling-extension-functions"></a>25.1.2 <a href="#calling-extension-functions" style="text-decoration: none">Calling Extension Functions</a></h4><p>If the function name used in a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP40</small></sup> within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> identifies an extension function, then to evaluate the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP40</small></sup>, the processor will first evaluate each of the arguments in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP40</small></sup>. If the processor has information about the datatypes expected by the extension function, then it <span class="verb">may</span> perform any necessary type conversions between the XPath datatypes and those defined by the implementation language. If multiple extension functions are available with the same name, the processor <span class="verb">may</span> decide which one to invoke based on the number of arguments, the types of the arguments, or any other criteria. The result returned by the implementation is returned as the result of the function call, again after any necessary conversions between the datatypes of the implementation language and those of XPath. The details of such type conversions are outside the scope of this specification.</p><p><a id="err-XTDE1420"><span class="error">[ERR XTDE1420] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the arguments supplied to a call on an extension function do not satisfy the rules defined for that particular extension function, or if the extension function reports an error, or if the result of the extension function cannot be converted to an XPath value. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Implementations may also provide mechanisms allowing extension functions to report recoverable dynamic errors, or to execute within an environment that treats some or all of the errors listed above as recoverable.</p></div><p><a id="err-XTDE1425"><span class="error">[ERR XTDE1425] </span></a>When the containing element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate an extension function call if no implementation of the extension function is available. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>When XSLT 1.0 behavior is not enabled, this is a static error <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPST0017" title="XPST0017"><span class="error">[ERR XPST0017] </span></a><sup><small>XP40</small></sup>.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no prohibition on calling extension functions that have side-effects (for example, an extension function that writes data to a file). However, the order of execution of XSLT instructions is not defined in this specification, so the effects of such functions are unpredictable.</p></div><p>Implementations are not <span class="verb">required</span> to perform full validation of values returned by extension functions. It is an error for an extension function to return a string containing characters that are not permitted in XML, but the consequences of this error are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The implementation <span class="verb">may</span> raise an error, <span class="verb">may</span> convert the string to a string containing valid characters only, or <span class="verb">may</span> treat the invalid characters as if they were permitted characters.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The ability to execute extension functions represents a potential security weakness, since untrusted stylesheets may invoke code that has privileged access to resources on the machine where the <a title="processor" class="termref" href="#dt-processor">processor</a> executes. Implementations may therefore provide mechanisms that restrict the use of extension functions by untrusted stylesheets.</p></div><p>All observations in this section regarding the errors that can occur when invoking extension functions apply equally when invoking <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>.</p></div><div class="div3"><h4><a id="external-objects"></a>25.1.3 <a href="#external-objects" style="text-decoration: none">External Objects</a></h4><p>An implementation <span class="verb">may</span> allow an extension function to return an object that does not have any natural representation in the XDM data model, whether as an atomic value, a node, or a function item. For example, an extension function <code>sql:connect</code> might return an object that represents a connection to a relational database; the resulting connection object might be passed as an argument to calls on other extension functions such as <code>sql:insert</code> and <code>sql:select</code>.</p><p>The way in which such objects are represented in the type system is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. They might be represented by a completely new datatype, or they might be mapped to existing datatypes such as <code>integer</code>, <code>string</code>, or <code>anyURI</code>.</p></div><div class="div3"><h4><a id="func-type-available"></a>25.1.4 <a href="#func-type-available" style="text-decoration: none">fn:type-available</a></h4><dl><dt class="label">Summary</dt><dd><p>Used to control how a stylesheet behaves if a particular schema type is or is not available in the static context.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:type-available</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$name</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">union(xs:QName, xs:string)</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:boolean</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-type-available"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:type-available</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$name</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">union(xs:QName, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. It depends on namespaces, and schema definitions. </p></dd><dt class="label">Rules</dt><dd><p>A schema type (that is, a simple type or a complex type) is said to be available within an XPath expression if it is a type definition that is present in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP40</small></sup> for that expression (see <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a>). This includes built-in types, types imported using <a href="#element-import-schema"><code>xsl:import-schema</code></a>, and extension types defined by the implementation.</p><p>The value of the <code>$name</code> argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or</span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. The EQName is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in scope for the <a title="expression" class="termref" href="#dt-expression">expression</a>. If the value is an unprefixed lexical QName, then the default namespace is used in the expanded QName.</p><p>The function returns true if and only if there is an available type whose name matches the value of the <code>$name</code> argument. </p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1428"><span class="error">[ERR XTDE1428] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt class="label">Notes</dt><dd><p class="note">The <a href="#func-type-available"><code>type-available</code></a> function is of limited use within an <code>[xsl:]use-when</code> expression, because the static context for the expression does not include any user-defined types.</p></dd></dl></div></div><div class="div2"><h3><a id="extension-instruction"></a>25.2 <a href="#extension-instruction" style="text-decoration: none">Extension Instructions</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-extension-namespace" title="extension namespace"></a>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as <b>extension namespaces</b>. When a namespace is designated as an extension namespace and an element with a name from that namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.<span class="definition">]</span> The namespace determines the semantics of the instruction.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Since an element that is a child of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is not occurring <em>in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a></em>, <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.7.3 User-defined Data Elements</i></a>) are not extension elements as defined here, and nothing in this section applies to them.</p></div><div class="div3"><h4><a id="designating-extension-namespace"></a>25.2.1 <a href="#designating-extension-namespace" style="text-decoration: none">Designating an Extension Namespace</a></h4><p>A namespace is designated as an extension namespace by using an <code>[xsl:]extension-element-prefixes</code> attribute on an element in the stylesheet (see <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>). The attribute <span class="verb">must</span> be in the XSLT namespace only if its parent element is <em>not</em> in the XSLT namespace. The value of the attribute is a whitespace-separated list of namespace prefixes. The namespace bound to each of the prefixes is designated as an extension namespace.</p><p>The default namespace (as declared by <code>xmlns</code>) may be designated as an extension namespace by including <code>#default</code> in the list of namespace prefixes.</p><p>A <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> cannot be designated as an extension namespace: see <span class="error">[see <a href="#err-XTSE0085">ERR XTSE0085</a>]</span>.</p><p><a id="err-XTSE1430"><span class="error">[ERR XTSE1430] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is no namespace bound to the prefix on the element bearing the <code>[xsl:]extension-element-prefixes</code> attribute or, when <code>#default</code> is specified, if there is no default namespace. </p><p>The designation of a namespace as an extension namespace is effective for the element bearing the <code>[xsl:]extension-element-prefixes</code> attribute and for all descendants of that element within the same stylesheet module.</p></div><div class="div3"><h4><a id="func-element-available"></a>25.2.2 <a href="#func-element-available" style="text-decoration: none">fn:element-available</a></h4><dl><dt class="label">Summary</dt><dd><p>Determines whether a particular instruction is or is not available for use. The function is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see <a href="#conditional-inclusion"><i>3.13.3 Conditional Element Inclusion</i></a>) to test whether a particular <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> is available.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:element-available</span></code><span class="deltaxml-old" style="background:#FF5555">(</span></td></tr><tr class="arg"><td><code><span class="deltaxml-old" style="background:#FF5555">$name</span></code></td><td><code class="as"><span class="deltaxml-old" style="background:#FF5555">as&nbsp;</span></code><code class="type"><span class="deltaxml-old" style="background:#FF5555">union(xs:QName, xs:string)</span></code></td><td></td></tr><tr class="return-type"><td colspan="3"><span class="deltaxml-old" style="background:#FF5555">)</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code><span class="deltaxml-old" style="background:#FF5555">xs:boolean</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-element-available"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:element-available</span></code><span class="deltaxml-new" style="background:#90EE90">(</span><code class="arg"><span class="deltaxml-new" style="background:#90EE90">$name</span></code><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="type"><span class="deltaxml-new" style="background:#90EE90">union(xs:QName, xs:string)</span></code><span class="deltaxml-new" style="background:#90EE90">)</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:boolean</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>. It depends on namespaces. </p></dd><dt class="label">Rules</dt><dd><p>The value of the <code>$name</code> argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or</span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix, then it is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in the static context of the <a title="expression" class="termref" href="#dt-expression">expression</a>. If there is a default namespace in scope, then it is used to expand an unprefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p><p> If the resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, the function returns true if and only if the local name matches the name of an XSLT element that is defined in this specification and implemented by the XSLT processor.</p><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has a null namespace URI, the <a href="#func-element-available"><code>element-available</code></a> function will return false. </p><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, the function returns true if and only if the processor has an <span>external</span> implementation available of an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> with the given expanded QName. This applies whether or not the namespace has been designated as an <a title="extension namespace" class="termref" href="#dt-extension-namespace">extension namespace</a>.</p><p>The term <b>external implementation</b> excludes the use of a <a title="named template" class="termref" href="#dt-named-template">named template</a> as the instruction's implementation. The function does not return true simply because the name matches the name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>.</p><p>If the processor does not have an implementation of a particular extension instruction available, and such an extension instruction is evaluated, then the processor <span class="verb">must</span> perform fallback for the element as specified in <a href="#fallback"><i>25.2.3 Fallback</i></a>. An implementation <span class="verb">must not</span> signal an error merely because the stylesheet contains an extension instruction for which no implementation is available.</p></dd><dt class="label">Error Conditions</dt><dd><p><a id="err-XTDE1440"><span class="error">[ERR XTDE1440] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt class="label">Notes</dt><dd><p class="note">For element names in the XSLT namespace:</p><ul class="note"><li><p>This function can be useful to distinguish processors that implement XSLT 3.0 from processors that implement other (older or newer) versions of the specification, and to distinguish full implementations from incomplete implementations. (Incomplete implementations, of course, cannot be assumed to behave as described in this specification.)</p></li><li><p>In earlier versions of this specification, <a href="#func-element-available"><code>element-available</code></a> was defined to return true only for elements classified as instructions. The distinction between instructions and other elements, however, is sometimes rather technical, and in XSLT 3.0 the effect of the function has therefore been aligned to do what its name might suggest.</p></li><li><p>If an instruction is recognized but offers no useful functionality (for example, if the system has been configured for security reasons so that <a href="#element-evaluate"><code>xsl:evaluate</code></a> always raises an error), then <a href="#func-element-available"><code>element-available</code></a> when applied to that instruction <span class="verb">should</span> return false.</p></li></ul><p class="note">For element names in other namespaces:</p><ul class="note"><li><p>The result of the <a href="#func-element-available"><code>element-available</code></a> does not depend on whether or not the namespace of the supplied instruction name has been designated as an extension element namespace; it tests whether the instruction would be available if the namespace were designated as such.</p></li></ul></dd></dl></div><div class="div3"><h4><a id="fallback"></a>25.2.3 <a href="#fallback" style="text-decoration: none">Fallback</a></h4><p class="element-syntax"><a id="element-fallback"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:fallback&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:fallback&gt;</code></p><p>The content of an <a href="#element-fallback"><code>xsl:fallback</code></a> element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and when performing fallback, the value returned by the <a href="#element-fallback"><code>xsl:fallback</code></a> element is the result of evaluating this sequence constructor.</p><p>When not performing fallback, evaluating an <a href="#element-fallback"><code>xsl:fallback</code></a> element returns an empty sequence: the content of the <a href="#element-fallback"><code>xsl:fallback</code></a> element is not evaluated.</p><p>There are two situations where a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback: when an extension instruction that is not available is evaluated, and when an instruction in the XSLT namespace, that is not defined in XSLT 3.0, is evaluated within a region of the stylesheet for which <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is enabled.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Fallback processing is not invoked in other situations, for example it is not invoked when an XPath expression uses unrecognized syntax or contains a call to an unknown function. To handle such situations dynamically, the stylesheet should call functions such as <a href="#func-system-property"><code>system-property</code></a> and <a href="#func-function-available"><code>function-available</code></a> to decide what capabilities are available.</p></div><p><a id="err-XTDE1450"><span class="error">[ERR XTDE1450] </span></a>When a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback for an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> that is not recognized, if the instruction element has one or more <a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the <a href="#element-fallback"><code>xsl:fallback</code></a> children <span class="verb">must</span> be evaluated; it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if it has no <a href="#element-fallback"><code>xsl:fallback</code></a> children. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This is different from the situation with unrecognized <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>. As explained in <a href="#forwards"><i>3.10 Forwards Compatible Processing</i></a>, an unrecognized XSLT element appearing within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is a static error unless (a) <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is enabled, and (b) the instruction has an <a href="#element-fallback"><code>xsl:fallback</code></a> child.</p></div></div></div></div><div class="div1"><h2><a id="result-trees"></a>26 <a href="#result-trees" style="text-decoration: none">Transformation Results</a></h2><p>The output of a transformation includes a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> and zero or more <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>.</p><p>The way in which these results are delivered to an application is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>Serialization of results is described further in <a href="#serialization"><i>27 Serialization</i></a></p><div class="div2"><h3><a id="creating-result-trees"></a>26.1 <a href="#creating-result-trees" style="text-decoration: none">Creating Secondary Results</a></h3><p class="element-syntax"><a id="element-result-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:result-document<br>&nbsp;&nbsp;format? = { <var>eqname</var> }<br>&nbsp;&nbsp;href? = { <var>uri</var> }<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;method? = { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var> }<br>&nbsp;&nbsp;allow-duplicate-names? = { <var>boolean</var> }<br>&nbsp;&nbsp;build-tree? = { <var>boolean</var> }<br>&nbsp;&nbsp;byte-order-mark? = { <var>boolean</var> }<br>&nbsp;&nbsp;cdata-section-elements? = { <var>eqnames</var> }<br>&nbsp;&nbsp;doctype-public? = { <var>string</var> }<br>&nbsp;&nbsp;doctype-system? = { <var>string</var> }<br>&nbsp;&nbsp;encoding? = { <var>string</var> }<br>&nbsp;&nbsp;escape-uri-attributes? = { <var>boolean</var> }<br>&nbsp;&nbsp;html-version? = { <var>decimal</var> }<br>&nbsp;&nbsp;include-content-type? = { <var>boolean</var> }<br>&nbsp;&nbsp;indent? = { <var>boolean</var> }<br>&nbsp;&nbsp;item-separator? = { <var>string</var> }<br>&nbsp;&nbsp;json-node-output-method? = { "xml" | "html" | "xhtml" | "text" | <var>eqname</var> }<br>&nbsp;&nbsp;media-type? = { <var>string</var> }<br>&nbsp;&nbsp;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var> }<br>&nbsp;&nbsp;omit-xml-declaration? = { <var>boolean</var> }<br>&nbsp;&nbsp;parameter-document? = { <var>uri</var> }<br>&nbsp;&nbsp;standalone? = { <var>boolean</var> | "omit" }<br>&nbsp;&nbsp;suppress-indentation? = { <var>eqnames</var> }<br>&nbsp;&nbsp;undeclare-prefixes? = { <var>boolean</var> }<br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;output-version? = { <var>nmtoken</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:result-document&gt;</code></p><p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is used to create a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. The content of the <a href="#element-result-document"><code>xsl:result-document</code></a> element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and the value of the <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> (known as the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>) is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of this sequence constructor. </p><p>As with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> of the transformation, a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> may be delivered to the calling application in three ways (see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>):</p><ol class="enumar"><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be delivered <em>as is</em>.</p></li><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be used to construct a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> by invoking the process of <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#sequence-normalization">sequence normalization</a><sup><small>SER30</small></sup>.</p></li><li><p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be serialized to a sequence of octets (which may then, optionally, be saved to a persistent storage location).</p></li></ol><p>The decision whether or not to serialize the raw result depends on the <a title="processor" class="termref" href="#dt-processor">processor</a> and on the way it is invoked. This is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, and it is not controlled by anything in the stylesheet.</p><p><span style="display: none;" class="delete_version">If the result is not serialized, then the decision whether to return the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> or to construct a tree depends on the effective value of the <code>build-tree</code> attribute. If the effective value of the <code>build-tree</code> attribute is <code>yes</code>, then a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is created by invoking the process of <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#sequence-normalization">sequence normalization</a><sup><small>SER30</small></sup>. <span>Conversely, if the result <em>is</em> serialized, then the decision whether or not to construct a tree depends on the choice of serialization method, and the <code>build-tree</code> attribute is then ignored. For example, with <code>method="xml"</code> a tree is always constructed, whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208]. </span></span><span style="display: none;" class="add_version">If the result is not serialized, then the decision whether to return the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> or to construct a tree depends on the effective value of the <code>build-tree</code> attribute. If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>build-tree</code> attribute is <code>yes</code>, then a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is created by invoking the process of <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#sequence-normalization">sequence normalization</a><sup><small>SER30</small></sup>. <span>Conversely, if the result <em>is</em> serialized, then the decision whether or not to construct a tree depends on the choice of serialization method, and the <code>build-tree</code> attribute is then ignored. For example, with <code>method="xml"</code> a tree is always constructed, whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208]. </span></span><span class="modify_version">If the result is not serialized, then the decision whether to return the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> or to construct a tree depends on the effective value of the <code>build-tree</code> attribute. If the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>build-tree</code> attribute is <code>yes</code>, then a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is created by invoking the process of <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#sequence-normalization">sequence normalization</a><sup><small>SER30</small></sup>. <span>Conversely, if the result <em>is</em> serialized, then the decision whether or not to construct a tree depends on the choice of serialization method, and the <code>build-tree</code> attribute is then ignored. For example, with <code>method="xml"</code> a tree is always constructed, whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208]. </span></span></p><p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction defines a URI that may be used to identify the <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. The instruction may optionally specify the output format to be used for serializing the result.</p><p>Technically, the result of evaluating the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is an empty sequence. This means it does not contribute anything to the result of the sequence constructor it is part of.</p><p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>format</code> attribute, if specified, <span class="verb">must</span> be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. The value is expanded using the namespace declarations in scope for the <a href="#element-result-document"><code>xsl:result-document</code></a> element. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a><span class="verb">must</span> match the expanded QName of a named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This identifies the <a href="#element-output"><code>xsl:output</code></a> declaration that will control the serialization of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> (see <a href="#serialization"><i>27 Serialization</i></a>), if the result tree is serialized. If the <code>format</code> attribute is omitted, the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> is used to control serialization of the result tree.</p><p><a id="err-XTDE1460"><span class="error">[ERR XTDE1460] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>format</code> attribute is not a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if it does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect the error statically (for example, when the <code>format</code> attribute contains no curly brackets), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The only way to select the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> is to omit the <code>format</code> attribute.</p></div><p>The <code>parameter-document</code> attribute allows serialization parameters to be supplied in an external document. The external document must contain an <code>output:serialization-parameters</code> element with the format described in <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">Section 3.1 Setting Serialization Parameters by Means of a Data Model Instance </a><sup><small>SER30</small></sup>, and the parameters are interpreted as described in that specification.</p><p>If present, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the URI supplied in the <code>parameter-document</code> attribute is dereferenced, after resolution against the base URI of the <a href="#element-result-document"><code>xsl:result-document</code></a> element if it is a relative reference. The parameter document <span class="verb">should</span> be read during run-time evaluation of the stylesheet. If the location of the stylesheet at development time is different from the deployed location, any relative reference should be resolved against the deployed location. A serialization error occurs if the result of dereferencing the URI is ill-formed or invalid; but if no document can be found at the specified location, the attribute <code>should</code> be ignored.</p><p>A serialization parameter specified in the <code>parameter-document</code> takes precedence over a value supplied directly as an attribute of <a href="#element-result-document"><code>xsl:result-document</code></a>, which in turn takes precedence over a value supplied in the selected output definition, except that the values of the <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes are merged in the same way as when multiple <a href="#element-output"><code>xsl:output</code></a> declarations are merged.</p><p>The attributes <code>method</code>, <code>allow-duplicate-names</code>, <code>build-tree</code>, <code>byte-order-mark</code><code>cdata-section-elements</code>, <code>doctype-public</code>, <code>doctype-system</code>, <code>encoding</code>, <code>escape-uri-attributes</code>, <code>html-version</code>, <code>indent</code>, <code>item-separator</code>, <code>json-node-output-method</code>, <code>media-type</code>, <code>normalization-form</code>, <code>omit-xml-declaration</code>, <code>standalone</code>, <code>suppress-indentation</code>, <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and <code>output-version</code> may be used to override attributes defined in the selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>.</p><p>With the exception of <code>use-character-maps</code>, these attributes are all defined as <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>, so their values may be set dynamically. For any of these attributes that is present on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute overrides or supplements the corresponding value from the output definition. This works in the same way as when one <a href="#element-output"><code>xsl:output</code></a> declaration overrides another. Some of the attributes have more specific rules:</p><ul><li><p>In the case of <code>cdata-section-elements</code> and <code>suppress-indentation</code>, the value of the serialization parameter is the union of the expanded names of the elements named in this instruction and the elements named in the selected output definition.</p></li><li><p>In the case of <code>use-character-maps</code>, the character maps referenced in this instruction supplement and take precedence over those defined in the selected output definition.</p></li><li><p><span style="display: none;" class="delete_version">In the case of <code>doctype-public</code> and <code>doctype-system</code>, setting the effective value of the attribute to a zero-length string has the effect of overriding any value for these attributes obtained from the output definition. The corresponding serialization parameter is not set (is “absent”).</span><span style="display: none;" class="add_version">In the case of <code>doctype-public</code> and <code>doctype-system</code>, setting the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute to a zero-length string has the effect of overriding any value for these attributes obtained from the output definition. The corresponding serialization parameter is not set (is “absent”).</span><span class="modify_version">In the case of <code>doctype-public</code> and <code>doctype-system</code>, setting the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the attribute to a zero-length string has the effect of overriding any value for these attributes obtained from the output definition. The corresponding serialization parameter is not set (is “absent”).</span></p></li><li><p><span style="display: none;" class="delete_version">In the case of <code>item-separator</code>, setting the effective value of the attribute to the special value <code>"#absent"</code> has the effect of overriding any value for this attribute obtained from the output definition. The corresponding serialization parameter is not set (is “absent”). It is not possible to set the value of the serialization parameter to the literal 7-character string <code>"#absent"</code>. </span><span style="display: none;" class="add_version">In the case of <code>item-separator</code>, setting the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute to the special value <code>"#absent"</code> has the effect of overriding any value for this attribute obtained from the output definition. The corresponding serialization parameter is not set (is “absent”). It is not possible to set the value of the serialization parameter to the literal 7-character string <code>"#absent"</code>. </span><span class="modify_version">In the case of <code>item-separator</code>, setting the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the attribute to the special value <code>"#absent"</code> has the effect of overriding any value for this attribute obtained from the output definition. The corresponding serialization parameter is not set (is “absent”). It is not possible to set the value of the serialization parameter to the literal 7-character string <code>"#absent"</code>. </span></p></li><li><p>In all other cases, the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of an attribute actually present on this instruction takes precedence over the value defined in the selected output definition.</p></li></ul><div class="note"><p class="prefix"><b>Note:</b></p><p>In the case of the attributes <code>method</code>, <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and <code>use-character-maps</code>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute contains a space-separated list of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>. If any of these is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix, the prefix is expanded using the in-scope namespaces for the <a href="#element-result-document"><code>xsl:result-document</code></a> element. In the case of <code>cdata-section-elements</code> and <code>suppress-indentation</code>, an unprefixed element name is expanded using the default namespace. In the case of the <code>method</code> attribute, if the method is not one of the system-defined methods (xml, html, xhtml, text) then the expanded name must have a non-absent namespace.</p></div><p>The <code>output-version</code> attribute on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction overrides the <code>version</code> attribute on <a href="#element-output"><code>xsl:output</code></a> (it has been renamed because <code>version</code> is available with a different meaning as a standard attribute: see <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>). In all other cases, attributes correspond if they have the same name.</p><p>There are some serialization parameters that apply to some output methods but not to others. For example, the <code>indent</code> attribute has no effect on the <code>text</code> output method. If a value is supplied for an attribute that is inapplicable to the output method, its value is not passed to the serializer. The processor <span class="verb">may</span> validate the value of such an attribute, but is not <span class="verb">required</span> to do so.</p><p>The <code>item-separator</code> serialization parameter is used when the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is used to construct a result tree by applying sequence normalization, and it is also used when the result tree is serialized. For example, if the sequence constructor delivers a sequence of integers, and the <code>text</code> serialization method is used, then the result of serialization will be a string obtained by converting each integer to a string, and separating the strings using the defined <code>item-separator</code>.</p><p>The <code>href</code> attribute is optional. The default value is the zero-length string. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute <span class="verb">must</span> be a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a>, which may be absolute or relative. If it is relative, then it is resolved against the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>. There <span class="verb">may</span> be <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> restrictions on the form of absolute URI that may be used, but the implementation is not <span class="verb">required</span> to enforce any restrictions. Any valid relative URI reference <span class="verb">must</span> be accepted. Note that the zero-length string is a valid relative URI reference.</p><p><span style="display: none;" class="delete_version">If the implementation provides an API to access <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>, then it <span class="verb">must</span> allow a secondary result to be identified by means of the absolutized value of the <code>href</code> attribute. In addition, if a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is constructed (that is, if the effective value of <code>build-tree</code> is <code>yes</code>), then this value is used as the base URI of the document node at the root of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. </span><span style="display: none;" class="add_version">If the implementation provides an API to access <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>, then it <span class="verb">must</span> allow a secondary result to be identified by means of the absolutized value of the <code>href</code> attribute. In addition, if a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is constructed (that is, if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of <code>build-tree</code> is <code>yes</code>), then this value is used as the base URI of the document node at the root of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. </span><span class="modify_version">If the implementation provides an API to access <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>, then it <span class="verb">must</span> allow a secondary result to be identified by means of the absolutized value of the <code>href</code> attribute. In addition, if a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is constructed (that is, if the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of <code>build-tree</code> is <code>yes</code>), then this value is used as the base URI of the document node at the root of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The base URI of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is not necessarily the same thing as the URI of its serialized representation on disk, if any. For example, a server (or browser client) might store final result trees only in memory, or in an internal disk cache. As long as the processor satisfies requests for those URIs, it is irrelevant where they are actually written on disk, if at all.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>It will often be the case that one <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> contains links to another final result tree produced during the same transformation, in the form of a relative URI reference. The mechanism of associating a URI with a final result tree has been chosen to allow the integrity of such links to be preserved when the trees are serialized.</p><p>As well as being potentially significant in any API that provides access to final result trees, the base URI of the new document node is relevant if the final result tree, rather than being serialized, is supplied as input to a further transformation.</p></div><p>The optional attributes <code>type</code> and <code>validation</code> may be used on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction to validate the contents of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that elements and attributes within the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> will carry. The permitted values and their semantics are described in <a href="#validating-document-nodes"><i>26.4.2 Validating Document Nodes</i></a>. Any such validation is applied to the document node produced as the result of <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#sequence-normalization">sequence normalization</a><sup><small>SER30</small></sup>. If sequence normalization does not take place (typically because the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is delivered to the application directly, or because the selected serialization method does not involve sequence normalization) then the <code>validation</code> and <code>type</code> attributes are ignored.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Validation applies after inserting item separators as determined by the <code>item-separator</code> serialization parameter, and an inappropriate choice of <code>item-separator</code> may cause the result to become invalid.</p></div><p>A <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">may</span> allow a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be serialized. Serialization is described in <a href="#serialization"><i>27 Serialization</i></a>. However, an implementation (for example, a <a title="processor" class="termref" href="#dt-processor">processor</a> running in an environment with no access to writable filestore) is not <span class="verb">required</span> to support the serialization of <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a>. An implementation that does not support the serialization of final result trees <span class="verb">may</span> ignore the <code>format</code> attribute and the serialization attributes. Such an implementation <span class="verb">must</span> provide the application with some means of access to the (un-serialized) result tree, using its URI to identify it.</p><p>Implementations may provide additional mechanisms, outside the scope of this specification, for defining the way in which <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> are processed. Such mechanisms <span class="verb">may</span> make use of the XSLT-defined attributes on the <a href="#element-result-document"><code>xsl:result-document</code></a> and/or <a href="#element-output"><code>xsl:output</code></a> elements, or they <span class="verb">may</span> use additional elements or attributes in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> namespace.</p><div class="example"><div class="exampleHeader"><a id="d8e58132"></a><a id="d8e58254"></a>Example: Multiple Result Documents</div><p> The following example takes an XHTML document as input, and breaks it up so that the text following each &lt;h1&gt; element is included in a separate document. A new document <code>toc.html</code> is constructed to act as an index:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:stylesheet</span><span class="z"></span><span class="atn">version</span><span class="atneq">=</span><span class="z">"</span><span class="av">3.0</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xsl</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/XSL/Transform</span><span class="z">"</span><span class="z"></span><span class="atn">xmlns:xhtml</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/xhtml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">toc-format</span><span class="z">"</span><span class="z"></span><span class="atn">method</span><span class="atneq">=</span><span class="z">"</span><span class="av">xhtml</span><span class="z">"</span><span class="z"></span><span class="atn">indent</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="z"></span><span class="atn">doctype-system</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd</span><span class="z">"</span><span class="z"></span><span class="atn">doctype-public</span><span class="atneq">=</span><span class="z">"</span><span class="av">-//W3C//DTD XHTML 1.0 Strict//EN</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">section-format</span><span class="z">"</span><span class="z"></span><span class="atn">method</span><span class="atneq">=</span><span class="z">"</span><span class="av">xhtml</span><span class="z">"</span><span class="z"></span><span class="atn">indent</span><span class="atneq">=</span><span class="z">"</span><span class="av">no</span><span class="z">"</span><span class="z"></span><span class="atn">doctype-system</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd</span><span class="z">"</span><span class="z"></span><span class="atn">doctype-public</span><span class="atneq">=</span><span class="z">"</span><span class="av">-//W3C//DTD XHTML 1.0 Transitional//EN</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:template</span><span class="z"></span><span class="atn">match</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">toc.html</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">toc-format</span><span class="z">"</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strict</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">html</span><span class="z"></span><span class="atn">xmlns</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/xhtml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt">Table of Contents</span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">h1</span><span class="scx">&gt;</span><span class="txt">Table of Contents</span><span class="ez">&lt;/</span><span class="cl">h1</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="op">*</span><span class="step">/</span><span class="qname">xhtml:body</span><span class="step">/</span><span class="parenthesis">(</span><span class="op">*</span><span class="filter">[</span><span class="numeric">1</span><span class="filter">]</span><span class="whitespace"></span><span class="op">|</span><span class="whitespace"></span><span class="qname">xhtml:h1</span><span class="parenthesis">)</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">p</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">a</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">section</span><span class="op">{</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="av">.html</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">a</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">p</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">html</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:for-each-group</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="step">/</span><span class="op">*</span><span class="step">/</span><span class="qname">xhtml:body</span><span class="step">/</span><span class="op">*</span><span class="z">"</span><span class="z"></span><span class="atn">group-starting-with</span><span class="atneq">=</span><span class="z">"</span><span class="qname">xhtml:h1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:result-document</span><span class="z"></span><span class="atn">href</span><span class="atneq">=</span><span class="z">"</span><span class="av">section</span><span class="op">{</span><span class="function">position</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="op">}</span><span class="av">.html</span><span class="z">"</span><span class="z"></span><span class="atn">format</span><span class="atneq">=</span><span class="z">"</span><span class="av">section-format</span><span class="z">"</span><span class="z"></span><span class="atn">validation</span><span class="atneq">=</span><span class="z">"</span><span class="av">strip</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">html</span><span class="z"></span><span class="atn">xmlns</span><span class="atneq">=</span><span class="z">"</span><span class="av">http://www.w3.org/1999/xhtml</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">head</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:value-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="context">.</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">head</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">body</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:copy-of</span><span class="z"></span><span class="atn">select</span><span class="atneq">=</span><span class="z">"</span><span class="function">current-group</span><span class="parenthesis">(</span><span class="parenthesis">)</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">body</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">html</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:result-document</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:for-each-group</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:template</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:stylesheet</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div></div><div class="div2"><h3><a id="result-document-restrictions"></a>26.2 <a href="#result-document-restrictions" style="text-decoration: none">Restrictions on the use of </a><a href="#element-result-document"><code>xsl:result-document</code></a></h3><p>There are restrictions on the use of the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, designed to ensure that the results are fully interoperable even when processors optimize the sequence in which instructions are evaluated. Informally, the restriction is that the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction can only be used while writing a final result tree, not while writing to a temporary tree or a sequence. This restriction is defined formally as follows.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-output-state" title="output state"></a>Each instruction in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated in one of two possible <b>output states</b>: <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> or <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-final-output-state" title="final output state"></a>The first of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>final output</b> state. This state applies when instructions are writing to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-temporary-output-state" title="temporary output state"></a>The second of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>temporary output</b> state. This state applies when instructions are writing to a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> or any other non-final destination.<span class="definition">]</span></p><p>The instructions in the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a> are evaluated in <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>. An instruction is evaluated in the same <a title="output state" class="termref" href="#dt-output-state">output state</a> as its calling instruction, except that <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, <a href="#element-with-param"><code>xsl:with-param</code></a>, <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-key"><code>xsl:key</code></a>, <a href="#element-sort"><code>xsl:sort</code></a>, <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>, and <a href="#element-merge-key"><code>xsl:merge-key</code></a> always evaluate the instructions in their contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p><p><a id="err-XTDE1480"><span class="error">[ERR XTDE1480] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>. </p><p><a id="err-XTDE1490"><span class="error">[ERR XTDE1490] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a transformation to generate two or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> with the same URI. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Note, this means that it is an error to evaluate more than one <a href="#element-result-document"><code>xsl:result-document</code></a> instruction that omits the <code>href</code> attribute, or to evaluate any <a href="#element-result-document"><code>xsl:result-document</code></a> instruction that omits the <code>href</code> attribute if an initial <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is created implicitly.</p></div><p>In addition, an implementation <span class="verb">may</span> report this error if it is able to detect that two or more final result trees are generated with different URIs that refer to the same physical resource.</p><p><a id="err-XTDE1500"><span class="error">[ERR XTDE1500] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to write to an external resource and read from the same resource during a single transformation, if the same absolute URI is used to access the resource in both cases. </p><p>In addition, an implementation <span class="verb">may</span> report this error if it is able to detect that a transformation writes to a resource and reads from the same resource using different URIs that refer to the same physical resource. Note that if the error is not detected, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether the document that is read from the resource reflects its state before or after the result tree is written.</p></div><div class="div2"><h3><a id="current-output-uri"></a>26.3 <a href="#current-output-uri" style="text-decoration: none">The Current Output URI</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-output-uri" title="current output URI"></a>The <b>current output URI</b> is the URI associated with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> that is currently being written.<span class="definition">]</span></p><div class="div3"><h4><a id="func-current-output-uri"></a>26.3.1 <a href="#func-current-output-uri" style="text-decoration: none">fn:current-output-uri</a></h4><dl><dt class="label">Summary</dt><dd><p>Returns the value of the <a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a>.</p></dd><dt class="label">Signature</dt><dd><div class="proto"><table class="proto" border="0"><tbody><tr class="name return-type"><td colspan="3"><code class="function"><span class="deltaxml-old" style="background:#FF5555">fn:current-output-uri</span></code><span class="deltaxml-old" style="background:#FF5555">()</span><code class="as"><span class="deltaxml-old" style="background:#FF5555">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-old" style="background:#FF5555">xs:anyURI?</span></code></td></tr></tbody></table></div><div class="proto"><a id="function-current-output-uri"></a><code class="function"><span class="deltaxml-new" style="background:#90EE90">fn:current-output-uri</span></code><span class="deltaxml-new" style="background:#90EE90">()</span><code class="as"><span class="deltaxml-new" style="background:#90EE90">&nbsp;as&nbsp;</span></code><code class="return-type"><span class="deltaxml-new" style="background:#90EE90">xs:anyURI?</span></code></div></dd><dt class="label">Properties</dt><dd><p>This function is <a href="https://www.w3.org/TR/xpath-functions-30/#dt-deterministic">deterministic</a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#dt-focus-independent">focus-independent</a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#dt-context-dependent">context-dependent</a><sup><small>FO30</small></sup>. </p></dd><dt class="label">Rules</dt><dd><p>On initial invocation of a stylesheet component, the current output uri is set to the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p><p>During execution of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction with an <code>href</code> attribute, the current output URI changes to the absolute URI obtained by resolving the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>href</code> attribute against the base output URI.</p><p>The current output URI is cleared (set to <a title="absent" class="termref" href="#dt-absent">absent</a>) while evaluating stylesheet functions, dynamic function calls, evaluation of global variables, stylesheet parameters, and patterns. If the function is called when the current output URI is absent, the function returns the empty sequence. </p><p>The current output URI may also be <a title="absent" class="termref" href="#dt-absent">absent</a> in the event that a stylesheet is invoked without supplying a <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p></dd><dt class="label">Notes</dt><dd><p class="note">The current output URI is not cleared when evaluating a local variable, even though <a href="#element-result-document"><code>xsl:result-document</code></a> cannot be used while evaluating a local variable. The reason for this is to allow the value of <code>current-output-uri</code> to be set as the value of a tunnel parameter, so that the original base output URI is accessible even when writing nested result documents.</p></dd></dl></div></div><div class="div2"><h3><a id="validation"></a>26.4 <a href="#validation" style="text-decoration: none">Validation</a></h3><p>It is possible to control the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> applied to individual element and attribute nodes as they are constructed. This is done using the <code>type</code> and <code>validation</code> attributes of the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a> instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. The same attributes are used on <a href="#element-source-document"><code>xsl:source-document</code></a> and <a href="#element-merge-source"><code>xsl:merge-source</code></a> to control validation of input documents.</p><p>The <code>[xsl:]type</code> attribute is used to request validation of an element or attribute against a specific simple or complex type defined in a schema. The <code>[xsl:]validation</code> attribute is used to request validation against the global element or attribute declaration whose name matches the name of the element or attribute being validated.</p><p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually exclusive. Both are optional, but if one is present then the other <span class="verb">must</span> be omitted. If both attributes are omitted, the effect is the same as specifying the <code>validation</code> attribute with the value specified in the <code>[xsl:]default-validation</code> attribute of the innermost containing element having such an attribute; if this is not specified, the effect is the same as specifying <code>validation="strip"</code>.</p><p>The <code>[xsl:]default-validation</code> attribute defines the default value of the <code>validation</code> attribute of all <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a> instructions, and of the <code>xsl:validation</code> attribute of all <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, appearing <span>appearing as descendants of the element on which the attribute appears, unless there is an inner element that defines a different default</span>. This default does not extend to included or imported stylesheet modules or used packages. If the attribute is omitted, the default is <code>strip</code>. The permitted values are <code>preserve</code> and <code>strip</code>.</p><p> The <code>default-validation</code> attribute on the outermost element of the principal stylesheet module of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> also determines the validation applied to the implicit final result tree created in the absence of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction. [XSLT 3.0 Erratum E15, bug 30211]. </p><p>The <code>[xsl:]default-validation</code> attribute has no effect on the <a href="#element-source-document"><code>xsl:source-document</code></a> and <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, which perform no validation unless explicitly requested.</p><p><a id="err-XTSE1505"><span class="error">[ERR XTSE1505] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if both the <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are present on the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, or on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. </p><p>The detailed rules for validation vary depending on the kind of node being validated. The rules for element and attribute nodes are given in <a href="#validating-constructed-nodes"><i>26.4.1 Validating Constructed Elements and Attributes</i></a>, while those for document nodes are given in <a href="#validating-document-nodes"><i>26.4.2 Validating Document Nodes</i></a>.</p><div class="div3"><h4><a id="validating-constructed-nodes"></a>26.4.1 <a href="#validating-constructed-nodes" style="text-decoration: none">Validating Constructed Elements and Attributes</a></h4><div class="div4"><h5><a id="validating-using-validation-attribute"></a>26.4.1.1 <a href="#validating-using-validation-attribute" style="text-decoration: none">Validation using the </a><code>[xsl:]validation</code><a href="#validating-using-validation-attribute" style="text-decoration: none"> Attribute</a></h5><p>The <code>[xsl:]validation</code> attribute defines the validation action to be taken. It determines not only the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the node that is constructed by the relevant instruction itself, but also the type annotations of all element and attribute nodes that have the constructed node as an ancestor. Conceptually, the validation requested for a child element or attribute node is applied before the validation requested for its parent element. For example, if the instruction that constructs a child element specifies <code>validation="strict"</code>, this will cause the child element to be checked against an element declaration, but if the instruction that constructs its parent element specifies <code>validation="strip"</code>, then the final effect will be that the child node is annotated as <code>xs:untyped</code>.</p><p>In the paragraphs below, the term <em>contained nodes</em> means the elements and attributes that have the newly constructed node as an ancestor.</p><ol class="enumar"><li><p>The value <code>strip</code> indicates that the new node and each of the contained nodes will have the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untyped</code> if it is an element, or <code>xs:untypedAtomic</code> if it is an attribute. Any previous type annotation present on a contained element or attribute node (for example, a type annotation that is present on an element copied from a source document) is also replaced by <code>xs:untyped</code> or <code>xs:untypedAtomic</code> as appropriate. The typed value of the node is changed to be the same as its string value, as an instance of <code>xs:untypedAtomic</code>. In the case of elements the <code>nilled</code> property is set to <code>false</code>. The values of the <code>is-id</code> and <code>is-idrefs</code> properties are unchanged. Schema validation is not invoked.</p></li><li><p>The value <code>preserve</code> indicates that nodes that are copied will retain their <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a>, but nodes whose content is newly constructed will be annotated as <code>xs:anyType</code> in the case of elements, or <code>xs:untypedAtomic</code> in the case of attributes. Schema validation is not invoked. The detailed effect depends on the instruction:</p><ol class="enumla"><li><p>In the case of <a href="#element-element"><code>xsl:element</code></a> and literal result elements, the new element has a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of <code>xs:anyType</code>, and the type annotations of contained nodes are retained unchanged.</p><p>The <code>nilled</code>, <code>is-id</code> and <code>is-idrefs</code> properties on the new element are set to <code>false</code>.</p></li><li><p>In the case of <a href="#element-attribute"><code>xsl:attribute</code></a>, the effect is exactly the same as specifying <code>validation="strip"</code>: that is, the new attribute will have the type annotation <code>xs:untypedAtomic</code>.</p><p>The <code>is-id</code> and <code>is-idrefs</code> properties on the new attribute are set to <code>false</code>.</p></li><li><p>In the case of <a href="#element-copy-of"><code>xsl:copy-of</code></a>, all the nodes that are copied will retain their type annotations unchanged. The values of their <code>nilled</code>, <code>is-id</code> and <code>is-idrefs</code> properties are also unchanged.</p></li><li><p>In the case of <a href="#element-copy"><code>xsl:copy</code></a>, the effect depends on the kind of node being copied.</p><ol class="enumlr"><li><p>Where the node being copied is an attribute, the copied attribute will retain its <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> and the values of its <code>is-id</code> and <code>is-idrefs</code> properties.</p></li><li><p>Where the node being copied is an element, the copied element will have a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of <code>xs:anyType</code> (because this instruction does not copy the content of the element, it would be wrong to assume that the type is unchanged); but any contained nodes will have their type annotations retained in the same way as with <a href="#element-element"><code>xsl:element</code></a>. The values of the <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code> properties are handled in the same way as <a href="#element-element"><code>xsl:element</code></a>. </p></li></ol></li></ol></li><li><p>The value <code>strict</code> indicates that <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> are established by performing strict schema validity assessment on the element or attribute node created by this instruction as follows:</p><ol class="enumla"><li><p>In the case of an element, a top-level element declaration is identified whose local name and namespace (if any) match the name of the element, and schema-validity assessment is carried out according to the rules defined in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 3.3.4 "Element Declaration Validation Rules", validation rule "Schema-Validity Assessment (Element)", clauses 1.1 and 2, using the top-level element declaration as the “declaration stipulated by the processor”, which is mentioned in clause 1.1.1.1). The element is considered valid if the result of the schema validity assessment is a PSVI in which the relevant element node has a <code>validity</code> property whose value is <code>valid</code>. If there is no matching element declaration, or if the element is not considered valid, the transformation fails <span class="error">[see <a href="#err-XTTE1510">ERR XTTE1510</a>]</span>, <span class="error">[see <a href="#err-XTTE1512">ERR XTTE1512</a>]</span>. In effect this means that the element being validated <span class="verb">must</span> be declared using a top-level declaration in the schema, and <span class="verb">must</span> conform to its declaration. The process of validation applies recursively to contained elements and attributes to the extent required by the schema definition.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not an error if the identified type definition is a simple type, although <a href="#xmlschema-1">[XML Schema Part 1]</a> does not define explicitly that this case is permitted.</p></div></li><li><p>In the case of an attribute, a top-level attribute declaration is identified whose local name and namespace (if any) match the name of the attribute, and schema-validity assessment is carried out according to the rules defined in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 3.2.4 "Attribute Declaration Validation Rules", validation rule "Schema-Validity Assessment (Attribute)"). The attribute is considered valid if the result of the schema validity assessment is a PSVI in which the relevant attribute node has a <code>validity</code> property whose value is <code>valid</code>. If the attribute is not considered valid, the transformation fails <span class="error">[see <a href="#err-XTTE1510">ERR XTTE1510</a>]</span>. In effect this means that the attribute being validated <span class="verb">must</span> be declared using a top-level declaration in the schema, and <span class="verb">must</span> conform to its declaration.</p></li><li><p>The schema components used to validate an element or attribute may be located in any way described by <a href="#xmlschema-1">[XML Schema Part 1]</a> (see section 4.3.2, <em>How schema documents are located on the Web</em>). The components in the schema constructed from the synthetic schema document (see <a href="#import-schema"><i>3.15 Importing Schema Components</i></a>) will always be available for validating constructed nodes; if additional schema components are needed, they <span class="verb">may</span> be located in other ways, for example implicitly from knowledge of the namespace in which the elements and attributes appear, or using the <code>xsi:schemaLocation</code> attribute of elements within the tree being validated.</p></li><li><p>The type annotations on the resulting nodes, as well as the values of their <code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code> properties, are defined by the rules in <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 3.3 Construction from a PSVI </a><sup><small>DM31</small></sup>.</p></li><li><p>If no validation is performed for a node, which can happen when the schema specifies <code>lax</code> or <code>skip</code> validation for that node or for a subtree, then the node is annotated as <code>xs:anyType</code> in the case of an element, and <code>xs:untypedAtomic</code> in the case of an attribute.</p></li></ol></li><li><p>The value <code>lax</code> has the same effect as the value <code>strict</code>, except that whereas <code>strict</code> validation fails if there is no matching top-level element declaration or if the outcome of validity assessment is a <code>validity</code> property of <code>invalid</code> or <code>notKnown</code>, <code>lax</code> validation fails only if the outcome of validity assessment is a <code>validity</code> property of <code>invalid</code>. That is, <code>lax</code> validation does not cause a <a title="type error" class="termref" href="#dt-type-error">type error</a> when the outcome is <code>notKnown</code>.</p><p>In practice this means that the element or attribute being validated <span class="verb">must</span> conform to its declaration if a top-level declaration is available. If no such declaration is available, then the element or attribute is not validated, but its attributes and children are validated, again with lax validation. Any nodes whose validation outcome is a <code>validity</code> property of <code>notKnown</code> are annotated as <code>xs:anyType</code> in the case of an element, and <code>xs:untypedAtomic</code> in the case of an attribute.</p><p>The type annotations on the resulting nodes, as well as the values of their <code>is-id</code>, <code>is-idrefs</code>, and <code>nilled</code> properties, are defined by the rules in <a href="https://www.w3.org/TR/xpath-datamodel-31/#const-psvi">Section 3.3 Construction from a PSVI </a><sup><small>DM31</small></sup>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When the parent element lacks a declaration, the XML Schema specification defines the recursive checking of children and attributes as optional. For this specification, this recursive checking is required.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>If an element that is being validated has an <code>xsi:type</code> attribute, then the value of the <code>xsi:type</code> attribute will be taken into account when performing the validation. However, the presence of an <code>xsi:type</code> attribute will not of itself cause an element to be validated: if validation against a named type is required, as distinct from validation against a top-level element declaration, then it must be requested using the XSLT <code>[xsl:]type</code> attribute on the instruction that invokes the validation, as described in section <a href="#validation-xsl-type"><i>26.4.1.2 Validation using the [xsl:]type Attribute</i></a></p></div></li></ol><p><span style="display: none;" class="delete_version"><a id="err-XTTE1510"><span class="error">[ERR XTTE1510] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the effective value <code>strict</code>, and schema validity assessment concludes that the validity of the element or attribute is invalid or unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span style="display: none;" class="add_version"><a id="err-XTTE1510"><span class="error">[ERR XTTE1510] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>strict</code>, and schema validity assessment concludes that the validity of the element or attribute is invalid or unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span class="modify_version"><a id="err-XTTE1510"><span class="error">[ERR XTTE1510] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>strict</code>, and schema validity assessment concludes that the validity of the element or attribute is invalid or unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span></p><p><span style="display: none;" class="delete_version"><a id="err-XTTE1512"><span class="error">[ERR XTTE1512] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the effective value <code>strict</code>, and there is no matching top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span style="display: none;" class="add_version"><a id="err-XTTE1512"><span class="error">[ERR XTTE1512] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>strict</code>, and there is no matching top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span class="modify_version"><a id="err-XTTE1512"><span class="error">[ERR XTTE1512] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>strict</code>, and there is no matching top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span></p><p><span style="display: none;" class="delete_version"><a id="err-XTTE1515"><span class="error">[ERR XTTE1515] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the effective value <code>lax</code>, and schema validity assessment concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span style="display: none;" class="add_version"><a id="err-XTTE1515"><span class="error">[ERR XTTE1515] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>lax</code>, and schema validity assessment concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span class="modify_version"><a id="err-XTTE1515"><span class="error">[ERR XTTE1515] </span></a>If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>lax</code>, and schema validity assessment concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>No mechanism is provided to validate an element or attribute against a local declaration in a schema. Such validation can usually be achieved by applying validation to a containing element for which a top-level element declaration exists.</p></div></div><div class="div4"><h5><a id="validation-xsl-type"></a>26.4.1.2 <a href="#validation-xsl-type" style="text-decoration: none">Validation using the </a><code>[xsl:]type</code><a href="#validation-xsl-type" style="text-decoration: none"> Attribute</a></h5><p>The <code>[xsl:]type</code> attribute takes as its value an <span><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP40</small></sup></span>. If it is a lexical QName with no prefix, it is expanded using the <span>default namespace for types</span>. This <span class="verb">must</span> be the name of a type definition included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the stylesheet. </p><p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed element or attribute is validated against the type definition identified by this attribute.</p><ul><li><p>In the case of an element, schema-validity assessment is carried out according to the rules defined in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 3.3.4 "Element Declaration Validation Rules", validation rule "Schema-Validity Assessment (Element)", clauses 1.2 and 2), using this type definition as the "processor-stipulated type definition". The element is considered valid if the result of the schema validity assessment is a PSVI in which the relevant element node has a <code>validity</code> property whose value is <code>valid</code>. </p></li><li><p>In the case of an attribute, the attribute is considered valid if (in the terminology of XML Schema) the attribute’s normalized value is locally valid with respect to that type definition according to the rules for "String Valid" (<a href="#xmlschema-1">[XML Schema Part 1]</a>, section 3.14.4). (Normalization here refers to the process of normalizing whitespace according to the rules of the <code>whiteSpace</code> facet for the datatype).</p></li><li><p>If the element or attribute is not considered valid, as defined above, the transformation fails <span class="error">[see <a href="#err-XTTE1540">ERR XTTE1540</a>]</span>.</p></li></ul><p>If an element node is validated against the type <code>xs:untyped</code>, the effect is the same as specifying <code>validation="strip"</code>: that is, the elements and attributes in the subtree rooted at the target element are copied with a type annotation of <code>xs:untyped</code> or <code>xs:untypedAtomic</code> respectively.</p><p>If an element or attribute node is validated against the type <code>xs:untypedAtomic</code>, the effect is the same as specifying <code>[xsl:]type="xs:string"</code> except that when validation succeeds, the returned element or attribute has a type annotation of <code>xs:untypedAtomic</code>. Validation fails in the case of an element with element children.</p><p><a id="err-XTSE1520"><span class="error">[ERR XTSE1520] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>type</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <span><a href="#element-source-document"><code>xsl:source-document</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a></span> instruction, or the <code>xsl:type</code> attribute of a literal result element, is not a valid <code>QName</code>, or if it uses a prefix that is not defined in an in-scope namespace declaration, or if the QName is not the name of a type definition included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="package" class="termref" href="#dt-package">package</a>. <span>[XSLT 3.0 Erratum E20, bug 30234]</span></p><p><a id="err-XTSE1530"><span class="error">[ERR XTSE1530] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>type</code> attribute of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction refers to a complex type definition.</p><p><a id="err-XTTE1535"><span class="error">[ERR XTTE1535] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the value of the <code>type</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction refers to a complex type definition and one or more of the items being copied is an attribute node.</p><p><a id="err-XTTE1540"><span class="error">[ERR XTTE1540] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <code>[xsl:]type</code> attribute is defined for a constructed element or attribute, and the outcome of schema validity assessment against that type is that the <code>validity</code> property of that element or attribute information item is other than <code>valid</code>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>Like other type errors, this error may be signaled statically if it can be detected statically. For example, the instruction <code>&lt;xsl:attribute name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may result in a static error being signaled. If the error is not signaled statically, it will be signaled when the instruction is evaluated.</p></div></div><div class="div4"><h5><a id="validation-process"></a>26.4.1.3 <a href="#validation-process" style="text-decoration: none">The Validation Process</a></h5><p>As well as checking for validity against the schema, the validity assessment process causes <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> to be associated with element and attribute nodes. If default values for elements or attributes are defined in the schema, the validation process will where necessary create new nodes containing these default values.</p><p>Validation of an element or attribute node only takes into account constraints on the content of the element or attribute. Validation rules affecting the document as a whole are not applied. Specifically, this means:</p><ul><li><p>The validation rule "Validation Root Valid (ID/IDREF)" is not applied. This means that validation will not fail if there are non-unique ID values or dangling IDREF values in the subtree being validated.</p></li><li><p>The validation rule "Validation Rule: Identity-constraint Satisfied" <span class="verb">should</span> be applied.</p></li><li><p>There is no check that the document contains unparsed entities whose names match the values of nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>. (XSLT 3.0 provides no facility to construct unparsed entities within a tree.)</p></li></ul><p>With these caveats, validating a newly constructed element, using strict or lax validation, is equivalent to the following steps:</p><ol class="enumar"><li><p>The element is serialized to textual XML form, according to the rules defined in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a> using the XML output method, with all parameters defaulted. Note that this process discards any existing <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a>.</p></li><li><p>The resulting XML document is parsed to create an XML Information Set (see <a href="#xml-infoset">[XML Information Set]</a>.)</p></li><li><p>The Information Set produced in the previous step is validated according to the rules in <a href="#xmlschema-1">[XML Schema Part 1]</a>. The result of this step is a Post-Schema Validation Infoset (PSVI). If the validation process is not successful (as defined above), a <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised.</p></li><li><p>The PSVI produced in the previous step is converted back into the XDM data model by the mapping described in <a href="#xpath-datamodel-30">[XDM 3.0]</a> (<a href="https://www.w3.org/TR/xpath-datamodel-30/#PSVI2Types">Section 3.3.1 Mapping PSVI Additions to Node Properties </a><sup><small>DM30</small></sup>). This process creates nodes with simple or complex <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> based on the types established during schema validation.</p></li></ol><p> The above process must be done in such a way that the base URI property of every node in the resulting XDM tree is the same as the base URI property of the corresponding node in the input tree. </p><div class="note"><p class="prefix"><b>Note:</b></p><p> As an alternative to steps 1 and 2, the XDM tree may be converted to an Infoset directly, using the mapping rules given for each kind of node in <a href="#xpath-datamodel-30">[XDM 3.0]</a> (Section 6). </p></div><p>Validating an attribute using strict or lax validation requires a modified version of this procedure. A copy of the attribute is first added to an element node that is created for the purpose, and namespace fixup (see <a href="#namespace-fixup"><i>5.8.3 Namespace Fixup</i></a>) is performed on this element node. The name of this element is of no consequence, but it must be the same as the name of a synthesized element declaration of the form:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">xs:element</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">E</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:complexType</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:sequence</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">xs:attribute</span><span class="z"></span><span class="atn">ref</span><span class="atneq">=</span><span class="z">"</span><span class="av">A</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">xs:complexType</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">xs:element</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>where A is the name of the attribute being validated.</p><p>This synthetic element is then validated using the procedure given above for validating elements, and if it is found to be valid, a copy of the validated attribute is made, retaining its <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>, but detaching it from the containing element (and thus, from any namespace nodes).</p><p>The XDM data model does not permit an attribute node with no parent to have a typed value that includes a namespace-qualified name, that is, a value whose type is derived from <code>xs:QName</code> or <code>xs:NOTATION</code>. This restriction is imposed because these types rely on the namespace nodes of a containing element to resolve namespace prefixes. Therefore, it is an error to validate a parentless attribute against such a type. This affects the instructions <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, and <a href="#element-copy-of"><code>xsl:copy-of</code></a>.</p><p><a id="err-XTTE1545"><span class="error">[ERR XTTE1545] </span></a>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs if a <code>type</code> or <code>validation</code> attribute is defined (explicitly or implicitly) for an instruction that constructs a new attribute node, if the effect of this is to cause the attribute value to be validated against a type that is derived from, or constructed by list or union from, the primitive types <code>xs:QName</code> or <code>xs:NOTATION</code>. </p></div></div><div class="div3"><h4><a id="validating-document-nodes"></a>26.4.2 <a href="#validating-document-nodes" style="text-decoration: none">Validating Document Nodes</a></h4><p>It is possible to apply validation to a document node. This happens when a new document node is constructed by one of the XSLT elements <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-merge-source"><code>xsl:merge-source</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, or <a href="#element-copy-of"><code>xsl:copy-of</code></a>, and this element has a <code>type</code> attribute, or a <code>validation</code> attribute with the value <code>strict</code> or <code>lax</code>.</p><p>Document-level validation is not applied to the document node that is created implicitly when a variable-binding element has no <code>select</code> attribute and no <code>as</code> attribute (see <a href="#temporary-trees"><i>9.4 Creating Implicit Document Nodes</i></a>). This is equivalent to using <code>validation="preserve"</code> on <a href="#element-document"><code>xsl:document</code></a>: nodes within such trees retain their <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>. Similarly, validation is not applied to document nodes created using <a href="#element-message"><code>xsl:message</code></a> or <a href="#element-assert"><code>xsl:assert</code></a>. </p><p>The values <code>validation="preserve"</code> and <code>validation="strip"</code> do not request validation. In the first case, all element and attribute nodes within the tree rooted at the new document node retain their <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a>. In the second case, elements within the tree have their type annotation set to <code>xs:untyped</code>, while attributes have their type annotation set to <code>xs:untypedAtomic</code>.</p><p>When validation is requested for a document node (that is, when <code>validation</code> is set to <code>strict</code> or <code>lax</code>, or when a <code>type</code> attribute is present), the following processing takes place:</p><ul><li><p><a id="err-XTTE1550"><span class="error">[ERR XTTE1550] </span></a>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs unless the children of the document node comprise exactly one element node, no text nodes, and zero or more comment and processing instruction nodes, in any order. </p></li><li><p>The single element node child is validated, using the supplied values of the <code>validation</code> and <code>type</code> attributes, as described in <a href="#validating-constructed-nodes"><i>26.4.1 Validating Constructed Elements and Attributes</i></a>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>type</code> attribute on <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-document"><code>xsl:document</code></a> and <a href="#element-result-document"><code>xsl:result-document</code></a>, and on <a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-copy-of"><code>xsl:copy-of</code></a> when copying a document node, thus refers to the required type of the element node that is the only element child of the document node. It does not refer to the type of the document node itself.</p></div></li><li><p>The validation rule "Validation Root Valid (ID/IDREF)" is applied to the single element node child of the document node. This means that validation will fail if there are non-unique ID values or dangling IDREF values in the document tree.</p></li><li><p>Identity constraints, as defined in section 3.11 of <a href="#xmlschema-1">[XML Schema Part 1]</a>, are checked. (This refers to constraints defined using <code>xs:unique</code>, <code>xs:key</code>, and <code>xs:keyref</code>.)</p></li><li><p>There is no check that the tree contains unparsed entities whose names match the values of nodes of type <code>xs:ENTITY</code> or <code>xs:ENTITIES</code>. This is because there is no facility in XSLT 3.0 to create unparsed entities in a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. It is possible to add unparsed entity declarations to the result document by referencing a suitable DOCTYPE during serialization.</p></li><li><p>All other children of the document node (comments and processing instructions) are copied unchanged.</p></li></ul><p><a id="err-XTTE1555"><span class="error">[ERR XTTE1555] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if, when validating a document node, document-level constraints (such as ID/IDREF constraints) are not satisfied. </p></div><div class="div3"><h4><a id="validating-xml-id"></a>26.4.3 <a href="#validating-xml-id" style="text-decoration: none">Validating </a><code>xml:id</code><a href="#validating-xml-id" style="text-decoration: none"> attributes</a></h4><p>This section provides a non-normative summary of the effect of validation on attributes named <code>xml:id</code>. The normative rules can be inferred from rules given elsewhere in this section.</p><ol class="enumar"><li><p>When an attribute named <code>xml:id</code> is encountered in the course of validation:</p><ol class="enumla"><li><p>A validation error occurs if it the attribute is not lexically valid against type <code>xs:ID</code>.</p></li><li><p>The typed value of the attribute is whitespace-normalized.</p></li><li><p>The attribute is labeled with type annotation <code>xs:ID</code>.</p></li><li><p>The attribute acquires the <code>is-id</code> property.</p></li></ol></li><li><p>The previous rule applies whether validation is strict, lax, or by type; validation will never fail (or be skipped) on the grounds that no global attribute declaration named <code>xsl:id</code> is available.</p></li><li><p>Checking <code>xml:id</code> attributes for uniqueness happens if and only if validation is applied at the level of a document node.</p></li></ol></div></div></div><div class="div1"><h2><a id="serialization"></a>27 <a href="#serialization" style="text-decoration: none">Serialization</a></h2><p>A <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">may</span> output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as a sequence of octets, although it is not <span class="verb">required</span> to be able to do so (see <a href="#conformance"><i>28 Conformance</i></a>). Stylesheet authors can use <a href="#element-output"><code>xsl:output</code></a> declarations to specify how they wish result trees to be serialized. If a processor serializes a final result tree, it <span class="verb">must</span> do so as specified by these declarations.</p><p>The rules governing the output of the serializer are defined in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>. The serialization is controlled using a number of serialization parameters. The values of these serialization parameters may be set within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, using the <a href="#element-output"><code>xsl:output</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, and <a href="#element-character-map"><code>xsl:character-map</code></a> declarations.</p><p class="element-syntax"><a id="element-output"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:output<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;method? = "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var><br>&nbsp;&nbsp;allow-duplicate-names? = <var>boolean</var><br>&nbsp;&nbsp;build-tree? = <var>boolean</var><br>&nbsp;&nbsp;byte-order-mark? = <var>boolean</var><br>&nbsp;&nbsp;cdata-section-elements? = <var>eqnames</var><br>&nbsp;&nbsp;doctype-public? = <var>string</var><br>&nbsp;&nbsp;doctype-system? = <var>string</var><br>&nbsp;&nbsp;encoding? = <var>string</var><br>&nbsp;&nbsp;escape-uri-attributes? = <var>boolean</var><br>&nbsp;&nbsp;html-version? = <var>decimal</var><br>&nbsp;&nbsp;include-content-type? = <var>boolean</var><br>&nbsp;&nbsp;indent? = <var>boolean</var><br>&nbsp;&nbsp;item-separator? = <var>string</var><br>&nbsp;&nbsp;json-node-output-method? = "xml" | "html" | "xhtml" | "text" | <var>eqname</var><br>&nbsp;&nbsp;media-type? = <var>string</var><br>&nbsp;&nbsp;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var><br>&nbsp;&nbsp;omit-xml-declaration? = <var>boolean</var><br>&nbsp;&nbsp;parameter-document? = <var>uri</var><br>&nbsp;&nbsp;standalone? = <var>boolean</var> | "omit"<br>&nbsp;&nbsp;suppress-indentation? = <var>eqnames</var><br>&nbsp;&nbsp;undeclare-prefixes? = <var>boolean</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;version? = <var>nmtoken</var>&nbsp;/&gt;</code></p><p>The <a href="#element-output"><code>xsl:output</code></a> declaration is optional; if used, it <span class="verb">must</span> always appear as a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element within a stylesheet module.</p><p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> may contain multiple <a href="#element-output"><code>xsl:output</code></a> declarations and may include or import stylesheet modules that also contain <a href="#element-output"><code>xsl:output</code></a> declarations. The name of an <a href="#element-output"><code>xsl:output</code></a> declaration is the value of its <code>name</code> attribute, if any.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-output-definition" title="output definition"></a>All the <a href="#element-output"><code>xsl:output</code></a> declarations within a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>output definition</b>; those that have no name are grouped into a single unnamed output definition.<span class="definition">]</span></p><p>An output definition is scoped to a package. If this is a <a title="library package" class="termref" href="#dt-library-package">library package</a> the output definition applies only to <a href="#element-result-document"><code>xsl:result-document</code></a> instructions within the same package. If it is the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, the output definition applies to <a href="#element-result-document"><code>xsl:result-document</code></a> instructions within the same package and also to the implicit <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p><p>A stylesheet always includes an unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>; in the absence of an unnamed <a href="#element-output"><code>xsl:output</code></a> declaration, the unnamed output definition is equivalent to the one that would be used if the stylesheet contained an <a href="#element-output"><code>xsl:output</code></a> declaration having no attributes.</p><p>A named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> is used when its name matches the <code>format</code> attribute used in an <a href="#element-result-document"><code>xsl:result-document</code></a> element. The unnamed output definition is used when an <a href="#element-result-document"><code>xsl:result-document</code></a> element omits the <code>format</code> attribute. It is also used when serializing the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a>. .</p><p>All the <a href="#element-output"><code>xsl:output</code></a> elements making up an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> are effectively merged. For those attributes whose values are namespace-sensitive, the merging is done after <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QNames</a> have been converted into <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a>. For the <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes, the output definition uses the union of the values from all the constituent <a href="#element-output"><code>xsl:output</code></a> declarations. For the <code>use-character-maps</code> attribute, the output definition uses the concatenation of the sequences of <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> values from all the constituent <a href="#element-output"><code>xsl:output</code></a> declarations, taking them in order of increasing <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, or where several have the same import precedence, in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>. For other attributes, the <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> uses the value of that attribute from the <a href="#element-output"><code>xsl:output</code></a> declaration with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p><p>The <code>parameter-document</code> attribute allows serialization parameters to be supplied in an external document. The external document must contain an <code>output:serialization-parameters</code> element with the format described in <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/#serparams-in-xdm-instance">Section 3.1 Setting Serialization Parameters by Means of a Data Model Instance </a><sup><small>SER30</small></sup>, and the parameters are interpreted as described in that specification.</p><p>If present, the URI supplied in the <code>parameter-document</code> attribute is dereferenced, after resolution against the base URI of the <a href="#element-output"><code>xsl:output</code></a> element if it is a relative reference. The parameter document <span class="verb">should</span> be read during static analysis of the stylesheet. A serialization error occurs if the result of dereferencing the URI is ill-formed or invalid; but if no document can be found at the specified location, the attribute <span class="verb">should</span> be ignored.</p><p>A serialization parameter specified in the <code>parameter-document</code> takes precedence over a value supplied directly in the output declaration, except that the values of the <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes are merged in the same way as when multiple <a href="#element-output"><code>xsl:output</code></a> declarations are merged.</p><p><a id="err-XTSE1560"><span class="error">[ERR XTSE1560] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two <a href="#element-output"><code>xsl:output</code></a> declarations within an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> specify explicit values for the same attribute (other than <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and <code>use-character-maps</code>), with the values of the attributes being not equal, unless there is another <a href="#element-output"><code>xsl:output</code></a> declaration within the same <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> that has higher import precedence and that specifies an explicit value for the same attribute. </p><p><span style="display: none;" class="delete_version"> If the result is not serialized, then the decision whether to return the raw result or to construct a tree depends on the effective value of the <code>build-tree</code> attribute. If the effective value of the <code>build-tree</code> attribute is <code>yes</code>, then a final result tree is created by invoking the process of sequence normalization. Conversely, if the result is serialized, then the decision whether or not to construct a tree depends on the choice of serialization method, and the <code>build-tree</code> attribute is then ignored. For example, with <code>method="xml"</code> a tree is always constructed, whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208]. </span><span style="display: none;" class="add_version"> If the result is not serialized, then the decision whether to return the raw result or to construct a tree depends on the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>build-tree</code> attribute. If the effective value of the <code>build-tree</code> attribute is <code>yes</code>, then a final result tree is created by invoking the process of sequence normalization. Conversely, if the result is serialized, then the decision whether or not to construct a tree depends on the choice of serialization method, and the <code>build-tree</code> attribute is then ignored. For example, with <code>method="xml"</code> a tree is always constructed, whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208]. </span><span class="modify_version"> If the result is not serialized, then the decision whether to return the raw result or to construct a tree depends on the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>build-tree</code> attribute. If the effective value of the <code>build-tree</code> attribute is <code>yes</code>, then a final result tree is created by invoking the process of sequence normalization. Conversely, if the result is serialized, then the decision whether or not to construct a tree depends on the choice of serialization method, and the <code>build-tree</code> attribute is then ignored. For example, with <code>method="xml"</code> a tree is always constructed, whereas with <code>method="json"</code> a tree is never constructed. [XSLT 3.0 Erratum E14, bug 30208]. </span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The default for <code>build-tree</code> may differ for user-defined serialization methods or for serialization methods introduced in future versions of this specification.</p></div><p>If none of the <a href="#element-output"><code>xsl:output</code></a> declarations within an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> specifies a value for a particular attribute, then the corresponding serialization parameter takes a default value. The default value depends on the chosen output method.</p><p>There are some serialization parameters that apply to some output methods but not to others. For example, the <code>indent</code> attribute has no effect on the <code>text</code> output method. If a value is supplied for an attribute that is inapplicable to the output method, its value is not passed to the serializer. The processor <span class="verb">may</span> validate the value of such an attribute, but is not <span class="verb">required</span> to do so.</p><p>An implementation <span class="verb">may</span> allow the attributes of the <a href="#element-output"><code>xsl:output</code></a> declaration to be overridden, or the default values to be changed, using the API that controls the transformation.</p><p>The location to which <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> are serialized (whether in filestore or elsewhere) is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> (which in practice <span class="verb">may</span> mean that it is controlled using an implementation-defined API). However, these locations <span class="verb">must</span> satisfy the constraint that when two <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> are both created (implicitly or explicitly) using relative URI references in the <code>href</code> attribute of the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, then these relative URI references may be used to construct references from one tree to the other, and such references <span class="verb">must</span> remain valid when both result trees are serialized. </p><p>The <code>method</code> attribute on the <a href="#element-output"><code>xsl:output</code></a> element identifies the overall method that is to be used for outputting the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p><p><a id="err-XTSE1570"><span class="error">[ERR XTSE1570] </span></a>The value <span class="verb">must</span> (if present) be a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with no a prefix, then it identifies a method specified in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a> and <span class="verb">must</span> be one of <code>xml</code>, <code>html</code>, <code>xhtml</code>, or <code>text</code>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix, then the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>; the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> identifies the output method; the behavior in this case is not specified by this document.</p><p>The default for the <code>method</code> attribute depends on the contents of the tree being serialized, and is chosen as follows. If the document node of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> has an element child, and any text nodes preceding the first element child of the document node of the result tree contain only whitespace characters, then:</p><ul><li><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of this first element child has local part <code>html</code> (in lower case), and namespace URI <code>http://www.w3.org/1999/xhtml</code>, then the default output method is normally <code>xhtml</code>. However, if the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of the outermost element of the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> in the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> has the value <code>1.0</code>, and if the result tree is generated implicitly (rather than by an explicit <a href="#element-result-document"><code>xsl:result-document</code></a> instruction), then the default output method in this situation is <code>xml</code>.</p></li><li><p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of this first element child has local part <code>html</code> (in any combination of upper and lower case) and a null namespace URI, then the default output method is <code>html</code>.</p></li></ul><p>In all other cases, the default output method is <code>xml</code>.</p><p>The default output method is used if the selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> does not include a <code>method</code> attribute.</p><p>The other attributes on <a href="#element-output"><code>xsl:output</code></a> provide parameters for the output method. The following attributes are allowed:</p><ul><li><p> The value of the <code>encoding</code> attribute provides the value of the <code>encoding</code> parameter to the serialization method. The default value is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but in the case of the <code>xml</code> and <code>xhtml</code> methods it <span class="verb">must</span> be either <code>UTF-8</code> or <code>UTF-16</code>. </p></li><li><p>The <code>byte-order-mark</code> attribute defines whether a byte order mark is written at the start of the file. If the value <code>yes</code> is specified, a byte order mark is written; if <code>no</code> is specified, no byte order mark is written. The default value depends on the encoding used. If the encoding is <code>UTF-16</code>, the default is <code>yes</code>; for <code>UTF-8</code> it is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, and for all other encodings it is <code>no</code>. The value of the byte order mark indicates whether high order bytes are written before or after low order bytes; the actual byte order used is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, unless it is defined by the selected encoding. </p></li><li><p> The <code>cdata-section-elements</code> attribute is a whitespace-separated list of QNames. The default value is an empty list. After expansion of these names using the in-scope namespace declarations for the <a href="#element-output"><code>xsl:output</code></a> declaration in which they appear, this list of names provides the value of the <code>cdata-section-elements</code> parameter to the serialization method. In the case of an unprefixed name, the default namespace (that is, the namespace declared using <code>xmlns="uri"</code>) is used. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This differs from the rule for most other QNames used in a stylesheet. The reason is that these names refer to elements in the result document, and therefore follow the same convention as the name of a literal result element or the <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a>.</p></div></li><li><p> The value of the <code>doctype-system</code> attribute provides the value of the <code>doctype-system</code> parameter to the serialization method. If the attribute is absent or has a zero-length string as its value, then the serialization parameter is not set (is “absent”). </p></li><li><p> The value of the <code>doctype-public</code> attribute provides the value of the <code>doctype-public</code> parameter to the serialization method. If the attribute is absent or has a zero-length string as its value, then the serialization parameter is not set (is “absent”). </p><p>The value of <code>doctype-public</code> must conform to the rules for a <a href="https://www.w3.org/TR/REC-xml/#NT-PubidLiteral">PubidLiteral</a><sup><small>XML</small></sup> (see <a href="#REC-xml">[XML 1.0]</a>).</p></li><li><p> The value of the <code>escape-uri-attributes</code> attribute provides the value of the <code>escape-uri-attributes</code> parameter to the serialization method. The default value is <code>yes</code>. </p></li><li><p> The value of the <code>html-version</code> attribute provides the value of the <code>html-version</code> parameter to the serialization method. The set of permitted values, and the default value, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. A <a title="serialization error" class="termref" href="#dt-serialization-error">serialization error</a> will be reported if the requested version is not supported by the implementation. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This serialization parameter is new in version 3.0. If it is absent, the html output method uses the value of the <code>version</code> parameter in its place. For XHTML serialization, the <code>html-version</code> parameter indicates the version of XHTML to be used, while the <code>version</code> parameter indicates the version of XML.</p></div></li><li><p> The value of the <code>include-content-type</code> attribute provides the value of the <code>include-content-type</code> parameter to the serialization method. The default value is <code>yes</code>. </p></li><li><p> The value of the <code>indent</code> attribute provides the value of the <code>indent</code> parameter to the serialization method. The default value is <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code> output methods, <code>no</code> in the case of the <code>xml</code> output method. </p></li><li><p> The value of the <code>item-separator</code> attribute provides the value of the <code>item-separator</code> parameter to the serialization method. The value of the serialization parameter can be any string (including a zero-length string), or absent. To set the parameter to absent, the <code>item-separator</code> attribute can either be omitted, or set to the special value <code>item-separator="#absent"</code>; it is not possible to set the value of the serialization parameter to the literal 7-character string <code>"#absent"</code>. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>The <code>item-separator</code> attribute has no effect if the sequence being serialized contains only one item. <span>[XSLT 3.0 Erratum E14, bug 30208].</span></p></div></li><li><p> The value of the <code>media-type</code> attribute provides the value of the <code>media-type</code> parameter to the serialization method. The default value is <code>text/xml</code> in the case of the <code>xml</code> output method, <code>text/html</code> in the case of the <code>html</code> and <code>xhtml</code> output methods, and <code>text/plain</code> in the case of the <code>text</code> output method. <span>The default for the <code>json</code> output method is <code>application/json</code>; the default for the adaptive output method is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. [XSLT 3.0 Erratum E26, bug 30245].</span></p></li><li><p> The value of the <code>normalization-form</code> attribute provides the value of the <code>normalization-form</code> parameter to the serialization method. A value that is an <code>NMTOKEN</code> other than one of those enumerated for the <code>normalization-form</code> attribute specifies an implementation-defined normalization form; the behavior in this case is not specified by this document. The default value is <code>none</code>. </p></li><li><p> The value of the <code>omit-xml-declaration</code> attribute provides the value of the <code>omit-xml-declaration</code> parameter to the serialization method. The default value is <code>no</code>. </p></li><li><p> The value of the <code>standalone</code> attribute provides the value of the <code>standalone</code> parameter to the serialization method. The default value is <code>omit</code>; this means that no <code>standalone</code> attribute is to be included in the XML declaration. </p></li><li><p> The <code>suppress-indentation</code> attribute is a whitespace-separated list of QNames. The default value is an empty list. After expansion of these names using the in-scope namespace declarations for the <a href="#element-output"><code>xsl:output</code></a> declaration in which they appear, this list of names provides the value of the <code>suppress-indentation</code> parameter to the serialization method. In the case of an unprefixed name, the default namespace (that is, the namespace declared using <code>xmlns="uri"</code>) is used. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>This differs from the rule for most other QNames used in a stylesheet. The reason is that these names refer to elements in the result document, and therefore follow the same convention as the name of a literal result element or the <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a>.</p></div></li><li><p> The value of the <code>undeclare-prefixes</code> attribute provides the value of the <code>undeclare-prefixes</code> parameter to the serialization method. The default value is <code>no</code>.</p></li><li><p>The <code>use-character-maps</code> attribute provides a list of named character maps that are used in conjunction with this <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>. The way this attribute is used is described in <a href="#character-maps"><i>27.1 Character Maps</i></a>. The default value is an empty list.</p></li><li><p> The value of the <code>version</code> attribute provides the value of the <code>version</code> parameter to the serialization method. The set of permitted values, and the default value, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. A <a title="serialization error" class="termref" href="#dt-serialization-error">serialization error</a> will be reported if the requested version is not supported by the implementation. </p></li></ul><p>If the processor performs serialization, then it must signal any serialization errors that occur. These have the same effect as <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic errors</a>: that is, the processor must signal the error and must not finish as if the transformation had been successful.</p><div class="div2"><h3><a id="character-maps"></a>27.1 <a href="#character-maps" style="text-decoration: none">Character Maps</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-character-map" title="character map"></a>A <b>character map</b> allows a specific character appearing in a text or attribute node in the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be substituted by a specified string of characters during serialization.<span class="definition">]</span> The effect of character maps is defined in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>.</p><p>The character map that is supplied as a parameter to the serializer is determined from the <a href="#element-character-map"><code>xsl:character-map</code></a> elements referenced from the <a href="#element-output"><code>xsl:output</code></a> declaration for the selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>.</p><p>The <a href="#element-character-map"><code>xsl:character-map</code></a> element is a declaration that may appear as a child of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p><p class="element-syntax"><a id="element-character-map"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:character-map<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-output-character">xsl:output-character</a>*) --&gt;<br>&lt;/xsl:character-map&gt;</code></p><p>The <a href="#element-character-map"><code>xsl:character-map</code></a> declaration declares a character map with a name and a set of character mappings. The character mappings are specified by means of <a href="#element-output-character"><code>xsl:output-character</code></a> elements contained either directly within the <a href="#element-character-map"><code>xsl:character-map</code></a> element, or in further character maps referenced in the <code>use-character-maps</code> attribute.</p><p>The <span class="verb">required</span><code>name</code> attribute provides a name for the character map. When a character map is used by an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> or another character map, the character map with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p><p>The name of a character map is local to the <a title="package" class="termref" href="#dt-package">package</a> in which its declaration appears; it may be referenced only from within the same package.</p><p><a id="err-XTSE1580"><span class="error">[ERR XTSE1580] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains two or more character maps with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains another character map with the same name and higher import precedence. </p><p>The optional <code>use-character-maps</code> attribute lists the names of further character maps that are included into this character map.</p><p><a id="err-XTSE1590"><span class="error">[ERR XTSE1590] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a name in the <code>use-character-maps</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-character-map"><code>xsl:character-map</code></a> elements does not match the <code>name</code> attribute of any <a href="#element-character-map"><code>xsl:character-map</code></a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. </p><p><a id="err-XTSE1600"><span class="error">[ERR XTSE1600] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a character map references itself, directly or indirectly, via a name in the <code>use-character-maps</code> attribute. </p><p>It is not an error if the same character map is referenced more than once, directly or indirectly.</p><p>An <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>, after recursive expansion of character maps referenced via its <code>use-character-maps</code> attribute, may contain several mappings for the same character. In this situation, the last character mapping takes precedence. To establish the ordering, the following rules are used:</p><ul><li><p>Within a single <a href="#element-character-map"><code>xsl:character-map</code></a> element, the characters defined in character maps referenced in the <code>use-character-maps</code> attribute are considered before the characters defined in the child <a href="#element-output-character"><code>xsl:output-character</code></a> elements.</p></li><li><p>The character maps referenced in a single <code>use-character-maps</code> attribute are considered in the order in which they are listed in that attribute. The expansion is depth-first: each referenced character map is fully expanded before the next one is considered.</p></li><li><p>Two <a href="#element-output-character"><code>xsl:output-character</code></a> elements appearing as children of the same <a href="#element-character-map"><code>xsl:character-map</code></a> element are considered in document order.</p></li></ul><p>The <a href="#element-output-character"><code>xsl:output-character</code></a> element is defined as follows:</p><p class="element-syntax"><a id="element-output-character"></a><code>&lt;xsl:output-character<br>&nbsp;&nbsp;<b>character</b> = <var>char</var><br>&nbsp;&nbsp;<b>string</b> = <var>string</var>&nbsp;/&gt;</code></p><p>The character map that is passed as a parameter to the serializer contains a mapping for the character specified in the <code>character</code> attribute to the string specified in the <code>string</code> attribute. </p><p>Character mapping is not applied to characters for which output escaping has been disabled as described in <a href="#disable-output-escaping"><i>27.2 Disabling Output Escaping</i></a>.</p><p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p><div class="example"><div class="exampleHeader"><a id="d8e60377"></a><a id="d8e60509"></a>Example: Using Character Maps to Generate Non-XML Output</div><p>Character maps can be useful when producing serialized output in a format that resembles, but is not strictly conformant to, HTML or XML. For example, when the output is a JSP page, there might be a need to generate the output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">jsp:setProperty</span><span class="atn"> name</span><span class="atneq">=</span><span class="z">"</span><span class="av">user</span><span class="z">"</span><span class="atn"> property</span><span class="atneq">=</span><span class="z">"</span><span class="av">id</span><span class="z">"</span><span class="atn"> value</span><span class="atneq">=</span><span class="z">'</span><span class="av">&lt;%= "id" + idValue %&gt;</span><span class="z">'</span><span class="z">/&gt;</span></pre></div><p>Although this output is not well-formed XML or HTML, it is valid in Java Server Pages. This can be achieved by allocating three Unicode characters (which are not needed for any other purpose) to represent the strings <code>&lt;%</code>, <code>%&gt;</code>, and <code>"</code>, for example:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:character-map</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">jsp</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">«</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;lt;%</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">»</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">%&amp;gt;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">§</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">'</span><span class="av">"</span><span class="z">'</span><span class="sc">/&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="clxsl">xsl:character-map</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>When this character map is referenced in the <a href="#element-output"><code>xsl:output</code></a> declaration, the required output can be produced by writing the following in the stylesheet:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">jsp:setProperty</span><span class="atn"> name</span><span class="atneq">=</span><span class="z">"</span><span class="av">user</span><span class="z">"</span><span class="atn"> property</span><span class="atneq">=</span><span class="z">"</span><span class="av">id</span><span class="z">"</span><span class="atn"> value</span><span class="atneq">=</span><span class="z">'</span><span class="av">«= §id§ + idValue »</span><span class="z">'</span><span class="z">/&gt;</span></pre></div><p>This works on the assumption that when an apostrophe or quotation mark is generated as part of an attribute value by the use of character maps, the serializer will (where possible) use the other choice of delimiter around the attribute value.</p></div><p>&nbsp;</p><div class="example"><div class="exampleHeader"><a id="d8e60399"></a><a id="d8e60531"></a>Example: Constructing a Composite Character Map</div><p>The following example illustrates a composite character map constructed in a modular fashion:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:output</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">htmlDoc</span><span class="z">"</span><span class="z"></span><span class="atn">use-character-maps</span><span class="atneq">=</span><span class="z">"</span><span class="av">htmlDoc</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:character-map</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">htmlDoc</span><span class="z">"</span><span class="z"></span><span class="atn">use-character-maps</span><span class="atneq">=</span><span class="z">"</span><span class="av">html-chars doc-entities windows-format</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:character-map</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">html-chars</span><span class="z">"</span><span class="z"></span><span class="atn">use-character-maps</span><span class="atneq">=</span><span class="z">"</span><span class="av">latin1 ...</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:character-map</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">latin1</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#160;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;amp;nbsp;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#161;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;amp;iexcl;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="clxsl">xsl:character-map</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:character-map</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">doc-entities</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#xE400;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;amp;t-and-c;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#xE401;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;amp;chap1;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#xE402;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;amp;chap2;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="clxsl">xsl:character-map</span><span class="ec">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:character-map</span><span class="z"></span><span class="atn">name</span><span class="atneq">=</span><span class="z">"</span><span class="av">windows-format</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> newlines as CRLF </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#xA;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#xD;&amp;#xA;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> tabs as three spaces </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#x9;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av"></span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="z">&lt;!--</span><span class="cm"> images for special characters </span><span class="z">--&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#xF001;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;lt;img src='special1.gif' /&amp;gt;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:output-character</span><span class="z"></span><span class="atn">character</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;#xF002;</span><span class="z">"</span><span class="z"></span><span class="atn">string</span><span class="atneq">=</span><span class="z">"</span><span class="av">&amp;lt;img src='special2.gif' /&amp;gt;</span><span class="z">"</span><span class="sc">/&gt;</span><span class="txt"> ... </span><span class="ez">&lt;/</span><span class="clxsl">xsl:character-map</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><div class="note"><p class="prefix"><b>Note:</b></p><p>When character maps are used, there is no guarantee that the serialized output will be well-formed XML (or HTML). Furthermore, the fact that the result tree was validated against a schema gives no guarantee that the serialized output will still be valid against the same schema. Conversely, it is possible to use character maps to produce schema-valid output from a result tree that would fail validation.</p></div></div><div class="div2"><h3><a id="disable-output-escaping"></a>27.2 <a href="#disable-output-escaping" style="text-decoration: none">Disabling Output Escaping</a></h3><p>Normally, when using the XML, HTML, or XHTML output method, the serializer will escape special characters such as <code>&amp;</code> and <code>&lt;</code> when outputting text nodes. This ensures that the output is well-formed. However, it is sometimes convenient to be able to produce output that is almost, but not quite well-formed XML; for example, the output may include ill-formed sections which are intended to be transformed into well-formed XML by a subsequent non-XML-aware process. For this reason, XSLT defines a mechanism for disabling output escaping.</p><p>This feature is <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a>.</p><p>This is an optional feature: it is not <span class="verb">required</span> that an XSLT processor that implements the serialization option <span class="verb">should</span> offer the ability to disable output escaping, and there is no conformance level that requires this feature.</p><p>This feature requires the serializer (described in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>) to be extended as follows. Conceptually, the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> provides an additional boolean property <code>disable-escaping</code> associated with every character in a text node. When this property is set, the normal action of the serializer to escape special characters such as <code>&amp;</code> and <code>&lt;</code> is suppressed.</p><p>An <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> element may have a <code>disable-output-escaping</code> attribute; the allowed values are <code>yes</code> or <code>no</code>. The default is <code>no</code>; if the value is <code>yes</code>, then every character in the text node generated by evaluating the <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> element <span class="verb">should</span> have the <code>disable-escaping</code> property set.</p><div class="example"><div class="exampleHeader"><a id="d8e60464"></a><a id="d8e60596"></a>Example: Disable Output Escaping</div><p>For example,</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="z"></span><span class="atn">disable-output-escaping</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">&amp;lt;</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>should generate the single character <code>&lt;</code>.</p></div><p>If output escaping is disabled for an <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> instruction evaluated when <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a> is in effect, the request to disable output escaping is ignored.</p><p>Similarly, if an <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> instruction specifies that output escaping is to be disabled when writing to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> that is not being serialized, the request to disable output escaping is ignored.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>Furthermore, a request to disable output escaping has no effect when the newly constructed text node is used to form the value of an attribute, comment, processing instruction, or namespace node. This is because the rules for constructing such nodes (see <a href="#constructing-simple-content"><i>5.8.2 Constructing Simple Content</i></a>) cause the text node to be atomized, and the process of atomizing a text node takes no account of the disable-escaping property.</p></div><p>If output escaping is disabled for text within an element that would normally be output using a CDATA section, because the element is listed in the <code>cdata-section-elements</code>, then the relevant text will not be included in a CDATA section. In effect, CDATA is treated as an alternative escaping mechanism, which is disabled by the <code>disable-output-escaping</code> option.</p><div class="example"><div class="exampleHeader"><a id="d8e60503"></a><a id="d8e60635"></a>Example: Interaction of Output Escaping and CDATA</div><p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code> is specified, then the following instructions:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="enxsl">xsl:text</span><span class="z"></span><span class="atn">disable-output-escaping</span><span class="atneq">=</span><span class="z">"</span><span class="av">yes</span><span class="z">"</span><span class="scx">&gt;</span><span class="txt">This is not &amp;lt;hr/&amp;gt; good coding practice</span><span class="ez">&lt;/</span><span class="clxsl">xsl:text</span><span class="ec">&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span></pre></div><p>should generate the output:</p><div class="exampleInner"><pre class="spectrum"><span class="es">&lt;</span><span class="en">title</span><span class="scx">&gt;</span><span class="txt"></span><span class="z">&lt;![CDATA[</span><span class="cd">This is not </span><span class="z">]]&gt;</span><span class="txt"></span><span class="es">&lt;</span><span class="en">hr</span><span class="sc">/&gt;</span><span class="txt"></span><span class="z">&lt;![CDATA[</span><span class="cd"> good coding practice</span><span class="z">]]&gt;</span><span class="txt"></span><span class="ez">&lt;/</span><span class="cl">title</span><span class="ec">&gt;</span><span class="txt"></span></pre></div></div><p>The <code>disable-output-escaping</code> attribute may be used with the <code>html</code> output method as well as with the <code>xml</code> output method. The <code>text</code> output method ignores the <code>disable-output-escaping</code> attribute, since this method does not perform any output escaping.</p><p>A <a title="processor" class="termref" href="#dt-processor">processor</a> will only be able to disable output escaping if it controls how the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is output. This might not always be the case. For example, the result tree might be used as a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> for another XSLT transformation instead of being output. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether (and under what circumstances) disabling output escaping is supported. If disabling output escaping is not supported, any request to disable output escaping is ignored.</p><p>If output escaping is disabled for a character that is not representable in the encoding that the <a title="processor" class="termref" href="#dt-processor">processor</a> is using for output, the request to disable output escaping is ignored in respect of that character.</p><p>Since disabling output escaping might not work with all implementations and can result in XML that is not well-formed, it <span class="verb">should</span> be used only when there is no alternative.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>When disable-output-escaping is used, there is no guarantee that the serialized output will be well-formed XML (or HTML). Furthermore, the fact that the result tree was validated against a schema gives no guarantee that the serialized output will still be valid against the same schema. Conversely, it is possible to use disable-output-escaping to produce schema-valid output from a result tree that would fail validation.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The facility to define character maps for use during serialization, as described in <a href="#character-maps"><i>27.1 Character Maps</i></a>, has been produced as an alternative mechanism that can be used in many situations where disabling of output escaping was previously necessary, without the same difficulties.</p></div></div></div><div class="div1"><h2><a id="conformance"></a>28 <a href="#conformance" style="text-decoration: none">Conformance</a></h2><p>A <a title="processor" class="termref" href="#dt-processor">processor</a> that claims conformance with this specification <span class="verb">must</span> satisfy the conformance requirements for a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a> and for each of the optional features with which it claims conformance.</p><p>The following optional features are defined:</p><ol class="enumar"><li><p>The schema-awareness feature, defined in <a href="#schema-aware-conformance"><i>28.2 Schema-Awareness Conformance Feature</i></a></p></li><li><p>The serialization feature, defined in <a href="#serialization-feature"><i>28.3 Serialization Feature</i></a></p></li><li><p>The backwards compatibility feature, defined in <a href="#backwards-compatibility-feature"><i>28.4 Compatibility Features</i></a></p></li><li><p>The streaming feature, defined in <a href="#streaming-feature"><i>28.5 Streaming Feature</i></a>.</p></li><li><p>The dynamic evaluation feature, defined in <a href="#dynamic-evaluation-feature"><i>28.6 Dynamic Evaluation Feature</i></a>.</p></li></ol><p>A processor that does not claim conformance with an optional feature <span class="verb">must</span> satisfy the requirements for processors that do not implement that feature.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There is no conformance level or feature defined in this specification that requires implementation of the static typing features described in <a href="#xpath-30">[XPath 3.0]</a>. An XSLT processor may provide a user option to invoke static typing, but to be conformant with this specification it must allow a stylesheet to be processed with static typing disabled. The interaction of XSLT stylesheets with the static typing feature of XPath 3.0 has not been specified, so the results of using static typing, if available, are implementation-defined.</p></div><p>An XSLT processor takes as its inputs a stylesheet and zero or more XDM trees conforming to the data model defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>. It is not <span class="verb">required</span> that the processor supports any particular method of constructing XDM trees, but conformance can only be tested if it provides a mechanism that enables XDM trees representing the stylesheet and primary source document to be constructed and supplied as input to the processor.</p><p>The output of the XSLT processor consists of zero or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a>. It is not <span class="verb">required</span> that the processor supports any particular method of accessing a final result tree, but if it does not support the serialization feature, conformance can only be tested if it provides some alternative mechanism that enables access to the results of the transformation.</p><p>Certain facilities in this specification are described as producing <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> results. A claim that asserts conformance with this specification <span class="verb">must</span> be accompanied by documentation stating the effect of each implementation-defined feature. For convenience, a non-normative checklist of implementation-defined features is provided at <a href="#implementation-defined-features"><i>F Checklist of Implementation-Defined Features</i></a>.</p><p>A conforming <a title="processor" class="termref" href="#dt-processor">processor</a><span class="verb">must</span> signal any <a title="static error" class="termref" href="#dt-static-error">static error</a> occurring in the stylesheet, or in any XPath <a title="expression" class="termref" href="#dt-expression">expression</a>, except where specified otherwise either for individual error conditions or under the general provisions for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.10 Forwards Compatible Processing</i></a>). After signaling such an error, the processor <span class="verb">may</span> continue for the purpose of signaling additional errors, but <span class="verb">must</span> terminate abnormally without performing any transformation.</p><p>When a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during the course of a transformation, and is not caught using <a href="#element-catch"><code>xsl:catch</code></a>, the processor <span class="verb">must</span> signal it and <span class="verb">must</span> eventually terminate abnormally. </p><p>Some errors, notably <a title="type error" class="termref" href="#dt-type-error">type errors</a>, <span class="verb">may</span> be treated as <a title="static error" class="termref" href="#dt-static-error">static errors</a> or <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> at the discretion of the processor.</p><p>A conforming processor <span class="verb">may</span> impose limits on the processing resources consumed by the processing of a stylesheet.</p><p>The mandatory requirements of this specification are taken to include the mandatory requirements of <a href="#xpath-30">[XPath 3.0]</a>, <a href="#xpath-datamodel-30">[XDM 3.0]</a>, and <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. An XSLT 3.0 processor <span class="verb">must</span> provide a mode of operation which conforms to the 3.0 versions of those specifications as extended by <a href="#map"><i>21 Maps</i></a> and <a href="#json"><i>23 Processing JSON Data</i></a>.</p><p>A processor <span class="verb">may</span> also provide a mode of operation which conforms to versions of those specifications later than the 3.1 versions; in such cases the detail of how XSLT 3.0 interacts with new features introduced by such later versions (for example, extensions to the data model) is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p><p>A requirement is mandatory unless the specification includes wording (such as the use of the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates that it is optional.</p><p>Some of the optional features are defined in such a way that if the feature is not provided, the data model is constrained to exclude certain kinds of item. For example:</p><ul><li><p>A processor that does not provide the <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-awareness</a> feature restricts the data model so that it does not contain atomic values of types other than the built-in types, or nodes with non-trivial type annotations.</p></li></ul><p><a id="err-XTDE1665"><span class="error">[ERR XTDE1665] </span></a>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><span class="verb">may</span> be raised if the input to the processor includes an item that requires availability of an optional feature that the processor does not provide.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>It is not necessarily possible to trigger this error. A processor that does not provide an optional feature might not define or recognize any representation of the items that are disallowed. The error code is provided for use in cases where a processor is able to interoperate with other software that does not have the same constraints — for example, where a package compiled with a non-schema-aware processor is able to invoke functions in a package that was compiled with a schema-aware processor. Even in that case, processors have the option of filtering or converting the input so that it meets the relevant constraints: for example, a non-schema-aware processor when presented with a schema-validated document in the form of a PSVI might simply ignore the properties it does not understand.</p><p>The dynamic error is optional: for example a processor might report no error if the offending item is not actually used.</p><p>The phrase <em>input to the processor</em> is deliberately wide: it includes (inter alia) the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>, items present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, items passed as <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, items returned by functions such as <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>, items returned by <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> and <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, items supplied in function or template parameters or results across package boundaries, and nodes reachable from any of the above by axis navigation.</p></div><div class="div2"><h3><a id="basic-conformance"></a>28.1 <a href="#basic-conformance" style="text-decoration: none">Basic XSLT Processor</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-basic-xslt-processor" title="basic XSLT processor"></a>A <b>basic XSLT processor</b> is an XSLT processor that implements all the mandatory requirements of this specification with the exception of constructs explicitly associated with an optional feature.<span class="definition">]</span> These constructs are listed below.</p></div><div class="div2"><h3><a id="schema-aware-conformance"></a>28.2 <a href="#schema-aware-conformance" style="text-decoration: none">Schema-Awareness Conformance Feature</a></h3><p>A conformant processor <span class="verb">must</span> either be a conformant <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a> or a conformant <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a>.</p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-aware-xslt-processor" title="schema-aware XSLT processor"></a>A <b>schema-aware XSLT processor</b> is an XSLT processor that implements the mandatory requirements of this specification connected with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the ability to handle input documents whose nodes have type annotations other than <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory requirements of this specification are taken to include the mandatory requirements of XPath 3.0, as described in <a href="#xpath-30">[XPath 3.0]</a>. A requirement is mandatory unless the specification includes wording (such as the use of the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates that it is optional.<span class="definition">]</span></p><p><span class="definition">[Definition:&nbsp;</span><a id="dt-non-schema-aware-processor" title="non-schema-aware processor"></a>A <b>non-schema-aware processor</b> is a processor that does not claim conformance with the schema-aware conformance feature. Such a processor <span class="verb">must</span> handle constructs associated with schema-aware processing as described in this section.<span class="definition">]</span></p><p><a id="err-XTSE1650"><span class="error">[ERR XTSE1650] </span></a>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> signal a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration. </p><div class="note"><p class="prefix"><b>Note:</b></p><p>A processor that rejects an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration will also reject any reference to a user-defined type defined in a schema, or to a user-defined element or attribute declaration; it will not, however, reject references to the built-in types listed in <a href="#built-in-types"><i>3.14 Built-in Types</i></a>.</p></div><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a> is not able to validate input documents, and is not able to handle input documents containing type annotations other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code>. Therefore, such a processor <span class="verb">must</span> treat any <code>[xsl:]validation</code> attribute with a value of <code>preserve</code> or <code>lax</code>, or a <code>[xsl:]default-validation</code> attribute with a value of <code>preserve</code> as if the value were <code>strip</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The values <code>lax</code> and <code>preserve</code> indicate that the validation to be applied depends on the calling application, so it is appropriate for the request to be treated differently by different kinds of processor. By contrast, requesting <code>strict</code> validation, either through the <code>[xsl:]validation</code> attribute or the <code>type</code> attribute, indicates that the stylesheet is expecting to deal with typed data, and therefore cannot be processed without performing the validation.</p></div><p><a id="err-XTSE1660"><span class="error">[ERR XTSE1660] </span></a>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> signal a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or <code>[xsl:]default-validation</code> attribute with a value other than <code>strip</code>, <code>preserve</code>, or <code>lax</code>; or an <a href="#element-mode"><code>xsl:mode</code></a> element whose <code>typed</code> attribute is equal to <code>yes</code> or <code>strict</code>; or an <code>as</code> attribute whose value is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> that can only match nodes with a type annotation other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> (for example, <code>as="element(*, xs:integer)"</code>). </p><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a> constrains the data model as follows, and raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> (<span class="error">[see <a href="#err-XTDE1665">ERR XTDE1665</a>]</span>) if the constraints are not satisfied:</p><ul><li><p>Atomic values <span class="verb">must</span> belong to one of the atomic types listed in <a href="#built-in-types"><i>3.14 Built-in Types</i></a> (except as noted below).</p><p>An atomic value may also belong to an implementation-defined type that has been added to the context for use with <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>.</p><p>The set of constructor functions available are limited to those that construct values of the above atomic types.</p><p>The static context, which defines the full set of type names recognized by an XSLT processor and also by the XPath processor, includes these atomic types, plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>, <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p></li><li><p>Element nodes <span class="verb">must</span> be annotated with the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a><code>xs:untyped</code>, and attribute nodes with the type annotation <code>xs:untypedAtomic</code>.</p></li></ul></div><div class="div2"><h3><a id="serialization-feature"></a>28.3 <a href="#serialization-feature" style="text-decoration: none">Serialization Feature</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-serialization-feature" title="serialization feature"></a>A processor that claims conformance with the <b>serialization feature</b><span class="verb">must</span> support the conversion of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to a sequence of octets following the rules defined in <a href="#serialization"><i>27 Serialization</i></a>.<span class="definition">]</span> It <span class="verb">must</span> respect all the attributes of the <a href="#element-output"><code>xsl:output</code></a> and <a href="#element-character-map"><code>xsl:character-map</code></a> declarations, and <span class="verb">must</span> provide all four output methods, <code>xml</code>, <code>xhtml</code>, <code>html</code>, and <code>text</code>. Where the specification uses words such as <span class="verb">must</span> and <span class="verb">required</span>, then it <span class="verb">must</span> serialize the result tree in precisely the way described; in other cases it <span class="verb">may</span> use an alternative, equivalent representation.</p><p>A processor may claim conformance with the serialization feature whether or not it supports the setting <code>disable-output-escaping="yes"</code> on <a href="#element-text"><code>xsl:text</code></a>, or <a href="#element-value-of"><code>xsl:value-of</code></a>. </p><p>A processor that does not claim conformance with the serialization feature <span class="verb">must not</span> signal an error merely because the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> contains <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-character-map"><code>xsl:character-map</code></a> declarations, or serialization attributes on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction. Such a processor <span class="verb">may</span> check that these declarations and attributes have valid values, but is not <span class="verb">required</span> to do so. Apart from optional validation, these declarations <span class="verb">should</span> be ignored.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A processor that does not claim conformance with the serialization feature <span class="verb">may</span> offer alternative serialization capabilities, and these <span class="verb">may</span> make use of the serialization parameters defined on <a href="#element-output"><code>xsl:output</code></a> and/or <a href="#element-result-document"><code>xsl:result-document</code></a>. <span>Such a processor <span class="verb">may</span> implement selected parts of the serialization capabilities defined in this specification. For example, it may implement selected output methods, or selected serialization properties. It may implement sequence normalization using the <code>item-separator</code> property even if it has no other serialization capabilities. [XSLT 3.0 Erratum E14, bug 30208].</span></p></div><p>If the processor claims conformance with the serialization feature then it <span class="verb">must</span> fully implement the <a href="https://www.w3.org/TR/xpath-functions-30/#func-serialize"><code>serialize</code></a><sup><small>FO30</small></sup> function defined in <span><a href="#xpath-functions-40">[Functions and Operators 4.0]</a></span>, and <span class="verb">must not</span> raise error <a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFODC0010" title="FODC0010"><span class="error">[ERR FODC0010] </span></a><sup><small>FO40</small></sup> as the result of such a call.</p><p>If the processor does not claim conformance with the serialization feature, then it <span class="verb">may</span> raise error <a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFODC0010" title="FODC0010"><span class="error">[ERR FODC0010] </span></a><sup><small>FO40</small></sup> in respect of some or all calls on the <a href="https://www.w3.org/TR/xpath-functions-30/#func-serialize"><code>serialize</code></a><sup><small>FO30</small></sup> function; it <span class="verb">must not</span> return a result from a call on this function unless the result is conformant with the specification, given the parameters actually supplied. </p><p>A processor that claims conformance with the Serialization Feature must satisfy the mandatory requirements of <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a>. It <span class="verb">must</span> provide a mode of operation which conforms to the 3.0 version of that specification. It <span class="verb">may</span> also provide a mode of operation which conforms to a later version of that specification; in such cases the detail of how XSLT 3.0 interacts with new features introduced by such a version (for example, support for new serialization properties) is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p></div><div class="div2"><h3><a id="backwards-compatibility-feature"></a>28.4 <a href="#backwards-compatibility-feature" style="text-decoration: none">Compatibility Features</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-1.0-compatibility-feature" title="XSLT 1.0 compatibility feature"></a>A processor that claims conformance with the <b>XSLT 1.0 compatibility feature</b><span class="verb">must</span> support the processing of stylesheet instructions and XPath expressions with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>.<span class="definition">]</span></p><p>Note that a processor that does not claim conformance with the <a title="XSLT 1.0 compatibility feature" class="termref" href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a><span class="verb">must</span> raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if an instruction is evaluated whose <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is 1.0. <span class="error">[see <a href="#err-XTDE0160">ERR XTDE0160</a>]</span>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The reason this is a dynamic error rather than a static error is to allow stylesheets to contain conditional logic, following different paths depending on whether the XSLT processor implements XSLT 1.0, 2.0, or 3.0. The selection of which path to use can be controlled by using the <a href="#func-system-property"><code>system-property</code></a> function to test the <code>xsl:version</code> system property.</p></div><p>A processor that claims conformance with the <a title="XSLT 1.0 compatibility feature" class="termref" href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a><span class="verb">must</span> permit the use of the namespace axis in XPath expressions when backwards compatible behavior is enabled. In all other circumstances, support for the namespace axis is optional.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>There are no incompatibilities between 3.0 and 2.0 that would justify a 2.0-compatibility mode. When a 3.0 processor encounters a stylesheet that specifies <code>version="2.0"</code>, evaluation therefore proceeds exactly as if it specified <code>version="3.0"</code>. However, a software product may invoke an XSLT 2.0 processor in preference to an XSLT 3.0 processor when the stylesheet specifies <code>version="2.0"</code>, in which case any use of new 3.0 constructs will be rejected.</p></div></div><div class="div2"><h3><a id="streaming-feature"></a>28.5 <a href="#streaming-feature" style="text-decoration: none">Streaming Feature</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-streaming-feature" title="streaming feature"></a>A processor that claims conformance with the <b>streaming feature</b><span class="verb">must</span> use streamed processing in cases where (a) streaming is requested (for example by using the attribute <code>streamable="yes"</code> on <a href="#element-mode"><code>xsl:mode</code></a>, or on the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction) and (b) the constructs in question are <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> according to this specification.<span class="definition">]</span></p><p>A processor that does not claim conformance with the streaming feature is not required to use streamed processing and is not required to determine whether any construct is guaranteed streamable. Such a processor must, however, implement the semantics of all constructs in the language provided that enough memory is available to perform the processing without streaming.</p><p>A processor that conforms with the feature <span class="verb">must</span> return the value <code>"yes"</code> in response to the function call <code>system-property('xsl:supports-streaming')</code>; a processor that does not conform with the feature <span class="verb">must</span> return the value <code>"no"</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The term <em>streamed processing</em> as used here means the ability to process arbitrarily large input documents without ever-increasing memory requirements.</p></div></div><div class="div2"><h3><a id="dynamic-evaluation-feature"></a>28.6 <a href="#dynamic-evaluation-feature" style="text-decoration: none">Dynamic Evaluation Feature</a></h3><p><span class="definition">[Definition:&nbsp;</span><a id="dt-dynamic-evaluation-feature" title="dynamic evaluation feature"></a>A processor that claims conformance with the <b>dynamic evaluation feature</b><span class="verb">must</span> evaluate the <a href="#element-evaluate"><code>xsl:evaluate</code></a> function as described in this specification.<span class="definition">]</span></p><p>A processor that does not claim conformance with the dynamic evaluation feature <span class="verb">must</span> report a dynamic error if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated. It <span class="verb">must not</span> report a static error merely because of the presence of an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction in the stylesheet, unless a processor that conforms with the feature would report the same static error.</p><p>A processor that conforms with the feature <span class="verb">must</span> return the value <code>"yes"</code> in response to the function call <code>system-property('xsl:supports-dynamic-evaluation')</code>; a processor that does not conform with the feature <span class="verb">must</span> return the value <code>"no"</code>.</p><p>A processor that conforms with the feature <span class="verb">must</span> return the value <code>true</code> in response to the function call <code>element-available('xsl:evaluate')</code>; a processor that does not conform with the feature <span class="verb">must</span> return the value <code>false</code>.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>A processor may allow dynamic evaluation to be enabled and disabled by means of configuration settings, perhaps for security reasons. In consequence, it may be impossible to tell during static analysis of the stylesheet whether or not the feature will be available during execution. A stylesheet author wanting to check whether the feature is available should therefore make the test using a run-time call on <code>system-property</code>, rather than relying on tests in an <code>[xsl:]use-when</code> attribute.</p></div></div></div></div><div class="back"><div class="div1"><h2><a id="references"></a>A <a href="#references" style="text-decoration: none">References</a></h2><div class="div2"><h3><a id="normative-references"></a>A.1 <a href="#normative-references" style="text-decoration: none">Normative References</a></h3><dl><dt class="label"><span><a id="xpath-datamodel-30"></a>XDM 3.0</span></dt><dd><div><a href="https://www.w3.org/TR/xpath-datamodel-30/"><cite>XQuery and XPath Data Model (XDM) 3.0</cite></a>, Norman Walsh, Anders Berglund, John Snelson, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xpath-datamodel-30-20140408/. The <a href="https://www.w3.org/TR/xpath-datamodel-30/">latest version</a> is available at https://www.w3.org/TR/xpath-datamodel-30/.</div></dd><dt class="label"><span><a id="xpath-datamodel-31"></a>XDM 3.1</span></dt><dd><div><a href="https://www.w3.org/TR/xpath-datamodel-31/"><cite>XQuery and XPath Data Model (XDM) 3.1</cite></a>, Norman Walsh, John Snelson, Andrew Coleman, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xpath-datamodel-31-20170321/. The <a href="https://www.w3.org/TR/xpath-datamodel-31/">latest version</a> is available at https://www.w3.org/TR/xpath-datamodel-31/.</div></dd><dt class="label"><span><a id="xpath-datamodel-40"></a><span class="deltaxml-new" style="background:#90EE90">XDM 4.0</span></span></dt><dd><div><a href="https://qt4cg.org/specifications/xpath-datamodel-40/Overview.html"><cite><span class="deltaxml-new" style="background:#90EE90">XQuery and XPath Data Model (XDM) 4.0</span></cite></a><span class="deltaxml-new" style="background:#90EE90">, XSLT Extensions Community Group, World Wide Web Consortium.</span></div></dd><dt class="label"><span><a id="xpath-functions-30"></a>Functions and Operators 3.0</span></dt><dd><div><a href="https://www.w3.org/TR/xpath-functions-30/"><cite>XQuery and XPath Functions and Operators 3.0</cite></a>, Michael Kay, Editor. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xpath-functions-30-20140408/. The <a href="https://www.w3.org/TR/xpath-functions-30/">latest version</a> is available at https://www.w3.org/TR/xpath-functions-30/.</div></dd><dt class="label"><span><a id="xpath-functions-31"></a>Functions and Operators 3.1</span></dt><dd><div><a href="https://www.w3.org/TR/xpath-functions-31/"><cite>XQuery and XPath Functions and Operators 3.1</cite></a>, Michael Kay, Editor. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xpath-functions-31-20170321/. The <a href="https://www.w3.org/TR/xpath-functions-31/">latest version</a> is available at https://www.w3.org/TR/xpath-functions-31/.</div></dd><dt class="label"><span><a id="xpath-functions-40"></a>Functions and Operators 4.0</span></dt><dd><div><em>CITATION: T.B.D.</em></div></dd><dt class="label"><span><a id="xml-infoset"></a>XML Information Set</span></dt><dd><div><a href="http://www.w3.org/TR/xml-infoset/"><cite>XML Information Set (Second Edition)</cite></a>, John Cowan and Richard Tobin, Editors. World Wide Web Consortium, 04&nbsp;Feb&nbsp;2004. This version is http://www.w3.org/TR/2004/REC-xml-infoset-20040204. The <a href="http://www.w3.org/TR/xml-infoset">latest version</a> is available at http://www.w3.org/TR/xml-infoset.</div></dd><dt class="label"><span><a id="ISO15924"></a>ISO 15924</span></dt><dd><div>ISO (International Organization for Standardization) <em>Information and documentation — Codes for the representation of names of scripts</em> ISO 15924:2004, January 2004. See <a href="https://www.iso.org/obp/ui/#!iso:std:iso:15924:ed-1:v1:en">https://www.iso.org/obp/ui/#!iso:std:iso:15924:ed-1:v1:en</a>.</div></dd><dt class="label"><span><a id="ISO15924_register"></a>ISO 15924 Register</span></dt><dd><div>Unicode Consortium. <em>Codes for the representation of names of scripts — Alphabetical list of four-letter script codes.</em> See <a href="http://www.unicode.org/iso15924/iso15924-codes.html">http://www.unicode.org/iso15924/iso15924-codes.html</a>. Retrieved February 2013; continually updated.</div></dd><dt class="label"><span><a id="xslt-xquery-serialization-30"></a>XSLT and XQuery Serialization</span></dt><dd><div><a href="https://www.w3.org/TR/xslt-xquery-serialization-30/"><cite>XSLT and XQuery Serialization 3.0</cite></a>, Henry Zongaro, Andrew Coleman, Michael Sperberg-McQueen, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xslt-xquery-serialization-30-20140408/. The <a href="https://www.w3.org/TR/xslt-xquery-serialization-30/">latest version</a> is available at https://www.w3.org/TR/xslt-xquery-serialization-30/.</div></dd><dt class="label"><span><a id="xslt-xquery-serialization-31"></a>XSLT and XQuery Serialization 3.1</span></dt><dd><div><a href="https://www.w3.org/TR/xslt-xquery-serialization-31/"><cite>XSLT and XQuery Serialization 3.1</cite></a>, Andrew Coleman and Michael Sperberg-McQueen, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xslt-xquery-serialization-31-20170321/. The <a href="https://www.w3.org/TR/xslt-xquery-serialization-31/">latest version</a> is available at https://www.w3.org/TR/xslt-xquery-serialization-31/.</div></dd><dt class="label"><span><a id="rfc7159"></a>RFC 7159</span></dt><dd><div>IETF. <em>The JavaScript Object Notation (JSON) Data Interchange Format.</em> March 2014. See <a href="http://www.ietf.org/rfc/rfc7159.txt">http://www.ietf.org/rfc/rfc7159.txt</a></div></dd><dt class="label"><span><a id="UNICODE"></a>UNICODE</span></dt><dd><div>Unicode Consortium. <em>The Unicode Standard</em> as updated from time to time by the publication of new versions. See <a href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a> for the latest version and additional information on versions of the standard and of the Unicode Character Database. The version of Unicode to be used is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but implementations are recommended to use the latest Unicode version.</div></dd><dt class="label"><span><a id="UNICODE-TR10"></a>UNICODE TR10</span></dt><dd><div>Unicode Consortium. <em>Unicode Technical Standard #10. Unicode Collation Algorithm</em>. Unicode Technical Report. See <a href="http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a>.</div></dd><dt class="label"><span><a id="UNICODE-TR35"></a>UNICODE TR35</span></dt><dd><div>Unicode Consortium. <em>Unicode Technical Standard #35. Unicode Locale Data Markup Language</em>. Unicode Technical Report. See <a href="http://www.unicode.org/reports/tr35/">http://www.unicode.org/reports/tr35/</a>.</div></dd><dt class="label"><span><a id="REC-xml"></a>XML 1.0</span></dt><dd><div> World Wide Web Consortium. <em>Extensible Markup Language (XML) 1.0. W3C Recommendation.</em> See <a href="https://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml/</a>. The edition of XML 1.0 must be no earlier than the Third Edition; the edition used is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but we recommend that implementations use the latest version. </div></dd><dt class="label"><span><a id="xml11"></a>XML 1.1</span></dt><dd><div><a href="http://www.w3.org/TR/xml11/"><cite>Extensible Markup Language (XML) 1.1 (Second Edition)</cite></a>, Tim Bray, Jean Paoli, Michael Sperberg-McQueen, <em>et. al.</em>, Editors. World Wide Web Consortium, 16&nbsp;Aug&nbsp;2006. This version is http://www.w3.org/TR/2006/REC-xml11-20060816. The <a href="http://www.w3.org/TR/xml11/">latest version</a> is available at http://www.w3.org/TR/xml11/.</div></dd><dt class="label"><span><a id="xmlbase"></a>XML Base</span></dt><dd><div><a href="http://www.w3.org/TR/xmlbase/"><cite>XML Base (Second Edition)</cite></a>, Jonathan Marsh and Richard Tobin, Editors. World Wide Web Consortium, 28&nbsp;Jan&nbsp;2009. This version is http://www.w3.org/TR/2009/REC-xmlbase-20090128/. The <a href="http://www.w3.org/TR/xmlbase/">latest version</a> is available at http://www.w3.org/TR/xmlbase/.</div></dd><dt class="label"><span><a id="xml-id"></a>xml:id</span></dt><dd><div><a href="http://www.w3.org/TR/xml-id/"><cite>xml:id Version 1.0</cite></a>, Jonathan Marsh, Daniel Veillard, and Norman Walsh, Editors. World Wide Web Consortium, 09&nbsp;Sep&nbsp;2005. This version is http://www.w3.org/TR/2005/REC-xml-id-20050909/. The <a href="http://www.w3.org/TR/xml-id/">latest version</a> is available at http://www.w3.org/TR/xml-id/.</div></dd><dt class="label"><span><a id="xml-names"></a>Namespaces in XML</span></dt><dd><div><a href="http://www.w3.org/TR/xml-names/"><cite>Namespaces in XML 1.0 (Third Edition)</cite></a>, Tim Bray, Dave Hollander, Andrew Layman, <em>et. al.</em>, Editors. World Wide Web Consortium, 08&nbsp;Dec&nbsp;2009. This version is http://www.w3.org/TR/2009/REC-xml-names-20091208/. The <a href="http://www.w3.org/TR/xml-names/">latest version</a> is available at http://www.w3.org/TR/xml-names/.</div></dd><dt class="label"><span><a id="xml-names11"></a>Namespaces in XML 1.1</span></dt><dd><div><a href="http://www.w3.org/TR/xml-names11/"><cite>Namespaces in XML 1.1 (Second Edition)</cite></a>, Tim Bray, Dave Hollander, Andrew Layman, and Richard Tobin, Editors. World Wide Web Consortium, 16&nbsp;Aug&nbsp;2006. This version is http://www.w3.org/TR/2006/REC-xml-names11-20060816. The <a href="http://www.w3.org/TR/xml-names11/">latest version</a> is available at http://www.w3.org/TR/xml-names11/.</div></dd><dt class="label"><span><a id="xmlschema-1"></a>XML Schema Part 1</span></dt><dd><div><a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema Part 1: Structures Second Edition</cite></a>, Henry Thompson, David Beech, Murray Maloney, and Noah Mendelsohn, Editors. World Wide Web Consortium, 28&nbsp;Oct&nbsp;2004. This version is http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/. The <a href="http://www.w3.org/TR/xmlschema-1/">latest version</a> is available at http://www.w3.org/TR/xmlschema-1/.</div></dd><dt class="label"><span><a id="xmlschema-2"></a>XML Schema Part 2</span></dt><dd><div><a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2: Datatypes Second Edition</cite></a>, Paul V. Biron and Ashok Malhotra, Editors. World Wide Web Consortium, 28&nbsp;Oct&nbsp;2004. This version is http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href="http://www.w3.org/TR/xmlschema-2/">latest version</a> is available at http://www.w3.org/TR/xmlschema-2/.</div></dd><dt class="label"><span><a id="xmlschema11-1"></a>XML Schema 1.1 Part 1</span></dt><dd><div><a href="http://www.w3.org/TR/xmlschema11-1/"><cite>W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures</cite></a>, Sandy Gao, Michael Sperberg-McQueen, Henry Thompson, <em>et. al.</em>, Editors. World Wide Web Consortium, 05&nbsp;Apr&nbsp;2012. This version is http://www.w3.org/TR/2012/REC-xmlschema11-1-20120405/. The <a href="http://www.w3.org/TR/xmlschema11-1/">latest version</a> is available at http://www.w3.org/TR/xmlschema11-1/.</div></dd><dt class="label"><span><a id="xmlschema11-2"></a>XML Schema 1.1 Part 2</span></dt><dd><div><a href="http://www.w3.org/TR/xmlschema11-2/"><cite>W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</cite></a>, David Peterson, Sandy Gao, Ashok Malhotra, <em>et. al.</em>, Editors. World Wide Web Consortium, 05&nbsp;Apr&nbsp;2012. This version is http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/. The <a href="http://www.w3.org/TR/xmlschema11-2/">latest version</a> is available at http://www.w3.org/TR/xmlschema11-2/.</div></dd><dt class="label"><span><a id="xpath-30"></a>XPath 3.0</span></dt><dd><div><a href="https://www.w3.org/TR/xpath-30/"><cite>XML Path Language (XPath) 3.0</cite></a>, Jonathan Robie, Don Chamberlin, Michael Dyck, John Snelson, Editors. World Wide Web Consortium, 08 April 2014. This version is https://www.w3.org/TR/2014/REC-xpath-30-20140408/. The <a href="https://www.w3.org/TR/xpath-30/">latest version</a> is available at https://www.w3.org/TR/xpath-30/.</div></dd><dt class="label"><span><a id="xpath-31"></a>XPath 3.1</span></dt><dd><div><a href="https://www.w3.org/TR/xpath-31/"><cite>XML Path Language (XPath) 3.1</cite></a>, Jonathan Robie, Michael Dyck and Josh Spiegel, Editors. World Wide Web Consortium, 21 March 2017. This version is https://www.w3.org/TR/2017/REC-xpath-31-20170321/. The <a href="https://www.w3.org/TR/xpath-31/">latest version</a> is available at https://www.w3.org/TR/xpath-31/.</div></dd><dt class="label"><span><a id="xpath-40"></a>XPath 4.0</span></dt><dd><div><em>CITATION: T.B.D.</em></div></dd><dt class="label"><span><a id="XSLT-Mime-Type"></a>XSLT Media Type</span></dt><dd><div>World Wide Web Consortium. <em>Registration of MIME Media Type application/xslt+xml</em>. In <a href="https://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration">Appendix B.1 of the XSLT 2.0 specification.</a></div></dd></dl></div><div class="div2"><h3><a id="other-references"></a>A.2 <a href="#other-references" style="text-decoration: none">Other References</a></h3><dl><dt class="label"><span><a id="CLDR"></a>Unicode CLDR</span></dt><dd><div>CLDR - Unicode Common Locale Data Repository. Available at: <a href="http://cldr.unicode.org">http://cldr.unicode.org</a></div></dd><dt class="label"><span><a id="DOM-Level-2-Core"></a>DOM Level 2</span></dt><dd><div><a href="http://www.w3.org/TR/DOM-Level-2-Core/"><cite>Document Object Model (DOM) Level 2 Core Specification</cite></a>, Arnaud Le Hors, Philippe Le Hégaret, Lauren Wood, <em>et. al.</em>, Editors. World Wide Web Consortium, 13&nbsp;Nov&nbsp;2000. This version is http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113. The <a href="http://www.w3.org/TR/DOM-Level-2-Core/">latest version</a> is available at http://www.w3.org/TR/DOM-Level-2-Core/.</div></dd><dt class="label"><span><a id="ECMA-404"></a>ECMA-404</span></dt><dd><div> ECMA International. <em>The JSON Data Interchange Format</em> October 2013. See <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf</a>. </div></dd><dt class="label"><span><a id="ICU"></a>ICU</span></dt><dd><div>ICU - International Components for Unicode. Available at <a href="http://site.icu-project.org">http://site.icu-project.org</a></div></dd><dt class="label"><span><a id="rfc2119"></a>RFC2119</span></dt><dd><div>S. Bradner. <em>Key words for use in RFCs to Indicate Requirement Levels</em>. IETF RFC 2119. See <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div></dd><dt class="label"><span><a id="RFC3986"></a>RFC3986</span></dt><dd><div> T. Berners-Lee, R. Fielding, and L. Masinter. <em>Uniform Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986. See <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div></dd><dt class="label"><span><a id="RFC3987"></a>RFC3987</span></dt><dd><div>M. Duerst, M. Suignard. <em>Internationalized Resource Identifiers (IRIs)</em>. IETF RFC 3987. See <a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div></dd><dt class="label"><span><a id="RFC4647"></a>RFC4647</span></dt><dd><div>A. Phillips and M. Davis. <em>Matching of Language Tags</em>. IETF RFC 4647. See <a href="http://www.ietf.org/rfc/rfc4647.txt">http://www.ietf.org/rfc/rfc4647.txt</a>.</div></dd><dt class="label"><span><a id="rfc7303"></a>RFC7303</span></dt><dd><div>H. Thompson and C. Lilley. <em>XML Media Types</em>. IETF RFC 7303. See <a href="http://www.ietf.org/rfc/rfc7303.txt">http://www.ietf.org/rfc/rfc7303.txt</a></div></dd><dt class="label"><span><a id="SemVer"></a>SemVer</span></dt><dd><div>Tom Preston-Werner, <em>Semantic Versioning 2.0.0</em>. See <a href="http://semver.org/">http://semver.org/</a>. Undated (retrieved 1 August 2014).</div></dd><dt class="label"><span><a id="STX"></a>STX</span></dt><dd><div>Petr Cimprich <em>et al</em>, <em>Streaming Transformations for XML (STX) Version 1.0</em>. Working Draft 27 April 2007. See <a href="http://stx.sourceforge.net/documents/spec-stx-20070427.html">http://stx.sourceforge.net/documents/spec-stx-20070427.html</a></div></dd><dt class="label"><span><a id="xlink"></a>XLink</span></dt><dd><div><a href="http://www.w3.org/TR/xlink/"><cite>XML Linking Language (XLink) Version 1.0</cite></a>, Steven DeRose, Eve Maler, and David Orchard, Editors. World Wide Web Consortium, 27&nbsp;Jun&nbsp;2001. This version is http://www.w3.org/TR/2001/REC-xlink-20010627/. The <a href="http://www.w3.org/TR/xlink/">latest version</a> is available at http://www.w3.org/TR/xlink/.</div></dd><dt class="label"><span><a id="SCHEMA-AND-XML-1.1"></a>XML Schema 1.0 and XML 1.1</span></dt><dd><div>World Wide Web Consortium. <em>Processing XML 1.1 documents with XML Schema 1.0 processors</em>. W3C Working Group Note 11 May 2005. See <a href="https://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/">https://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/</a></div></dd><dt class="label"><span><a id="xml-stylesheet"></a>XML Stylesheet</span></dt><dd><div><a href="http://www.w3.org/TR/xml-stylesheet"><cite>Associating Style Sheets with XML documents 1.0 (Second Edition)</cite></a>, James Clark, Simon Pieters, and Henry Thompson, Editors. World Wide Web Consortium, 28&nbsp;Oct&nbsp;2010. This version is http://www.w3.org/TR/2010/REC-xml-stylesheet-20101028. The <a href="http://www.w3.org/TR/xml-stylesheet">latest version</a> is available at http://www.w3.org/TR/xml-stylesheet.</div></dd><dt class="label"><span><a id="xptr-framework"></a>XPointer Framework</span></dt><dd><div><a href="http://www.w3.org/TR/xptr-framework/"><cite>XPointer Framework</cite></a>, Paul Grosso, Eve Maler, Jonathan Marsh, and Norman Walsh, Editors. World Wide Web Consortium, 25&nbsp;Mar&nbsp;2003. This version is http://www.w3.org/TR/2003/REC-xptr-framework-20030325/. The <a href="http://www.w3.org/TR/xptr-framework/">latest version</a> is available at http://www.w3.org/TR/xptr-framework/.</div></dd><dt class="label"><span><a id="xsl11"></a>XSL-FO</span></dt><dd><div><a href="http://www.w3.org/TR/xsl11/"><cite>Extensible Stylesheet Language (XSL) Version 1.1</cite></a>, Anders Berglund, Editor. World Wide Web Consortium, 05&nbsp;Dec&nbsp;2006. This version is http://www.w3.org/TR/2006/REC-xsl11-20061205/. The <a href="http://www.w3.org/TR/xsl11/">latest version</a> is available at http://www.w3.org/TR/xsl11/.</div></dd><dt class="label"><span><a id="xslt"></a>XSLT 1.0</span></dt><dd><div><a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations (XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999. This version is http://www.w3.org/TR/1999/REC-xslt-19991116. The <a href="http://www.w3.org/TR/xslt">latest version</a> is available at http://www.w3.org/TR/xslt.</div></dd><dt class="label"><span><a id="xslt20"></a>XSLT 2.0</span></dt><dd><div><a href="https://www.w3.org/TR/xslt20/"><cite>XSL Transformations (XSLT) Version 2.0 (Second Edition)</cite></a>, Michael Kay, Editor. World Wide Web Consortium, 23 January 2007. This version is https://www.w3.org/TR/2007/REC-xslt20-20070123/. The <a href="https://www.w3.org/TR/xslt20/">latest version</a> is available at https://www.w3.org/TR/xslt20/.</div></dd><dt class="label"><span><a id="xslt-30"></a>XSLT 3.0</span></dt><dd><div><a href="https://www.w3.org/TR/xslt-30/"><cite>XSL Transformations (XSLT) Version 3.0</cite></a>, Michael Kay, Editor. World Wide Web Consortium, 7 February 2017. This version is https://www.w3.org/TR/2017/CR-xslt-30-20170207/. The <a href="https://www.w3.org/TR/xslt-30/">latest version</a> is available at https://www.w3.org/TR/xslt-30/.</div></dd></dl></div></div><div class="div1"><h2><a id="json-in-xml"></a>B <a href="#json-in-xml" style="text-decoration: none">XML Representation of JSON</a></h2><p>This appendix contains the schema for the XML representation of JSON described in <a href="#json-to-xml-mapping"><i>23.1 XML Representation of JSON</i></a>, together with the stylesheets used for converting from this XML representation to strings matching the JSON grammar.</p><p>These schema documents and stylesheets are also available as separate resources (links are listed at the top of this document).</p><div class="div2"><h3><a id="schema-for-json"></a>B.1 <a href="#schema-for-json" style="text-decoration: none">Schema for the XML Representation of JSON</a></h3><p>The schema is reproduced below:</p><pre class="small">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" elementFormDefault="qualified" targetNamespace="http://www.w3.org/2005/xpath-functions" xmlns:j="http://www.w3.org/2005/xpath-functions"&gt; &lt;!-- * This is a schema for the XML representation of JSON used as the target for the * function fn:json-to-xml() * * The schema is made available under the terms of the W3C software notice and license * at http://www.w3.org/Consortium/Legal/copyright-software-19980720 * --&gt; &lt;xs:element name="map" type="j:mapType"&gt; &lt;xs:unique name="unique-key"&gt; &lt;xs:selector xpath="*"/&gt; &lt;xs:field xpath="@key"/&gt; &lt;xs:field xpath="@escaped-key"/&gt; &lt;/xs:unique&gt; &lt;/xs:element&gt; &lt;xs:element name="array" type="j:arrayType"/&gt; &lt;xs:element name="string" type="j:stringType"/&gt; &lt;xs:element name="number" type="j:numberType"/&gt; &lt;xs:element name="boolean" type="xs:boolean"/&gt; &lt;xs:element name="null" type="j:nullType"/&gt; &lt;xs:complexType name="nullType"&gt; &lt;xs:sequence/&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="stringType"&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base="xs:string"&gt; &lt;xs:attribute name="escaped" type="xs:boolean" use="optional" default="false"/&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;xs:simpleType name="numberType"&gt; &lt;xs:restriction base="xs:double"&gt; &lt;!-- exclude positive and negative infinity, and NaN --&gt; &lt;xs:minExclusive value="-INF"/&gt; &lt;xs:maxExclusive value="INF"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:complexType name="arrayType"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="j:map"/&gt; &lt;xs:element ref="j:array"/&gt; &lt;xs:element ref="j:string"/&gt; &lt;xs:element ref="j:number"/&gt; &lt;xs:element ref="j:boolean"/&gt; &lt;xs:element ref="j:null"/&gt; &lt;/xs:choice&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="mapType"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element name="map"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="j:mapType"&gt; &lt;xs:attribute name="key" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:unique name="unique-key-2"&gt; &lt;xs:selector xpath="*"/&gt; &lt;xs:field xpath="@key"/&gt; &lt;/xs:unique&gt; &lt;/xs:element&gt; &lt;xs:element name="array"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="j:arrayType"&gt; &lt;xs:attributeGroup ref="j:key-group"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="string"&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base="j:stringType"&gt; &lt;xs:attributeGroup ref="j:key-group"/&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="number"&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base="j:numberType"&gt; &lt;xs:attributeGroup ref="j:key-group"/&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="boolean"&gt; &lt;xs:complexType&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base="xs:boolean"&gt; &lt;xs:attributeGroup ref="j:key-group"/&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="null"&gt; &lt;xs:complexType&gt; &lt;xs:attributeGroup ref="j:key-group"/&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;/xs:choice&gt; &lt;/xs:complexType&gt; &lt;xs:attributeGroup name="key-group"&gt; &lt;xs:attribute name="key" type="xs:string" use="required"/&gt; &lt;xs:attribute name="escaped-key" type="xs:boolean" use="optional" default="false"/&gt; &lt;/xs:attributeGroup&gt; &lt;/xs:schema&gt; </pre></div><div class="div2"><h3><a id="xml-to-json-stylesheet"></a>B.2 <a href="#xml-to-json-stylesheet" style="text-decoration: none">Stylesheet for converting XML to JSON</a></h3><p>This stylesheet contains the implementation of a function very similar to <a href="#func-xml-to-json"><code>xml-to-json</code></a>, but implemented in XSLT so that it can be customized and extended. This stylesheet is provided for the benefit of users and there are no conformance requirements associated with it; there is no requirement that processors should make this stylesheet available. The stylesheet is reproduced below:</p><pre class="small">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!-- * This is a stylesheet for converting XML to JSON. * It expects the XML to be in the format produced by the XSLT 3.0 function * fn:json-to-xml(), but is designed to be highly customizable. * * The stylesheet is made available under the terms of the W3C software notice and license * at http://www.w3.org/Consortium/Legal/copyright-software-19980720 * --&gt; &lt;xsl:package name="http://www.w3.org/2013/XSLT/xml-to-json" package-version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:fn="http://www.w3.org/2005/xpath-functions" xmlns:j="http://www.w3.org/2013/XSLT/xml-to-json" exclude-result-prefixes="xs fn j" default-mode="j:xml-to-json" version="3.0"&gt; &lt;xsl:variable name="quot" visibility="private"&gt;"&lt;/xsl:variable&gt; &lt;xsl:param name="indent-spaces" select="2"/&gt; &lt;!-- The static parameter STREAMABLE controls whether the stylesheet is declared as streamable --&gt; &lt;xsl:param name="STREAMABLE" static="yes" as="xs:boolean" select="true()"/&gt; &lt;xsl:mode name="j:xml-to-json"/&gt; &lt;!-- fixes erratum E30 for bug 30288 --&gt; &lt;xsl:mode name="indent" _streamable="{$STREAMABLE}" visibility="public"/&gt; &lt;xsl:mode name="no-indent" _streamable="{$STREAMABLE}" visibility="public"/&gt; &lt;xsl:mode name="key-attribute" streamable="false" on-no-match="fail" visibility="public"/&gt; &lt;!-- The static parameter VALIDATE controls whether the input, if untyped, should be validated --&gt; &lt;xsl:param name="VALIDATE" static="yes" as="xs:boolean" select="false()"/&gt; &lt;xsl:import-schema namespace="http://www.w3.org/2005/xpath-functions" use-when="$VALIDATE"/&gt; &lt;!-- Entry point: function to convert a supplied XML node to a JSON string --&gt; &lt;xsl:function name="j:xml-to-json" as="xs:string" visibility="public"&gt; &lt;xsl:param name="input" as="node()"/&gt; &lt;xsl:sequence select="j:xml-to-json($input, map{})"/&gt; &lt;/xsl:function&gt; &lt;!-- Entry point: function to convert a supplied XML node to a JSON string, supplying options --&gt; &lt;xsl:function name="j:xml-to-json" as="xs:string" visibility="public"&gt; &lt;xsl:param name="input" as="node()"/&gt; &lt;xsl:param name="options" as="map(*)"/&gt; &lt;xsl:variable name="input" as="node()" use-when="$VALIDATE"&gt; &lt;xsl:copy-of select="$input" validation="strict"/&gt; &lt;/xsl:variable&gt; &lt;xsl:choose&gt; &lt;xsl:when test="$options('indent') eq true()"&gt; &lt;xsl:apply-templates select="$input" mode="indent"&gt; &lt;xsl:with-param name="fallback" as="(function(element()) as xs:string)?" select="$options('fallback')" tunnel="yes"/&gt; &lt;/xsl:apply-templates&gt; &lt;/xsl:when&gt; &lt;xsl:otherwise&gt; &lt;xsl:apply-templates select="$input" mode="no-indent"&gt; &lt;xsl:with-param name="fallback" as="(function(element()) as xs:string)?" select="$options('fallback')" tunnel="yes"/&gt; &lt;/xsl:apply-templates&gt; &lt;/xsl:otherwise&gt; &lt;/xsl:choose&gt; &lt;/xsl:function&gt; &lt;!-- A document node is ignored --&gt; &lt;xsl:template match="/" mode="indent no-indent"&gt; &lt;xsl:apply-templates mode="#current"/&gt; &lt;/xsl:template&gt; &lt;!-- Template rule for fn:map elements, representing JSON objects --&gt; &lt;xsl:template match="fn:map" mode="indent"&gt; &lt;xsl:value-of&gt; &lt;xsl:variable name="depth" select="count(ancestor::*) + 1"/&gt; &lt;xsl:text&gt;{&lt;/xsl:text&gt; &lt;xsl:for-each select="*"&gt; &lt;xsl:if test="position() gt 1"&gt; &lt;xsl:text&gt;, &lt;/xsl:text&gt; &lt;xsl:value-of select="j:indent($depth)"/&gt; &lt;/xsl:if&gt; &lt;xsl:apply-templates select="snapshot(@key)" mode="key-attribute"/&gt; &lt;xsl:text&gt; : &lt;/xsl:text&gt; &lt;xsl:apply-templates select="." mode="#current"/&gt; &lt;/xsl:for-each&gt; &lt;xsl:text&gt;}&lt;/xsl:text&gt; &lt;/xsl:value-of&gt; &lt;/xsl:template&gt; &lt;xsl:template match="fn:map" mode="no-indent"&gt; &lt;xsl:value-of&gt; &lt;xsl:text&gt;{&lt;/xsl:text&gt; &lt;xsl:for-each select="*"&gt; &lt;xsl:if test="position() gt 1"&gt; &lt;xsl:text&gt;,&lt;/xsl:text&gt; &lt;/xsl:if&gt; &lt;xsl:apply-templates select="snapshot(@key)" mode="key-attribute"/&gt; &lt;xsl:text&gt;:&lt;/xsl:text&gt; &lt;xsl:apply-templates select="." mode="#current"/&gt; &lt;/xsl:for-each&gt; &lt;xsl:text&gt;}&lt;/xsl:text&gt; &lt;/xsl:value-of&gt; &lt;/xsl:template&gt; &lt;!-- Template rule for fn:array elements, representing JSON arrays --&gt; &lt;xsl:template match="fn:array" mode="indent"&gt; &lt;xsl:value-of&gt; &lt;xsl:variable name="depth" select="count(ancestor::*) + 1"/&gt; &lt;xsl:text&gt;[&lt;/xsl:text&gt; &lt;xsl:for-each select="*"&gt; &lt;xsl:if test="position() gt 1"&gt; &lt;xsl:text&gt;, &lt;/xsl:text&gt; &lt;xsl:value-of select="j:indent($depth)"/&gt; &lt;/xsl:if&gt; &lt;xsl:apply-templates select="." mode="#current"/&gt; &lt;/xsl:for-each&gt; &lt;xsl:text&gt;]&lt;/xsl:text&gt; &lt;/xsl:value-of&gt; &lt;/xsl:template&gt; &lt;xsl:template match="fn:array" mode="no-indent"&gt; &lt;xsl:value-of&gt; &lt;xsl:text&gt;[&lt;/xsl:text&gt; &lt;xsl:for-each select="*"&gt; &lt;xsl:if test="position() gt 1"&gt; &lt;xsl:text&gt;,&lt;/xsl:text&gt; &lt;/xsl:if&gt; &lt;xsl:apply-templates select="." mode="#current"/&gt; &lt;/xsl:for-each&gt; &lt;xsl:text&gt;]&lt;/xsl:text&gt; &lt;/xsl:value-of&gt; &lt;/xsl:template&gt; &lt;!-- Template rule for fn:string elements in which special characters are already escaped --&gt; &lt;xsl:template match="fn:string[@escaped='true']" mode="indent no-indent"&gt; &lt;xsl:sequence select="concat($quot, ., $quot)"/&gt; &lt;/xsl:template&gt; &lt;!-- Template rule for fn:string elements in which special characters need to be escaped --&gt; &lt;xsl:template match="fn:string[not(@escaped='true')]" mode="indent no-indent"&gt; &lt;xsl:sequence select="concat($quot, j:escape(.), $quot)"/&gt; &lt;/xsl:template&gt; &lt;!-- Template rule for fn:boolean elements --&gt; &lt;xsl:template match="fn:boolean" mode="indent no-indent"&gt; &lt;xsl:sequence select="xs:string(xs:boolean(.))"/&gt; &lt;/xsl:template&gt; &lt;!-- Template rule for fn:number elements --&gt; &lt;xsl:template match="fn:number" mode="indent no-indent"&gt; &lt;xsl:value-of select="xs:string(xs:double(.))"/&gt; &lt;/xsl:template&gt; &lt;!-- Template rule for JSON null elements --&gt; &lt;xsl:template match="fn:null" mode="indent no-indent"&gt; &lt;xsl:text&gt;null&lt;/xsl:text&gt; &lt;/xsl:template&gt; &lt;!-- Template rule matching a key within a map where special characters in the key are already escaped --&gt; &lt;xsl:template match="fn:*[@key-escaped='true']/@key" mode="key-attribute"&gt; &lt;xsl:value-of select="concat($quot, ., $quot)"/&gt; &lt;/xsl:template&gt; &lt;!-- Template rule matching a key within a map where special characters in the key need to be escaped --&gt; &lt;xsl:template match="fn:*[not(@key-escaped='true')]/@key" mode="key-attribute"&gt; &lt;xsl:value-of select="concat($quot, j:escape(.), $quot)"/&gt; &lt;/xsl:template&gt; &lt;!-- Template matching "invalid" elements --&gt; &lt;xsl:template match="*" mode="indent no-indent"&gt; &lt;xsl:param name="fallback" as="(function(element()) as xs:string)?" tunnel="yes" required="yes"/&gt; &lt;xsl:choose&gt; &lt;xsl:when test="exists($fallback)"&gt; &lt;xsl:value-of select="$fallback(snapshot(.))"/&gt; &lt;/xsl:when&gt; &lt;xsl:otherwise&gt; &lt;xsl:message terminate="yes"&gt;&gt;Inc&lt;/xsl:message&gt; &lt;/xsl:otherwise&gt; &lt;/xsl:choose&gt; &lt;/xsl:template&gt; &lt;!-- Template rule matching (and discarding) whitespace text nodes in the XML --&gt; &lt;xsl:template match="text()[not(normalize-space())]" mode="indent no-indent"/&gt; &lt;!-- Function to escape special characters --&gt; &lt;xsl:function name="j:escape" as="xs:string" visibility="final"&gt; &lt;xsl:param name="in" as="xs:string"/&gt; &lt;xsl:value-of&gt; &lt;xsl:for-each select="string-to-codepoints($in)"&gt; &lt;xsl:choose&gt; &lt;xsl:when test=". gt 65535"&gt; &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) idiv 1024 + 55296))"/&gt; &lt;xsl:value-of select="concat('\u', j:hex4((. - 65536) mod 1024 + 56320))"/&gt; &lt;/xsl:when&gt; &lt;xsl:when test=". = 34"&gt;\"&lt;/xsl:when&gt; &lt;xsl:when test=". = 92"&gt;\\&lt;/xsl:when&gt; &lt;xsl:when test=". = 08"&gt;\b&lt;/xsl:when&gt; &lt;xsl:when test=". = 09"&gt;\t&lt;/xsl:when&gt; &lt;xsl:when test=". = 10"&gt;\n&lt;/xsl:when&gt; &lt;xsl:when test=". = 12"&gt;\f&lt;/xsl:when&gt; &lt;xsl:when test=". = 13"&gt;\r&lt;/xsl:when&gt; &lt;xsl:when test=". lt 32 or (. ge 127 and . le 160)"&gt; &lt;xsl:value-of select="concat('\u', j:hex4(.))"/&gt; &lt;/xsl:when&gt; &lt;xsl:otherwise&gt; &lt;xsl:value-of select="codepoints-to-string(.)"/&gt; &lt;/xsl:otherwise&gt; &lt;/xsl:choose&gt; &lt;/xsl:for-each&gt; &lt;/xsl:value-of&gt; &lt;/xsl:function&gt; &lt;!-- Function to convert a UTF16 codepoint into a string of four hex digits --&gt; &lt;xsl:function name="j:hex4" as="xs:string" visibility="final"&gt; &lt;xsl:param name="ch" as="xs:integer"/&gt; &lt;xsl:variable name="hex" select="'0123456789abcdef'"/&gt; &lt;xsl:value-of&gt; &lt;xsl:value-of select="substring($hex, $ch idiv 4096 + 1, 1)"/&gt; &lt;xsl:value-of select="substring($hex, $ch idiv 256 mod 16 + 1, 1)"/&gt; &lt;xsl:value-of select="substring($hex, $ch idiv 16 mod 16 + 1, 1)"/&gt; &lt;xsl:value-of select="substring($hex, $ch mod 16 + 1, 1)"/&gt; &lt;/xsl:value-of&gt; &lt;/xsl:function&gt; &lt;!-- Function to output whitespace indentation based on the depth of the node supplied as a parameter --&gt; &lt;xsl:function name="j:indent" as="text()" visibility="public"&gt; &lt;xsl:param name="depth" as="xs:integer"/&gt; &lt;xsl:value-of select="'&amp;#xa;', string-join((1 to ($depth + 1) * $indent-spaces) ! ' ', '')"/&gt; &lt;/xsl:function&gt; &lt;/xsl:package&gt; </pre></div></div><div class="div1"><h2><a id="glossary"></a>C Glossary (Non-Normative)</h2><dl><dt><a href="#dt-absent">absent</a></dt><dd><p>A component of the context that has no value is said to be <b>absent</b>.</p></dd><dt><a href="#dt-absorption">absorption</a></dt><dd><p>An operand usage of <b>absorption</b> indicates that the construct reads the subtree(s) rooted at a supplied node(s).</p></dd><dt><a href="#dt-accumulator">accumulator</a></dt><dd><p>An <b>accumulator</b> defines a series of values associated with the nodes of the tree. If an accumulator is applicable to a particular tree, then for each node in the tree, other than attribute and namespace nodes, there will be two values available, called the pre-descent and post-descent values. These two values are available via a pair of functions, <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>.</p></dd><dt><a href="#dt-accumulator-function">accumulator function</a></dt><dd><p>The functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a> are referred to as the <b>accumulator functions</b>.</p></dd><dt><a href="#dt-alias">alias</a></dt><dd><p>A stylesheet can use the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is being used as an <b>alias</b> for a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>.</p></dd><dt><a href="#dt-applicable">applicable</a></dt><dd><p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is <b>applicable</b> to one or more modes. The modes to which it is applicable are defined by the <code>mode</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element. If the attribute is omitted, then the template rule is applicable to the default mode specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing element that has such an attribute, which in turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. If the <code>mode</code> attribute is present, then its value <span class="verb">must</span> be a non-empty whitespace-separated list of tokens, each of which defines a mode to which the template rule is applicable.</p></dd><dt><a href="#dt-arity-range">arity range</a></dt><dd><p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> has an <b>arity range</b> which defines the minimum and maximum number of arguments that must be supplied in a call to the function. The static context can contain multiple <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> with the same name, provided that their <b>arity ranges</b> do not overlap.</p></dd><dt><a href="#dt-atomization">atomize</a></dt><dd><p>The term <b>atomization</b> is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-atomization">Section 2.5.2 Atomization</a><sup><small>XP40</small></sup>. It is a process that takes as input a sequence of items, and returns a sequence of atomic values, in which the nodes are replaced by their typed values as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>. Arrays (see <a href="#arrays"><i>22 Arrays</i></a>) are atomized by atomizing their members, recursively.</p></dd><dt><a href="#dt-attribute-set">attribute set</a></dt><dd><p>An <b>attribute set</b> is defined as a set of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#dt-attribute-set-invocation">attribute set invocation</a></dt><dd><p>An <b>attribute set invocation</b> is a pseudo-instruction corresponding to a single EQName appearing within an <code>[xsl:]use-attribute-sets</code> attribute; the effect of the pseudo-instruction is to cause the referenced <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to be evaluated.</p></dd><dt><a href="#dt-attribute-value-template">attribute value template</a></dt><dd><p>In an attribute that is designated as an <b>attribute value template</b>, such as an attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a> can be used by surrounding the expression with curly brackets (<code>{}</code>), following the general rules for <a title="value template" class="termref" href="#dt-value-template">value templates</a></p></dd><dt><a href="#dt-backwards-compatible-behavior">backwards compatible behavior</a></dt><dd><p>An element is processed with <b>backwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is less than <span>4.0</span>.</p></dd><dt><a href="#dt-base-output-uri">base output URI</a></dt><dd><p> The <b>base output URI</b> is a URI to be used as the base URI when resolving a relative URI reference allocated to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. If the transformation generates more than one final result tree, then typically each one will be allocated a URI relative to this base URI.</p></dd><dt><a href="#dt-basic-xslt-processor">basic XSLT processor</a></dt><dd><p>A <b>basic XSLT processor</b> is an XSLT processor that implements all the mandatory requirements of this specification with the exception of constructs explicitly associated with an optional feature.</p></dd><dt><a href="#dt-character-map">character map</a></dt><dd><p>A <b>character map</b> allows a specific character appearing in a text or attribute node in the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be substituted by a specified string of characters during serialization.</p></dd><dt><a href="#dt-choice-operand-group">choice operand group</a></dt><dd><p>For some construct kinds, one or more operand roles may be defined to form a <b>choice operand group</b>. This concept is used where it is known that <a title="operand" class="termref" href="#dt-operand">operands</a> are mutually exclusive (for example the <code>then</code> and <code>else</code> clauses in a conditional expression).</p></dd><dt><a href="#dt-circularity">circularity</a></dt><dd><p>A <b>circularity</b> is said to exist if a construct such as a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, or a <a title="key" class="termref" href="#dt-key">key</a>, is defined in terms of itself. For example, if the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the value of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><var>X</var> references a global variable <var>Y</var>, then the value for <var>Y</var><span class="verb">must</span> be computed before the value of <var>X</var>. A circularity exists if it is impossible to do this for all global variable definitions.</p></dd><dt><a href="#dt-climbing">climbing</a></dt><dd><p><b>Climbing</b>: indicates that streamed nodes returned by the construct are reached by navigating the parent, ancestor[-or-self], attribute, and/or namespace axes from the node at the current streaming position.</p></dd><dt><a href="#dt-coercion-rules">coercion rules</a></dt><dd><p> When used in this specification without further qualification, the term <b>coercion rules</b> means the coercion rules defined in <a href="#xpath-40">[XPath 4.0]</a>, applied with XPath 1.0 compatibility mode set to false.</p></dd><dt><a href="#dt-collation">collation</a></dt><dd><p>Facilities in XSLT 3.0 and XPath 3.0 that require strings to be ordered rely on the concept of a named <b>collation</b>. A collation is a set of rules that determine whether two strings are equal, and if not, which of them is to be sorted before the other.</p></dd><dt><a href="#dt-combined-posture">combined posture</a></dt><dd><p>The <b>combined posture</b> of a <a title="choice operand group" class="termref" href="#dt-choice-operand-group">choice operand group</a> is determined by the <a title="posture" class="termref" href="#dt-posture">postures</a> of the <a title="operand" class="termref" href="#dt-operand">operands</a> in the group (the <b>operand postures</b>), and is the first of the following that applies:</p><ol class="enumar"><li><p>If any of the operand postures is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, then the combined posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>.</p></li><li><p>If all of the operand postures are <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li><li><p>If one or more of the operand postures is <a title="climbing" class="termref" href="#dt-climbing">climbing</a> and the remainder (if any) are <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="climbing" class="termref" href="#dt-climbing">climbing</a>.</p></li><li><p>If one or more of the operand postures is <a title="striding" class="termref" href="#dt-striding">striding</a> and the remainder (if any) are <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="striding" class="termref" href="#dt-striding">striding</a>.</p></li><li><p>If one or more of the operand postures is <a title="crawling" class="termref" href="#dt-crawling">crawling</a> and each of the remainder (if any) is either <a title="striding" class="termref" href="#dt-striding">striding</a> or <a title="grounded" class="termref" href="#dt-grounded">grounded</a>, then the combined posture is <a title="crawling" class="termref" href="#dt-crawling">crawling</a>.</p></li><li><p>Otherwise (for example, if the group includes both an operand with <a title="climbing" class="termref" href="#dt-climbing">climbing</a> posture and one with <a title="crawling" class="termref" href="#dt-crawling">crawling</a> posture), the combined posture is <a title="roaming" class="termref" href="#dt-roaming">roaming</a>. </p></li></ol></dd><dt><a href="#dt-compatible">compatible</a></dt><dd><p>The signatures of two <a title="component" class="termref" href="#dt-component">components</a> are <b>compatible</b> if they present the same interface to the user of the component. The additional rules depend on the kind of component.</p></dd><dt><a href="#dt-component">component</a></dt><dd><p>The term <b>component</b> is used to refer to any of the following: a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="accumulator function" class="termref" href="#dt-accumulator-function">accumulator</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, or a <a title="mode" class="termref" href="#dt-mode">mode</a>.</p></dd><dt><a href="#dt-composite-merge-key-value">composite merge key value</a></dt><dd><p> The ordered collection of <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> computed for one item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a> (one for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>) is referred to as a <b>composite merge key value</b>.</p></dd><dt><a href="#dt-construct">construct</a></dt><dd><p>The term <b>construct</b> refers to the union of the following: a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="value template" class="termref" href="#dt-value-template">value template</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a>, or a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#dt-consuming">consuming</a></dt><dd><p>A <b>consuming</b> construct is any <a title="construct" class="termref" href="#dt-construct">construct</a> deemed consuming by the rules in this section (<a href="#streamability"><i>19 Streamability</i></a>).</p></dd><dt><a href="#dt-containing-package">containing package</a></dt><dd><p>A component declaration results in multiple components, one in the package in which the declaration appears, and potentially one in each package that uses the declaring package, directly or indirectly, subject to the visibility of the component. Each of these multiple components has the same <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, but each has a different <b>containing package</b>. For the original component, the declaring package and the containing package are the same; for a copy of a component made as a result of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, the declaring package will be the original package, and the containing package will be the package in which the <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears.</p></dd><dt><a href="#dt-context-item">context item</a></dt><dd><p>The <b>context item</b> is the item currently being processed. An item (see <a href="#xpath-datamodel-30">[XDM 3.0]</a>) is either an atomic value (such as an integer, date, or string), a node, or a function item. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; each item in such a sequence becomes the context item while that item is being processed.</p></dd><dt><a href="#dt-context-item-type">context item type</a></dt><dd><p>For every expression, it is possible to establish by static analysis, information about the item type of the context item for evaluation of that expression. This is called the <b>context item type</b> of the expression.</p></dd><dt><a href="#dt-context-node">context node</a></dt><dd><p>If the <a title="context item" class="termref" href="#dt-context-item">context item</a> is a node (as distinct from an atomic value such as an integer), then it is also referred to as the <b>context node</b>. The context node is not an independent variable, it changes whenever the context item changes. When the context item is an atomic value or a function item, there is no context node.</p></dd><dt><a href="#dt-context-position">context position</a></dt><dd><p>The <b>context position</b> is the position of the context item within the sequence of items currently being processed. It changes whenever the context item changes. When an instruction such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process a sequence of items, the first item in the sequence is processed with a context position of 1, the second item with a context position of 2, and so on.</p></dd><dt><a href="#dt-context-posture">context posture</a></dt><dd><p>The <b>context posture</b>. This captures information about how the <a title="context item" class="termref" href="#dt-context-item">context item</a> used as input to the construct is positioned relative to the streamed input. The <b>context posture</b> of a construct C is the posture of the expression whose value sets the focus for the evaluation of C.</p></dd><dt><a href="#dt-context-size">context size</a></dt><dd><p>The <b>context size</b> is the number of items in the sequence of items currently being processed. It changes whenever instructions such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of items; during the processing of each one of those items, the context size is set to the count of the number of items in the sequence (or equivalently, the position of the last item in the sequence).</p></dd><dt><a href="#dt-controlled-operand">controlled operand</a></dt><dd><p>Within a <a title="focus-changing construct" class="termref" href="#dt-focus-changing-construct">focus-changing construct</a> there are one or more <a title="operand" class="termref" href="#dt-operand">operands</a> that are evaluated with a <a title="focus" class="termref" href="#dt-focus">focus</a> determined by the <a title="controlling operand" class="termref" href="#dt-controlling-operand">controlling operand</a> (or in some cases such as <a href="#element-on-completion"><code>xsl:on-completion</code></a>, with an <a title="absent" class="termref" href="#dt-absent">absent</a><a title="focus" class="termref" href="#dt-focus">focus</a>); these are referred to as <b>controlled operands</b>.</p></dd><dt><a href="#dt-controlling-operand">controlling operand</a></dt><dd><p>Within a <a title="focus-changing construct" class="termref" href="#dt-focus-changing-construct">focus-changing construct</a> there is in many cases one <a title="operand" class="termref" href="#dt-operand">operand</a> whose value determines the <a title="focus" class="termref" href="#dt-focus">focus</a> for evaluating other operands; this is referred to as the <b>controlling operand</b>.</p></dd><dt><a href="#dt-crawling">crawling</a></dt><dd><p><b>Crawling</b>: typically indicates that streamed nodes returned by a construct are reached by navigating the descendant[-or-self] axis.</p></dd><dt><a href="#dt-current-captured-substrings">current captured substrings</a></dt><dd><p>While the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active, a set of <b>current captured substrings</b> is available, corresponding to the parenthesized subexpressions of the regular expression.</p></dd><dt><a href="#dt-current-group">current group</a></dt><dd><p>The <b>current group</b> is the <a title="group" class="termref" href="#dt-group">group</a> itself, as a sequence of items</p></dd><dt><a href="#dt-current-grouping-key">current grouping key</a></dt><dd><p>The <b>current grouping key</b> is a single atomic value, or in the case of a composite key, a sequence of atomic values, containing the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of the items in the <a title="current group" class="termref" href="#dt-current-group">current group</a>.</p></dd><dt><a href="#dt-current-merge-group">current merge group</a></dt><dd><p>The <b>current merge group</b> is a map. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key values</a> is processed, the current merge group is set to a map whose keys are the names of the various merge sources, and whose associated values are the items from each merge source having the relevant composite merge key value.</p></dd><dt><a href="#dt-current-merge-key">current merge key</a></dt><dd><p>The <b>current merge key</b> is a sequence of atomic values. During evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key values</a> is processed, the current merge key is set to the composite merge key value that these items have in common.</p></dd><dt><a href="#dt-current-mode">current mode</a></dt><dd><p>At any point in the processing of a stylesheet, there is a <b>current mode</b>. When the transformation is initiated, the current mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is evaluated, the current mode becomes the mode selected by this instruction.</p></dd><dt><a href="#dt-current-output-uri">current output URI</a></dt><dd><p>The <b>current output URI</b> is the URI associated with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> that is currently being written.</p></dd><dt><a href="#dt-current-template-rule">current template rule</a></dt><dd><p>At any point in the processing of a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there may be a <b>current template rule</b>. Whenever a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is chosen as a result of evaluating <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>, the template rule becomes the current template rule for the evaluation of the rule’s sequence constructor.</p></dd><dt><a href="#dt-decimal-format">decimal format</a></dt><dd><p>All the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in a package that share the same name are grouped into a named <b>decimal format</b>; those that have no name are grouped into a single unnamed decimal format.</p></dd><dt><a href="#dt-declaration">declaration</a></dt><dd><p>Top-level elements fall into two categories: declarations, and user-defined data elements. Top-level elements whose names are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> are <b>declarations</b>. Top-level elements in any other namespace are <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.7.3 User-defined Data Elements</i></a>)</p></dd><dt><a href="#dt-declaration-order">declaration order</a></dt><dd><p>The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> within a <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering known as <b>declaration order</b>. The order of declarations within a stylesheet level is the same as the document order that would result if each stylesheet module were inserted textually in place of the <a href="#element-include"><code>xsl:include</code></a> element that references it.</p></dd><dt><a href="#dt-declared-streamable">declared-streamable</a></dt><dd><p>The above constructs (template rules belonging to a mode declared with <code>streamable="yes"</code>; and <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>, <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-merge-source"><code>xsl:merge-source</code></a>, and <a href="#element-accumulator"><code>xsl:accumulator</code></a> elements specifying <code>streamable="yes"</code>) are said to be <b>declared-streamable</b>.</p></dd><dt><a href="#dt-declaring-package">declaring package</a></dt><dd><p>The <b>declaring package</b> of a <a title="component" class="termref" href="#dt-component">component</a> is the package that contains the declaration (or, in the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> and <a href="#element-key"><code>xsl:key</code></a>, multiple declarations) of the component.</p></dd><dt><a href="#dt-default-collation">default collation</a></dt><dd><p>In this specification the term <b>default collation</b> means the collation that is used by XPath operators such as <code>eq</code> and <code>lt</code> appearing in XPath expressions within the stylesheet.</p></dd><dt><a href="#dt-default-priority">default priority</a></dt><dd><p>If no <code>priority</code> attribute is specified on an <a href="#element-template"><code>xsl:template</code></a> element, a <b>default priority</b> is computed, based on the syntax of the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> supplied in the <code>match</code> attribute.</p></dd><dt><a href="#dt-defining-element">defining element</a></dt><dd><p>A string in the form of a lexical QName may occur as the value of an attribute node in a stylesheet module, or within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in an attribute or text node within a stylesheet module, or as the result of evaluating an XPath expression contained in such a node. The element containing this attribute or text node is referred to as the <b>defining element</b> of the lexical QName.</p></dd><dt><a href="#dt-deprecated">deprecated</a></dt><dd><p>Some constructs defined in this specification are described as being <b>deprecated</b>. The use of this term implies that stylesheet authors <span class="verb">should not</span> use the construct, and that the construct may be removed in a later version of this specification.</p></dd><dt><a href="#dt-dynamic-error">dynamic error</a></dt><dd><p>An error that is not capable of detection until a source document is being transformed is referred to as a <b>dynamic error</b>.</p></dd><dt><a href="#dt-dynamic-evaluation-feature">dynamic evaluation feature</a></dt><dd><p>A processor that claims conformance with the <b>dynamic evaluation feature</b><span class="verb">must</span> evaluate the <a href="#element-evaluate"><code>xsl:evaluate</code></a> function as described in this specification.</p></dd><dt><a href="#dt-eclipsed">eclipsed</a></dt><dd><p>An <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> is said to be <b>eclipsed</b> if the containing package includes an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same name, <var>F</var> has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of <var>G</var> includes the totality of the arity range of <var>F</var>.</p></dd><dt><a href="#dt-effective-value">effective value</a></dt><dd><p><span class="deltaxml-old" style="background:#FF5555">The result of evaluating a value template is referred to as its </span><b><span class="deltaxml-old" style="background:#FF5555">effective value</span></b><span class="deltaxml-old" style="background:#FF5555">.</span></p><p><span class="deltaxml-new" style="background:#90EE90">The </span><b><span class="deltaxml-new" style="background:#90EE90">effective value</span></b><span class="deltaxml-new" style="background:#90EE90"> of an attribute or text node in the stylesheet is the value after any required expansion or normalization.</span></p></dd><dt><a href="#dt-effective-version">effective version</a></dt><dd><p>The <b>effective version</b> of an element in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> is the decimal value of the <code>[xsl:]version</code> attribute (see <a href="#standard-attributes"><i>3.4 Standard Attributes</i></a>) on that element or on the innermost ancestor element that has such an attribute, excluding the <code>version</code> attribute on an <a href="#element-output"><code>xsl:output</code></a> element.</p></dd><dt><a href="#dt-embedded-stylesheet-module">embedded stylesheet module</a></dt><dd><p>A stylesheet module whose outermost element is the child of a non-XSLT element in a host document is referred to as an <b>embedded stylesheet module</b>. See <a href="#embedded"><i>3.12 Embedded Stylesheet Modules</i></a>.</p></dd><dt><a href="#dt-enclosing-mode">enclosing mode</a></dt><dd><p>A mode declared by an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has one or more contained <a href="#element-template"><code>xsl:template</code></a> declarations is referred to as an <b>enclosing mode</b>.</p></dd><dt><a href="#dt-eqname">EQName</a></dt><dd><p>An <b>EQName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is in the form defined by the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP40</small></sup> production in the XPath specification.</p></dd><dt><a href="#dt-expanded-qname">expanded QName</a></dt><dd><p>An <b>expanded QName</b> is a value in the value space of the <code>xs:QName</code> datatype as defined in the XDM data model (see <a href="#xpath-datamodel-30">[XDM 3.0]</a>): that is, a triple containing namespace prefix (optional), namespace URI (optional), and local name. Two expanded QNames are equal if the namespace URIs are the same (or both absent) and the local names are the same. The prefix plays no part in the comparison, but is used only if the expanded QName needs to be converted back to a string.</p></dd><dt><a href="#dt-explicit-default">explicit default</a></dt><dd><p>An <b>explicit default</b> for a parameter is indicated by the presence of either a <code>select</code> attribute or a non-empty sequence constructor.</p></dd><dt><a href="#dt-explicitly-mandatory">explicitly mandatory</a></dt><dd><p>A parameter is <b>explicitly mandatory</b> if it is a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a><span>with no <code>required</code> attribute</span>, or if the <code>required</code> attribute is present and has the value <code>yes</code>.</p></dd><dt><a href="#dt-expression">expression</a></dt><dd><p>Within this specification, the term <b>XPath expression</b>, or simply <b>expression</b>, means a string that matches the production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP40</small></sup> defined in <a href="#xpath-30">[XPath 3.0]</a>.</p></dd><dt><a href="#dt-extension-attribute">extension attribute</a></dt><dd><p>An element from the XSLT namespace may have any attribute not from the XSLT namespace, provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (see <a href="#xpath-30">[XPath 3.0]</a>) of the attribute has a non-null namespace URI. These attributes are referred to as <b>extension attributes</b>.</p></dd><dt><a href="#dt-extension-function">extension function</a></dt><dd><p>An <b>extension function</b> is a named function introduced to the static or dynamic context by mechanisms outside the scope of this specification.</p></dd><dt><a href="#dt-extension-instruction">extension instruction</a></dt><dd><p>An <b>extension instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension namespace.</p></dd><dt><a href="#dt-extension-namespace">extension namespace</a></dt><dd><p>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows namespaces to be designated as <b>extension namespaces</b>. When a namespace is designated as an extension namespace and an element with a name from that namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p></dd><dt><a href="#dt-final-output-state">final output state</a></dt><dd><p>The first of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>final output</b> state. This state applies when instructions are writing to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p></dd><dt><a href="#dt-final-result-tree">final result tree</a></dt><dd><p>A <b>final result tree</b> is a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that forms part of the output of a transformation: specifically, a tree built by post-processing the items in the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or in a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. Once created, the contents of a final result tree are not accessible within the stylesheet itself.</p></dd><dt><a href="#dt-focus">focus</a></dt><dd><p>When a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is evaluated, the <a title="processor" class="termref" href="#dt-processor">processor</a> keeps track of which items are being processed by means of a set of implicit variables referred to collectively as the <b>focus</b>.</p></dd><dt><a href="#dt-focus-changing-construct">focus-changing construct</a></dt><dd><p>A <b>focus-changing construct</b> is a <a title="construct" class="termref" href="#dt-construct">construct</a> that has one or more <a title="operand" class="termref" href="#dt-operand">operands</a> that are evaluated with a different <a title="focus" class="termref" href="#dt-focus">focus</a> from the parent construct.</p></dd><dt><a href="#dt-focus-setting-container">focus-setting container</a></dt><dd><p>The <b>focus-setting container</b> of a construct <var>C</var> is the innermost <a title="focus-changing construct" class="termref" href="#dt-focus-changing-construct">focus-changing construct</a><var>F</var> (if one exists) such that <var>C</var> is directly or indirectly contained in a <a title="controlled operand" class="termref" href="#dt-controlled-operand">controlled operand</a> of <var>F</var>. If there is no such construct <var>F</var>, then the focus-setting container is the containing <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, for example an <a href="#element-function"><code>xsl:function</code></a> or <a href="#element-template"><code>xsl:template</code></a> element.</p></dd><dt><a href="#dt-forwards-compatible-behavior">forwards compatible behavior</a></dt><dd><p>An element is processed with <b>forwards compatible behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is greater than <span>4.0</span>.</p></dd><dt><a href="#dt-free-ranging">free-ranging</a></dt><dd><p>A <b>free-ranging</b> construct is any <a title="construct" class="termref" href="#dt-construct">construct</a> deemed free-ranging by the rules in this section (<a href="#streamability"><i>19 Streamability</i></a>).</p></dd><dt><a href="#dt-function-definition">function definition</a></dt><dd><p>The term <b>function definition</b> is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#static_context">Section 2.2.1 Static Context</a><sup><small>XP40</small></sup>. It is the definition of a function that can be called statically from within an XPath expression: in the case of XSLT it typically means either a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, or a built-in function such as those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a></p></dd><dt><a href="#dt-function-parameter">function parameter</a></dt><dd><p> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-function"><code>xsl:function</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>function parameter</b>. A function parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the function is called, using a function call in an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p></dd><dt><a href="#dt-fundamental-item-type">fundamental item type</a></dt><dd><p>There are 28 <b>fundamental item types</b>: the 7 node kinds defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a> (element, attribute, etc.), the 19 primitive atomic types defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>, plus the types <code>function(*)</code> and <code>xs:untypedAtomic</code>. The fundamental item types are disjoint, and every item is an instance of exactly one of them.</p></dd><dt><a href="#dt-general-streamability-rules">general streamability rules</a></dt><dd><p>Many <a title="construct" class="termref" href="#dt-construct">constructs</a> share the same streamability rules. These rules, referred to as the <b>general streamability rules</b>, are defined here.</p></dd><dt><a href="#dt-global-context-item">global context item</a></dt><dd><p>An item that acts as the <b>global context item</b> for the transformation. This item acts as the <a title="context item" class="termref" href="#dt-context-item">context item</a> when evaluating the <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a><span>whose declaration is</span> within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, as described in <a href="#focus"><i>5.3.4.1 Maintaining Position: the Focus</i></a>. The global context item may also be available in a <a title="named template" class="termref" href="#dt-named-template">named template</a> when the stylesheet is invoked as described in <a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a></p></dd><dt><a href="#dt-global-variable">global variable</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> declares a <b>global variable</b> that is visible everywhere <span>except (a) within the <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element itself, (b) within any other global variable declaration that binds a variable with the same name, and (c) within any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding.</span>.</p></dd><dt><a href="#dt-grounded">grounded</a></dt><dd><p><b>Grounded</b>: indicates that the value returned by the construct does not contain nodes from the streamed input document</p></dd><dt><a href="#dt-group">group</a></dt><dd><p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction allocates the items in an input sequence into <b>groups</b> of items (that is, it establishes a collection of sequences) based either on common values of a grouping key, or on a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that the initial or final item in a group must match.</p></dd><dt><a href="#dt-grouping-key">grouping key</a></dt><dd><p>If either of the <code>group-by</code> or <code>group-adjacent</code> attributes is present, then for each item in the <a title="population" class="termref" href="#dt-population">population</a> a set of <b>grouping keys</b> is calculated, as follows: the expression contained in the <code>group-by</code> or <code>group-adjacent</code> attribute is evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> values are cast to <code>xs:string</code>. If <code>composite="yes"</code> is specified, there is a single grouping key whose value is the resulting sequence; otherwise, there is a set of grouping keys, consisting of the distinct atomic values present in the result sequence.</p></dd><dt><a href="#dt-guaranteed-streamable">guaranteed-streamable</a></dt><dd><p>A <b>guaranteed-streamable</b> construct is a <a title="construct" class="termref" href="#dt-construct">construct</a> that is declared to be streamable and that follows the particular rules for that construct to make streaming possible, as defined by the analysis in this specification.</p></dd><dt><a href="#dt-higher-order-operand">higher-order operand</a></dt><dd><p>Whether or not the <a title="operand" class="termref" href="#dt-operand">operand</a> is <b>higher-order</b>. For this purpose an operand <var>O</var> of a construct <var>C</var> is higher-order if the semantics of <var>C</var> potentially require <var>O</var> to be evaluated more than once during a single evaluation of <var>C</var>.</p></dd><dt><a href="#dt-homonymous">homonymous</a></dt><dd><p>Two <a title="component" class="termref" href="#dt-component">components</a> are said to be <b>homonymous</b> if they have the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>.</p></dd><dt><a href="#dt-identical-types">identical (types)</a></dt><dd><p>Types S and T are considered <b>identical</b> for the purpose of these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T, S)</code> both hold, where the subtype relation is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#id-seqtype-subtype">Section 3.7.1 Subtypes of Sequence Types</a><sup><small>XP40</small></sup>.</p></dd><dt><a href="#dt-immediate-result">immediate result</a></dt><dd><p>The result of evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the sequence of items formed by concatenating the results of evaluating each of the nodes in the sequence constructor, retaining order. This is referred to as the <b>immediate result</b> of the sequence constructor.</p></dd><dt><a href="#dt-implementation">implementation</a></dt><dd><p>A specific product that performs the functions of an <a title="processor" class="termref" href="#dt-processor">XSLT processor</a> is referred to as an <b>implementation</b>.</p></dd><dt><a href="#dt-implementation-defined">implementation-defined</a></dt><dd><p>In this specification, the term <b>implementation-defined</b> refers to a feature where the implementation is allowed some flexibility, and where the choices made by the implementation <span class="verb">must</span> be described in documentation that accompanies any conformance claim.</p></dd><dt><a href="#dt-implementation-dependent">implementation-dependent</a></dt><dd><p>The term <b>implementation-dependent</b> refers to a feature where the behavior <span class="verb">may</span> vary from one implementation to another, and where the vendor is not expected to provide a full specification of the behavior.</p></dd><dt><a href="#dt-implicit-default">implicit default</a></dt><dd><p>If a parameter that is not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> has no <a title="explicit default" class="termref" href="#dt-explicit-default">explicit default</a> value, then it has an <b>implicit default</b> value, which is the empty sequence if there is an <code>as</code> attribute, or a zero-length string if not.</p></dd><dt><a href="#dt-implicitly-mandatory">implicitly mandatory</a></dt><dd><p>If a parameter has an <a title="implicit default" class="termref" href="#dt-implicit-default">implicit default</a> value which cannot be converted to the <a title="required type" class="termref" href="#dt-required-type">required type</a> (that is, if it has an <code>as</code> attribute which does not permit the empty sequence), then the parameter is <b>implicitly mandatory</b>.</p></dd><dt><a href="#dt-import-precedence">import precedence</a></dt><dd><p>A <a title="declaration" class="termref" href="#dt-declaration">declaration</a><var>D</var> in the stylesheet is defined to have lower <b>import precedence</b> than another declaration <var>E</var> if the stylesheet level containing <var>D</var> would be visited before the stylesheet level containing <var>E</var> in a post-order traversal of the import tree (that is, a traversal of the import tree in which a stylesheet level is visited after its children). Two declarations within the same stylesheet level have the same import precedence.</p></dd><dt><a href="#dt-import-tree">import tree</a></dt><dd><p>The <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a> making up a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> are treated as forming an <b>import tree</b>. In the import tree, each stylesheet level has one child for each <a href="#element-import"><code>xsl:import</code></a> declaration that it contains.</p></dd><dt><a href="#dt-in-scope-schema-component">in-scope schema component</a></dt><dd><p>The <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> that may be referenced by name in a <a title="package" class="termref" href="#dt-package">package</a> are referred to as the <b>in-scope schema components</b>.</p></dd><dt><a href="#dt-initial-function">initial function</a></dt><dd><p>A stylesheet may be evaluated by calling a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, referred to as the <b>initial function</b>.</p></dd><dt><a href="#dt-initial-item">initial item</a></dt><dd><p>For each <a title="group" class="termref" href="#dt-group">group</a>, the item within the group that is first in <a title="population order" class="termref" href="#dt-population-order">population order</a> is known as the <b>initial item</b> of the group.</p></dd><dt><a href="#dt-initial-match-selection">initial match selection</a></dt><dd><p>A stylesheet may be evaluated by supplying a value to be processed, together with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. The value (which can be any sequence of items) is referred to as the <b>initial match selection</b>. The processing then corresponds to the effect of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p></dd><dt><a href="#dt-initial-mode">initial mode</a></dt><dd><p>The <b>initial mode</b> is the <a title="mode" class="termref" href="#dt-mode">mode</a> used to select <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> for processing items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> when apply-templates invocation is used to initiate a transformation.</p></dd><dt><a href="#dt-initial-named-template">initial named template</a></dt><dd><p>A stylesheet may be evaluated by selecting a named template to be evaluated; this is referred to as the <b>initial named template</b>.</p></dd><dt><a href="#dt-initial-sequence">initial sequence</a></dt><dd><p>The sequence to be sorted is referred to as the <b>initial sequence</b>.</p></dd><dt><a href="#dt-initial-setting">initial setting</a></dt><dd><p>The <b>initial setting</b> of a component of the dynamic context is used when evaluating <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, when evaluating the <code>use</code> and <code>match</code> attributes of <a href="#element-key"><code>xsl:key</code></a>, and when evaluating the <code>initial-value</code> of <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> expressions or contained sequence constructors of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a></p></dd><dt><a href="#dt-inspection">inspection</a></dt><dd><p>An operand usage of <b>inspection</b> indicates that the construct accesses properties of a supplied node that are available without reading its subtree.</p></dd><dt><a href="#dt-instruction">instruction</a></dt><dd><p>An <b>instruction</b> is either an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.</p></dd><dt><a href="#dt-invocation-construct">invocation construct</a></dt><dd><p>The following <a title="construct" class="termref" href="#dt-construct">constructs</a> are classified as <b>invocation constructs</b>: the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute. These all have the characteristic that they can cause evaluation of constructs that are not lexically contained within the calling construct.</p></dd><dt><a href="#dt-key">key</a></dt><dd><p>A <b>key</b> is defined as a set of <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> that share the same name.</p></dd><dt><a href="#dt-key-specifier">key specifier</a></dt><dd><p>The expression in the <code>use</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> within an <a href="#element-key"><code>xsl:key</code></a> declaration are referred to collectively as the <b>key specifier</b>. The key specifier determines the values that may be used to find a node using this <a title="key" class="termref" href="#dt-key">key</a>.</p></dd><dt><a href="#dt-lexical-qname">lexical QName</a></dt><dd><p>A <b>lexical QName</b> is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where the string, after removing leading and trailing whitespace, is within the lexical space of the <code>xs:QName</code> datatype as defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local name optionally preceded by a namespace prefix and a colon.</p></dd><dt><a href="#dt-library-package">library package</a></dt><dd><p>Every <a title="package" class="termref" href="#dt-package">package</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, other than the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, is referred to as a <b>library package</b>.</p></dd><dt><a href="#dt-literal-namespace-uri">literal namespace URI</a></dt><dd><p>A namespace URI in the stylesheet tree that is being used to specify a namespace URI in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is called a <b>literal namespace URI</b>.</p></dd><dt><a href="#dt-literal-result-element">literal result element</a></dt><dd><p>In a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that does not belong to the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> and that is not an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><i>25.2 Extension Instructions</i></a>) is classified as a <b>literal result element</b>.</p></dd><dt><a href="#dt-local-variable">local variable</a></dt><dd><p>As well as being allowed as a <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, the <a href="#element-variable"><code>xsl:variable</code></a> element is also allowed in <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a>. Such a variable is known as a <b>local variable</b>.</p></dd><dt><a href="#dt-match-type">match type</a></dt><dd><p>The <b>match type</b> of a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> is the most specific <a title="U-type" class="termref" href="#dt-utype">U-type</a> that is known to match all items that the pattern can match.</p></dd><dt><a href="#dt-merge-activation">merge activation</a></dt><dd><p>A <b>merge activation</b> is a single evaluation of the sequence constructor contained within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, which occurs once for each distinct <a title="composite merge key value" class="termref" href="#dt-composite-merge-key-value">composite merge key value</a>.</p></dd><dt><a href="#dt-merge-input-sequence">merge input sequence</a></dt><dd><p>A <b>merge input sequence</b> is an arbitrary <a href="https://www.w3.org/TR/xpath-datamodel-30/#dt-sequence">sequence</a><sup><small>DM30</small></sup> of items which is already sorted according to the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> for the corresponding <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a>.</p></dd><dt><a href="#dt-merge-key-component">merge key component</a></dt><dd><p>A <b>merge key component</b> specifies one component of a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>; it corresponds to a single <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the stylesheet.</p></dd><dt><a href="#dt-merge-key-specification">merge key specification</a></dt><dd><p>A <b>merge key specification</b> consists of one or more adjacent <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements which together define how the <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a> selected by a <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a> are sorted. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a>.</p></dd><dt><a href="#dt-merge-key-value">merge key value</a></dt><dd><p> For each item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>. The value computed for an item by using the <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the <var>N</var>th <b>merge key value</b> of that item.</p></dd><dt><a href="#dt-merge-source-definition">merge source definition</a></dt><dd><p>A <b>merge source definition</b> is the definition of one kind of input to the merge operation. It selects zero or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a>, and it includes a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> to define how the <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a> are computed for each such merge input sequence.</p></dd><dt><a href="#dt-mode">mode</a></dt><dd><p> A <b>mode</b> is a set of template rules; when the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects a set of items for processing, it identifies the rules to be used for processing those items by nominating a mode, explicitly or implicitly.</p></dd><dt><a href="#dt-mode-definition">mode definition</a></dt><dd><p>All the <a href="#element-mode"><code>xsl:mode</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>mode definition</b>; those that have no name are grouped into a single unnamed mode definition.</p></dd><dt><a href="#dt-motionless">motionless</a></dt><dd><p>A <b>motionless</b> construct is any <a title="construct" class="termref" href="#dt-construct">construct</a> deemed motionless by the rules in this section (<a href="#streamability"><i>19 Streamability</i></a>).</p></dd><dt><a href="#dt-named-template">named template</a></dt><dd><p>Templates can be invoked by name. An <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute defines a <b>named template</b>.</p></dd><dt><a href="#dt-namespace-fixup">namespace fixup</a></dt><dd><p>The rules for the individual XSLT instructions that construct a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> (see <a href="#creating-new-nodes"><i>11 Creating Nodes and Sequences</i></a>) prescribe some of the situations in which namespace nodes are written to the tree. These rules, however, are not sufficient to ensure that the prescribed constraints are always satisfied. The XSLT processor <span class="verb">must</span> therefore add additional namespace nodes to satisfy these constraints. This process is referred to as <b>namespace fixup</b>.</p></dd><dt><a href="#dt-navigation">navigation</a></dt><dd><p>An operand usage of <b>navigation</b> indicates that the construct may navigate freely from the supplied node to other nodes in the same tree, in a way that is not constrained by the streamability rules.</p></dd><dt><a href="#dt-node-pattern">node pattern</a></dt><dd><p>A <b>node pattern</b> uses a subset of the syntax for path expressions, and is defined to match a node if the corresponding path expression would select the node. Node patterns may also be formed by combining other patterns using union, intersection, and difference operators.</p></dd><dt><a href="#dt-non-contextual-function-call">non-contextual function call</a></dt><dd><p>The term <b>non-contextual function call</b> is used to refer to function calls that do not pass the dynamic context to the called function. This includes all calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> and all <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-function-invocation">dynamic function invocations</a><sup><small>XP40</small></sup>, (that is calls to function items as permitted by XPath 3.0). It excludes calls to some functions in the namespace <code>http://www.w3.org/2005/xpath-functions</code>, in particular those that explicitly depend on the context, such as the <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-regex-group"><code>regex-group</code></a> functions. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances, calls to <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are non-contextual.</p></dd><dt><a href="#dt-non-positional-predicate">non-positional predicate</a></dt><dd><p>A predicate is a <b>non-positional predicate</b> if it satisfies both of the following conditions:</p><ol class="enumar"><li><p>The predicate does not contain a function call or named function reference to any of the following functions, unless that call or reference occurs within a nested predicate:</p><ol class="enumla"><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-position"><code>position</code></a><sup><small>FO30</small></sup></p></li><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-last"><code>last</code></a><sup><small>FO30</small></sup></p></li><li><p><a href="https://www.w3.org/TR/xpath-functions-30/#func-function-lookup"><code>function-lookup</code></a><sup><small>FO30</small></sup>.</p></li></ol><div class="note"><p class="prefix"><b>Note:</b></p><p>The exception for nested predicates is there to ensure that patterns such as <code>match="p[@code = $status[last()]]</code> are not disqualified.</p></div></li><li><p>The expression immediately contained in the predicate is a non-numeric expression. An expression is non-numeric if the intersection of its <a title="static type" class="termref" href="#dt-static-type">static type</a> (see <a href="#determining-static-type"><i>19.1 Determining the Static Type of a Construct</i></a>) with <var>U{xs:decimal, xs:double, xs:float}</var> is <var>U{}</var>.</p></li></ol></dd><dt><a href="#dt-non-schema-aware-processor">non-schema-aware processor</a></dt><dd><p>A <b>non-schema-aware processor</b> is a processor that does not claim conformance with the schema-aware conformance feature. Such a processor <span class="verb">must</span> handle constructs associated with schema-aware processing as described in this section.</p></dd><dt><a href="#dt-operand">operand</a></dt><dd><p>In an actual instance of a construct, there will be a number of <b>operands</b>. Each operand is itself a <a title="construct" class="termref" href="#dt-construct">construct</a>; the construct tree can be defined as the transitive relation between constructs and their operands.</p></dd><dt><a href="#dt-operand-role">operand role</a></dt><dd><p>For every construct kind, there is a set of zero or more <b>operand roles</b>.</p></dd><dt><a href="#dt-operand-usage">operand usage</a></dt><dd><p>The <b>operand usage</b>. This gives information, in the case where the operand value contains nodes, about how those nodes are used. The operand usage takes one of the values <a title="absorption" class="termref" href="#dt-absorption">absorption</a>, <a title="inspection" class="termref" href="#dt-inspection">inspection</a>, <a title="transmission" class="termref" href="#dt-transmission">transmission</a>, or <a title="navigation" class="termref" href="#dt-navigation">navigation</a>.</p></dd><dt><a href="#dt-first-appearance">order of first appearance</a></dt><dd><p>There is a total ordering among <a title="group" class="termref" href="#dt-group">groups</a> referred to as the <b>order of first appearance</b>. A group <var>G</var> is defined to precede a group <var>H</var> in order of first appearance if the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of <var>G</var> precedes the initial item of <var>H</var> in population order. If two groups <var>G</var> and <var>H</var> have the same initial item (because the item is in both groups) then <var>G</var> precedes <var>H</var> if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of <var>G</var> precedes the grouping key of <var>H</var> in the sequence that results from evaluating the <code>group-by</code> expression of this initial item.</p></dd><dt><a href="#dt-output-definition">output definition</a></dt><dd><p>All the <a href="#element-output"><code>xsl:output</code></a> declarations within a <a title="package" class="termref" href="#dt-package">package</a> that share the same name are grouped into a named <b>output definition</b>; those that have no name are grouped into a single unnamed output definition.</p></dd><dt><a href="#dt-output-state">output state</a></dt><dd><p>Each instruction in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated in one of two possible <b>output states</b>: <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> or <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p></dd><dt><a href="#dt-override">override</a></dt><dd><p>A component in a using package may <b>override</b> a component in a used package, provided that the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in the used package is either <code>abstract</code> or <code>public</code>. The overriding declaration is written as a child of the <a href="#element-override"><code>xsl:override</code></a> element, which in turn appears as a child of <a href="#element-use-package"><code>xsl:use-package</code></a>.</p></dd><dt><a href="#dt-package">package</a></dt><dd><p>An explicit <b>package</b> is represented by an <a href="#element-package"><code>xsl:package</code></a> element, which will generally be the outermost element of an XML document. When the <a href="#element-package"><code>xsl:package</code></a> element is not used explicitly, the entire stylesheet comprises a single implicit package.</p></dd><dt><a href="#dt-package-manifest">package manifest</a></dt><dd><p>The content of the <a href="#element-package"><code>xsl:package</code></a> element is referred to as the <b>package manifest</b></p></dd><dt><a href="#dt-parameter">parameter</a></dt><dd><p>The <a href="#element-param"><code>xsl:param</code></a> element declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that its value can be set by the caller.</p></dd><dt><a href="#dt-pattern">pattern</a></dt><dd><p>A <b>pattern</b> specifies a set of conditions on an item. An item that satisfies the conditions matches the pattern; an item that does not satisfy the conditions does not match the pattern.</p></dd><dt><a href="#dt-picture-string">picture string</a></dt><dd><p>The <b>picture string</b> is the string supplied as the second argument of the <a href="https://www.w3.org/TR/xpath-functions-30/#func-format-number"><code>format-number</code></a><sup><small>FO30</small></sup> function.</p></dd><dt><a href="#dt-place-marker">place marker</a></dt><dd><p>The <a href="#element-number"><code>xsl:number</code></a> instruction performs two tasks: firstly, determining a <b>place marker</b> (this is a sequence of integers, to allow for hierarchic numbering schemes such as <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place marker for output as a text node in the result sequence.</p></dd><dt><a href="#dt-population">population</a></dt><dd><p>The sequence of items to be grouped, which is referred to as the <b>population</b>, is determined by evaluating the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>select</code> attribute, <span>or constructed from the expressions in the <code>array</code> or <code>map</code> attributes</span>.</p></dd><dt><a href="#dt-population-order">population order</a></dt><dd><p>The population is treated as a sequence; the order of items in this sequence is referred to as <b>population order</b>.</p></dd><dt><a href="#dt-portion">portion</a></dt><dd><p>The integer literals and the optional <code>NamePart</code> within the version number are referred to as the <b>portions</b> of the version number.</p></dd><dt><a href="#dt-posture">posture</a></dt><dd><p>The <b>posture</b> of the expression. This captures information about the way in which the streamed input document is positioned on return from evaluating the construct. The posture takes one of the values <a title="climbing" class="termref" href="#dt-climbing">climbing</a>, <a title="striding" class="termref" href="#dt-striding">striding</a>, <a title="crawling" class="termref" href="#dt-crawling">crawling</a>, <a title="roaming" class="termref" href="#dt-roaming">roaming</a>, or <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></dd><dt><a href="#dt-potentially-consuming">potentially consuming</a></dt><dd><p>An <a title="operand" class="termref" href="#dt-operand">operand</a> is <b>potentially consuming</b> if at least one of the following conditions applies:</p><ol class="enumlr"><li><p>The operand’s adjusted <a title="sweep" class="termref" href="#dt-sweep">sweep</a><var>S′</var> is <a title="consuming" class="termref" href="#dt-consuming">consuming</a>.</p></li><li><p>The <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> is <a title="transmission" class="termref" href="#dt-transmission">transmission</a> and the operand is not <a title="grounded" class="termref" href="#dt-grounded">grounded</a>.</p></li></ol></dd><dt><a href="#dt-predicate-pattern">predicate pattern</a></dt><dd><p>A <b>predicate pattern</b> is written as <code>.</code> (dot) followed by zero or more predicates in square brackets, and it matches any item for which each of the predicates evaluates to <code>true</code>.</p></dd><dt><a href="#dt-principal-result">principal result</a></dt><dd><p>A <b>principal result</b>: this can be any sequence of items (as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>).</p></dd><dt><a href="#dt-principal-stylesheet-module">principal stylesheet module</a></dt><dd><p>Within a <a title="package" class="termref" href="#dt-package">package</a>, one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> functions as the <b>principal stylesheet module</b>. The complete package is assembled by finding the stylesheet modules referenced directly or indirectly from the principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><i>3.11.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.11.3 Stylesheet Import</i></a>.</p></dd><dt><a href="#dt-priority">priority</a></dt><dd><p>The <b>priority</b> of a template rule is specified by the <code>priority</code> attribute on the <a href="#element-template"><code>xsl:template</code></a> declaration. If no priority is specified explicitly for a template rule, its <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> is used, as defined in <a href="#default-priority"><i>6.6 Default Priority for Template Rules</i></a>.</p></dd><dt><a href="#dt-processing-order">processing order</a></dt><dd><p>There is another total ordering among groups referred to as <b>processing order</b>. If group <var>R</var> precedes group <var>S</var> in processing order, then in the result sequence returned by the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction the items generated by processing group <var>R</var> will precede the items generated by processing group <var>S</var>.</p></dd><dt><a href="#dt-processor">processor</a></dt><dd><p>The software responsible for transforming source trees into result trees using an XSLT stylesheet is referred to as the <b>processor</b>. This is sometimes expanded to <em>XSLT processor</em> to avoid any confusion with other processors, for example an XML processor.</p></dd><dt><a href="#dt-raw-result">raw result</a></dt><dd><p>The result of invoking the selected component, after any required conversion to the declared result type of the component, is referred to as the <b>raw result</b>.</p></dd><dt><a href="#dt-reference-binding">reference binding</a></dt><dd><p>The process of identifying the <a title="component" class="termref" href="#dt-component">component</a> to which a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> applies (possibly chosen from several <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> alternatives) is called <b>reference binding</b>.</p></dd><dt><a href="#dt-required-type">required type</a></dt><dd><p>The context within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> appears may specify the <b>required type</b> of the expression. The required type indicates the type of the value that the expression is expected to return.</p></dd><dt><a href="#dt-reserved-namespace">reserved namespace</a></dt><dd><p>The XSLT namespace, together with certain other namespaces recognized by an XSLT processor, are classified as <b>reserved namespaces</b> and <span class="verb">must</span> be used only as specified in this and related specifications.</p></dd><dt><a href="#dt-result-tree">result tree</a></dt><dd><p>The term <b>result tree</b> is used to refer to any <a title="tree" class="termref" href="#dt-tree">tree</a> constructed by <a title="instruction" class="termref" href="#dt-instruction">instructions</a> in the stylesheet. A result tree is either a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> or a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a>.</p></dd><dt><a href="#dt-roaming">roaming</a></dt><dd><p><b>Roaming</b>: indicates that the nodes returned by an expression could be anywhere in the tree, which inevitably means that the construct cannot be evaluated using streaming.</p></dd><dt><a href="#dt-scanning-expression">scanning expression</a></dt><dd><p>A <code>RelativePathExpr</code> is a <b>scanning expression</b> if and only if it is syntactically equivalent to some <a title="motionless" class="termref" href="#dt-motionless">motionless</a><a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#dt-schema-component">schema component</a></dt><dd><p>Type definitions and element and attribute declarations are referred to collectively as <b>schema components</b>.</p></dd><dt><a href="#dt-schema-instance-namespace">schema instance namespace</a></dt><dd><p>The <b>schema instance namespace</b><code>http://www.w3.org/2001/XMLSchema-instance</code> is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p></dd><dt><a href="#dt-schema-namespace">schema namespace</a></dt><dd><p>The <b>schema namespace</b><code>http://www.w3.org/2001/XMLSchema</code> is used as defined in <a href="#xmlschema-1">[XML Schema Part 1]</a></p></dd><dt><a href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a></dt><dd><p>A <b>schema-aware XSLT processor</b> is an XSLT processor that implements the mandatory requirements of this specification connected with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, the <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the ability to handle input documents whose nodes have type annotations other than <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory requirements of this specification are taken to include the mandatory requirements of XPath 3.0, as described in <a href="#xpath-30">[XPath 3.0]</a>. A requirement is mandatory unless the specification includes wording (such as the use of the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates that it is optional.</p></dd><dt><a href="#dt-secondary-result">secondary result</a></dt><dd><p>Zero or more <b>secondary results</b>: each secondary result can be any sequence of items (as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>).</p></dd><dt><a href="#dt-sequence-constructor">sequence constructor</a></dt><dd><p>A <b>sequence constructor</b> is a sequence of zero or more sibling nodes in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be evaluated to return a sequence of nodes, atomic values, and function items. The way that the resulting sequence is used depends on the containing instruction.</p></dd><dt><a href="#dt-sequence-type">SequenceType</a></dt><dd><p>A <b>SequenceType</b> constrains the type and number of items in a sequence. The term is used both to denote the concept, and to refer to the syntactic form in which sequence types are expressed in the XPath grammar: specifically <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP40</small></sup> in <a href="#xpath-30">[XPath 3.0]</a>.</p></dd><dt><a href="#dt-serialization">serialization</a></dt><dd><p>A frequent requirement is to output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as an XML document (or in other formats such as HTML). This process is referred to as <b>serialization</b>.</p></dd><dt><a href="#dt-serialization-error">serialization error</a></dt><dd><p>If a transformation has successfully produced a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>, it is still possible that errors may occur in serializing that result . For example, it may be impossible to serialize the result using the encoding selected by the user. Such an error is referred to as a <b>serialization error</b>.</p></dd><dt><a href="#dt-serialization-feature">serialization feature</a></dt><dd><p>A processor that claims conformance with the <b>serialization feature</b><span class="verb">must</span> support the conversion of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to a sequence of octets following the rules defined in <a href="#serialization"><i>27 Serialization</i></a>.</p></dd><dt><a href="#dt-shadows">shadows</a></dt><dd><p>Within a region of the stylesheet where a binding <var>B</var>1 is visible, <var>B<sub>1</sub></var> shadows another binding <var>B<sub>2</sub></var> having the same name as <var>B<sub>1</sub></var> if <var>B<sub>1</sub></var> occurs at a point where <var>B<sub>2</sub></var> is visible.</p></dd><dt><a href="#dt-simplified-stylesheet-module">simplified stylesheet</a></dt><dd><p>A <b>simplified stylesheet</b>, which is a subtree rooted at a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, as described in <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>. This is first converted to a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> by wrapping it in an xsl:stylesheet element using the transformation described in <a href="#simplified-stylesheet"><i>3.8 Simplified Stylesheet Modules</i></a>.</p></dd><dt><a href="#dt-singleton-focus">singleton focus</a></dt><dd><p>A <b>singleton focus</b> based on an item <var>J</var> has the <a title="context item" class="termref" href="#dt-context-item">context item</a> (and therefore the <a title="context node" class="termref" href="#dt-context-node">context node</a>, if <var>J</var> is a node) set to <var>J</var>, and the <a title="context position" class="termref" href="#dt-context-position">context position</a> and <a title="context size" class="termref" href="#dt-context-size">context size</a> both set to 1 (one).</p></dd><dt><a href="#dt-snapshot">snapshot</a></dt><dd><p>A <b>snapshot</b> of a node <var>N</var> is a deep copy of <var>N</var>, as produced by the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with <code>copy-namespaces</code> set to <code>yes</code>, <code>copy-accumulators</code> set to <code>yes</code>, and <code>validation</code> set to <code>preserve</code>, with the additional property that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor whose name, node-kind, and base URI are the same as the corresponding ancestor of <var>N</var>, and that has copies of the attributes, namespaces and accumulator values of the corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of <code>xs:anyType</code>, has the properties <code>nilled</code>, <code>is-id</code>, and <code>is-idref</code> set to false, and has no children other than the child that is a copy of <var>N</var> or one of its ancestors.</p></dd><dt><a href="#dt-sort-key-component">sort key component</a></dt><dd><p>Within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>, each <a href="#element-sort"><code>xsl:sort</code></a> element defines one <b>sort key component</b>.</p></dd><dt><a href="#dt-sort-key-specification">sort key specification</a></dt><dd><p>A <b>sort key specification</b> is a sequence of one or more adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules for sorting the items in an input sequence to form a sorted sequence.</p></dd><dt><a href="#dt-sort-key-value">sort key value</a></dt><dd><p> For each item in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, a value is computed for each <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a> within the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>. The value computed for an item by using the <var>N</var>th sort key component is referred to as the <var>N</var>th <b>sort key value</b> of that item.</p></dd><dt><a href="#dt-sorted-sequence">sorted sequence</a></dt><dd><p>The sequence after sorting as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements is referred to as the <b>sorted sequence</b>.</p></dd><dt><a href="#dt-source-tree">source tree</a></dt><dd><p>The term <b>source tree</b> means any tree provided as input to the transformation. This includes the document containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if any, documents containing nodes present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, documents containing nodes supplied as the values of <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, documents obtained from the results of functions such as <a href="#func-document"><code>document</code></a>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup>, documents read using the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, and documents returned by extension functions or extension instructions. In the context of a particular XSLT instruction, the term <b>source tree</b> means any tree provided as input to that instruction; this may be a source tree of the transformation as a whole, or it may be a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> produced during the course of the transformation.</p></dd><dt><a href="#dt-stable">stable</a></dt><dd><p>A <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is said to be <b>stable</b> if its first <a href="#element-sort"><code>xsl:sort</code></a> element has no <code>stable</code> attribute, or has a <code>stable</code> attribute whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>yes</code>.</p></dd><dt><a href="#dt-standard-attributes">standard attributes</a></dt><dd><p>There are a number of <b>standard attributes</b> that may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>: specifically <code>default-collation</code>, <code>default-element-namespace</code>, <code>default-mode</code>, <code>default-type-namespace</code>, <code>default-validation</code>, <code>exclude-result-prefixes</code>, <code>expand-text</code>, <code>extension-element-prefixes</code>, <code>use-when</code>, <code>version</code>, and <code>xpath-default-namespace</code>.</p></dd><dt><a href="#dt-standard-error-namespace">standard error namespace</a></dt><dd><p>The <b>standard error namespace</b><code>http://www.w3.org/2005/xqt-errors</code> is used for error codes defined in this specification and related specifications. It is also used for the names of certain predefined variables accessible within the scope of an <a href="#element-catch"><code>xsl:catch</code></a> element.</p></dd><dt><a href="#dt-standard-function-namespace">standard function namespace</a></dt><dd><p>The <b>standard function namespace</b><code>http://www.w3.org/2005/xpath-functions</code> is used for functions in the function library defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> and for standard functions defined in this specification.</p></dd><dt><a href="#dt-standard-stylesheet-module">standard stylesheet module</a></dt><dd><p>A <b>standard stylesheet module</b>, which is a subtree rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element.</p></dd><dt><a href="#dt-static-error">static error</a></dt><dd><p>An error that can be detected by examining a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> before execution starts (that is, before the source document and values of stylesheet parameters are available) is referred to as a <b>static error</b>.</p></dd><dt><a href="#dt-static-expression">static expression</a></dt><dd><p>A <b>static expression</b> is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> whose value must be computed during static analysis of the stylesheet.</p></dd><dt><a href="#dt-static-parameter">static parameter</a></dt><dd><p>A <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declared using an <a href="#element-param"><code>xsl:param</code></a> element is referred to as a <b>static parameter</b>.</p></dd><dt><a href="#dt-static-type">static type</a></dt><dd><p>The <b>static type</b> of a <a title="construct" class="termref" href="#dt-construct">construct</a> is such that all values produced by evaluating the construct will conform to that type. The static type of a construct is a <a title="U-type" class="termref" href="#dt-utype">U-type</a>.</p></dd><dt><a href="#dt-static-variable">static variable</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> having the attribute <code>static="yes"</code> declares a <b>static variable</b>: that is, a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> whose value is known during static analysis of the stylesheet.</p></dd><dt><a href="#dt-streamability-category">streamability category</a></dt><dd><p>Stylesheet functions belong to one of a number of <b>streamability categories</b>: the choice of category characterizes the way in which the function handles streamed input.</p></dd><dt><a href="#dt-streamable-mode">streamable mode</a></dt><dd><p>A <b>streamable mode</b> is a <a title="mode" class="termref" href="#dt-mode">mode</a> that is declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration with the attribute <code>streamable="yes"</code>.</p></dd><dt><a href="#dt-streamed-document">streamed document</a></dt><dd><p>A <b>streamed document</b> is a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> that is processed using streaming, that is, without constructing a complete tree of nodes in memory.</p></dd><dt><a href="#dt-streamed-node">streamed node</a></dt><dd><p>A <b>streamed node</b> is a node in a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a>.</p></dd><dt><a href="#dt-streaming">streaming</a></dt><dd><p>The term <b>streaming</b> refers to a manner of processing in which XML documents (such as source and result documents) are not represented by a complete tree of nodes occupying memory proportional to document size, but instead are processed “on the fly” as a sequence of events, similar in concept to the stream of events notified by an XML parser to represent markup in lexical XML.</p></dd><dt><a href="#dt-streaming-feature">streaming feature</a></dt><dd><p>A processor that claims conformance with the <b>streaming feature</b><span class="verb">must</span> use streamed processing in cases where (a) streaming is requested (for example by using the attribute <code>streamable="yes"</code> on <a href="#element-mode"><code>xsl:mode</code></a>, or on the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction) and (b) the constructs in question are <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a> according to this specification.</p></dd><dt><a href="#dt-streaming-parameter">streaming parameter</a></dt><dd><p>The first <a title="function parameter" class="termref" href="#dt-function-parameter">parameter</a> of a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a><a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> is referred to as a <b>streaming parameter</b>.</p></dd><dt><a href="#dt-striding">striding</a></dt><dd><p><b>Striding</b>: indicates that the result of a construct contains a sequence of streamed nodes, in document order, that are peers in the sense that none of them is an ancestor or descendant of any other.</p></dd><dt><a href="#dt-string-value">string value</a></dt><dd><p>The term <b>string value</b> is defined in <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-string-value">Section 5.13 string-value Accessor </a><sup><small>DM30</small></sup>. Every node has a <a title="string value" class="termref" href="#dt-string-value">string value</a>. For example, the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an element is the concatenation of the <a title="string value" class="termref" href="#dt-string-value">string values</a> of all its descendant text nodes.</p></dd><dt><a href="#dt-stylesheet">stylesheet</a></dt><dd><p>A <b>stylesheet</b> consists of one or more packages: specifically, one <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> and zero or more <a title="library package" class="termref" href="#dt-library-package">library packages</a>.</p></dd><dt><a href="#dt-stylesheet-function">stylesheet function</a></dt><dd><p>An <a href="#element-function"><code>xsl:function</code></a> declaration declares the name, parameters, and implementation of a family of <b>stylesheet functions</b> that can be called from any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (subject to visibility rules).</p></dd><dt><a href="#dt-stylesheet-level">stylesheet level</a></dt><dd><p>A <b>stylesheet level</b> is a collection of <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> connected using <a href="#element-include"><code>xsl:include</code></a> declarations: specifically, two stylesheet modules <var>A</var> and <var>B</var> are part of the same stylesheet level if one of them includes the other by means of an <a href="#element-include"><code>xsl:include</code></a> declaration, or if there is a third stylesheet module <var>C</var> that is in the same stylesheet level as both <var>A</var> and <var>B</var>.</p></dd><dt><a href="#dt-stylesheet-module">stylesheet module</a></dt><dd><p>A <a title="package" class="termref" href="#dt-package">package</a> consists of one or more <b>stylesheet modules</b>, each one forming all or part of an XML document.</p></dd><dt><a href="#dt-stylesheet-parameter">stylesheet parameter</a></dt><dd><p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a><a href="#element-param"><code>xsl:param</code></a> element declares a <b>stylesheet parameter</b>. A stylesheet parameter is a global variable with the additional property that its value can be supplied by the caller when a transformation is initiated.</p></dd><dt><a href="#dt-supplied-value">supplied value</a></dt><dd><p>The value of the variable is computed using the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. This value is referred to as the <b>supplied value</b> of the variable.</p></dd><dt><a href="#dt-sweep">sweep</a></dt><dd><p>Every construct has a <b>sweep</b>, which is a measure of the extent to which the current position in the input stream moves during the evaluation of the expression. The sweep is one of: <a title="motionless" class="termref" href="#dt-motionless">motionless</a>, <a title="consuming" class="termref" href="#dt-consuming">consuming</a>, or <a title="free-ranging" class="termref" href="#dt-free-ranging">free-ranging</a> .</p></dd><dt><a href="#dt-symbolic-identifier">symbolic identifier</a></dt><dd><p>The <b>symbolic identifier</b> of a <a title="component" class="termref" href="#dt-component">component</a> is a composite name used to identify the component uniquely within a package. The symbolic identifier comprises the kind of component (stylesheet function, named template, accumulator, attribute set, global variable, key, or mode), the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the component (namespace URI plus local name), and in the case of stylesheet functions, <span>the upper bound of the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a></span>.</p></dd><dt><a href="#dt-symbolic-reference">symbolic reference</a></dt><dd><p>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a component includes constructs that can be interpreted as references to other <a title="component" class="termref" href="#dt-component">components</a> by means of their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. These constructs are generically referred to as <b>symbolic references</b>. Examples of constructs that give rise to symbolic references are the <code>name</code> attribute of <a href="#element-call-template"><code>xsl:call-template</code></a>; the <code>[xsl:]use-attribute-sets</code> attribute of <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>; the explicit or implicit <code>mode</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>; XPath variable references referring to global variables; XPath static function calls (including partial function applications) referring to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; and named function references (example: <code>my:f#1</code>) referring to stylesheet functions. </p></dd><dt><a href="#dt-tail-position">tail position</a></dt><dd><p>An <a title="instruction" class="termref" href="#dt-instruction">instruction</a><var>J</var> is in a <b>tail position</b> within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a><var>SC</var> if it satisfies one of the following conditions:</p><ul><li><p><var>J</var> is the last instruction in <var>SC</var>, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-if"><code>xsl:if</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch of an <a href="#element-choose"><code>xsl:choose</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var> (that is, it is immediately followed by an <a href="#element-catch"><code>xsl:catch</code></a> element, ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> elements).</p></li><li><p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the sequence constructor that forms the body of an <a href="#element-catch"><code>xsl:catch</code></a> element within an <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p></li></ul></dd><dt><a href="#dt-target-expression">target expression</a></dt><dd><p>The string that results from evaluating the expression in the <code>xpath</code> attribute is referred to as the <b>target expression</b>.</p></dd><dt><a href="#dt-target-namespace-uri">target namespace URI</a></dt><dd><p>The namespace URI that is to be used in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> as a substitute for a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is called the <b>target namespace URI</b>.</p></dd><dt><a href="#dt-template">template</a></dt><dd><p>An <a href="#element-template"><code>xsl:template</code></a> declaration defines a <b>template</b>, which contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>; this sequence constructor is evaluated to determine the result of the template. A template can serve either as a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, invoked by matching items against a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, or as a <a title="named template" class="termref" href="#dt-named-template">named template</a>, invoked explicitly by name. It is also possible for the same template to serve in both capacities.</p></dd><dt><a href="#dt-template-parameter">template parameter</a></dt><dd><p> An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an <a href="#element-template"><code>xsl:template</code></a> element, before any non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter is known as a <b>template parameter</b>. A template parameter is a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the additional property that its value can be set when the template is called, using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>.</p></dd><dt><a href="#dt-template-rule">template rule</a></dt><dd><p>A stylesheet contains a set of <b>template rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A template rule has three parts: a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that is matched against selected items (often but not necessarily nodes), a (possibly empty) set of <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>, and a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is evaluated to produce a sequence of items.</p></dd><dt><a href="#dt-temporary-output-state">temporary output state</a></dt><dd><p>The second of the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>temporary output</b> state. This state applies when instructions are writing to a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> or any other non-final destination.</p></dd><dt><a href="#dt-temporary-tree">temporary tree</a></dt><dd><p>The term <b>temporary tree</b> means any tree that is neither a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> nor a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p></dd><dt><a href="#dt-text-value-template">text value template</a></dt><dd><p>In a text node that is designated as a <b>text value template</b>, <a title="expression" class="termref" href="#dt-expression">expressions</a> can be used by surrounding each expression with curly brackets (<code>{}</code>).</p></dd><dt><a href="#dt-top-level">top-level</a></dt><dd><p>An element occurring as a child of an <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a> element is called a <b>top-level</b> element.</p></dd><dt><a href="#dt-top-level-package">top-level package</a></dt><dd><p>For a given transformation, one <a title="package" class="termref" href="#dt-package">package</a> functions as the <b>top-level package</b>. The complete <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is assembled by finding the packages referenced directly or indirectly from the top-level package using <a href="#element-use-package"><code>xsl:use-package</code></a> declarations: see <a href="#package-dependencies"><i>3.5.2 Dependencies between Packages</i></a>.</p></dd><dt><a href="#dt-transmission">transmission</a></dt><dd><p>An operand usage of <b>transmission</b> indicates that the construct will (potentially) return a supplied node as part of its result to the calling construct (that is, to its parent in the construct tree).</p></dd><dt><a href="#dt-traversal">traversal</a></dt><dd><p>A <b>traversal</b> of a tree is a sequence of <a title="traversal-event" class="termref" href="#dt-traversal-event">traversal events</a>.</p></dd><dt><a href="#dt-traversal-event">traversal-event</a></dt><dd><p>a <b>traversal event</b> (shortened to <b>event</b> in this section) is a pair comprising a phase (start or end) and a node.</p></dd><dt><a href="#dt-tree">tree</a></dt><dd><p>The term <b>tree</b> is used (as in <a href="#xpath-datamodel-30">[XDM 3.0]</a>) to refer to the aggregate consisting of a parentless node together with all its descendant nodes, plus all their attributes and namespaces.</p></dd><dt><a href="#dt-tunnel-parameter">tunnel parameter</a></dt><dd><p>A parameter passed to a template may be defined as a <b>tunnel parameter</b>. Tunnel parameters have the property that they are automatically passed on by the called template to any further templates that it calls, and so on recursively.</p></dd><dt><a href="#dt-type-annotation">type annotation</a></dt><dd><p>The term <b>type annotation</b> is used in this specification to refer to the value returned by the <code>dm:type-name</code> accessor of a node: see <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-type-name">Section 5.14 type-name Accessor </a><sup><small>DM30</small></sup>.</p></dd><dt><a href="#dt-type-error">type error</a></dt><dd><p>Certain errors are classified as <b>type errors</b>. A type error occurs when the value supplied as input to an operation is of the wrong type for that operation, for example when an integer is supplied to an operation that expects a node.</p></dd><dt><a href="#dt-type-pattern">type pattern</a></dt><dd><p>A <b>type pattern</b> can be written as <code>type(T)</code> (where <var>T</var> is an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP40</small></sup> followed by zero or more predicates in square brackets, and it matches any item of type <var>T</var> which each of the predicates evaluates to <code>true</code>.</p></dd><dt><a href="#dt-type-adjusted-posture-and-sweep">type-adjusted posture and sweep</a></dt><dd><p>The <b>type-adjusted posture and sweep</b> of a construct <var>C</var>, with respect to a type <var>T</var>, are the <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> established by applying the <a title="general streamability rules" class="termref" href="#dt-general-streamability-rules">general streamability rules</a> to a construct <var>D</var> whose single operand is the construct <var>C</var>, where the <a title="operand usage" class="termref" href="#dt-operand-usage">operand usage</a> of <var>C</var> in <var>D</var> is the <a title="type-determined usage" class="termref" href="#dt-type-determined-usage">type-determined usage</a> based on the required type <var>T</var>.</p></dd><dt><a href="#dt-type-determined-usage">type-determined usage</a></dt><dd><p>The <b>type-determined usage</b> of an <a title="operand" class="termref" href="#dt-operand">operand</a> is as follows: if the required type (ignoring occurrence indicator) is <code>function(*)</code> or a subtype thereof, then <a title="inspection" class="termref" href="#dt-inspection">inspection</a>; if the required type (ignoring occurrence indicator) is an atomic or union type, then <a title="absorption" class="termref" href="#dt-absorption">absorption</a>; otherwise <a title="navigation" class="termref" href="#dt-navigation">navigation</a>.</p></dd><dt><a href="#dt-typed-value">typed value</a></dt><dd><p>The term <b>typed value</b> is defined in <a href="https://www.w3.org/TR/xpath-datamodel-30/#dm-typed-value">Section 5.15 typed-value Accessor </a><sup><small>DM30</small></sup>. Every node, other than an element whose type annotation identifies it as having element-only content, has a <a title="string value" class="termref" href="#dt-string-value">typed value</a>. For example, the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of an attribute of type <code>xs:IDREFS</code> is a sequence of zero or more <code>xs:IDREF</code> values.</p></dd><dt><a href="#dt-utype">U-type</a></dt><dd><p>A <b>U-type</b> is a set of <a title="fundamental item type" class="termref" href="#dt-fundamental-item-type">fundamental item types</a>.</p></dd><dt><a href="#dt-unnamed-mode">unnamed mode</a></dt><dd><p>The <b>unnamed mode</b> is the default mode used when no <code>mode</code> attribute is specified on an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction or <a href="#element-template"><code>xsl:template</code></a> declaration, unless a different default mode has been specified using the <code>[xsl:]default-mode</code> attribute of a containing element.</p></dd><dt><a href="#dt-uri-reference">URI Reference</a></dt><dd><p>Within this specification, the term <b>URI Reference</b>, unless otherwise stated, refers to a string in the lexical space of the <code>xs:anyURI</code> datatype as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p></dd><dt><a href="#dt-use">use</a></dt><dd><p>If a package <var>Q</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package <var>P</var>, then package <var>Q</var> is said to <b>use</b> package <var>P</var>. In this relationship package <var>Q</var> is referred to as the <b>using</b> package, package <var>P</var> as the <b>used</b> package.</p></dd><dt><a href="#dt-data-element">user-defined data element</a></dt><dd><p>In addition to <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain among its children any element not from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element has a non-null namespace URI. Such elements are referred to as <b>user-defined data elements</b>.</p></dd><dt><a href="#dt-vacuous">vacuous</a></dt><dd><p>An item is <b>vacuous</b> if it is one of the following: a zero-length text node; a document node with no children; an atomic value which, on casting to <code>xs:string</code>, produces a zero-length string; or an array which on flattening using the <a href="https://www.w3.org/TR/xpath-functions-30/#func-array-flatten"><code>array:flatten</code></a><sup><small>FO40</small></sup> function produces either an empty sequence or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.</p></dd><dt><a href="#dt-value">value</a></dt><dd><p>A variable is a binding between a name and a value. The <b>value</b> of a variable is any sequence (of nodes, atomic values, and/or function items), as defined in <a href="#xpath-datamodel-30">[XDM 3.0]</a>.</p></dd><dt><a href="#dt-value-template">value template</a></dt><dd><p>Collectively, attribute value templates and text value templates are referred to as <b>value templates</b>.</p></dd><dt><a href="#dt-variable">variable</a></dt><dd><p>The <a href="#element-variable"><code>xsl:variable</code></a> element declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>.</p></dd><dt><a href="#dt-variable-binding-element">variable-binding element</a></dt><dd><p>The two elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to as <b>variable-binding elements</b>.</p></dd><dt><a href="#dt-visibility">visibility</a></dt><dd><p>The <b>visibility</b> of a <a title="component" class="termref" href="#dt-component">component</a> is one of: <code>private</code>, <code>public</code>, <code>abstract</code>, <code>final</code>, or <code>hidden</code>.</p></dd><dt><a href="#dt-whitespace-text-node">whitespace text node</a></dt><dd><p>A <b>whitespace text node</b> is a text node whose content consists entirely of whitespace characters (that is, #x09, #x0A, #x0D, or #x20).</p></dd><dt><a href="#xml-namespace">XML namespace</a></dt><dd><p>The <b>XML namespace</b>, defined in <a href="#xml-names">[Namespaces in XML]</a> as <code>http://www.w3.org/XML/1998/namespace</code>, is used for attributes such as <code>xml:lang</code>, <code>xml:space</code>, and <code>xml:id</code>.</p></dd><dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a></dt><dd><p>The term <b>XPath 1.0 compatibility mode</b> is defined in <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#static_context">Section 2.2.1 Static Context</a><sup><small>XP40</small></sup>. This is a setting in the static context of an XPath expression; it has two values, <code>true</code> and <code>false</code>. When the value is set to true, the semantics of function calls and certain other operations are adjusted to give a greater degree of backwards compatibility between XPath <span>4.0</span> and XPath 1.0.</p></dd><dt><a href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></dt><dd><p>An element in the stylesheet is processed with <b>XSLT 1.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 1.0.</p></dd><dt><a href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a></dt><dd><p>A processor that claims conformance with the <b>XSLT 1.0 compatibility feature</b><span class="verb">must</span> support the processing of stylesheet instructions and XPath expressions with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, as defined in <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>.</p></dd><dt><a href="#dt-xslt-20-behavior">XSLT 2.0 behavior</a></dt><dd><p>An element is processed with <b>XSLT 2.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 2.0.</p></dd><dt><a href="#dt-xslt-30-behavior">XSLT 3.0 behavior</a></dt><dd><p>An element is processed with <b>XSLT 3.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 3.0.</p></dd><dt><a href="#dt-xslt-element">XSLT element</a></dt><dd><p>An <b>XSLT element</b> is an element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose syntax and semantics are defined in this specification.</p></dd><dt><a href="#dt-xslt-instruction">XSLT instruction</a></dt><dd><p>An <b>XSLT instruction</b> is an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> whose syntax summary in this specification contains the annotation <code>&lt;!-- category: instruction --&gt;</code>.</p></dd><dt><a href="#dt-xslt-namespace">XSLT namespace</a></dt><dd><p>The <b>XSLT namespace</b> has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to identify elements, attributes, and other names that have a special meaning defined in this specification.</p></dd></dl></div><div class="div1"><h2><a id="element-syntax-summary"></a>D Element Syntax Summary (Non-Normative)</h2><p>The syntax of each XSLT element is summarized below, together with the context in the stylesheet where the element may appear. Some elements (specifically, instructions) are allowed as a child of any element that is allowed to contain a sequence constructor. These elements are:</p><ul><li>Literal result elements</li><li>Extension instructions, if so defined</li></ul><p><b><a href="#element-accept">xsl:accept</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:accept</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:accept<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract" | "hidden"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-use-package">xsl:use-package</a></li></ul></td></tr></tbody></table><p><b><a href="#element-accumulator">xsl:accumulator</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:accumulator</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:accumulator<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>initial-value</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br>&lt;/xsl:accumulator&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-accumulator-rule">xsl:accumulator-rule</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:accumulator-rule</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:accumulator-rule<br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;phase? = "start" | "end"<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:accumulator-rule&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-accumulator">xsl:accumulator</a></li></ul></td></tr></tbody></table><p><b><a href="#element-analyze-string">xsl:analyze-string</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:analyze-string</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:analyze-string<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;<b>regex</b> = { <var>string</var> }<br>&nbsp;&nbsp;flags? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-matching-substring">xsl:matching-substring</a>?, <a href="#element-non-matching-substring">xsl:non-matching-substring</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:analyze-string&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-apply-imports">xsl:apply-imports</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:apply-imports</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:apply-imports&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:apply-imports&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-apply-templates">xsl:apply-templates</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:apply-templates</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:apply-templates<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;mode? = <var>token</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br>&lt;/xsl:apply-templates&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-array">xsl:array</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:array</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:array<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;use? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:array&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-assert">xsl:assert</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:assert</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:assert<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:assert&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-attribute">xsl:attribute</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:attribute</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:attribute<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:attribute&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-attribute-set">xsl:attribute-set</a></li><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-attribute-set">xsl:attribute-set</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:attribute-set</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:attribute-set<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"<br>&nbsp;&nbsp;streamable? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>* --&gt;<br>&lt;/xsl:attribute-set&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li><li><a href="#element-override">xsl:override</a></li></ul></td></tr></tbody></table><p><b><a href="#element-break">xsl:break</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:break</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:break<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:break&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-call-template">xsl:call-template</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:call-template</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:call-template<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:call-template&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-catch">xsl:catch</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:catch</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:catch<br>&nbsp;&nbsp;errors? = <var>tokens</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:catch&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-try">xsl:try</a></li></ul></td></tr></tbody></table><p><b><a href="#element-character-map">xsl:character-map</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:character-map</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:character-map<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-output-character">xsl:output-character</a>*) --&gt;<br>&lt;/xsl:character-map&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-choose">xsl:choose</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:choose</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:choose&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br>&lt;/xsl:choose&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-comment">xsl:comment</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:comment</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:comment<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:comment&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-context-item">xsl:context-item</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:context-item</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-template">xsl:template</a></li></ul></td></tr></tbody></table><p><b><a href="#element-copy">xsl:copy</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:copy</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:copy<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var><br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:copy&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-copy-of">xsl:copy-of</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:copy-of</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:copy-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;copy-accumulators? = <var>boolean</var><br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-decimal-format">xsl:decimal-format</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:decimal-format</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:decimal-format<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;decimal-separator? = <var>char</var><br>&nbsp;&nbsp;grouping-separator? = <var>char</var><br>&nbsp;&nbsp;infinity? = <var>string</var><br>&nbsp;&nbsp;minus-sign? = <var>char</var><br>&nbsp;&nbsp;exponent-separator? = <var>char</var><br>&nbsp;&nbsp;NaN? = <var>string</var><br>&nbsp;&nbsp;percent? = <var>char</var><br>&nbsp;&nbsp;per-mille? = <var>char</var><br>&nbsp;&nbsp;zero-digit? = <var>char</var><br>&nbsp;&nbsp;digit? = <var>char</var><br>&nbsp;&nbsp;pattern-separator? = <var>char</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-document">xsl:document</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:document</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:document<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:document&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-element">xsl:element</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:element</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:element<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var><br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:element&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-evaluate">xsl:evaluate</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:evaluate</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:evaluate<br>&nbsp;&nbsp;<b>xpath</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;base-uri? = { <var>uri</var> }<br>&nbsp;&nbsp;with-params? = <var>expression</var><br>&nbsp;&nbsp;context-item? = <var>expression</var><br>&nbsp;&nbsp;namespace-context? = <var>expression</var><br>&nbsp;&nbsp;schema-aware? = { <var>boolean</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:evaluate&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-expose">xsl:expose</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:expose</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:expose<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li></ul></td></tr></tbody></table><p><b><a href="#element-fallback">xsl:fallback</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:fallback</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:fallback&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:fallback&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-analyze-string">xsl:analyze-string</a></li><li><a href="#element-evaluate">xsl:evaluate</a></li><li><a href="#element-fork">xsl:fork</a></li><li><a href="#element-merge">xsl:merge</a></li><li><a href="#element-next-match">xsl:next-match</a></li><li><a href="#element-try">xsl:try</a></li><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-for-each">xsl:for-each</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:for-each</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:for-each<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-for-each-group">xsl:for-each-group</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:for-each-group</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:for-each-group<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;group-by? = <var>expression</var><br>&nbsp;&nbsp;group-adjacent? = <var>expression</var><br>&nbsp;&nbsp;group-starting-with? = <var>pattern</var><br>&nbsp;&nbsp;group-ending-with? = <var>pattern</var><br>&nbsp;&nbsp;break-when? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var><br>&nbsp;&nbsp;collation? = { <var>uri</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each-group&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-fork">xsl:fork</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:fork</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:fork&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-fallback">xsl:fallback</a>*, ((<a href="#element-sequence">xsl:sequence</a>, <a href="#element-fallback">xsl:fallback</a>*)* | (<a href="#element-for-each-group">xsl:for-each-group</a>, <a href="#element-fallback">xsl:fallback</a>*))) --&gt;<br>&lt;/xsl:fork&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-function">xsl:function</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:function</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:function<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"<br>&nbsp;&nbsp;streamability? = "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | <var>eqname</var><br>&nbsp;&nbsp;override-extension-function? = <var>boolean</var><br>&nbsp;&nbsp;<span class="grayed">[override]?</span> = <var>boolean</var><br>&nbsp;&nbsp;new-each-time? = "yes" | "true" | "1" | "no" | "false" | "0" | "maybe"<br>&nbsp;&nbsp;cache? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:function&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li><li><a href="#element-override">xsl:override</a></li></ul></td></tr></tbody></table><p><b><a href="#element-function-library">xsl:function-library</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:function-library</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:function-library<br>&nbsp;&nbsp;namespace? = <var>uri</var><br>&nbsp;&nbsp;schema-location? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-function-namespace">xsl:function-namespace</a>* --&gt;<br>&lt;/xsl:function-library&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-function-namespace">xsl:function-namespace</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:function-namespace</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:function-namespace<br>&nbsp;&nbsp;<b>uri</b> = <var>uri</var><br>&nbsp;&nbsp;prefix? = <var>ncname</var><br>&nbsp;&nbsp;exclude? = <var>ncnames</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-function-library">xsl:function-library</a></li></ul></td></tr></tbody></table><p><b><a href="#element-global-context-item">xsl:global-context-item</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:global-context-item</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:global-context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-if">xsl:if</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:if</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:if<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;then? = <var>expression</var><br>&nbsp;&nbsp;else? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:if&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-import">xsl:import</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:import</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:import<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-import-schema">xsl:import-schema</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:import-schema</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:import-schema<br>&nbsp;&nbsp;namespace? = <var>uri</var><br>&nbsp;&nbsp;schema-location? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: xs:schema? --&gt;<br>&lt;/xsl:import-schema&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-include">xsl:include</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:include</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:include<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-item-type">xsl:item-type</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:item-type</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:item-type<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;visibility? = "private" | "final"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-iterate">xsl:iterate</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:iterate</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:iterate<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <a href="#element-on-completion">xsl:on-completion</a>?, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:iterate&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-key">xsl:key</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:key</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:key<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;use? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var><br>&nbsp;&nbsp;collation? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:key&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-map">xsl:map</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:map</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:map<br>&nbsp;&nbsp;on-duplicates? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-map-entry">xsl:map-entry</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:map-entry</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:map-entry<br>&nbsp;&nbsp;<b>key</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map-entry&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-matching-substring">xsl:matching-substring</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:matching-substring</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:matching-substring&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-analyze-string">xsl:analyze-string</a></li></ul></td></tr></tbody></table><p><b><a href="#element-merge">xsl:merge</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:merge</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:merge&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-merge-source">xsl:merge-source</a>+, <a href="#element-merge-action">xsl:merge-action</a>, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:merge&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-merge-action">xsl:merge-action</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:merge-action</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:merge-action&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-action&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-merge">xsl:merge</a></li></ul></td></tr></tbody></table><p><b><a href="#element-merge-key">xsl:merge-key</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:merge-key</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:merge-key<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-key&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-merge-source">xsl:merge-source</a></li></ul></td></tr></tbody></table><p><b><a href="#element-merge-source">xsl:merge-source</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:merge-source</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:merge-source<br>&nbsp;&nbsp;name? = <var>ncname</var><br>&nbsp;&nbsp;for-each-item? = <var>expression</var><br>&nbsp;&nbsp;for-each-source? = <var>expression</var><br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var><br>&nbsp;&nbsp;sort-before-merge? = <var>boolean</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-merge-key">xsl:merge-key</a>+ --&gt;<br>&lt;/xsl:merge-source&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-merge">xsl:merge</a></li></ul></td></tr></tbody></table><p><b><a href="#element-message">xsl:message</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:message</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:message<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;terminate? = { <var>boolean</var> }<br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:message&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-mode">xsl:mode</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:mode</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:mode<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var><br>&nbsp;&nbsp;on-no-match? = "deep-copy" | "shallow-copy" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail"<br>&nbsp;&nbsp;on-multiple-match? = "use-last" | "fail"<br>&nbsp;&nbsp;warning-on-no-match? = <var>boolean</var><br>&nbsp;&nbsp;warning-on-multiple-match? = <var>boolean</var><br>&nbsp;&nbsp;typed? = <var>boolean</var> | "strict" | "lax" | "unspecified"<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a>*) --&gt;<br>&lt;/xsl:mode&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-namespace">xsl:namespace</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:namespace</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:namespace<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:namespace&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-namespace-alias">xsl:namespace-alias</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:namespace-alias</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:namespace-alias<br>&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | "#default"<br>&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> | "#default"&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-next-iteration">xsl:next-iteration</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:next-iteration</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:next-iteration&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a>*) --&gt;<br>&lt;/xsl:next-iteration&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-next-match">xsl:next-match</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:next-match</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:next-match&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:next-match&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-non-matching-substring">xsl:non-matching-substring</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:non-matching-substring</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:non-matching-substring&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:non-matching-substring&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-analyze-string">xsl:analyze-string</a></li></ul></td></tr></tbody></table><p><b><a href="#element-note">xsl:note</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:note</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:note<br>&nbsp;&nbsp;#any#? = <var>string</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>any</var> --&gt;<br>&lt;/xsl:note&gt;</code></p></td></tr></tbody></table><p><b><a href="#element-number">xsl:number</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:number</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:number<br>&nbsp;&nbsp;value? = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;level? = "single" | "multiple" | "any"<br>&nbsp;&nbsp;count? = <var>pattern</var><br>&nbsp;&nbsp;from? = <var>pattern</var><br>&nbsp;&nbsp;format? = { <var>string</var> }<br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;letter-value? = { "alphabetic" | "traditional" }<br>&nbsp;&nbsp;ordinal? = { <var>string</var> }<br>&nbsp;&nbsp;start-at? = { <var>string</var> }<br>&nbsp;&nbsp;grouping-separator? = { <var>char</var> }<br>&nbsp;&nbsp;grouping-size? = { <var>integer</var> }&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-on-completion">xsl:on-completion</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:on-completion</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:on-completion<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-completion&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-iterate">xsl:iterate</a></li></ul></td></tr></tbody></table><p><b><a href="#element-on-empty">xsl:on-empty</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:on-empty</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:on-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-empty&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-on-non-empty">xsl:on-non-empty</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:on-non-empty</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:on-non-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-non-empty&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-otherwise">xsl:otherwise</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:otherwise</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-choose">xsl:choose</a></li></ul></td></tr></tbody></table><p><b><a href="#element-otherwise">xsl:otherwise</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:otherwise</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-choose">xsl:choose</a></li></ul></td></tr></tbody></table><p><b><a href="#element-output">xsl:output</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:output</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:output<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;method? = "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var><br>&nbsp;&nbsp;allow-duplicate-names? = <var>boolean</var><br>&nbsp;&nbsp;build-tree? = <var>boolean</var><br>&nbsp;&nbsp;byte-order-mark? = <var>boolean</var><br>&nbsp;&nbsp;cdata-section-elements? = <var>eqnames</var><br>&nbsp;&nbsp;doctype-public? = <var>string</var><br>&nbsp;&nbsp;doctype-system? = <var>string</var><br>&nbsp;&nbsp;encoding? = <var>string</var><br>&nbsp;&nbsp;escape-uri-attributes? = <var>boolean</var><br>&nbsp;&nbsp;html-version? = <var>decimal</var><br>&nbsp;&nbsp;include-content-type? = <var>boolean</var><br>&nbsp;&nbsp;indent? = <var>boolean</var><br>&nbsp;&nbsp;item-separator? = <var>string</var><br>&nbsp;&nbsp;json-node-output-method? = "xml" | "html" | "xhtml" | "text" | <var>eqname</var><br>&nbsp;&nbsp;media-type? = <var>string</var><br>&nbsp;&nbsp;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var><br>&nbsp;&nbsp;omit-xml-declaration? = <var>boolean</var><br>&nbsp;&nbsp;parameter-document? = <var>uri</var><br>&nbsp;&nbsp;standalone? = <var>boolean</var> | "omit"<br>&nbsp;&nbsp;suppress-indentation? = <var>eqnames</var><br>&nbsp;&nbsp;undeclare-prefixes? = <var>boolean</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;version? = <var>nmtoken</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-output-character">xsl:output-character</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:output-character</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:output-character<br>&nbsp;&nbsp;<b>character</b> = <var>char</var><br>&nbsp;&nbsp;<b>string</b> = <var>string</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-character-map">xsl:character-map</a></li></ul></td></tr></tbody></table><p><b><a href="#element-override">xsl:override</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:override</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:override&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a> | <a href="#element-function">xsl:function</a> | <a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a> | <a href="#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br>&lt;/xsl:override&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-use-package">xsl:use-package</a></li></ul></td></tr></tbody></table><p><b><a href="#element-package">xsl:package</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:package</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:package<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;name? = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"<br>&nbsp;&nbsp;declared-modes? = <var>boolean</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;default-element-namespace? = <var>uri</var><br>&nbsp;&nbsp;default-type-namespace? = <var>uri</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;use-when? = <var>expression</var><br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-expose">xsl:expose</a> | <var>declarations</var>)*) --&gt;<br>&lt;/xsl:package&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>None</li></ul></td></tr></tbody></table><p><b><a href="#element-param">xsl:param</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:param</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;required? = <var>boolean</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var><br>&nbsp;&nbsp;static? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:param&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li><li><a href="#element-override">xsl:override</a></li><li><a href="#element-function">xsl:function</a></li><li><a href="#element-template">xsl:template</a></li><li><a href="#element-iterate">xsl:iterate</a></li></ul></td></tr></tbody></table><p><b><a href="#element-perform-sort">xsl:perform-sort</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:perform-sort</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:perform-sort<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:perform-sort&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-preserve-space">xsl:preserve-space</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:preserve-space</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:preserve-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-processing-instruction">xsl:processing-instruction</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:processing-instruction</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:processing-instruction<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:processing-instruction&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-result-document">xsl:result-document</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:result-document</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:result-document<br>&nbsp;&nbsp;format? = { <var>eqname</var> }<br>&nbsp;&nbsp;href? = { <var>uri</var> }<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;method? = { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var> }<br>&nbsp;&nbsp;allow-duplicate-names? = { <var>boolean</var> }<br>&nbsp;&nbsp;build-tree? = { <var>boolean</var> }<br>&nbsp;&nbsp;byte-order-mark? = { <var>boolean</var> }<br>&nbsp;&nbsp;cdata-section-elements? = { <var>eqnames</var> }<br>&nbsp;&nbsp;doctype-public? = { <var>string</var> }<br>&nbsp;&nbsp;doctype-system? = { <var>string</var> }<br>&nbsp;&nbsp;encoding? = { <var>string</var> }<br>&nbsp;&nbsp;escape-uri-attributes? = { <var>boolean</var> }<br>&nbsp;&nbsp;html-version? = { <var>decimal</var> }<br>&nbsp;&nbsp;include-content-type? = { <var>boolean</var> }<br>&nbsp;&nbsp;indent? = { <var>boolean</var> }<br>&nbsp;&nbsp;item-separator? = { <var>string</var> }<br>&nbsp;&nbsp;json-node-output-method? = { "xml" | "html" | "xhtml" | "text" | <var>eqname</var> }<br>&nbsp;&nbsp;media-type? = { <var>string</var> }<br>&nbsp;&nbsp;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var> }<br>&nbsp;&nbsp;omit-xml-declaration? = { <var>boolean</var> }<br>&nbsp;&nbsp;parameter-document? = { <var>uri</var> }<br>&nbsp;&nbsp;standalone? = { <var>boolean</var> | "omit" }<br>&nbsp;&nbsp;suppress-indentation? = { <var>eqnames</var> }<br>&nbsp;&nbsp;undeclare-prefixes? = { <var>boolean</var> }<br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;output-version? = { <var>nmtoken</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:result-document&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-sequence">xsl:sequence</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:sequence</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:sequence<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sequence&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-sort">xsl:sort</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:sort</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:sort<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;stable? = { <var>boolean</var> }<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sort&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-apply-templates">xsl:apply-templates</a></li><li><a href="#element-for-each">xsl:for-each</a></li><li><a href="#element-for-each-group">xsl:for-each-group</a></li><li><a href="#element-perform-sort">xsl:perform-sort</a></li></ul></td></tr></tbody></table><p><b><a href="#element-source-document">xsl:source-document</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:source-document</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:source-document<br>&nbsp;&nbsp;<b>href</b> = { <var>uri</var> }<br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:source-document&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-strip-space">xsl:strip-space</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:strip-space</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:strip-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-stylesheet">xsl:stylesheet</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:stylesheet</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:stylesheet<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;default-element-namespace? = <var>uri</var><br>&nbsp;&nbsp;default-type-namespace? = <var>uri</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;use-when? = <var>expression</var><br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:stylesheet&gt;</code></p></td></tr></tbody></table><p><b><a href="#element-switch">xsl:switch</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:switch</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:switch<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:switch&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-template">xsl:template</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:template</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:template<br>&nbsp;&nbsp;match? = <var>pattern</var><br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;priority? = <var>decimal</var><br>&nbsp;&nbsp;mode? = <var>tokens</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-context-item">xsl:context-item</a>?, <a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:template&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li><li><a href="#element-override">xsl:override</a></li></ul></td></tr></tbody></table><p><b><a href="#element-text">xsl:text</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:text</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:text<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: #PCDATA --&gt;<br>&lt;/xsl:text&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-transform">xsl:transform</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:transform</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:transform<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;default-element-namespace? = <var>uri</var><br>&nbsp;&nbsp;default-type-namespace? = <var>uri</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;use-when? = <var>expression</var><br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:transform&gt;</code></p></td></tr></tbody></table><p><b><a href="#element-try">xsl:try</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:try</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:try<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;rollback-output? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>sequence-constructor</var>, <a href="#element-catch">xsl:catch</a>, (<a href="#element-catch">xsl:catch</a> | <a href="#element-fallback">xsl:fallback</a>)*) --&gt;<br>&lt;/xsl:try&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-use-package">xsl:use-package</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:use-package</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:use-package<br>&nbsp;&nbsp;<b>name</b> = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-accept">xsl:accept</a> | <a href="#element-override">xsl:override</a>)* --&gt;<br>&lt;/xsl:use-package&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li></ul></td></tr></tbody></table><p><b><a href="#element-value-of">xsl:value-of</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:value-of</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:value-of<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:value-of&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-variable">xsl:variable</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:variable</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>declaration instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:variable<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;static? = <var>boolean</var><br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:variable&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-package">xsl:package</a></li><li><a href="#element-stylesheet">xsl:stylesheet</a></li><li><a href="#element-transform">xsl:transform</a></li><li><a href="#element-override">xsl:override</a></li><li><a href="#element-function">xsl:function</a></li><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-when">xsl:when</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:when</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-choose">xsl:choose</a></li></ul></td></tr></tbody></table><p><b><a href="#element-when">xsl:when</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:when</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-choose">xsl:choose</a></li></ul></td></tr></tbody></table><p><b><a href="#element-where-populated">xsl:where-populated</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:where-populated</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Category: </i>instruction</p><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:where-populated&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:where-populated&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li>any XSLT element whose content model is <i>sequence constructor</i></li><li>any literal result element</li></ul></td></tr></tbody></table><p><b><a href="#element-with-param">xsl:with-param</a></b></p><table style="width:100%"><caption>Syntax summary for element xsl:with-param</caption><tbody><tr><td style="width:10%">&nbsp;</td><td><p><i>Model:</i></p><p class="element-syntax-summary"><code>&lt;xsl:with-param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:with-param&gt;</code></p><p><i>Permitted parent elements:</i></p><ul><li><a href="#element-apply-templates">xsl:apply-templates</a></li><li><a href="#element-apply-imports">xsl:apply-imports</a></li><li><a href="#element-call-template">xsl:call-template</a></li><li><a href="#element-evaluate">xsl:evaluate</a></li><li><a href="#element-next-match">xsl:next-match</a></li><li><a href="#element-next-iteration">xsl:next-iteration</a></li></ul></td></tr></tbody></table></div><div class="div1"><h2><a id="error-summary"></a>E Summary of Error Conditions (Non-Normative)</h2><p>This appendix provides a summary of error conditions that a processor may signal. This list includes all error codes defined in this specification, but this is not an exhaustive list of all errors that can occur. Implementations <span class="verb">must</span> signal errors using these error codes, and applications can test for these codes; however, when more than one rule in the specification is violated, different processors will not necessarily signal the same error code. Implementations are not <span class="verb">required</span> to signal errors using the descriptive text used here.</p><div class="note"><p class="prefix"><b>Note:</b></p><p>The appendix is non-normative because the same information is given normatively elsewhere.</p></div><p><b>Static errors</b></p><dl><dt><a href="#err-XTSE0010"><span class="error">ERR XTSE0010</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an XSLT-defined element is used in a context where it is not permitted, if a <span class="verb">required</span> attribute is omitted, or if the content of the element does not correspond to the content that is allowed for the element.</p></dd><dt><a href="#err-XTSE0020"><span class="error">ERR XTSE0020</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an attribute (other than an attribute written using curly brackets in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted) contains a value that is not one of the permitted values for that attribute.</p></dd><dt><a href="#err-XTSE0080"><span class="error">ERR XTSE0080</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, a <a title="decimal format" class="termref" href="#dt-decimal-format">decimal-format</a>, a <a title="variable" class="termref" href="#dt-variable">variable</a> or <a title="parameter" class="termref" href="#dt-parameter">parameter</a>, a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>, an <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>, or a <a title="character map" class="termref" href="#dt-character-map">character map</a><span>; except that the name <code>xsl:initial-template</code> is permitted as a template name.</span></p></dd><dt><a href="#err-XTSE0085"><span class="error">ERR XTSE0085</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the name of any <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>, other than a function or instruction defined in this specification or in a normatively referenced specification. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a prefix bound to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute. </p></dd><dt><a href="#err-XTSE0090"><span class="error">ERR XTSE0090</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an element from the XSLT namespace to have an attribute whose namespace is either null (that is, an attribute with an unprefixed name) or the XSLT namespace, other than attributes defined for the element in this document.</p></dd><dt><a href="#err-XTSE0110"><span class="error">ERR XTSE0110</span></a></dt><dd><p>The value of the <code>version</code> attribute <span class="verb">must</span> be a number: specifically, it <span class="verb">must</span> be a valid instance of the type <code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p></dd><dt><a href="#err-XTSE0120"><span class="error">ERR XTSE0120</span></a></dt><dd><p>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any text node children.</p></dd><dt><a href="#err-XTSE0125"><span class="error">ERR XTSE0125</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of an <code>[xsl:]default-collation</code> attribute, after resolving against the base URI, contains no URI that the implementation recognizes as a collation URI.</p></dd><dt><a href="#err-XTSE0130"><span class="error">ERR XTSE0130</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element has a child element whose name has a null namespace URI.</p></dd><dt><a href="#err-XTSE0150"><span class="error">ERR XTSE0150</span></a></dt><dd><p>A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> that is used as the outermost element of a simplified stylesheet module <span class="verb">must</span> have an <code>xsl:version</code> attribute.</p></dd><dt><a href="#err-XTSE0165"><span class="error">ERR XTSE0165</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the processor is not able to retrieve the resource identified by the URI reference [ in the <code>href</code> attribute of <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> ] , or if the resource that is retrieved does not contain a stylesheet module.</p></dd><dt><a href="#err-XTSE0170"><span class="error">ERR XTSE0170</span></a></dt><dd><p>An <a href="#element-include"><code>xsl:include</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p></dd><dt><a href="#err-XTSE0180"><span class="error">ERR XTSE0180</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a stylesheet module directly or indirectly includes itself.</p></dd><dt><a href="#err-XTSE0190"><span class="error">ERR XTSE0190</span></a></dt><dd><p>An <a href="#element-import"><code>xsl:import</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p></dd><dt><a href="#err-XTSE0210"><span class="error">ERR XTSE0210</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a stylesheet module directly or indirectly imports itself.</p></dd><dt><a href="#err-XTSE0215"><span class="error">ERR XTSE0215</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-import-schema"><code>xsl:import-schema</code></a> element that contains an <code>xs:schema</code> element has a <code>schema-location</code> attribute, or if it has a <code>namespace</code> attribute that conflicts with the target namespace of the contained schema.</p></dd><dt><a href="#err-XTSE0220"><span class="error">ERR XTSE0220</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the synthetic schema document does not satisfy the constraints described in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in Schema Construction and Structure</em>). This includes, without loss of generality, conflicts such as multiple definitions of the same name.</p></dd><dt><a href="#err-XTSE0260"><span class="error">ERR XTSE0260</span></a></dt><dd><p>Within an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> that is <span class="verb">required</span> to be empty, any content other than comments or processing instructions, including any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> preserved using the <code>xml:space="preserve"</code> attribute, is a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTSE0265"><span class="error">ERR XTSE0265</span></a></dt><dd><p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> in a <a title="package" class="termref" href="#dt-package">package</a> that specifies <code>input-type-annotations="strip"</code> and another <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that specifies <code>input-type-annotations="preserve"</code>, or if a stylesheet module specifies the value <code>strip</code> or <code>preserve</code> and the same value is not specified on the <a href="#element-package"><code>xsl:package</code></a> element of the containing package.</p></dd><dt><a href="#err-XTSE0270"><span class="error">ERR XTSE0270</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within any <a title="package" class="termref" href="#dt-package">package</a> the same <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP40</small></sup> appears in both an <a href="#element-strip-space"><code>xsl:strip-space</code></a> and an <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declaration if both have the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. Two NameTests are considered the same if they match the same set of names (which can be determined by comparing them after expanding namespace prefixes to URIs).</p></dd><dt><a href="#err-XTSE0280"><span class="error">ERR XTSE0280</span></a></dt><dd><p>In the case of a prefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> used as the value (or as part of the value) of an attribute in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, or appearing within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> in the stylesheet, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="defining element" class="termref" href="#dt-defining-element">defining element</a> has no namespace node whose name matches the prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p></dd><dt><a href="#err-XTSE0340"><span class="error">ERR XTSE0340</span></a></dt><dd><p>Where an attribute is defined to contain a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the pattern does not match the production <a href="#doc-xslt40-patterns-Pattern40">Pattern40</a>.</p></dd><dt><a href="#err-XTSE0350"><span class="error">ERR XTSE0350</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped left curly bracket appears in a fixed part of a value template without a matching right curly bracket.</p></dd><dt><a href="#err-XTSE0370"><span class="error">ERR XTSE0370</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped right curly bracket occurs in a fixed part of a value template.</p></dd><dt><a href="#err-XTSE0500"><span class="error">ERR XTSE0500</span></a></dt><dd><p>An <a href="#element-template"><code>xsl:template</code></a> element <span class="verb">must</span> have either a <code>match</code> attribute or a <code>name</code> attribute, or both. An <a href="#element-template"><code>xsl:template</code></a> element that has no <code>match</code> attribute <span class="verb">must</span> have no <code>mode</code> attribute and no <code>priority</code> attribute. An <a href="#element-template"><code>xsl:template</code></a> element that has no <code>name</code> attribute <span class="verb">must</span> have no <code>visibility</code> attribute.</p></dd><dt><a href="#err-XTSE0530"><span class="error">ERR XTSE0530</span></a></dt><dd><p>The value of the <code>priority</code> attribute [ of the <a href="#element-template"><code>xsl:template</code></a> element] <span class="verb">must</span> conform to the rules for the <code>xs:decimal</code> type defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>. Negative values are permitted.</p></dd><dt><a href="#err-XTSE0545"><span class="error">ERR XTSE0545</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if for any named or unnamed <a title="mode" class="termref" href="#dt-mode">mode</a>, a package explicitly specifies two conflicting values for the same attribute in different <a href="#element-mode"><code>xsl:mode</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same attribute with higher import precedence. The attributes in question are the attributes other than <code>name</code> on the <a href="#element-mode"><code>xsl:mode</code></a> element.</p></dd><dt><a href="#err-XTSE0550"><span class="error">ERR XTSE0550</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of modes [in the <code>mode</code> attribute of <a href="#element-template"><code>xsl:template</code></a> ] is empty, if the same token is included more than once in the list, if the list contains an invalid token, or if the token <code>#all</code> appears together with any other value.</p></dd><dt><a href="#err-XTSE0580"><span class="error">ERR XTSE0580</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the values of the <code>name</code> attribute of two sibling <a href="#element-param"><code>xsl:param</code></a> elements represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#err-XTSE0620"><span class="error">ERR XTSE0620</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a <code>select</code> attribute and has non-empty content.</p></dd><dt><a href="#err-XTSE0630"><span class="error">ERR XTSE0630</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more than one non-hidden binding of a global variable with the same name and same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains another binding with the same name and higher import precedence.</p></dd><dt><a href="#err-XTSE0650"><span class="error">ERR XTSE0650</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute does not match the <code>name</code> attribute of any <a title="named template" class="termref" href="#dt-named-template">named template</a> visible in the containing <a title="package" class="termref" href="#dt-package">package</a> (this includes any template defined in this package, as well as templates accepted from used packages whose visibility in this package is not <code>hidden</code>). For more details of the process of binding the called template, see <a href="#component-references"><i>3.5.3.5 Binding References to Components</i></a>.</p></dd><dt><a href="#err-XTSE0660"><span class="error">ERR XTSE0660</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more than one non-hidden <a title="template" class="termref" href="#dt-template">template</a> with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains a <a title="template" class="termref" href="#dt-template">template</a> with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></dd><dt><a href="#err-XTSE0670"><span class="error">ERR XTSE0670</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two or more sibling <a href="#element-with-param"><code>xsl:with-param</code></a> elements have <code>name</code> attributes that represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p></dd><dt><a href="#err-XTSE0680"><span class="error">ERR XTSE0680</span></a></dt><dd><p>In the case of <a href="#element-call-template"><code>xsl:call-template</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to pass a non-tunnel parameter named <var>x</var> to a template that does not have a non-tunnel <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> named <var>x</var>, unless the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>.</p></dd><dt><a href="#err-XTSE0690"><span class="error">ERR XTSE0690</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains both (a) a named template named <var>T</var> that is not overridden by another named template of higher import precedence and that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> non-tunnel parameter named <var>P</var>, and (b) an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code> attribute equals <var>T</var> and that has no non-tunnel <a href="#element-with-param"><code>xsl:with-param</code></a> child element whose <code>name</code> attribute equals <var>P</var>. (All names are compared as QNames.)</p></dd><dt><a href="#err-XTSE0710"><span class="error">ERR XTSE0710</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>use-attribute-sets</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, or <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, or the <code>xsl:use-attribute-sets</code> attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, is not a whitespace-separated sequence of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>, or if it contains an EQName that does not match the <code>name</code> attribute of any <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>.</p></dd><dt><a href="#err-XTSE0730"><span class="error">ERR XTSE0730</span></a></dt><dd><p>If an <a href="#element-attribute"><code>xsl:attribute</code></a> set element specifies <code>streamable="yes"</code> then every attribute set referenced in its <code>use-attribute-sets</code> attribute (if present) must also specify <code>streamable="yes"</code>.</p></dd><dt><a href="#err-XTSE0740"><span class="error">ERR XTSE0740</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> has a name that is in no namespace.</p></dd><dt><a href="#err-XTSE0760"><span class="error">ERR XTSE0760</span></a></dt><dd><p>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of an <a href="#element-function"><code>xsl:function</code></a> element has either a <code>select</code> attribute or non-empty content<span>, unless it specifies <code>required="no"</code>.</span></p></dd><dt><a href="#err-XTSE0761"><span class="error">ERR XTSE0761</span></a></dt><dd><p>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of an <a href="#element-function"><code>xsl:function</code></a> element specifies <code>required="no"</code>, unless all following-sibling <a href="#element-param"><code>xsl:param</code></a> elements also specify <code>required="no"</code>.</p></dd><dt><a href="#err-XTSE0769"><span class="error">ERR XTSE0769</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain an <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, <var>F</var> has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of <var>G</var> includes part but not all of the arity range of <var>F</var>, unless <var>G</var> is itself <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another <a href="#element-function"><code>xsl:function</code></a> declaration.</p></dd><dt><a href="#err-XTSE0770"><span class="error">ERR XTSE0770</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain an <a href="#element-function"><code>xsl:function</code></a> declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration <var>G</var> such that <var>F</var> and <var>G</var> have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, if the <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a> of <var>F</var> and <var>G</var> overlap in whole or in part, unless <var>F</var> and <var>G</var> are both <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another <a href="#element-function"><code>xsl:function</code></a> declaration.</p></dd><dt><a href="#err-XTSE0805"><span class="error">ERR XTSE0805</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an attribute on a literal result element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, unless it is one of the attributes explicitly defined in this specification.</p></dd><dt><a href="#err-XTSE0808"><span class="error">ERR XTSE0808</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a namespace prefix is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and there is no namespace binding in scope for that prefix.</p></dd><dt><a href="#err-XTSE0809"><span class="error">ERR XTSE0809</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value <code>#default</code> is used within the <code>[xsl:]exclude-result-prefixes</code> attribute and the parent element of the <code>[xsl:]exclude-result-prefixes</code> attribute has no default namespace.</p></dd><dt><a href="#err-XTSE0810"><span class="error">ERR XTSE0810</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within a <a title="package" class="termref" href="#dt-package">package</a> there is more than one such declaration [more than one <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration] with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and different values for the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, unless there is also an <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and a higher import precedence. </p></dd><dt><a href="#err-XTSE0812"><span class="error">ERR XTSE0812</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a value other than <code>#default</code> is specified for either the <code>stylesheet-prefix</code> or the <code>result-prefix</code> attributes of the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element when there is no in-scope binding for that namespace prefix.</p></dd><dt><a href="#err-XTSE0840"><span class="error">ERR XTSE0840</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-attribute"><code>xsl:attribute</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE0870"><span class="error">ERR XTSE0870</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-value-of"><code>xsl:value-of</code></a> element is present when the content of the element is non-empty.</p></dd><dt><a href="#err-XTSE0880"><span class="error">ERR XTSE0880</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE0910"><span class="error">ERR XTSE0910</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-namespace"><code>xsl:namespace</code></a> element is present when the element has content other than one or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions, or if the <code>select</code> attribute is absent when the element has empty content.</p></dd><dt><a href="#err-XTSE0940"><span class="error">ERR XTSE0940</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-comment"><code>xsl:comment</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE0975"><span class="error">ERR XTSE0975</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> is present unless the <code>select</code>, <code>level</code>, <code>count</code>, and <code>from</code> attributes are all absent.</p></dd><dt><a href="#err-XTSE1015"><span class="error">ERR XTSE1015</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-sort"><code>xsl:sort</code></a> element with a <code>select</code> attribute has non-empty content.</p></dd><dt><a href="#err-XTSE1017"><span class="error">ERR XTSE1017</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-sort"><code>xsl:sort</code></a> element other than the first in a sequence of sibling <a href="#element-sort"><code>xsl:sort</code></a> elements has a <code>stable</code> attribute.</p></dd><dt><a href="#err-XTSE1040"><span class="error">ERR XTSE1040</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction with a <code>select</code> attribute has any content other than <a href="#element-sort"><code>xsl:sort</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p></dd><dt><a href="#err-XTSE1060"><span class="error">ERR XTSE1060</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-group"><code>current-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE1070"><span class="error">ERR XTSE1070</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE1080"><span class="error">ERR XTSE1080</span></a></dt><dd><p>These <span>five</span> attributes [the <code>group-by</code>, <code>group-adjacent</code>, <code>group-starting-with</code>, <code>group-ending-with</code>, <span>and <code>break-when</code></span> attributes of <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> ] are mutually exclusive: it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if none of these attributes is present or if more than one of them is present.</p></dd><dt><a href="#err-XTSE1090"><span class="error">ERR XTSE1090</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to specify the <code>collation</code> attribute or the <code>composite</code> attribute if neither the <code>group-by</code> attribute nor <code>group-adjacent</code> attribute is specified.</p></dd><dt><a href="#err-XTSE1130"><span class="error">ERR XTSE1130</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction contains neither an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> nor an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element.</p></dd><dt><a href="#err-XTSE1205"><span class="error">ERR XTSE1205</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>use</code> attribute and has non-empty content, or if it has empty content and no <code>use</code> attribute.</p></dd><dt><a href="#err-XTSE1210"><span class="error">ERR XTSE1210</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>collation</code> attribute whose value (after resolving against the base URI) is not a URI recognized by the implementation as referring to a collation.</p></dd><dt><a href="#err-XTSE1220"><span class="error">ERR XTSE1220</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different effective collations. Two collations are the same if their URIs are equal under the rules for comparing <code>xs:anyURI</code> values, or if the implementation can determine that they are different URIs referring to the same collation.</p></dd><dt><a href="#err-XTSE1222"><span class="error">ERR XTSE1222</span></a></dt><dd><p><span style="display: none;" class="delete_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different effective values for the <code>composite</code> attribute.</span><span style="display: none;" class="add_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for the <code>composite</code> attribute.</span><span class="modify_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> with the same key name and different <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective values</span></a> <span class="deltaxml-old" style="background:#FF5555">values </span>for the <code>composite</code> attribute.</span></p></dd><dt><a href="#err-XTSE1290"><span class="error">ERR XTSE1290</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a named or unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a> contains two conflicting values for the same attribute in different <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same attribute with higher import precedence.</p></dd><dt><a href="#err-XTSE1295"><span class="error">ERR XTSE1295</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the character specified in the <code>zero-digit</code> attribute is not a digit or is a digit that does not have the numeric value zero. </p></dd><dt><a href="#err-XTSE1300"><span class="error">ERR XTSE1300</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if, for any named or unnamed decimal format, the variables representing characters used in a <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> do not each have distinct values. These variables are <var>decimal-separator-sign</var>, <var>grouping-sign</var>, <var>percent-sign</var>, <var>per-mille-sign</var>, <var>digit-zero-sign</var>, <var>digit-sign</var>, and <var>pattern-separator-sign</var>.</p></dd><dt><a href="#err-XTSE1430"><span class="error">ERR XTSE1430</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is no namespace bound to the prefix on the element bearing the <code>[xsl:]extension-element-prefixes</code> attribute or, when <code>#default</code> is specified, if there is no default namespace.</p></dd><dt><a href="#err-XTSE1505"><span class="error">ERR XTSE1505</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if both the <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are present on the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, or on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p></dd><dt><a href="#err-XTSE1520"><span class="error">ERR XTSE1520</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>type</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <span><a href="#element-source-document"><code>xsl:source-document</code></a>, or <a href="#element-merge-source"><code>xsl:merge-source</code></a></span> instruction, or the <code>xsl:type</code> attribute of a literal result element, is not a valid <code>QName</code>, or if it uses a prefix that is not defined in an in-scope namespace declaration, or if the QName is not the name of a type definition included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the <a title="package" class="termref" href="#dt-package">package</a>. <span>[XSLT 3.0 Erratum E20, bug 30234]</span></p></dd><dt><a href="#err-XTSE1530"><span class="error">ERR XTSE1530</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the <code>type</code> attribute of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction refers to a complex type definition</p></dd><dt><a href="#err-XTSE1560"><span class="error">ERR XTSE1560</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two <a href="#element-output"><code>xsl:output</code></a> declarations within an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> specify explicit values for the same attribute (other than <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and <code>use-character-maps</code>), with the values of the attributes being not equal, unless there is another <a href="#element-output"><code>xsl:output</code></a> declaration within the same <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> that has higher import precedence and that specifies an explicit value for the same attribute. </p></dd><dt><a href="#err-XTSE1570"><span class="error">ERR XTSE1570</span></a></dt><dd><p>The value [of the <code>method</code> attribute on <a href="#element-output"><code>xsl:output</code></a> ] <span class="verb">must</span> (if present) be a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with no a prefix, then it identifies a method specified in <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a> and <span class="verb">must</span> be one of <code>xml</code>, <code>html</code>, <code>xhtml</code>, or <code>text</code>.</p></dd><dt><a href="#err-XTSE1580"><span class="error">ERR XTSE1580</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains two or more character maps with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also contains another character map with the same name and higher import precedence.</p></dd><dt><a href="#err-XTSE1590"><span class="error">ERR XTSE1590</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a name in the <code>use-character-maps</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-character-map"><code>xsl:character-map</code></a> elements does not match the <code>name</code> attribute of any <a href="#element-character-map"><code>xsl:character-map</code></a> in the containing <a title="package" class="termref" href="#dt-package">package</a>.</p></dd><dt><a href="#err-XTSE1600"><span class="error">ERR XTSE1600</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a character map references itself, directly or indirectly, via a name in the <code>use-character-maps</code> attribute.</p></dd><dt><a href="#err-XTSE1650"><span class="error">ERR XTSE1650</span></a></dt><dd><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> signal a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p></dd><dt><a href="#err-XTSE1660"><span class="error">ERR XTSE1660</span></a></dt><dd><p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a><span class="verb">must</span> signal a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or <code>[xsl:]default-validation</code> attribute with a value other than <code>strip</code>, <code>preserve</code>, or <code>lax</code>; or an <a href="#element-mode"><code>xsl:mode</code></a> element whose <code>typed</code> attribute is equal to <code>yes</code> or <code>strict</code>; or an <code>as</code> attribute whose value is a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> that can only match nodes with a type annotation other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> (for example, <code>as="element(*, xs:integer)"</code>).</p></dd><dt><a href="#err-XTSE2200"><span class="error">ERR XTSE2200</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of a <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is not equal to the number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of another <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the same <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p></dd><dt><a href="#err-XTSE3000"><span class="error">ERR XTSE3000</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if no package matching the package name and version specified in an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration can be located.</p></dd><dt><a href="#err-XTSE3005"><span class="error">ERR XTSE3005</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package is dependent on itself, where package <var>A</var> is defined as being dependent on package <var>B</var> if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references <var>B</var>, or if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references a package <var>C</var> that is itself dependent on <var>B</var>.</p></dd><dt><a href="#err-XTSE3008"><span class="error">ERR XTSE3008</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is not in the same <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> as the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the <a title="package" class="termref" href="#dt-package">package</a>.</p></dd><dt><a href="#err-XTSE3010"><span class="error">ERR XTSE3010</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the explicit exposed visibility of a component is inconsistent with its declared visibility, as defined in the above table. (This error occurs only when the component declaration has an explicit <code>visibility</code> attribute, and the component is also listed explicitly by name in an <a href="#element-expose"><code>xsl:expose</code></a> declaration.)</p></dd><dt><a href="#err-XTSE3020"><span class="error">ERR XTSE3020</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a>, other than a wildcard, matches no component in the containing package.</p></dd><dt><a href="#err-XTSE3022"><span class="error">ERR XTSE3022</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>component</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a> specifies <code>*</code> (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p></dd><dt><a href="#err-XTSE3025"><span class="error">ERR XTSE3025</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the effect of an <a href="#element-expose"><code>xsl:expose</code></a> declaration would be to make a component <code>abstract</code>, unless the component is already <code>abstract</code> in the absence of the <a href="#element-expose"><code>xsl:expose</code></a> declaration. </p></dd><dt><a href="#err-XTSE3030"><span class="error">ERR XTSE3030</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other than a wildcard, matches no component in the used package.</p></dd><dt><a href="#err-XTSE3032"><span class="error">ERR XTSE3032</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>component</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a> specifies <code>*</code> (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p></dd><dt><a href="#err-XTSE3040"><span class="error">ERR XTSE3040</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the visibility assigned to a component by an <a href="#element-accept"><code>xsl:accept</code></a> element is incompatible with the visibility of the corresponding component in the used package, as defined by the above table, unless the token that matches the component name is a wildcard, in which case the <a href="#element-accept"><code>xsl:accept</code></a> element is treated as not matching that component.</p></dd><dt><a href="#err-XTSE3050"><span class="error">ERR XTSE3050</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#element-use-package"><code>xsl:use-package</code></a> elements in a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> cause two or more <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> components to be accepted with a visibility other than <code>hidden</code>.</p></dd><dt><a href="#err-XTSE3051"><span class="error">ERR XTSE3051</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other than a wildcard, matches the symbolic name of a component declared within an <a href="#element-override"><code>xsl:override</code></a> child of the same <a href="#element-use-package"><code>xsl:use-package</code></a> element.</p></dd><dt><a href="#err-XTSE3055"><span class="error">ERR XTSE3055</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a component declaration appearing as a child of <a href="#element-override"><code>xsl:override</code></a> is <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with any other declaration in the using package, regardless of <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, including any other overriding declaration in the package manifest of the using package.</p></dd><dt><a href="#err-XTSE3058"><span class="error">ERR XTSE3058</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a component declaration appearing as a child of <a href="#element-override"><code>xsl:override</code></a> does not match (is not <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with) some component in the used package.</p></dd><dt><a href="#err-XTSE3060"><span class="error">ERR XTSE3060</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the component referenced by an <a href="#element-override"><code>xsl:override</code></a> declaration has <a title="visibility" class="termref" href="#dt-visibility">visibility</a> other than <code>public</code> or <code>abstract</code></p></dd><dt><a href="#err-XTSE3070"><span class="error">ERR XTSE3070</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the signature of an overriding component is not <a title="compatible" class="termref" href="#dt-compatible">compatible</a> with the signature of the component that it is overriding.</p></dd><dt><a href="#err-XTSE3075"><span class="error">ERR XTSE3075</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use the component reference <code>xsl:original</code> when the overridden component has <code>visibility="abstract"</code>.</p></dd><dt><a href="#err-XTSE3080"><span class="error">ERR XTSE3080</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> (as distinct from a <a title="library package" class="termref" href="#dt-library-package">library package</a>) contains components whose visibility is <code>abstract</code>.</p></dd><dt><a href="#err-XTSE3085"><span class="error">ERR XTSE3085</span></a></dt><dd><p><span style="display: none;" class="delete_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, when the effective value of the <code>declared-modes</code> attribute of an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the package contains an explicit reference to an undeclared mode, or if it implicitly uses the unnamed mode and the unnamed mode is undeclared.</span><span style="display: none;" class="add_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, when the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the package contains an explicit reference to an undeclared mode, or if it implicitly uses the unnamed mode and the unnamed mode is undeclared.</span><span class="modify_version">It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, when the <span class="deltaxml-old" style="background:#FF5555">effective</span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a> <span class="deltaxml-old" style="background:#FF5555">value </span>of the <code>declared-modes</code> attribute of an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the package contains an explicit reference to an undeclared mode, or if it implicitly uses the unnamed mode and the unnamed mode is undeclared.</span></p></dd><dt><a href="#err-XTSE3087"><span class="error">ERR XTSE3087</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if more than one <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, or if several modules within a single <a title="package" class="termref" href="#dt-package">package</a> contain inconsistent <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declarations</p></dd><dt><a href="#err-XTSE3088"><span class="error">ERR XTSE3088</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is present [on the <a href="#element-context-item"><code>xsl:context-item</code></a> element] when <code>use="absent"</code> is specified.</p></dd><dt><a href="#err-XTSE3089"><span class="error">ERR XTSE3089</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is present [on the <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element] when <code>use="absent"</code> is specified.</p></dd><dt><a href="#err-XTSE3105"><span class="error">ERR XTSE3105</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a template rule applicable to a mode that is defined with <code>typed="strict"</code> uses a match pattern that contains a <code>RelativePathExprP</code> whose first <code>StepExprP</code> is an <code>AxisStepP</code> whose <code>ForwardStepP</code> uses an axis whose principal node kind is <code>Element</code> and whose <code>NodeTest</code> is an <code>EQName</code> that does not correspond to the name of any global element declaration in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>.</p></dd><dt><a href="#err-XTSE3120"><span class="error">ERR XTSE3120</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element appears other than in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction.</p></dd><dt><a href="#err-XTSE3125"><span class="error">ERR XTSE3125</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-on-completion"><code>xsl:on-completion</code></a> is present and the instruction has children.</p></dd><dt><a href="#err-XTSE3130"><span class="error">ERR XTSE3130</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>name</code> attribute of an <a href="#element-with-param"><code>xsl:with-param</code></a> child of an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element does not match the <code>name</code> attribute of an <a href="#element-param"><code>xsl:param</code></a> child of the innermost containing <a href="#element-iterate"><code>xsl:iterate</code></a> instruction.</p></dd><dt><a href="#err-XTSE3140"><span class="error">ERR XTSE3140</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-try"><code>xsl:try</code></a> element is present and the element has children other than <a href="#element-catch"><code>xsl:catch</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a> elements.</p></dd><dt><a href="#err-XTSE3150"><span class="error">ERR XTSE3150</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-catch"><code>xsl:catch</code></a> element is present unless the element has empty content.</p></dd><dt><a href="#err-XTSE3185"><span class="error">ERR XTSE3185</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of <a href="#element-sequence"><code>xsl:sequence</code></a> is present and the instruction has children other than <a href="#element-fallback"><code>xsl:fallback</code></a>.</p></dd><dt><a href="#err-XTSE3190"><span class="error">ERR XTSE3190</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two sibling <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements have the same name.</p></dd><dt><a href="#err-XTSE3195"><span class="error">ERR XTSE3195</span></a></dt><dd><p>If the <code>for-each-item</code> attribute is present then the <code>for-each-source</code>, <code>use-accumulators</code>, and <code>streamable</code> attributes must all be absent. If <span>either or both of the <code>use-accumulators</code> or <code>streamable</code> attributes is present </span> then the <code>for-each-source</code> attribute must be present. If the <code>for-each-source</code> attribute is present then the <code>for-each-item</code> attribute must be absent. <span>[XSLT 3.0 Erratum E40, bugs 30265 and 30378].</span></p></dd><dt><a href="#err-XTSE3200"><span class="error">ERR XTSE3200</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-merge-key"><code>xsl:merge-key</code></a> element with a <code>select</code> attribute has non-empty content.</p></dd><dt><a href="#err-XTSE3280"><span class="error">ERR XTSE3280</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>select</code> attribute of the <a href="#element-map-entry"><code>xsl:map-entry</code></a> element is present unless the element has no children other than <a href="#element-fallback"><code>xsl:fallback</code></a> elements.</p></dd><dt><a href="#err-XTSE3300"><span class="error">ERR XTSE3300</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of accumulator names [in the <code>use-accumulators</code> attribute] contains an invalid token, contains the same token more than once, or contains the token <code>#all</code> along with any other value; or if any token (other than <code>#all</code>) is not the name of a <a title="declared-streamable" class="termref" href="#dt-declared-streamable">declared-streamable</a> accumulator visible in the containing package.</p></dd><dt><a href="#err-XTSE3350"><span class="error">ERR XTSE3350</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to contain two or more accumulators with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another accumulator with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, and a higher import precedence.</p></dd><dt><a href="#err-XTSE3430"><span class="error">ERR XTSE3430</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains a construct that is declared to be streamable but which is not <a title="guaranteed-streamable" class="termref" href="#dt-guaranteed-streamable">guaranteed-streamable</a>, unless the user has indicated that the processor is to handle this situation by processing the stylesheet without streaming or by making use of processor extensions to the streamability rules where available.</p></dd><dt><a href="#err-XTSE3440"><span class="error">ERR XTSE3440</span></a></dt><dd><p>In the case of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> (that is, an <a href="#element-template"><code>xsl:template</code></a> element having a <code>match</code> attribute) appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of modes in the <code>mode</code> attribute contains <code>#all</code> or <code>#unnamed</code>, or if it contains <code>#default</code> and the default mode is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, or if the <code>mode</code> attribute is omitted when the default mode is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p></dd><dt><a href="#err-XTSE3450"><span class="error">ERR XTSE3450</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a variable declared with <code>static="yes"</code> is inconsistent with another static variable of the same name that is declared earlier in stylesheet tree order and that has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></dd><dt><a href="#err-XTSE3460"><span class="error">ERR XTSE3460</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element appears in a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within an <a href="#element-override"><code>xsl:override</code></a> element. (To invoke the template rule that is being overridden, <a href="#element-next-match"><code>xsl:next-match</code></a> should therefore be used.)</p></dd><dt><a href="#err-XTSE3470"><span class="error">ERR XTSE3470</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE3500"><span class="error">ERR XTSE3500</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p></dd><dt><a href="#err-XTSE3520"><span class="error">ERR XTSE3520</span></a></dt><dd><p>It is a static error if a parameter to <a href="#element-iterate"><code>xsl:iterate</code></a> is <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a>.</p></dd><dt><a href="#err-XTSE4005"><span class="error">ERR XTSE4005</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration with one or more <a href="#element-template"><code>xsl:template</code></a> children has no <code>name</code> attribute.</p></dd><dt><a href="#err-XTSE4010"><span class="error">ERR XTSE4010</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration has a child <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute, with a <code>mode</code> attribute, or with no <code>match</code> attribute.</p></dd><dt><a href="#err-XTSE4015"><span class="error">ERR XTSE4015</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code> attribute whose value differs from its <code>name</code> attribute, or if any of those child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code> attribute that differs from the <code>name</code> attribute of the <a href="#element-mode"><code>xsl:mode</code></a> declaration.</p></dd><dt><a href="#err-XTSE4020"><span class="error">ERR XTSE4020</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains both (a) an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) an <a href="#element-template"><code>xsl:template</code></a> declaration that is not one of those children but that references the <a href="#element-mode"><code>xsl:mode</code></a> declaration in its <code>name</code> attribute.</p></dd><dt><a href="#err-XTSE4025"><span class="error">ERR XTSE4025</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains (a) an <a href="#element-mode"><code>xsl:mode</code></a> declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) a second <a href="#element-mode"><code>xsl:mode</code></a> declaration having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p></dd><dt><a href="#err-XTSE9ZZZ"><span class="error">ERR XTSE9ZZZ</span></a></dt><dd><p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package contains two <a href="#element-item-type"><code>xsl:item-type</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is another definition of the same item type with higher import precedence.</p></dd></dl><p><b>Type errors</b></p><dl><dt><a href="#err-XTDE0450"><span class="error">ERR XTDE0450</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result sequence contains a function item. </p></dd><dt><a href="#err-XTTE0505"><span class="error">ERR XTTE0505</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> cannot be converted to the required type.</p></dd><dt><a href="#err-XTTE0510"><span class="error">ERR XTTE0510</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>select</code> attribute is evaluated when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. </p></dd><dt><a href="#err-XTTE0570"><span class="error">ERR XTTE0570</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a variable cannot be converted to the required type.</p></dd><dt><a href="#err-XTTE0590"><span class="error">ERR XTTE0590</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the conversion of the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a parameter, or of the context item, does not match the <a title="required type" class="termref" href="#dt-required-type">required type</a>, after applying any permitted conversions. [XSLT 3.0 Erratum E22, bug 30238].</p></dd><dt><a href="#err-XTTE0780"><span class="error">ERR XTTE0780</span></a></dt><dd><p>If the <code>as</code> attribute [of <a href="#element-function"><code>xsl:function</code></a> ] is specified, then the result evaluated by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see <a href="#sequence-constructors"><i>5.8 Sequence Constructors</i></a>) is converted to the required type, using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if this conversion fails.</p></dd><dt><a href="#err-XTTE0945"><span class="error">ERR XTTE0945</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> instruction with no <code>select</code> attribute when the context item is absent. </p></dd><dt><a href="#err-XTTE0950"><span class="error">ERR XTTE0950</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to copy a node that has namespace-sensitive content if the <code>copy-namespaces</code> attribute has the value <code>no</code> and its explicit or implicit <code>validation</code> attribute has the value <code>preserve</code>. It is also a type error if either of these instructions (with <code>validation="preserve"</code>) is used to copy an attribute having namespace-sensitive content, unless the parent element is also copied. A node has namespace-sensitive content if its typed value contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code> or a type derived therefrom. The reason this is an error is because the validity of the content depends on the namespace context being preserved.</p></dd><dt><a href="#err-XTTE0990"><span class="error">ERR XTTE0990</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a href="#element-number"><code>xsl:number</code></a> instruction is evaluated, with no <code>value</code> or <code>select</code> attribute, when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. </p></dd><dt><a href="#err-XTTE1000"><span class="error">ERR XTTE1000</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>select</code> attribute of the <a href="#element-number"><code>xsl:number</code></a> instruction is anything other than a single node.</p></dd><dt><a href="#err-XTTE1020"><span class="error">ERR XTTE1020</span></a></dt><dd><p>If any <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a>, after <a title="atomize" class="termref" href="#dt-atomization">atomization</a> and any type conversion <span class="verb">required</span> by the <code>data-type</code> attribute, is a sequence containing more than one item, then the effect depends on whether the <a href="#element-sort"><code>xsl:sort</code></a> element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>. With XSLT 1.0 behavior, the effective sort key value is the first item in the sequence. In other cases, this is a <a title="type error" class="termref" href="#dt-type-error">type error</a>.</p></dd><dt><a href="#err-XTTE1100"><span class="error">ERR XTTE1100</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>group-adjacent</code> expression is an empty sequence or a sequence containing more than one item, unless <code>composite="yes"</code> is specified.</p></dd><dt><a href="#err-XTTE1510"><span class="error">ERR XTTE1510</span></a></dt><dd><p><span style="display: none;" class="delete_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the effective value <code>strict</code>, and schema validity assessment concludes that the validity of the element or attribute is invalid or unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span style="display: none;" class="add_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>strict</code>, and schema validity assessment concludes that the validity of the element or attribute is invalid or unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span class="modify_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>strict</code>, and schema validity assessment concludes that the validity of the element or attribute is invalid or unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span></p></dd><dt><a href="#err-XTTE1512"><span class="error">ERR XTTE1512</span></a></dt><dd><p><span style="display: none;" class="delete_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the effective value <code>strict</code>, and there is no matching top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span style="display: none;" class="add_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>strict</code>, and there is no matching top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span class="modify_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>strict</code>, and there is no matching top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span></p></dd><dt><a href="#err-XTTE1515"><span class="error">ERR XTTE1515</span></a></dt><dd><p><span style="display: none;" class="delete_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the effective value <code>lax</code>, and schema validity assessment concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span style="display: none;" class="add_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a><code>lax</code>, and schema validity assessment concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span><span class="modify_version">If the <code>validation</code> attribute of an <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the <code>xsl:validation</code> attribute of a literal result element, has the <span class="deltaxml-old" style="background:#FF5555">effective</span><span class="deltaxml-old" style="background:#FF5555"> value </span><a title="effective value" class="termref" href="#dt-effective-value"><span class="deltaxml-new" style="background:#90EE90">effective value</span></a><code>lax</code>, and schema validity assessment concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error <span class="verb">may</span> be signaled statically if it can be detected statically. </span></p></dd><dt><a href="#err-XTTE1535"><span class="error">ERR XTTE1535</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the value of the <code>type</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction refers to a complex type definition and one or more of the items being copied is an attribute node.</p></dd><dt><a href="#err-XTTE1540"><span class="error">ERR XTTE1540</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <code>[xsl:]type</code> attribute is defined for a constructed element or attribute, and the outcome of schema validity assessment against that type is that the <code>validity</code> property of that element or attribute information item is other than <code>valid</code>.</p></dd><dt><a href="#err-XTTE1545"><span class="error">ERR XTTE1545</span></a></dt><dd><p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs if a <code>type</code> or <code>validation</code> attribute is defined (explicitly or implicitly) for an instruction that constructs a new attribute node, if the effect of this is to cause the attribute value to be validated against a type that is derived from, or constructed by list or union from, the primitive types <code>xs:QName</code> or <code>xs:NOTATION</code>.</p></dd><dt><a href="#err-XTTE1550"><span class="error">ERR XTTE1550</span></a></dt><dd><p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs [when a document node is validated] unless the children of the document node comprise exactly one element node, no text nodes, and zero or more comment and processing instruction nodes, in any order.</p></dd><dt><a href="#err-XTTE1555"><span class="error">ERR XTTE1555</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if, when validating a document node, document-level constraints (such as ID/IDREF constraints) are not satisfied. </p></dd><dt><a href="#err-XTTE2230"><span class="error">ERR XTTE2230</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if some item selected by a particular merge key in one input sequence is not comparable using the XPath <code>le</code> operator with some item selected by the corresponding sort key in another input sequence.</p></dd><dt><a href="#err-XTTE3090"><span class="error">ERR XTTE3090</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a href="#element-context-item"><code>xsl:context-item</code></a> child of <a href="#element-template"><code>xsl:template</code></a> specifies that a context item is required and none is supplied by the caller, that is, if the context item is absent at the point where <a href="#element-call-template"><code>xsl:call-template</code></a> is evaluated.</p></dd><dt><a href="#err-XTTE3100"><span class="error">ERR XTTE3100</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in a particular <code>mode</code> selects an element or attribute whose type is <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the <code>typed</code> attribute of that mode specifies the value <code>yes</code>, <code>strict</code>, or <code>lax</code>.</p></dd><dt><a href="#err-XTTE3110"><span class="error">ERR XTTE3110</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in a particular <code>mode</code> selects an element or attribute whose type is anything other than <code>xs:untyped</code> or <code>xs:untypedAtomic</code> when the <code>typed</code> attribute of that mode specifies the value <code>no</code>.</p></dd><dt><a href="#err-XTTE3165"><span class="error">ERR XTTE3165</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the expression in the <code>with-params</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single map of type <code>map(xs:QName, item()*)</code>.</p></dd><dt><a href="#err-XTTE3170"><span class="error">ERR XTTE3170</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>namespace-context</code> attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is anything other than a single node.</p></dd><dt><a href="#err-XTTE3180"><span class="error">ERR XTTE3180</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of evaluating the <code>select</code> expression [of the <a href="#element-copy"><code>xsl:copy</code></a> element] is a sequence of more than one item.</p></dd><dt><a href="#err-XTTE3210"><span class="error">ERR XTTE3210</span></a></dt><dd><p>If the result of evaluating the <code>context-item</code> expression [of an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction] is a sequence containing more than one item, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> is signaled.</p></dd><dt><a href="#err-XTTE3375"><span class="error">ERR XTTE3375</span></a></dt><dd><p>A type error occurs if the result of evaluating the sequence constructor [within an <a href="#element-map"><code>xsl:map</code></a> instruction] is not an instance of the required type <code>map(*)*</code>.</p></dd></dl><p><b>Dynamic errors</b></p><dl><dt><a href="#err-XTDE0030"><span class="error">ERR XTDE0030</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute written using curly brackets, in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> is permitted, is a value that is not one of the permitted values for that attribute. If the processor is able to detect the error statically (for example, when any XPath expressions within the curly brackets can be evaluated statically), then the processor may optionally signal this as a static error.</p></dd><dt><a href="#err-XTDE0040"><span class="error">ERR XTDE0040</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a template name that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of a named template defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is <code>public</code> or <code>final</code>.</p></dd><dt><a href="#err-XTDE0041"><span class="error">ERR XTDE0041</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a function name and arity that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and arity of a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is <code>public</code> or <code>final</code>.</p></dd><dt><a href="#err-XTDE0044"><span class="error">ERR XTDE0044</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> when no <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> is supplied (either explicitly, or defaulted to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>).</p></dd><dt><a href="#err-XTDE0045"><span class="error">ERR XTDE0045</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> and the specified mode is not eligible as an initial mode (as defined above).</p></dd><dt><a href="#err-XTDE0050"><span class="error">ERR XTDE0050</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a stylesheet declares a visible <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> that is <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly</a> mandatory, and no value for this parameter is supplied when the stylesheet is primed. A stylesheet parameter is visible if it is not masked by another global variable or parameter with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. If the parameter is a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a> then the value <span class="verb">must</span> be supplied prior to the static analysis phase.</p></dd><dt><a href="#err-XTDE0160"><span class="error">ERR XTDE0160</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if an element has an <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of <var>V</var> (with <var>V</var> &lt; <span>4.0</span>) when the implementation does not support backwards compatible behavior for XSLT version <var>V</var>.</p></dd><dt><a href="#err-XTDE0290"><span class="error">ERR XTDE0290</span></a></dt><dd><p>Where the result of evaluating an XPath expression (or an attribute value template) is required to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, or if it is permitted to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> and the actual value takes the form of a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then unless otherwise specified it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value has a prefix and the <a title="defining element" class="termref" href="#dt-defining-element">defining element</a> has no namespace node whose name matches that prefix. This error <span class="verb">may</span> be signaled as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the expression can be determined statically.</p></dd><dt><a href="#err-XTDE0410"><span class="error">ERR XTDE0410</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence used to construct the content of an element node contains a namespace node or attribute node that is preceded in the sequence by a node that is neither a namespace node nor an attribute node.</p></dd><dt><a href="#err-XTDE0420"><span class="error">ERR XTDE0420</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence used to construct the content of a document node contains a namespace node or attribute node.</p></dd><dt><a href="#err-XTDE0430"><span class="error">ERR XTDE0430</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence contains two or more namespace nodes having the same name but different <a title="string value" class="termref" href="#dt-string-value">string values</a> (that is, namespace nodes that map the same prefix to different namespace URIs).</p></dd><dt><a href="#err-XTDE0440"><span class="error">ERR XTDE0440</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the sequence contains a namespace node with no name and the element node being constructed has a null namespace URI (that is, it is an error to define a default namespace when the element is in no namespace). </p></dd><dt><a href="#err-XTDE0540"><span class="error">ERR XTDE0540</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the conflict resolution algorithm for template rules leaves more than one matching template rule when the declaration of the relevant <a title="mode" class="termref" href="#dt-mode">mode</a> has an <code>on-multiple-match</code> attribute with the value <code>fail</code>.</p></dd><dt><a href="#err-XTDE0555"><span class="error">ERR XTDE0555</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is used to process <span>an item</span> using a mode whose declaration specifies <code>on-no-match="fail"</code> when there is no <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> whose match pattern matches that <span>item</span>. </p></dd><dt><a href="#err-XTDE0560"><span class="error">ERR XTDE0560</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is evaluated when the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p></dd><dt><a href="#err-XTDE0640"><span class="error">ERR XTDE0640</span></a></dt><dd><p>In general, a <a title="circularity" class="termref" href="#dt-circularity">circularity</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a>.</p></dd><dt><a href="#err-XTDE0700"><span class="error">ERR XTDE0700</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a template that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a> parameter is invoked without supplying a value for that parameter.</p></dd><dt><a href="#err-XTDE0820"><span class="error">ERR XTDE0820</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of the <a href="#element-element"><code>xsl:element</code></a> instruction] is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>. </p></dd><dt><a href="#err-XTDE0830"><span class="error">ERR XTDE0830</span></a></dt><dd><p>In the case of an <a href="#element-element"><code>xsl:element</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-element"><code>xsl:element</code></a> instruction.</p></dd><dt><a href="#err-XTDE0835"><span class="error">ERR XTDE0835</span></a></dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>namespace</code> attribute [of the <a href="#element-element"><code>xsl:element</code></a> instruction] is not in the lexical space of the <code>xs:anyURI</code> datatype or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p></dd><dt><a href="#err-XTDE0850"><span class="error">ERR XTDE0850</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction] is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>.</p></dd><dt><a href="#err-XTDE0855"><span class="error">ERR XTDE0855</span></a></dt><dd><p>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is the string <code>xmlns</code>.</p></dd><dt><a href="#err-XTDE0860"><span class="error">ERR XTDE0860</span></a></dt><dd><p>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared in an in-scope namespace declaration for the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction.</p></dd><dt><a href="#err-XTDE0865"><span class="error">ERR XTDE0865</span></a></dt><dd><p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>namespace</code> attribute [of the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction] is not in the lexical space of the <code>xs:anyURI</code> datatype or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p></dd><dt><a href="#err-XTDE0890"><span class="error">ERR XTDE0890</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> instruction] is not both an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup> and a <a href="https://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.</p></dd><dt><a href="#err-XTDE0905"><span class="error">ERR XTDE0905</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the string value of the new namespace node is not valid in the lexical space of the datatype <code>xs:anyURI</code>, or if it is the string <code>http://www.w3.org/2000/xmlns/</code>.</p></dd><dt><a href="#err-XTDE0920"><span class="error">ERR XTDE0920</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code> attribute [of the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction] is neither a zero-length string nor an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, or if it is <code>xmlns</code>. </p></dd><dt><a href="#err-XTDE0925"><span class="error">ERR XTDE0925</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction generates a namespace node whose name is <code>xml</code> and whose string value is not <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose name is not <code>xml</code>.</p></dd><dt><a href="#err-XTDE0930"><span class="error">ERR XTDE0930</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if evaluating the <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of an <a href="#element-namespace"><code>xsl:namespace</code></a> instruction results in a zero-length string. </p></dd><dt><a href="#err-XTDE0980"><span class="error">ERR XTDE0980</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if any undiscarded item in the atomized sequence supplied as the value of the <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> cannot be converted to an integer, or if the resulting integer is less than 0 (zero). </p></dd><dt><a href="#err-XTDE1030"><span class="error">ERR XTDE1030</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if, for any <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>, the set of <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> evaluated for all the items in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, after any type conversion requested, contains a pair of ordinary values for which the result of the XPath <code>lt</code> operator is an error. If the processor is able to detect the error statically, it <span class="verb">may</span> optionally signal it as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1035"><span class="error">ERR XTDE1035</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <code>collation</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> (after resolving against the base URI) is not a URI that is recognized by the implementation as referring to a collation.</p></dd><dt><a href="#err-XTDE1061"><span class="error">ERR XTDE1061</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-group"><code>current-group</code></a> function is used when the current group is <a title="absent" class="termref" href="#dt-absent">absent</a> , or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE1071"><span class="error">ERR XTDE1071</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used when the current grouping key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE1110"><span class="error">ERR XTDE1110</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the collation URI specified to <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (after resolving against the base URI) is a collation that is not recognized by the implementation. (For notes, <span class="error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p></dd><dt><a href="#err-XTDE1140"><span class="error">ERR XTDE1140</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction] does not conform to the <span class="verb">required</span> syntax for regular expressions, as specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the regular expression is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> signal the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt><a href="#err-XTDE1145"><span class="error">ERR XTDE1145</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>flags</code> attribute [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction] has a value other than the values defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the value of the attribute is known statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then the processor <span class="verb">may</span> signal the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt><a href="#err-XTDE1160"><span class="error">ERR XTDE1160</span></a></dt><dd><p>When a URI reference [supplied to the <a href="#func-document"><code>document</code></a> function] contains a fragment identifier, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the media type is not one that is recognized by the processor, or if the fragment identifier does not conform to the rules for fragment identifiers for that media type, or if the fragment identifier selects something other than a sequence of nodes (for example, if it selects a range of characters within a text node). </p></dd><dt><a href="#err-XTDE1162"><span class="error">ERR XTDE1162</span></a></dt><dd><p>When a URI reference [supplied to the <a href="#func-document"><code>document</code></a> function] is a relative reference, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if no base URI is available to resolve the relative reference. This can arise for example when the URI is contained in a node that has no base URI (for example a parentless text node), or when the second argument to the function is a node that has no base URI, or when the base URI from the static context is undefined. </p></dd><dt><a href="#err-XTDE1260"><span class="error">ERR XTDE1260</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value [of the first argument to the <a href="#func-key"><code>key</code></a> function] is not a valid QName, or if there is no namespace declaration in scope for the prefix of the QName, or if the name obtained by expanding the QName is not the same as the expanded name of any <a href="#element-key"><code>xsl:key</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1270"><span class="error">ERR XTDE1270</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-key"><code>key</code></a> function with two arguments if there is no <a title="context node" class="termref" href="#dt-context-node">context node</a>, or if the root of the tree containing the context node is not a document node; or to call the function with three arguments if the root of the tree containing the node supplied in the third argument is not a document node.</p></dd><dt><a href="#err-XTDE1360"><span class="error">ERR XTDE1360</span></a></dt><dd><p>If the <a href="#func-current"><code>current</code></a> function is evaluated within an expression that is evaluated when the context item is absent, a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs.</p></dd><dt><a href="#err-XTDE1370"><span class="error">ERR XTDE1370</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node.</p></dd><dt><a href="#err-XTDE1380"><span class="error">ERR XTDE1380</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>, or the context item if the second argument is omitted, is a node in a tree whose root is not a document node.</p></dd><dt><a href="#err-XTDE1390"><span class="error">ERR XTDE1390</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value supplied as the <code>$property-name</code> argument [to the <a href="#func-system-property"><code>system-property</code></a> function] is not a valid QName, or if there is no namespace declaration in scope for the prefix of the QName. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p></dd><dt><a href="#err-XTDE1400"><span class="error">ERR XTDE1400</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <code>$name</code> argument [passed to the <a href="#func-function-available"><code>function-available</code></a> function] <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1420"><span class="error">ERR XTDE1420</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the arguments supplied to a call on an extension function do not satisfy the rules defined for that particular extension function, or if the extension function reports an error, or if the result of the extension function cannot be converted to an XPath value.</p></dd><dt><a href="#err-XTDE1425"><span class="error">ERR XTDE1425</span></a></dt><dd><p>When the containing element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate an extension function call if no implementation of the extension function is available.</p></dd><dt><a href="#err-XTDE1428"><span class="error">ERR XTDE1428</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument [passed to the <a href="#func-type-available"><code>type-available</code></a> function] <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1440"><span class="error">ERR XTDE1440</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument [passed to the <a href="#func-element-available"><code>element-available</code></a> function] <span>evaluates to a string that is not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no namespace declaration is present in the static context. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1450"><span class="error">ERR XTDE1450</span></a></dt><dd><p>When a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback for an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> that is not recognized, if the instruction element has one or more <a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the <a href="#element-fallback"><code>xsl:fallback</code></a> children <span class="verb">must</span> be evaluated; it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if it has no <a href="#element-fallback"><code>xsl:fallback</code></a> children.</p></dd><dt><a href="#err-XTDE1460"><span class="error">ERR XTDE1460</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>format</code> attribute [of an <a href="#element-result-document"><code>xsl:result-document</code></a> element] is not a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if it does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect the error statically (for example, when the <code>format</code> attribute contains no curly brackets), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE1480"><span class="error">ERR XTDE1480</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p></dd><dt><a href="#err-XTDE1490"><span class="error">ERR XTDE1490</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a transformation to generate two or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> with the same URI.</p></dd><dt><a href="#err-XTDE1500"><span class="error">ERR XTDE1500</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to write to an external resource and read from the same resource during a single transformation, if the same absolute URI is used to access the resource in both cases. </p></dd><dt><a href="#err-XTDE1665"><span class="error">ERR XTDE1665</span></a></dt><dd><p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a><span class="verb">may</span> be raised if the input to the processor includes an item that requires availability of an optional feature that the processor does not provide.</p></dd><dt><a href="#err-XTDE2210"><span class="error">ERR XTDE2210</span></a></dt><dd><p><span style="display: none;" class="delete_version">It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if the attribute is present on one element and not on the other, or if it is present on both elements with <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> that are not equal to each other. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be reported statically if it is detected statically.</span><span style="display: none;" class="add_version">It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if they have different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a>. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be reported statically if it is detected statically.</span><span class="modify_version">It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for any of the attributes <code>lang</code>, <code>order</code>, <code>collation</code>, <code>case-order</code>, or <code>data-type</code>. Values are considered to differ if <span class="deltaxml-old" style="background:#FF5555">the attribute is present on one element and not on the other, or if it is present on both elements with</span><span class="deltaxml-new" style="background:#90EE90">they have different</span> <a title="effective value" class="termref" href="#dt-effective-value">effective values</a><span class="deltaxml-old" style="background:#FF5555"> that are not equal to each other</span>. In the case of the <code>collation</code> attribute, the values are compared as absolute URIs after resolving against the base URI. The error <span class="verb">may</span> be reported statically if it is detected statically.</span></p></dd><dt><a href="#err-XTDE2220"><span class="error">ERR XTDE2220</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if any input sequence to an <a href="#element-merge"><code>xsl:merge</code></a> instruction contains two items that are not correctly sorted according to the merge key values defined on the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the corresponding <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, when compared using the collation rules defined by the attributes of the corresponding <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a> instruction, unless the attribute <code>sort-before-merge</code> is present with the value <code>yes</code>.</p></dd><dt><a href="#err-XTDE3052"><span class="error">ERR XTDE3052</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an invocation of an abstract component is evaluated. </p></dd><dt><a href="#err-XTDE3086"><span class="error">ERR XTDE3086</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration specifies <code>use="required"</code>, and no global context item is supplied. [XSLT 3.0 Erratum E6, bug 30173].</p></dd><dt><a href="#err-XTSE3155"><span class="error">ERR XTSE3155</span></a></dt><dd><p>It is a static error if an <a href="#element-function"><code>xsl:function</code></a> element with no <a href="#element-param"><code>xsl:param</code></a> children has a <code>streamability</code> attribute with any value other than <code>unclassified</code>.</p></dd><dt><a href="#err-XTDE3160"><span class="error">ERR XTDE3160</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> [of an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction] is not a valid <a title="expression" class="termref" href="#dt-expression">expression</a> (that is, if a static error occurs when analyzing the string according to the rules of the XPath specification).</p></dd><dt><a href="#err-XTDE3175"><span class="error">ERR XTDE3175</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated when use of <a href="#element-evaluate"><code>xsl:evaluate</code></a> has been statically or dynamically disabled. </p></dd><dt><a href="#err-XTDE3340"><span class="error">ERR XTDE3340</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the first argument to the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function is <span>a string that is</span> not a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if there is no namespace declaration in scope for the prefix of the QName, or if the name obtained by expanding the QName is not the same as the expanded name of any <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration appearing in the <a title="package" class="termref" href="#dt-package">package</a> in which the function call appears. If the processor is able to detect the error statically (for example, when the argument is supplied as a string literal), then the processor <span class="verb">may</span> optionally signal this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p></dd><dt><a href="#err-XTDE3350"><span class="error">ERR XTDE3350</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when there is no <a title="context item" class="termref" href="#dt-context-item">context item</a>.</p></dd><dt><a href="#err-XTTE3360"><span class="error">ERR XTTE3360</span></a></dt><dd><p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node, or when it is an attribute or namespace node.</p></dd><dt><a href="#err-XTDE3362"><span class="error">ERR XTDE3362</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the context item is a node in a tree to which the selected accumulator is not applicable (including the case where it is not applicable because the document is streamed and the accumulator is not declared with <code>streamable="yes"</code>). Implementations <span class="verb">may</span> raise this error but are <span class="verb">not required</span> to do so, if they are capable of streaming documents without imposing this restriction.</p></dd><dt><a href="#err-XTDE3365"><span class="error">ERR XTDE3365</span></a></dt><dd><p>In the absence of the <code>on-duplicates</code> attribute, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs if the set of keys in the maps resulting from evaluating the sequence constructor [within an <a href="#element-map"><code>xsl:map</code></a> instruction] contains duplicates.</p></dd><dt><a href="#err-XTDE3400"><span class="error">ERR XTDE3400</span></a></dt><dd><p>It is an error if there is a cyclic set of dependencies among accumulators such that the (pre- or post-descent) value of an accumulator depends directly or indirectly on itself. A processor <span class="verb">may</span> report this as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if it can be detected statically. Alternatively a processor <span class="verb">may</span> report this as a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>. As a further option, a processor may fail catastrophically when this error occurs.</p></dd><dt><a href="#err-XTDE3480"><span class="error">ERR XTDE3480</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used when the current merge group is <a title="absent" class="termref" href="#dt-absent">absent</a>. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE3490"><span class="error">ERR XTDE3490</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <code>$source</code> argument of the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function <span>(when supplied)</span> does not match the <code>name</code> attribute of any <a href="#element-merge-source"><code>xsl:merge-source</code></a> element for the current merge operation. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE3510"><span class="error">ERR XTDE3510</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used when the current merge key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern. The error <span class="verb">may</span> be reported statically if it can be detected statically.</p></dd><dt><a href="#err-XTDE3530"><span class="error">ERR XTDE3530</span></a></dt><dd><p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-try"><code>xsl:try</code></a> instruction is unable to recover the state of a final result tree because recovery has been disabled by use of the attribute <code>rollback-output="no"</code>.</p></dd><dt><a href="#err-XTMM9000"><span class="error">ERR XTMM9000</span></a></dt><dd><p>When a transformation is terminated by use of <code>&lt;xsl:message terminate="yes"/&gt;</code>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-message"><code>xsl:message</code></a> instruction.</p></dd><dt><a href="#err-XTMM9001"><span class="error">ERR XTMM9001</span></a></dt><dd><p>When a transformation is terminated by use of <a href="#element-assert"><code>xsl:assert</code></a>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9001</code>; this may be overridden using the <code>error-code</code> attribute of the <a href="#element-assert"><code>xsl:assert</code></a> instruction.</p></dd></dl></div><div class="div1"><h2><a id="implementation-defined-features"></a>F Checklist of Implementation-Defined Features (Non-Normative)</h2><p>This appendix provides a summary of XSLT language features whose effect is explicitly <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The conformance rules (see <a href="#conformance"><i>28 Conformance</i></a>) require vendors to provide documentation that explains how these choices have been exercised.</p><p>The implementation-defined features are grouped into categories for convenience.</p><div class="div2"><h3><a id="imp-def-api"></a>F.1 <a href="#imp-def-api" style="text-decoration: none">Application Programming Interfaces</a></h3><p>This category covers interfaces for initiating a transformation, setting its parameters, initializing the static and dynamic context, and collecting the results. In general terms, it is implementation defined how input is passed to the processor and how it returns its output. This includes the interpretation of URIs used to refer to stylesheet packages and modules, source documents and collections, collations, and result documents.</p><p>More specifically:</p><ol><li><p>If the initialization of any <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> or <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">parameter</a> depends on the context item, a dynamic error can occur if the context item is absent. It is implementation-defined whether this error occurs during priming of the stylesheet or subsequently when the variable is referenced; and it is implementation-defined whether the error occurs at all if the variable or parameter is never referenced. (See <a href="#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>)</p></li><li><p>The way in which an XSLT processor is invoked, and the way in which values are supplied for the source document, starting node, <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>, are implementation-defined. (See <a href="#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>)</p></li><li><p>The way in which a <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a> is established is implementation-defined (See <a href="#result-serialization"><i>2.3.6.2 Serializing the Result</i></a>)</p></li><li><p>It is implementation-defined how a package is located given its name and version, and which version of a package is chosen if several are available. (See <a href="#package-dependencies"><i>3.5.2 Dependencies between Packages</i></a>)</p></li><li><p>In the absence of an <code>[xsl:]default-collation</code> attribute, the default collation <span class="verb">may</span> be set by the calling application in an implementation-defined way. (See <a href="#default-collation-attribute"><i>3.7.1 The default-collation Attribute</i></a>)</p></li><li><p> It is implementation-defined what forms of URI reference are acceptable in the <code>href</code> attribute of the <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> elements, for example, the URI schemes that may be used, the forms of fragment identifier that may be used, and the media types that are supported. The way in which the URI reference is used to locate a representation of a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, and the way in which the stylesheet module is constructed from that representation, are also implementation-defined. (See <a href="#locating-modules"><i>3.11.1 Locating Stylesheet Modules</i></a>)</p></li><li><p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-docs">statically known documents</a><sup><small>XP40</small></sup>, <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-collections">statically known collections</a><sup><small>XP40</small></sup>, and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-known-default-collection">statically known default collection type</a><sup><small>XP40</small></sup> are implementation-defined. (See <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a>)</p></li><li><p>Implementations may provide user options that relax the requirement for the <a href="https://www.w3.org/TR/xpath-functions-30/#func-doc"><code>doc</code></a><sup><small>FO30</small></sup> and <a href="https://www.w3.org/TR/xpath-functions-30/#func-collection"><code>collection</code></a><sup><small>FO30</small></sup> functions (and therefore, by implication, the <a href="#func-document"><code>document</code></a> function) to return stable results. The manner in which such user options are provided, if at all, is implementation-defined. (See <a href="#xpath-dynamic-context"><i>5.3.4 Initializing the Dynamic Context</i></a>)</p></li><li><p>Streamed processing may be initiated by invoking the transformation with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> declared as streamable, while supplying the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> (in an implementation-defined way) as a streamed document. (See <a href="#streamable-templates"><i>6.7.6 Streamable Templates</i></a>)</p></li><li><p>The mechanism by which the caller supplies a value for a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> is implementation-defined. (See <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>)</p></li><li><p>The detail of any external mechanism allowing a processor to enable or disable checking of assertions is implementation-defined. (See <a href="#assertions"><i>24.2 Assertions</i></a>)</p></li><li><p>The way in which the results of the transformation are delivered to an application is implementation-defined. (See <a href="#result-trees"><i>26 Transformation Results</i></a>)</p></li><li><p> It is implementation-defined how the URI appearing in the <code>href</code> attribute of <a href="#element-result-document"><code>xsl:result-document</code></a> affects the way in which the result tree is delivered to the application. There <span class="verb">may</span> be restrictions on the form of this URI. (See <a href="#creating-result-trees"><i>26.1 Creating Secondary Results</i></a>)</p></li><li><p>If serialization is supported, then the location to which a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is serialized is implementation-defined, subject to the constraint that relative URI references used to reference one tree from another remain valid. (See <a href="#serialization"><i>27 Serialization</i></a>)</p></li></ol></div><div class="div2"><h3><a id="imp-def-ext"></a>F.2 <a href="#imp-def-ext" style="text-decoration: none">Vendor and User Extensions</a></h3><p>This category covers extensions and extensibility: mechanisms for providing vendor or user extensions to the language without sacrificing interoperability.</p><p>In general terms, it is implementation-defined:</p><ul><li><p>whether and under what circumstances the implementation recognizes any extension functions, extension instructions, extension attributes, user-defined data elements, additional types, additional serialization methods or serialization parameters, or additional collations, and if so, what effect they have. </p></li><li><p>whether, how, and under what circumstances the implementation allows users to define extension functions, extension instructions, extension attributes, user-defined data elements, additional types, additional serialization methods or serialization parameters, or additional collations. If it does allow users to do so, it must follow the rules given elsewhere in this specification. </p></li><li><p>what information is available to such extensions (for example, whether they have access to the static and dynamic context.) </p></li><li><p>where such extensions are allowed, the extent to which the processor enforces their correct behavior (for example, checking that strings returned by extension functions contain only valid XML characters) </p></li></ul><p>More specifically:</p><ol><li><p>The mechanisms for creating new <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a> and <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are implementation-defined. It is not <span class="verb">required</span> that implementations provide any such mechanism. (See <a href="#extensibility"><i>2.9 Extensibility</i></a>)</p></li><li><p>The set of namespaces that are specially recognized by the implementation (for example, for user-defined data elements, and <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>) is implementation-defined. (See <a href="#user-defined-top-level"><i>3.7.3 User-defined Data Elements</i></a>)</p></li><li><p>The effect of user-defined data elements whose name is in a namespace recognized by the implementation is implementation-defined. (See <a href="#user-defined-top-level"><i>3.7.3 User-defined Data Elements</i></a>)</p></li><li><p>An implementation may define mechanisms, above and beyond <a href="#element-import-schema"><code>xsl:import-schema</code></a>, that allow <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> such as type definitions to be made available within a stylesheet. (See <a href="#built-in-types"><i>3.14 Built-in Types</i></a>)</p></li><li><p>The set of extension functions available in the static context for the target expression of <a href="#element-evaluate"><code>xsl:evaluate</code></a> is implementation-defined. (See <a href="#evaluate-static-context"><i>10.4.1 Static context for the target expression</i></a>)</p></li><li><p>If the <code>data-type</code> attribute of the <a href="#element-sort"><code>xsl:sort</code></a> element has a value other than <code>text</code> or <code>number</code>, the effect is implementation-defined. (See <a href="#comparing-sort-keys"><i>13.1.2 Comparing Sort Key Values</i></a>)</p></li><li><p>The <a title="posture" class="termref" href="#dt-posture">posture</a> and <a title="sweep" class="termref" href="#dt-sweep">sweep</a> of <a title="extension function" class="termref" href="#dt-extension-function">extension functions (and references to extension functions)</a> and <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a> are implementation-defined. (See <a href="#streamability-extension-instructions"><i>19.8.4.2 Streamability of extension instructions</i></a>)</p></li><li><p>Additional <a title="streamability category" class="termref" href="#dt-streamability-category">streamability categories</a> for stylesheet functions may be defined by an implementation. (See <a href="#streamable-stylesheet-functions"><i>19.8.5 Classifying Stylesheet Functions</i></a>)</p></li><li><p>The effect of an extension function returning a string containing characters that are not permitted in XML is implementation-defined. (See <a href="#calling-extension-functions"><i>25.1.2 Calling Extension Functions</i></a>)</p></li><li><p>The way in which external objects are represented in the type system is implementation-defined. (See <a href="#external-objects"><i>25.1.3 External Objects</i></a>)</p></li></ol></div><div class="div2"><h3><a id="imp-def-feature"></a>F.3 <a href="#imp-def-feature" style="text-decoration: none">Localization</a></h3><p>This specification, and the specifications that it refers to, include facilities for adapting the output of a transformation to meet local expectations: examples include the formatting of numbers and dates, and the choice of collations for sorted output. The general principles are:</p><ul><li><p>The specification does not mandate any particular localizations that processors must offer: for example, a conformant processor might choose to provide output in Japanese only.</p></li><li><p>The specification provides fallback mechanisms so that if a particular localization is requested and is not available, processing does not fail.</p></li></ul><p>More specifically:</p><ol><li><p>The combinations of languages and numbering sequences recognized by the <a href="#element-number"><code>xsl:number</code></a> instruction, beyond those defined as mandatory in this specification, are implementation-defined. There <span class="verb">may</span> be implementation-defined upper bounds on the numbers that can be formatted using any particular numbering sequence. There <span class="verb">may</span> be constraints on the values of the <code>ordinal</code> attribute recognized for any given language. (See <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a>)</p></li><li><p>The facilities for defining collations and allocating URIs to identify them are largely implementation-defined. (See <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>)</p></li><li><p>The algorithm used by <a href="#element-sort"><code>xsl:sort</code></a> to locate a collation, given the values of the <code>lang</code> and <code>case-order</code> attributes, is implementation-defined. (See <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>)</p></li><li><p>If none of the <code>collation</code>, <code>lang</code>, or <code>case-order</code> attributes is present (on <a href="#element-sort"><code>xsl:sort</code></a>), the collation is chosen in an implementation-defined way. (See <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>)</p></li></ol></div><div class="div2"><h3><a id="imp-def-optional-feature"></a>F.4 <a href="#imp-def-optional-feature" style="text-decoration: none">Optional Features</a></h3><p>As well as the optional conformance features identified in <a href="#conformance"><i>28 Conformance</i></a>, some specific features of the specification are defined to be optional.</p><ol><li><p>It is implementation-defined whether an XSLT 4.0 processor supports backwards compatible behavior for any XSLT version earlier than XSLT 4.0. (See <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>)</p></li><li><p>If an <code>xml:id</code> attribute that has not been subjected to attribute value normalization is copied from a source tree to a result tree, it is implementation-defined whether attribute value normalization will be applied during the copy process. (See <a href="#shallow-copy"><i>11.9.1 Shallow Copy</i></a>)</p></li><li><p>It is implementation-defined whether, and under what circumstances, disabling output escaping is supported. (See <a href="#disable-output-escaping"><i>27.2 Disabling Output Escaping</i></a>)</p></li></ol></div><div class="div2"><h3><a id="imp-def-dependencies"></a>F.5 <a href="#imp-def-dependencies" style="text-decoration: none">Dependencies</a></h3><p>When this specification refers normatively to other specifications, it generally gives implementations freedom to decide (within constraints) which version of the referenced specification should be used. Specifically:</p><ol><li><p>It is implementation-defined which versions and editions of XML and XML Namespaces (1.0 and/or 1.1) are supported. (See <a href="#xml-versions"><i>4.1 XML Versions</i></a>)</p></li><li><p>It is implementation-defined which versions of XML, HTML, and XHTML are supported in the <code>version</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> declaration. (See <a href="#serialization"><i>27 Serialization</i></a>)</p></li><li><p>It is implementation-defined whether (and if so how) an XSLT 3.0 processor is able to work with versions of XPath later than XPath 3.1. (See <a href="#conformance"><i>28 Conformance</i></a>)</p></li><li><p>It is implementation-defined whether (and if so how) an XSLT 3.0 processor is able to work with versions of <a href="#xslt-xquery-serialization-30">[XSLT and XQuery Serialization]</a> later than 3.1. (See <a href="#serialization-feature"><i>28.3 Serialization Feature</i></a>)</p></li></ol></div><div class="div2"><h3><a id="imp-def-defaults-and-limits"></a>F.6 <a href="#imp-def-defaults-and-limits" style="text-decoration: none">Defaults and Limits</a></h3><p>To accommodate variations in the way that the XSLT language is deployed, and the constraints of different processing environments, defaults for some options are implementation-defined. In addition, limits on the sizes of ranges of values permitted are in general implementation-defined:</p><ol><li><p>Limits on the value space of primitive datatypes, where not fixed by <a href="#xmlschema-2">[XML Schema Part 2]</a>, are implementation-defined. (See <a href="#limits"><i>4.6 Limits</i></a>)</p></li><li><p>The default value of the <code>encoding</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> element is implementation-defined. Where the encoding is UTF-8, the default for the <code>byte-order-mark</code> attribute is implementation-defined. (See <a href="#serialization"><i>27 Serialization</i></a>)</p></li></ol></div><div class="div2"><h3><a id="imp-def-errors"></a>F.7 <a href="#imp-def-errors" style="text-decoration: none">Detection and Reporting of Errors</a></h3><p>Some aspects of error handling are implementation-defined:</p><ol><li><p>It is implementation-defined whether type errors are signaled statically. (See <a href="#errors"><i>2.14 Error Handling</i></a>)</p></li><li><p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of any element in the stylesheet is not 1.0 or 2.0 but is less than <span>4.0</span>, the <span class="verb">recommended</span> action is to report a static error; however, processors <span class="verb">may</span> recognize such values and process the element in an implementation-defined way. (See <a href="#backwards"><i>3.9 Backwards Compatible Processing</i></a>)</p></li><li><p>The default values for the <code>warning-on-no-match</code> and <code>warning-on-multiple-match</code> attributes of <a href="#element-mode"><code>xsl:mode</code></a> are implementation-defined. (See <a href="#declaring-modes"><i>6.7.1 Declaring Modes</i></a>)</p></li><li><p>The form of any warnings output when there is no matching template rule, or when there are multiple matching template rules, is implementation-defined. (See <a href="#declaring-modes"><i>6.7.1 Declaring Modes</i></a>)</p></li><li><p>The destination and formatting of messages written using the <a href="#element-message"><code>xsl:message</code></a> instruction are implementation-defined. (See <a href="#message"><i>24.1 Messages</i></a>)</p></li></ol></div></div><div class="div1"><h2><a id="summary-list-of-functions"></a>G Summary of Available Functions (Non-Normative)</h2><div class="div2"><h3><a id="function-categories"></a>G.1 <a href="#function-categories" style="text-decoration: none">Function Classification</a></h3><p>The functions available for use within an XSLT stylesheet can be classified based firstly, on where the function is defined, and secondly, on where it can be used. Specifically, the set of functions available is slightly different for :</p><ul><li><p>Regular XPath expressions within the stylesheet, for example those appearing in <code>select</code> or <code>test</code> attributes, or between braces in a <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a> (<var>R</var>)</p></li><li><p><a title="static expression" class="termref" href="#dt-static-expression">Static expressions</a> (<var>S</var>)</p></li><li><p>XPath expressions evaluated dynamically using <a href="#element-evaluate"><code>xsl:evaluate</code></a> (<var>D</var>)</p></li></ul><p>The categories are listed in the following table:</p><table class="data"><caption>Categories of Function, and their Availability</caption><thead><tr><th style="text-align:left; vertical-align:top">Category</th><th style="text-align:left; vertical-align:top">Defined where?</th><th style="text-align:left; vertical-align:top">Available where?</th><th style="text-align:left; vertical-align:top">Notes</th></tr></thead><tbody><tr><td style="text-align:left; vertical-align:top">User-defined functions</td><td style="text-align:left; vertical-align:top">Defined using <a href="#element-function"><code>xsl:function</code></a> declarations in the stylesheet</td><td style="text-align:left; vertical-align:top"><var>R</var>, <var>D</var></td><td style="text-align:left; vertical-align:top">Functions are private by default; private functions can be referenced only within the package where they are declared (and not in <a href="#element-evaluate"><code>xsl:evaluate</code></a> expressions).</td></tr><tr><td style="text-align:left; vertical-align:top">Constructor functions for built-in types</td><td style="text-align:left; vertical-align:top"><a href="https://qt4cg.org/specifications/xpath-functions-40/#constructor-functions">Section 20 Constructor functions</a><sup><small>FO40</small></sup></td><td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var>, <var>D</var></td><td style="text-align:left; vertical-align:top">These functions are all in the namespace conventionally associated with the prefix <code>xs</code>. The semantics of a constructor function are identical to the semantics of a <code>cast</code> expression.</td></tr><tr><td style="text-align:left; vertical-align:top">Constructor functions for user-defined types</td><td style="text-align:left; vertical-align:top"><a href="https://qt4cg.org/specifications/xpath-functions-40/#constructor-functions">Section 20 Constructor functions</a><sup><small>FO40</small></sup></td><td style="text-align:left; vertical-align:top"><var>R</var>, <var>D</var> (if <code>schema-aware="yes"</code>)</td><td style="text-align:left; vertical-align:top">This category includes a function for every named user-defined simple type in an imported schema; the function allows the conversion of strings and certain other values to instances of the user-defined type.</td></tr><tr><td style="text-align:left; vertical-align:top">Functions defined in XPath <span class="deltaxml-old" style="background:#FF5555">3.0</span><span class="deltaxml-new" style="background:#90EE90">4.0</span></td><td style="text-align:left; vertical-align:top"><a href="#xpath-functions-40">[Functions and Operators <span class="deltaxml-old" style="background:#FF5555">3.0</span><span class="deltaxml-new" style="background:#90EE90">4.0</span>]</a></td><td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var>, <var>D</var></td><td style="text-align:left; vertical-align:top">Includes functions in the namespaces conventionally referred to be the prefixes <code>fn</code> and <code>math</code>.</td></tr><tr class="delete_version" style="display: none;"><td style="text-align:left; vertical-align:top">Additional functions defined in XPath 3.1 (where supported)</td><td style="text-align:left; vertical-align:top"><a href="#xpath-functions-31">[Functions and Operators 3.1]</a></td><td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var>, <var>D</var>.</td><td style="text-align:left; vertical-align:top">This category has an overlap with the set of XSLT-defined-functions. Where a function is defined both in this document and in XPath 3.1, the function is available in an XSLT 3.0 stylesheet whether or not the processor supports XPath 3.1. This category includes functions in namespaces conventionally referred to by the prefixes <code>fn</code>, <code>map</code>, and <code>array</code>.</td></tr><tr class="modify_version"><td style="text-align:left; vertical-align:top"><span class="deltaxml-old" style="background:#FF5555">Additional functions defined in XPath 3.1 (where supported)</span></td><td style="text-align:left; vertical-align:top"><a href="#xpath-functions-31"><span class="deltaxml-old" style="background:#FF5555">[Functions and Operators 3.1]</span></a></td><td style="text-align:left; vertical-align:top"><var><span class="deltaxml-old" style="background:#FF5555">R</span></var><span class="deltaxml-old" style="background:#FF5555">, </span><var><span class="deltaxml-old" style="background:#FF5555">S</span></var><span class="deltaxml-old" style="background:#FF5555">, </span><var><span class="deltaxml-old" style="background:#FF5555">D</span></var><span class="deltaxml-old" style="background:#FF5555">.</span></td><td style="text-align:left; vertical-align:top"><span class="deltaxml-old" style="background:#FF5555">This category has an overlap with the set of XSLT-defined-functions. Where a function is defined both in this document and in XPath 3.1, the function is available in an XSLT 3.0 stylesheet whether or not the processor supports XPath 3.1. This category includes functions in namespaces conventionally referred to by the prefixes </span><code><span class="deltaxml-old" style="background:#FF5555">fn</span></code><span class="deltaxml-old" style="background:#FF5555">, </span><code><span class="deltaxml-old" style="background:#FF5555">map</span></code><span class="deltaxml-old" style="background:#FF5555">, and </span><code><span class="deltaxml-old" style="background:#FF5555">array</span></code><span class="deltaxml-old" style="background:#FF5555">.</span></td></tr><tr><td style="text-align:left; vertical-align:top">Functions defined in XSLT <span class="deltaxml-old" style="background:#FF5555">3.0</span><span class="deltaxml-new" style="background:#90EE90">4.0</span></td><td style="text-align:left; vertical-align:top">This specification</td><td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var> (see note), <var>D</var></td><td style="text-align:left; vertical-align:top">See <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>. There is an overlap with the set of functions defined in XPath <span class="deltaxml-old" style="background:#FF5555">3.1</span><span class="deltaxml-new" style="background:#90EE90">4.0</span>. The functions available in static expressions are: <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-available-system-properties"><code>available-system-properties</code></a>, and <a href="#func-system-property"><code>system-property</code></a>.</td></tr><tr><td style="text-align:left; vertical-align:top">Extension functions</td><td style="text-align:left; vertical-align:top">Implementation-defined: see <a href="#extension-functions"><i>25.1 Extension Functions</i></a>.</td><td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var>, <var>D</var></td><td style="text-align:left; vertical-align:top">Availability is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a></td></tr></tbody></table></div><div class="div2"><h3><a id="XSLT-defined-functions"></a>G.2 <a href="#XSLT-defined-functions" style="text-decoration: none">List of XSLT-defined functions</a></h3><p>This appendix acts as an index of functions defined in this specification, to augment the set of functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p><dl><dt class="label"><a href="#func-accumulator-after"><code>accumulator-after</code></a></dt><dd>See <a href="#func-accumulator-after"><i>18.2.7 fn:accumulator-after</i></a></dd><dt class="label"><a href="#func-accumulator-before"><code>accumulator-before</code></a></dt><dd>See <a href="#func-accumulator-before"><i>18.2.6 fn:accumulator-before</i></a></dd><dt class="label"><a href="#func-available-system-properties"><code>available-system-properties</code></a></dt><dd>See <a href="#func-available-system-properties"><i>20.4.5 fn:available-system-properties</i></a></dd><dt class="label"><a href="#func-copy-of"><code>copy-of</code></a></dt><dd>See <a href="#func-copy-of"><i>18.3 fn:copy-of</i></a></dd><dt class="label"><a href="#func-current"><code>current</code></a></dt><dd>See <a href="#func-current"><i>20.4.1 fn:current</i></a></dd><dt class="label"><a href="#func-current-group"><code>current-group</code></a></dt><dd>See <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a></dd><dt class="label"><a href="#func-current-grouping-key"><code>current-grouping-key</code></a></dt><dd>See <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a></dd><dt class="label"><a href="#func-current-merge-group"><code>current-merge-group</code></a></dt><dd>See <a href="#func-current-merge-group"><i>15.6.1 fn:current-merge-group</i></a></dd><dt class="label"><a href="#func-current-merge-key"><code>current-merge-key</code></a></dt><dd>See <a href="#func-current-merge-key"><i>15.6.2 fn:current-merge-key</i></a></dd><dt class="label"><a href="#func-current-output-uri"><code>current-output-uri</code></a></dt><dd>See <a href="#func-current-output-uri"><i>26.3.1 fn:current-output-uri</i></a></dd><dt class="label"><a href="#func-document"><code>document</code></a></dt><dd>See <a href="#func-document"><i>20.1 fn:document</i></a></dd><dt class="label"><a href="#func-element-available"><code>element-available</code></a></dt><dd>See <a href="#func-element-available"><i>25.2.2 fn:element-available</i></a></dd><dt class="label"><a href="#func-function-available"><code>function-available</code></a></dt><dd>See <a href="#func-function-available"><i>25.1.1 fn:function-available</i></a></dd><dt class="label"><a href="#func-key"><code>key</code></a></dt><dd>See <a href="#func-key"><i>20.2.2 fn:key</i></a></dd><dt class="label"><a href="#func-regex-group"><code>regex-group</code></a></dt><dd>See <a href="#func-regex-group"><i>17.2 fn:regex-group</i></a></dd><dt class="label"><a href="#func-snapshot"><code>snapshot</code></a></dt><dd>See <a href="#func-snapshot"><i>18.4 fn:snapshot</i></a></dd><dt class="label"><a href="#func-stream-available"><code>stream-available</code></a></dt><dd>See <a href="#func-stream-available"><i>18.1.3 fn:stream-available</i></a></dd><dt class="label"><a href="#func-system-property"><code>system-property</code></a></dt><dd>See <a href="#func-system-property"><i>20.4.4 fn:system-property</i></a></dd><dt class="label"><a href="#func-type-available"><code>type-available</code></a></dt><dd>See <a href="#func-type-available"><i>25.1.4 fn:type-available</i></a></dd><dt class="label"><a href="#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a></dt><dd>See <a href="#func-unparsed-entity-public-id"><i>20.4.3 fn:unparsed-entity-public-id</i></a></dd><dt class="label"><a href="#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a></dt><dd>See <a href="#func-unparsed-entity-uri"><i>20.4.2 fn:unparsed-entity-uri</i></a></dd></dl></div></div><div class="div1"><h2><a id="schema-for-xslt"></a>H Schemas for XSLT 4.0 Stylesheets (Non-Normative)</h2><p>TODO: the two schemas need to be updated for XSLT 4.0</p><p><span style="display: none;" class="delete_version">For convenience, schemas are provided for validation of XSLT 3.0 stylesheets using the XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect every static error that might arise in an XSLT 3.0 stylesheet (for example, there is no attempt to check the syntax of XPath expressions); in addition, these schemas may reject some stylesheets that are valid, for example because they rely on <code>xsl:use-when</code> to eliminate sections of code that would otherwise be invalid.</span><span style="display: none;" class="add_version">For convenience, schemas are provided for validation of XSLT 3.0 stylesheets using the XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect every static error that might arise in an XSLT 4.0 stylesheet (for example, there is no attempt to check the syntax of XPath expressions); in addition, these schemas may reject some stylesheets that are valid, for example because they rely on <code>xsl:use-when</code> to eliminate sections of code that would otherwise be invalid.</span><span class="modify_version">For convenience, schemas are provided for validation of XSLT 3.0 stylesheets using the XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect every static error that might arise in an XSLT <span class="deltaxml-old" style="background:#FF5555">3.0</span><span class="deltaxml-new" style="background:#90EE90">4.0</span> stylesheet (for example, there is no attempt to check the syntax of XPath expressions); in addition, these schemas may reject some stylesheets that are valid, for example because they rely on <code>xsl:use-when</code> to eliminate sections of code that would otherwise be invalid.</span></p><div class="div2"><h3><a id="xsd11-schema-for-xslt"></a>H.1 <a href="#xsd11-schema-for-xslt" style="text-decoration: none">XSD 1.1 Schema for XSLT Stylesheets</a></h3><p>The following XSD 1.1 schema describes the structure of an XSLT stylesheet module. It does not define all the constraints that apply to a stylesheet (for example, it does not attempt to define a datatype that precisely represents attributes containing XPath <a title="expression" class="termref" href="#dt-expression">expressions</a>). However, every valid stylesheet module conforms to this schema, unless it contains elements that invoke <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>.</p><p><span style="display: none;" class="delete_version">A copy of this schema is available at <a href="schema-for-xslt30.xsd">schema-for-xslt30.xsd</a></span><span style="display: none;" class="add_version">A copy of this schema is available at <span><a href="schema-for-xslt40.xsd">schema-for-xslt40.xsd</a></span></span><span class="modify_version">A copy of this schema is available at <span><a href="schema-for-xslt40.xsd">schema-for-<span class="deltaxml-old" style="background:#FF5555">xslt30</span><span class="deltaxml-new" style="background:#90EE90">xslt40</span>.xsd</a></span></span></p><div class="note"><p class="prefix"><b>Note:</b></p><p>The schema as written uses a lax wildcard to permit literal result elements to appear in a sequence constructor. This assumes that the schema used for validation will not contain any global element declaration that matches the element name of a literal result element. The content model for an element such as <code>invoice</code> appearing within a stylesheet is not the same as the content model for the same element appearing within a source document (it is likely to contain XSLT instructions rather than other elements from the target vocabulary): therefore, including such declarations in the schema used for validating a stylesheet is inappropriate.</p><p>The reason that lax validation rather than skip validation is used is so that XSLT instructions appearing as children of the literal result element will themselves be validated, using the appropriate global element declaration.</p></div><div class="note"><p class="prefix"><b>Note:</b></p><p>The schema uses XSD 1.1 assertions to represent some of the non-grammatical constraints appearing in the specification, for example the rule that some elements can have either a <code>select</code> attribute or a contained sequence constructor, but not both. At this stage, no attempt has been made to represent every such constraint, even where it is not difficult to express the rule. There will always be some constraints that cannot be expressed at all, for example those that require access to multiple stylesheet modules, those that require access to the in-scope schema components, and those that involve parsing a non-regular grammar, such as the grammar for patterns.</p><p>Apart from assertions, the only other significant use of XSD 1.1 features is that the elements <a href="#element-param"><code>xsl:param</code></a> and <a href="#element-variable"><code>xsl:variable</code></a> are in two substitution groups: one containing all instructions, and one containing all declarations. If the schema needs to be converted to an XSD 1.0 schema, removing all assertions is straightforward; the other change needed is to remove <a href="#element-param"><code>xsl:param</code></a> and <a href="#element-variable"><code>xsl:variable</code></a> from the substitution group for declarations, and instead permit them explicitly as children of <a href="#element-transform"><code>xsl:transform</code></a>.</p></div><pre class="font-size: small"><span class="deltaxml-old" style="background:#FF5555">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--* &lt;!DOCTYPE xs:schema PUBLIC "-//W3C//DTD XMLSCHEMA 200105//EN" "http://www.w3.org/2001/XMLSchema.dtd" [ &lt;!ENTITY % schemaAttrs " xmlns:xs CDATA #IMPLIED xmlns:xsl CDATA #IMPLIED xmlns:xsd CDATA #IMPLIED" &gt; &lt;!ENTITY % p "xs:"&gt; &lt;!ENTITY % s ":xs"&gt; ]&gt; *--&gt; &lt;?xml-stylesheet href="http://www.w3.org/2008/09/xsd.xsl" type="text/xsl"?&gt; &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" targetNamespace="http://www.w3.org/1999/XSL/Transform" elementFormDefault="qualified" vc:minVersion="1.1"&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This is an XSD 1.1 schema for XSLT 3.0 stylesheets. It defines all the elements that appear in the XSLT namespace; it also provides hooks that allow the inclusion of user-defined literal result elements, extension instructions, and top-level data elements. &lt;/p&gt; &lt;p&gt; This schema is available for use under the conditions of the W3C Software License published at http://www.w3.org/Consortium/Legal/copyright-software-19980720 &lt;/p&gt; &lt;p&gt; The schema is organized as follows: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; PART A: definitions of complex types and model groups used as the basis for element definitions &lt;/li&gt; &lt;li&gt; PART B: definitions of individual XSLT elements &lt;/li&gt; &lt;li&gt; PART C: definitions for literal result elements &lt;/li&gt; &lt;li&gt; PART D: definitions of simple types used in attribute definitions &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; The schema has a number of limitations: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; The XSLT specification allows additional elements and attributes to be present where forwards compatibility is invoked. This schema does not. &lt;/li&gt; &lt;li&gt; The XSLT specification allows arbitrary content in a part of the stylesheet that is excluded by virtue of a use-when attribute. This schema does not. &lt;/li&gt; &lt;li&gt; The handling of literal result elements in this schema is imperfect; although various options are allowed, none matches the specification exactly. For example, the content of a literal result element uses lax validation, which permits child elements in the XSLT namespace that have no declaration in this schema. &lt;/li&gt; &lt;li&gt; The schema makes no attempt to check XPath expressions for syntactic or semantic correctness, nor to check that component references are resolved (for example that a template named in xsl:call-template has a declaration). Doing this in general requires cross-document validation, which is beyond the scope of XSD. &lt;/li&gt; &lt;li&gt; The schema imports the schema for XSD 1.0 schema documents. In stylesheets that contain an inline XSD 1.1 schema, this import should be replaced with one for the schema for XSD 1.1 schema documents. &lt;/li&gt; &lt;/ul&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;!-- The declaration of xml:space and xml:lang may need to be commented out because of problems processing the schema using various tools --&gt; &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace"/&gt; &lt;!--schemaLocation="http://www.w3.org/2001/xml.xsd"--&gt; &lt;!-- An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element, so the Schema for schemas needs to be imported. We use the XSD 1.1 version. --&gt; &lt;xs:import namespace="http://www.w3.org/2001/XMLSchema" schemaLocation="http://www.w3.org/TR/xmlschema11-1/XMLSchema.xsd"/&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART A: definitions of complex types and model groups used as the basis for element definitions &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:complexType name="generic-element-type" mixed="true"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements; it contains the definitions of the standard attributes that may appear on any element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt; &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt; &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/&gt; &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt; &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt; &lt;xs:attribute name="use-when" type="xsl:expression"/&gt; &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt; &lt;xs:attribute name="_default-collation" type="xs:string"/&gt; &lt;xs:attribute name="_default-mode" type="xs:string"/&gt; &lt;xs:attribute name="_default-validation" type="xs:string"/&gt; &lt;xs:attribute name="_exclude-result-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_expand-text" type="xs:string"/&gt; &lt;xs:attribute name="_extension-element-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_use-when" type="xs:string"/&gt; &lt;xs:attribute name="_xpath-default-namespace" type="xs:string"/&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="versioned-element-type" mixed="true"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements with the exception of xsl:output; it contains the definitions of the version attribute that may appear on any element. &lt;/p&gt; &lt;p&gt; The xsl:output does not use this definition because, although it has a version attribute, the syntax and semantics of this attribute are unrelated to the standard version attribute allowed on other elements. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:generic-element-type"&gt; &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt; &lt;xs:attribute name="_version" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt; &lt;xs:complexContent&gt; &lt;xs:restriction base="xsl:versioned-element-type"&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="sequence-constructor"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements that allow a sequence constructor as their content. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="sequence-constructor-and-select"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type allows a sequence constructor and a select attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="sequence-constructor-or-select"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type allows a sequence constructor or a select attribute, but not both. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:restriction base="xsl:sequence-constructor-and-select"&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;xs:assert test="not(exists(@select | @_select) and (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:group name="sequence-constructor-group"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements that allow a sequence constructor as their content. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:choice&gt; &lt;xs:element ref="xsl:instruction"/&gt; &lt;xs:group ref="xsl:result-elements"/&gt; &lt;/xs:choice&gt; &lt;/xs:group&gt; &lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt; &lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART B: definitions of individual XSLT elements Elements are listed in alphabetical order. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:element name="accept"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:use-package and defines any variations that the containing package wishes to make to the visibility of components made available from a library package. For example, it may indicate that some of the public components in the library package are not to be made available to the containing package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt; &lt;xs:attribute name="names" type="xsl:EQNames"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="_component" type="xs:string"/&gt; &lt;xs:attribute name="_names" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:assert test="exists(@component | @_component)"/&gt; &lt;xs:assert test="exists(@names | @_names)"/&gt; &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="accumulator" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:accumulator-rule" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="initial-value" type="xsl:expression"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_initial-value" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="accumulator-rule"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:sequence/&gt; &lt;xs:attribute name="match" type="xsl:pattern"/&gt; &lt;xs:attribute name="phase"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="start"/&gt; &lt;xs:enumeration value="end"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_match" type="xs:string"/&gt; &lt;xs:attribute name="_phase" type="xs:string"/&gt; &lt;xs:assert test="exists(@match | @_match)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt; &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="regex" type="xsl:avt"/&gt; &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_regex" type="xs:string"/&gt; &lt;xs:attribute name="_flags" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;xs:assert test="exists(@regex | @_regex)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:sort"/&gt; &lt;xs:element ref="xsl:with-param"/&gt; &lt;/xs:choice&gt; &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt; &lt;xs:attribute name="mode" type="xsl:mode"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_mode" type="xs:string"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="assert" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="test" type="xsl:expression"/&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="error-code" type="xsl:avt"/&gt; &lt;xs:attribute name="_test" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_error-code" type="xs:string"/&gt; &lt;xs:assert test="exists(@test | @_test)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="namespace" type="xsl:avt"/&gt; &lt;xs:attribute name="separator" type="xsl:avt"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_namespace" type="xs:string"/&gt; &lt;xs:attribute name="_separator" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:attribute"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="break" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="catch"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="errors" type="xs:token" use="optional"/&gt; &lt;xs:attribute name="_errors" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="use-character-maps" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="comment" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="context-item"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="as" type="xsl:item-type"/&gt; &lt;xs:attribute name="use"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="required"/&gt; &lt;xs:enumeration value="optional"/&gt; &lt;xs:enumeration value="absent"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_use" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="copy-accumulators" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_copy-accumulators" type="xs:string"/&gt; &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="document" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="decimal-separator" type="xsl:char" default="."/&gt; &lt;xs:attribute name="grouping-separator" type="xsl:char" default=","/&gt; &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt; &lt;xs:attribute name="minus-sign" type="xsl:char" default="-"/&gt; &lt;xs:attribute name="exponent-separator" type="xsl:char" default="e"/&gt; &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt; &lt;xs:attribute name="percent" type="xsl:char" default="%"/&gt; &lt;xs:attribute name="per-mille" type="xsl:char" default="~"/&gt; &lt;xs:attribute name="zero-digit" type="xsl:zero-digit" default="0"/&gt; &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt; &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_decimal-separator" type="xs:string"/&gt; &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt; &lt;xs:attribute name="_infinity" type="xs:string"/&gt; &lt;xs:attribute name="_minus-sign" type="xs:string"/&gt; &lt;xs:attribute name="_exponent-separator" type="xs:string"/&gt; &lt;xs:attribute name="_NaN" type="xs:string"/&gt; &lt;xs:attribute name="_percent" type="xs:string"/&gt; &lt;xs:attribute name="_per-mille" type="xs:string"/&gt; &lt;xs:attribute name="_zero-digit" type="xs:string"/&gt; &lt;xs:attribute name="_digit" type="xs:string"/&gt; &lt;xs:attribute name="_pattern-separator" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType mixed="true"&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="namespace" type="xsl:avt"/&gt; &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_namespace" type="xs:string"/&gt; &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="evaluate" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:with-param"/&gt; &lt;xs:element ref="xsl:fallback"/&gt; &lt;/xs:choice&gt; &lt;xs:attribute name="xpath" type="xsl:expression"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="base-uri" type="xsl:avt"/&gt; &lt;xs:attribute name="context-item" type="xsl:expression"/&gt; &lt;xs:attribute name="namespace-context" type="xsl:expression"/&gt; &lt;xs:attribute name="schema-aware" type="xsl:avt"/&gt; &lt;xs:attribute name="with-params" type="xsl:expression"/&gt; &lt;xs:attribute name="_xpath" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_base-uri" type="xs:string"/&gt; &lt;xs:attribute name="_context-item" type="xs:string"/&gt; &lt;xs:attribute name="_namespace-context" type="xs:string"/&gt; &lt;xs:attribute name="_schema-aware" type="xs:string"/&gt; &lt;xs:attribute name="_with-params" type="xs:string"/&gt; &lt;xs:assert test="exists(@xpath | @_xpath)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="expose"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:use-package and defines the visibility of components that are made available (or not) by this package to other using packages. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt; &lt;xs:attribute name="names" type="xsl:EQNames"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt; &lt;xs:attribute name="_component" type="xs:string"/&gt; &lt;xs:attribute name="_names" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="fallback" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="group-by" type="xsl:expression"/&gt; &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt; &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt; &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt; &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="collation" type="xsl:avt"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_group-by" type="xs:string"/&gt; &lt;xs:attribute name="_group-adjacent" type="xs:string"/&gt; &lt;xs:attribute name="_group-starting-with" type="xs:string"/&gt; &lt;xs:attribute name="_group-ending-with" type="xs:string"/&gt; &lt;xs:attribute name="_composite" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="count(((@group-by|@_group-by)[1], (@group-adjacent|@_group-adjacent)[1], (@group-starting-with|@_group-starting-with)[1], (@group-ending-with|@_group-ending-with)[1])) = 1"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; These four attributes are mutually exclusive: it is a static error if none of these four attributes is present or if more than one of them is present. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (exists(@collation|@_collation) or exists(@composite|@_composite)) then (exists(@group-by|@_group-by) or exists(@group-adjacent|@_group-adjacent)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is an error to specify the collation attribute or the composite attribute if neither the group-by attribute nor group-adjacent attribute is specified. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="fork" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:choice&gt; &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:sequence"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:for-each-group"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName-in-namespace"/&gt; &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="streamability" type="xsl:streamability-type"/&gt; &lt;xs:attribute name="override-extension-function" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="new-each-time" type="xsl:yes-or-no-or-maybe"/&gt; &lt;xs:attribute name="cache" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_override" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:attribute name="_streamability" type="xs:string"/&gt; &lt;xs:attribute name="_override-extension-function" type="xs:string"/&gt; &lt;xs:attribute name="_identity-sensitive" type="xs:string"/&gt; &lt;xs:attribute name="_cache" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="every $e in xsl:param satisfies (empty($e/(@select | @_select)) and empty($e/child::node()))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a function must have no default value. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a function must have no visibility attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@required | @_required))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a function must have no required attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="global-context-item" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="as" type="xsl:item-type"/&gt; &lt;xs:attribute name="use"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="required"/&gt; &lt;xs:enumeration value="optional"/&gt; &lt;xs:enumeration value="absent"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_use" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="test" type="xsl:expression"/&gt; &lt;xs:attribute name="_test" type="xs:string"/&gt; &lt;xs:assert test="exists(@test | @_test)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="import" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="href" type="xs:anyURI"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:assert test="exists(@href | @_href)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt; &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt; &lt;xs:attribute name="_namespace" type="xs:string"/&gt; &lt;xs:attribute name="_schema-location" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@schema-location | @_schema-location) and exists(xs:schema))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; XTSE0215: It is a static error if an xsl:import-schema element that contains an xs:schema element has a schema-location attribute &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="href" type="xs:anyURI"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:assert test="exists(@href | @_href)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="iterate" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:on-completion" minOccurs="0" maxOccurs="1"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="match" type="xsl:pattern"/&gt; &lt;xs:attribute name="use" type="xsl:expression"/&gt; &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="collation" type="xs:anyURI"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_match" type="xs:string"/&gt; &lt;xs:attribute name="_use" type="xs:string"/&gt; &lt;xs:attribute name="_composite" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="exists(@match | @_match)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="map" type="xsl:sequence-constructor" substitutionGroup="xsl:instruction"/&gt; &lt;xs:element name="map-entry" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt; &lt;xs:attribute name="key" type="xsl:expression"/&gt; &lt;xs:attribute name="_key" type="xs:string"/&gt; &lt;xs:assert test="exists(@key | @_key)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="matching-substring" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="merge" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:merge-source" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:merge-action" minOccurs="1" maxOccurs="1"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="merge-action" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="merge-key" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="lang" type="xsl:avt"/&gt; &lt;xs:attribute name="order" type="xsl:avt"/&gt; &lt;xs:attribute name="collation" type="xs:anyURI"/&gt; &lt;xs:attribute name="case-order" type="xsl:avt"/&gt; &lt;xs:attribute name="data-type" type="xsl:avt"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_lang" type="xs:string"/&gt; &lt;xs:attribute name="_order" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:attribute name="_case-order" type="xs:string"/&gt; &lt;xs:attribute name="_data-type" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="merge-source"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:merge-key" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xs:NCName"/&gt; &lt;xs:attribute name="for-each-item" type="xsl:expression"/&gt; &lt;xs:attribute name="for-each-source" type="xsl:expression"/&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt; &lt;xs:attribute name="sort-before-merge" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_for-each-item" type="xs:string"/&gt; &lt;xs:attribute name="_for-each-source" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt; &lt;xs:attribute name="_sort-before-merge" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt; &lt;xs:attribute name="error-code" type="xsl:avt"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_terminate" type="xs:string"/&gt; &lt;xs:attribute name="_error-code" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="mode" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="false"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt; &lt;xs:attribute name="on-no-match" type="xsl:on-no-match-type" default="shallow-skip"/&gt; &lt;xs:attribute name="on-multiple-match" type="xsl:on-multiple-match-type" default="use-last"/&gt; &lt;xs:attribute name="warning-on-no-match" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="warning-on-multiple-match" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="typed" type="xsl:typed-type"/&gt; &lt;xs:attribute name="visibility"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xsl:visibility-type"&gt; &lt;xs:enumeration value="public"/&gt; &lt;xs:enumeration value="private"/&gt; &lt;xs:enumeration value="final"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_on-no-match" type="xs:string"/&gt; &lt;xs:attribute name="_on-multiple-match" type="xs:string"/&gt; &lt;xs:attribute name="_warning-on-no-match" type="xs:string"/&gt; &lt;xs:attribute name="_warning-on-multiple-match" type="xs:string"/&gt; &lt;xs:attribute name="_typed" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default"/&gt; &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default"/&gt; &lt;xs:attribute name="_stylesheet-prefix" type="xs:string"/&gt; &lt;xs:attribute name="_result-prefix" type="xs:string"/&gt; &lt;xs:assert test="exists(@stylesheet-prefix | @_stylesheet-prefix)"/&gt; &lt;xs:assert test="exists(@result-prefix | @_result-prefix)"/&gt; &lt;xs:assert test="every $prefix in (@stylesheet-prefix, @result-prefix) /normalize-space(.)[. ne '#default'] satisfies $prefix = in-scope-prefixes(.)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="next-iteration" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:with-param"/&gt; &lt;xs:element ref="xsl:fallback"/&gt; &lt;/xs:choice&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:attribute name="value" type="xsl:expression"/&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt; &lt;xs:attribute name="count" type="xsl:pattern"/&gt; &lt;xs:attribute name="from" type="xsl:pattern"/&gt; &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt; &lt;xs:attribute name="lang" type="xsl:avt"/&gt; &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt; &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt; &lt;xs:attribute name="start-at" type="xsl:avt"/&gt; &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt; &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt; &lt;xs:attribute name="_value" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_level" type="xs:string"/&gt; &lt;xs:attribute name="_count" type="xs:string"/&gt; &lt;xs:attribute name="_from" type="xs:string"/&gt; &lt;xs:attribute name="_format" type="xs:string"/&gt; &lt;xs:attribute name="_lang" type="xs:string"/&gt; &lt;xs:attribute name="_letter-value" type="xs:string"/&gt; &lt;xs:attribute name="_ordinal" type="xs:string"/&gt; &lt;xs:attribute name="_start-at" type="xs:string"/&gt; &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt; &lt;xs:attribute name="_grouping-size" type="xs:string"/&gt; &lt;xs:assert test="if (exists(@value | @_value)) then empty((@select | @_select, @count | @_count, @from | @_from)) and (exists(@_level) or normalize-space(@level)='single') else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if the value attribute of xsl:number is present unless the select, level, count, and from attributes are all absent. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="on-completion" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="on-empty" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="on-non-empty" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="otherwise" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:generic-element-type"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="method" type="xsl:method"/&gt; &lt;xs:attribute name="allow-duplicate-names" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="build-tree" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="cdata-section-elements" type="xsl:EQNames"/&gt; &lt;xs:attribute name="doctype-public" type="xs:string"/&gt; &lt;xs:attribute name="doctype-system" type="xs:string"/&gt; &lt;xs:attribute name="encoding" type="xs:string"/&gt; &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="html-version" type="xs:decimal"/&gt; &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="item-separator" type="xs:string"/&gt; &lt;xs:attribute name="json-node-output-method" type="xsl:method"/&gt; &lt;xs:attribute name="media-type" type="xs:string"/&gt; &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt; &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="parameter-document" type="xs:anyURI"/&gt; &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt; &lt;xs:attribute name="suppress-indentation" type="xsl:EQNames"/&gt; &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt; &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_method" type="xs:string"/&gt; &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt; &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt; &lt;xs:attribute name="_encoding" type="xs:string"/&gt; &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt; &lt;xs:attribute name="_html-version" type="xs:string"/&gt; &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt; &lt;xs:attribute name="_indent" type="xs:string"/&gt; &lt;xs:attribute name="_item-separator" type="xs:string"/&gt; &lt;xs:attribute name="_media-type" type="xs:string"/&gt; &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt; &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt; &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt; &lt;xs:attribute name="_standalone" type="xs:string"/&gt; &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt; &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt; &lt;xs:attribute name="_version" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="output-character"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="character" type="xsl:char"/&gt; &lt;xs:attribute name="string" type="xs:string"/&gt; &lt;xs:attribute name="_character" type="xs:string"/&gt; &lt;xs:attribute name="_string" type="xs:string"/&gt; &lt;xs:assert test="exists(@character | @_character)"/&gt; &lt;xs:assert test="exists(@string | @_string)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="override"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:use-package and defines any overriding definitions of components that the containing package wishes to make to the components made available from a library package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:template"/&gt; &lt;xs:element ref="xsl:function"/&gt; &lt;xs:element ref="xsl:variable"/&gt; &lt;xs:element ref="xsl:param"/&gt; &lt;xs:element ref="xsl:attribute-set"/&gt; &lt;/xs:choice&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="package"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:expose"/&gt; &lt;xs:element ref="xsl:declaration"/&gt; &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="declared-modes" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="id" type="xs:ID"/&gt; &lt;xs:attribute name="name" type="xs:anyURI"/&gt; &lt;xs:attribute name="package-version" type="xs:string"/&gt; &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"/&gt; &lt;xs:attribute name="_declared-modes" type="xs:string"/&gt; &lt;xs:attribute name="_id" type="xs:string"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_package-version" type="xs:string"/&gt; &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="param" substitutionGroup="xsl:declaration"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Declaration of the xsl:param element, used both defining function parameters, template parameters, parameters to xsl:iterate, and global stylesheet parameters. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_required" type="xs:string"/&gt; &lt;xs:attribute name="_tunnel" type="xs:string"/&gt; &lt;xs:attribute name="_static" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) then empty((*,text())) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; When the attribute static="yes" is specified, the xsl:param element must have empty content. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="elements" type="xsl:nametests"/&gt; &lt;xs:attribute name="_elements" type="xs:string"/&gt; &lt;xs:assert test="exists(@elements | @_elements)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="format" type="xsl:avt"/&gt; &lt;xs:attribute name="href" type="xsl:avt"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="method" type="xsl:avt"/&gt; &lt;xs:attribute name="allow-duplicate-names" type="xsl:avt"/&gt; &lt;xs:attribute name="build-tree" type="xsl:avt"/&gt; &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt; &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt; &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt; &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt; &lt;xs:attribute name="encoding" type="xsl:avt"/&gt; &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt; &lt;xs:attribute name="html-version" type="xsl:avt"/&gt; &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt; &lt;xs:attribute name="indent" type="xsl:avt"/&gt; &lt;xs:attribute name="item-separator" type="xsl:avt"/&gt; &lt;xs:attribute name="json-node-output-method" type="xsl:avt"/&gt; &lt;xs:attribute name="media-type" type="xsl:avt"/&gt; &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt; &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt; &lt;xs:attribute name="parameter-document" type="xsl:avt"/&gt; &lt;xs:attribute name="standalone" type="xsl:avt"/&gt; &lt;xs:attribute name="suppress-indentation" type="xsl:avt"/&gt; &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt; &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt; &lt;xs:attribute name="output-version" type="xsl:avt"/&gt; &lt;xs:attribute name="_format" type="xs:string"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:attribute name="_method" type="xs:string"/&gt; &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt; &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt; &lt;xs:attribute name="_encoding" type="xs:string"/&gt; &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt; &lt;xs:attribute name="_html-version" type="xs:string"/&gt; &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt; &lt;xs:attribute name="_indent" type="xs:string"/&gt; &lt;xs:attribute name="_item-separator" type="xs:string"/&gt; &lt;xs:attribute name="_media-type" type="xs:string"/&gt; &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt; &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt; &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt; &lt;xs:attribute name="_standalone" type="xs:string"/&gt; &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt; &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt; &lt;xs:attribute name="_output-version" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="sequence" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="sort"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="lang" type="xsl:avt"/&gt; &lt;xs:attribute name="data-type" type="xsl:avt" default="text"/&gt; &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt; &lt;xs:attribute name="case-order" type="xsl:avt"/&gt; &lt;xs:attribute name="collation" type="xsl:avt"/&gt; &lt;xs:attribute name="stable" type="xsl:avt"/&gt; &lt;xs:attribute name="_lang" type="xs:string"/&gt; &lt;xs:attribute name="_data-type" type="xs:string"/&gt; &lt;xs:attribute name="_order" type="xs:string"/&gt; &lt;xs:attribute name="_case-order" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:attribute name="_stable" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="source-document" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="href" type="xsl:avt"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="exists(@href | @_href)"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="elements" type="xsl:nametests"/&gt; &lt;xs:attribute name="_elements" type="xs:string"/&gt; &lt;xs:assert test="exists(@elements | @_elements)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt; &lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="1"/&gt; &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="match" type="xsl:pattern"/&gt; &lt;xs:attribute name="priority" type="xs:decimal"/&gt; &lt;xs:attribute name="mode" type="xsl:modes"/&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="_match" type="xs:string"/&gt; &lt;xs:attribute name="_priority" type="xs:string"/&gt; &lt;xs:attribute name="_mode" type="xs:string"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:assert test="exists(@match | @_match) or exists(@name | @_name)"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An xsl:template element must have either a match attribute or a name attribute, or both. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (empty(@match | @_match)) then (empty(@mode | @_mode) and empty(@priority | @_priority)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An xsl:template element that has no match attribute must have no mode attribute and no priority attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="not(exists(@visibility | @_visibility) and empty(@name | @_name))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An xsl:template element that has no name attribute must have no visibility attribute &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (normalize-space(@visibility) = 'abstract') then empty(* except (xsl:context-item, xsl:param)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; If the visibility attribute is present with the value abstract then (a) the sequence constructor defining the template body must be empty: that is, the only permitted children are xsl:context-item and xsl:param &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="not(normalize-space(@visibility) = 'abstract' and exists(@match))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; If the visibility attribute is present with the value abstract then there must be no match attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a template must have no visibility attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:complexType name="text-element-base-type"&gt; &lt;xs:simpleContent&gt; &lt;xs:restriction base="xsl:versioned-element-type"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"/&gt; &lt;/xs:simpleType&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="text-element-type"&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base="xsl:text-element-base-type"&gt; &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;xs:element name="text" substitutionGroup="xsl:instruction" type="xsl:text-element-type"/&gt; &lt;xs:complexType name="transform-element-base-type"&gt; &lt;xs:complexContent&gt; &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt; &lt;xs:attribute name="_version" type="xs:string"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The version attribute indicates the version of XSLT that the stylesheet module requires. The attribute is required, unless the xsl:stylesheet element is a child of an xsl:package element, in which case it is optional: the default is then taken from the parent xsl:package element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:attribute&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:element name="transform"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:transform-element-base-type"&gt; &lt;xs:sequence&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:declaration"/&gt; &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;!-- weaker than XSLT 1.0 --&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="id" type="xs:ID"/&gt; &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type" default="unspecified"/&gt; &lt;xs:attribute name="_id" type="xs:string"/&gt; &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt; &lt;!--* The 'static' attribute may be used on 'param' and 'variable' * only when they are top-level elements. *--&gt; &lt;xs:assert test="every $v in (.//xsl:param, .//xsl:variable)[exists(@static | @_static)] satisfies $v[parent::xsl:stylesheet or parent::xsl:transform or parent::xsl:override]"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The static attribute must not be present on an xsl:variable or xsl:param element unless it is a top-level element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $prefix in (@exclude-result-prefixes[not(. = '#all')], @extension-element-prefixes) satisfies ((if ($prefix = '#default') then '' else $prefix) = in-scope-prefixes(.))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; XTSE0808: It is a static error if a namespace prefix is used within the [xsl:]exclude-result-prefixes attribute and there is no namespace binding in scope for that prefix. &lt;/p&gt; &lt;p&gt; XTSE0809: It is a static error if the value #default is used within the [xsl:]exclude-result-prefixes attribute and the parent element of the [xsl:]exclude-result-prefixes attribute has no default namespace. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="try" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:catch" minOccurs="1" maxOccurs="1"/&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:catch"/&gt; &lt;xs:element ref="xsl:fallback"/&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="rollback-output" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt; &lt;xs:attribute name="_rollback-output" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="use-package" substitutionGroup="xsl:declaration"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:package and defines a dependency of the containing package on another package, identified by URI in the name attribute. The package-version attribute indicates which version of the library package is required, or may indicate a range of versions. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="false"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:accept"/&gt; &lt;xs:element ref="xsl:override"/&gt; &lt;/xs:choice&gt; &lt;xs:attribute name="name" type="xs:anyURI"/&gt; &lt;xs:attribute name="package-version" type="xs:string"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_package-version" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="separator" type="xsl:avt"/&gt; &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="_separator" type="xs:string"/&gt; &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="variable" substitutionGroup="xsl:declaration xsl:instruction"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Declaration of the xsl:variable element, used both for local and global variable bindings. &lt;/p&gt; &lt;p&gt; This definition takes advantage of the ability in XSD 1.1 for an element to belong to more than one substitution group. A global variable is a declaration, while a local variable can appear as an instruction in a sequence constructor. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:attribute name="_static" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) then (exists(@_visibility) or normalize-space(@visibility) = ('', 'private', 'final')) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; When the static attribute is present with the value yes, the visibility attribute must not have a value other than private or final. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) then (empty((*, text())) and exists(@select | @_select)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; When the attribute static="yes" is specified, the xsl:variable element must have empty content, and the select attribute must be present to define the value of the variable. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="when"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="test" type="xsl:expression"/&gt; &lt;xs:attribute name="_test" type="xs:string"/&gt; &lt;xs:assert test="exists(@test | @_test)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="where-populated" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="with-param"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_tunnel" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART C: definition of literal result elements There are three ways to define the literal result elements permissible in a stylesheet. (a) do nothing. This allows any element to be used as a literal result element, provided it is not in the XSLT namespace (b) declare all permitted literal result elements as members of the xsl:literal-result-element substitution group (c) redefine the model group xsl:result-elements to accommodate all permitted literal result elements. Literal result elements are allowed to take certain attributes in the XSLT namespace. These are defined in the attribute group literal-result-element-attributes, which can be included in the definition of any literal result element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt; &lt;xs:attributeGroup name="literal-result-element-attributes"&gt; &lt;xs:attribute name="default-collation" form="qualified" type="xsl:uri-list"/&gt; &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt; &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/&gt; &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="extension-element-prefixes" form="qualified" type="xsl:prefixes"/&gt; &lt;xs:attribute name="exclude-result-prefixes" form="qualified" type="xsl:prefixes"/&gt; &lt;xs:attribute name="xpath-default-namespace" form="qualified" type="xs:anyURI"/&gt; &lt;xs:attribute name="inherit-namespaces" form="qualified" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="use-attribute-sets" form="qualified" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="use-when" form="qualified" type="xsl:expression"/&gt; &lt;xs:attribute name="version" form="qualified" type="xs:decimal"/&gt; &lt;xs:attribute name="type" form="qualified" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" form="qualified" type="xsl:validation-type"/&gt; &lt;/xs:attributeGroup&gt; &lt;xs:group name="result-elements"&gt; &lt;xs:choice&gt; &lt;xs:element ref="xsl:literal-result-element"/&gt; &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;xs:any namespace="##local" processContents="lax"/&gt; &lt;/xs:choice&gt; &lt;/xs:group&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART D: definitions of simple types used in stylesheet attributes &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:simpleType name="accumulator-names"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The use-accumulators attribute of xsl:source-document, xsl:merge-source, or xsl:global-context-item: either a list, each member being a QName; or the value #all &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union&gt; &lt;xs:simpleType&gt; &lt;xs:list itemType="xsl:EQName"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#all"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="avt"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This type is used for all attributes that allow an attribute value template. The general rules for the syntax of attribute value templates, and the specific rules for each such attribute, are described in the XSLT 2.1 Recommendation. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:string"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="char"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A string containing exactly one character. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:length value="1"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="component-kind-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes a kind of component within a package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="template"/&gt; &lt;xs:enumeration value="function"/&gt; &lt;xs:enumeration value="variable"/&gt; &lt;xs:enumeration value="attribute-set"/&gt; &lt;xs:enumeration value="mode"/&gt; &lt;xs:enumeration value="*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="default-mode-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The default-mode attribute of xsl:stylesheet, xsl:transform, xsl:package (or any other xsl:* element): either a QName or #unnamed. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#unnamed"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="expression"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An XPath 2.0 expression. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value=".+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="item-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An XPath 2.1 ItemType &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value=".+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="input-type-annotations-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes how type annotations in source documents are handled. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="preserve"/&gt; &lt;xs:enumeration value="strip"/&gt; &lt;xs:enumeration value="unspecified"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="level"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The level attribute of xsl:number: one of single, multiple, or any. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="single"/&gt; &lt;xs:enumeration value="multiple"/&gt; &lt;xs:enumeration value="any"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="mode"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The mode attribute of xsl:apply-templates: either a QName, or #current, or #unnamed, or #default. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#default"/&gt; &lt;xs:enumeration value="#unnamed"/&gt; &lt;xs:enumeration value="#current"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="modes"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The mode attribute of xsl:template: either a list, each member being either a QName or #default or #unnamed; or the value #all &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union&gt; &lt;xs:simpleType&gt; &lt;xs:restriction&gt; &lt;xs:simpleType&gt; &lt;xs:list&gt; &lt;xs:simpleType&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#default"/&gt; &lt;xs:enumeration value="#unnamed"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;/xs:list&gt; &lt;/xs:simpleType&gt; &lt;xs:assertion test="count($value) = count(distinct-values($value))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; XTSE0550: It is a static error if the same token is included more than once in the list. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assertion&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#all"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="nametests"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A list of NameTests, as defined in the XPath 2.0 Recommendation. Each NameTest is either a QName, or "*", or "prefix:*", or "*:localname" &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:list&gt; &lt;xs:simpleType&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value="\i\c*:\*"/&gt; &lt;xs:pattern value="\*:\i\c*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;/xs:list&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="on-multiple-match-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the action to be taken when there are several template rules to match an item in a given mode. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="use-last"/&gt; &lt;xs:enumeration value="fail"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="on-no-match-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the action to be taken when there is no template rule to match an item in a given mode. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="deep-copy"/&gt; &lt;xs:enumeration value="shallow-copy"/&gt; &lt;xs:enumeration value="deep-skip"/&gt; &lt;xs:enumeration value="shallow-skip"/&gt; &lt;xs:enumeration value="text-only-copy"/&gt; &lt;xs:enumeration value="fail"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefixes"&gt; &lt;xs:list itemType="xs:NCName"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefix-list-or-all"&gt; &lt;xs:union memberTypes="xsl:prefix-list"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#all"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefix-list"&gt; &lt;xs:list itemType="xsl:prefix-or-default"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="method"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The method attribute of xsl:output: Either one of the recognized names "xml", "xhtml", "html", "text", or a QName that must include a prefix. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="xml"/&gt; &lt;xs:enumeration value="xhtml"/&gt; &lt;xs:enumeration value="html"/&gt; &lt;xs:enumeration value="text"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xsl:EQName"&gt; &lt;xs:pattern value="\c*:\c*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="pattern"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A match pattern as defined in the XSLT 2.1 Recommendation. The syntax for patterns is a restricted form of the syntax for XPath 2.0 expressions. Change since XSLT 2.0: Patterns may now match any item (not only nodes) &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:expression"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefix-or-default"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Either a namespace prefix, or #default. Used in the xsl:namespace-alias element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xs:NCName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#default"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="EQNames"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A list of QNames. Used in the [xsl:]use-attribute-sets attribute of various elements, and in the cdata-section-elements attribute of xsl:output &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:list itemType="xsl:EQName"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="EQName"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An extended QName. This schema does not use the built-in type xs:QName, but rather defines its own QName type. This may be either a local name, or a prefixed QName, or a name written using the extended QName notation Q{uri}local &lt;/p&gt; &lt;p&gt; Although xs:QName would define the correct validation on these attributes, a schema processor would expand unprefixed QNames incorrectly when constructing the PSVI, because (as defined in XML Schema errata) an unprefixed xs:QName is assumed to be in the default namespace, which is not the correct assumption for XSLT. The datatype is therefore defined as a union of NCName and QName, so that an unprefixed name will be validated as an NCName and will therefore not be treated as having the semantics of an unprefixed xs:QName. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xs:NCName xs:QName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value="Q\{[^{}]*\}[\i-[:]][\c-[:]]*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="EQName-in-namespace"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A subtype of EQNames that excludes no-namespace names &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:EQName"&gt; &lt;xs:pattern value="Q\{.+\}.+|\i\c*:.+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="sequence-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The description of a datatype, conforming to the SequenceType production defined in the XPath 2.0 Recommendation &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value=".+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="streamability-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the category to which a function belongs, with regards to its streaming behavior. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="unclassified"/&gt; &lt;xs:enumeration value="absorbing"/&gt; &lt;xs:enumeration value="inspection"/&gt; &lt;xs:enumeration value="filter"/&gt; &lt;xs:enumeration value="shallow-descent"/&gt; &lt;xs:enumeration value="deep-descent"/&gt; &lt;xs:enumeration value="ascent"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="typed-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes whether a mode is designed to match typed or untyped nodes. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;xs:enumeration value="strict"/&gt; &lt;xs:enumeration value="lax"/&gt; &lt;xs:enumeration value="unspecified"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="uri-list"&gt; &lt;xs:list itemType="xs:anyURI"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="validation-strip-or-preserve"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes different ways of type-annotating an element or attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:validation-type"&gt; &lt;xs:enumeration value="preserve"/&gt; &lt;xs:enumeration value="strip"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="validation-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes different ways of type-annotating an element or attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="strict"/&gt; &lt;xs:enumeration value="lax"/&gt; &lt;xs:enumeration value="preserve"/&gt; &lt;xs:enumeration value="strip"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="visibility-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the visibility of a component within a package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="public"/&gt; &lt;xs:enumeration value="private"/&gt; &lt;xs:enumeration value="final"/&gt; &lt;xs:enumeration value="abstract"/&gt; &lt;xs:enumeration value="hidden"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="visibility-not-hidden-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the visibility of a component within a package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:visibility-type"&gt; &lt;xs:enumeration value="public"/&gt; &lt;xs:enumeration value="private"/&gt; &lt;xs:enumeration value="final"/&gt; &lt;xs:enumeration value="abstract"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="yes-or-no"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; One of the values "yes" or "no": the values "true" or "false", or "1" or "0" are accepted as synonyms. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="yes-or-no-or-maybe"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; One of the values "yes" or "no" or "omit". The values "true" or "false", or "1" or "0" are accepted as synonyms of "yes" and "no" respectively. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;xs:enumeration value="maybe"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="yes-or-no-or-omit"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; One of the values "yes" or "no" or "omit". The values "true" or "false", or "1" or "0" are accepted as synonyms of "yes" and "no" respectively. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;xs:enumeration value="omit"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="zero-digit"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A digit that has the numerical value zero. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:char"&gt; &lt;xs:pattern value="\p{Nd}"/&gt; &lt;xs:assertion test="matches(string-join(codepoints-to-string( for $i in 0 to 9 return string-to-codepoints($value) + $i), ''), '\p{Nd}{10}')"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:schema&gt; </span></pre><pre class="font-size: small"><span class="deltaxml-new" style="background:#90EE90">&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;!--* &lt;!DOCTYPE xs:schema PUBLIC "-//W3C//DTD XMLSCHEMA 200105//EN" "http://www.w3.org/2001/XMLSchema.dtd" [ &lt;!ENTITY % schemaAttrs " xmlns:xs CDATA #IMPLIED xmlns:xsl CDATA #IMPLIED xmlns:xsd CDATA #IMPLIED" &gt; &lt;!ENTITY % p "xs:"&gt; &lt;!ENTITY % s ":xs"&gt; ]&gt; *--&gt; &lt;?xml-stylesheet href="http://www.w3.org/2008/09/xsd.xsl" type="text/xsl"?&gt; &lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning" targetNamespace="http://www.w3.org/1999/XSL/Transform" elementFormDefault="qualified" vc:minVersion="1.1"&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This is an XSD 1.1 schema for XSLT 3.0 stylesheets. It defines all the elements that appear in the XSLT namespace; it also provides hooks that allow the inclusion of user-defined literal result elements, extension instructions, and top-level data elements. &lt;/p&gt; &lt;p&gt; This schema is available for use under the conditions of the W3C Software License published at http://www.w3.org/Consortium/Legal/copyright-software-19980720 &lt;/p&gt; &lt;p&gt; The schema is organized as follows: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; PART A: definitions of complex types and model groups used as the basis for element definitions &lt;/li&gt; &lt;li&gt; PART B: definitions of individual XSLT elements &lt;/li&gt; &lt;li&gt; PART C: definitions for literal result elements &lt;/li&gt; &lt;li&gt; PART D: definitions of simple types used in attribute definitions &lt;/li&gt; &lt;/ul&gt; &lt;p&gt; The schema has a number of limitations: &lt;/p&gt; &lt;ul&gt; &lt;li&gt; The XSLT specification allows additional elements and attributes to be present where forwards compatibility is invoked. This schema does not. &lt;/li&gt; &lt;li&gt; The XSLT specification allows arbitrary content in a part of the stylesheet that is excluded by virtue of a use-when attribute. This schema does not. &lt;/li&gt; &lt;li&gt; The handling of literal result elements in this schema is imperfect; although various options are allowed, none matches the specification exactly. For example, the content of a literal result element uses lax validation, which permits child elements in the XSLT namespace that have no declaration in this schema. &lt;/li&gt; &lt;li&gt; The schema makes no attempt to check XPath expressions for syntactic or semantic correctness, nor to check that component references are resolved (for example that a template named in xsl:call-template has a declaration). Doing this in general requires cross-document validation, which is beyond the scope of XSD. &lt;/li&gt; &lt;li&gt; The schema imports the schema for XSD 1.0 schema documents. In stylesheets that contain an inline XSD 1.1 schema, this import should be replaced with one for the schema for XSD 1.1 schema documents. &lt;/li&gt; &lt;/ul&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;!-- The declaration of xml:space and xml:lang may need to be commented out because of problems processing the schema using various tools --&gt; &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace"/&gt; &lt;!--schemaLocation="http://www.w3.org/2001/xml.xsd"--&gt; &lt;!-- An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element, so the Schema for schemas needs to be imported. We use the XSD 1.1 version. --&gt; &lt;xs:import namespace="http://www.w3.org/2001/XMLSchema" schemaLocation="http://www.w3.org/TR/xmlschema11-1/XMLSchema.xsd"/&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART A: definitions of complex types and model groups used as the basis for element definitions &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:complexType name="generic-element-type" mixed="true"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements; it contains the definitions of the standard attributes that may appear on any element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt; &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt; &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/&gt; &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt; &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt; &lt;xs:attribute name="use-when" type="xsl:expression"/&gt; &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt; &lt;xs:attribute name="_default-collation" type="xs:string"/&gt; &lt;xs:attribute name="_default-mode" type="xs:string"/&gt; &lt;xs:attribute name="_default-validation" type="xs:string"/&gt; &lt;xs:attribute name="_exclude-result-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_expand-text" type="xs:string"/&gt; &lt;xs:attribute name="_extension-element-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_use-when" type="xs:string"/&gt; &lt;xs:attribute name="_xpath-default-namespace" type="xs:string"/&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="versioned-element-type" mixed="true"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements with the exception of xsl:output; it contains the definitions of the version attribute that may appear on any element. &lt;/p&gt; &lt;p&gt; The xsl:output does not use this definition because, although it has a version attribute, the syntax and semantics of this attribute are unrelated to the standard version attribute allowed on other elements. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:generic-element-type"&gt; &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt; &lt;xs:attribute name="_version" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt; &lt;xs:complexContent&gt; &lt;xs:restriction base="xsl:versioned-element-type"&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="sequence-constructor"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements that allow a sequence constructor as their content. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="sequence-constructor-and-select"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type allows a sequence constructor and a select attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="sequence-constructor-or-select"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type allows a sequence constructor or a select attribute, but not both. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:restriction base="xsl:sequence-constructor-and-select"&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;xs:assert test="not(exists(@select | @_select) and (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:group name="sequence-constructor-group"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This complex type provides a generic supertype for all XSLT elements that allow a sequence constructor as their content. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:choice&gt; &lt;xs:element ref="xsl:instruction"/&gt; &lt;xs:group ref="xsl:result-elements"/&gt; &lt;/xs:choice&gt; &lt;/xs:group&gt; &lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt; &lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART B: definitions of individual XSLT elements Elements are listed in alphabetical order. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:element name="accept"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:use-package and defines any variations that the containing package wishes to make to the visibility of components made available from a library package. For example, it may indicate that some of the public components in the library package are not to be made available to the containing package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt; &lt;xs:attribute name="names" type="xsl:EQNames"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="_component" type="xs:string"/&gt; &lt;xs:attribute name="_names" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:assert test="exists(@component | @_component)"/&gt; &lt;xs:assert test="exists(@names | @_names)"/&gt; &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="accumulator" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:accumulator-rule" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="initial-value" type="xsl:expression"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_initial-value" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="accumulator-rule"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:sequence/&gt; &lt;xs:attribute name="match" type="xsl:pattern"/&gt; &lt;xs:attribute name="phase"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="start"/&gt; &lt;xs:enumeration value="end"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_match" type="xs:string"/&gt; &lt;xs:attribute name="_phase" type="xs:string"/&gt; &lt;xs:assert test="exists(@match | @_match)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt; &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="regex" type="xsl:avt"/&gt; &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_regex" type="xs:string"/&gt; &lt;xs:attribute name="_flags" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;xs:assert test="exists(@regex | @_regex)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:sort"/&gt; &lt;xs:element ref="xsl:with-param"/&gt; &lt;/xs:choice&gt; &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt; &lt;xs:attribute name="mode" type="xsl:mode"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_mode" type="xs:string"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="array" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="use" type="xsl:expression"/&gt; &lt;xs:attribute name="_use" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="assert" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="test" type="xsl:expression"/&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="error-code" type="xsl:avt"/&gt; &lt;xs:attribute name="_test" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_error-code" type="xs:string"/&gt; &lt;xs:assert test="exists(@test | @_test)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="namespace" type="xsl:avt"/&gt; &lt;xs:attribute name="separator" type="xsl:avt"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_namespace" type="xs:string"/&gt; &lt;xs:attribute name="_separator" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:attribute"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="break" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="catch"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="errors" type="xs:token" use="optional"/&gt; &lt;xs:attribute name="_errors" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="use-character-maps" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="comment" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="context-item"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="as" type="xsl:item-type"/&gt; &lt;xs:attribute name="use"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="required"/&gt; &lt;xs:enumeration value="optional"/&gt; &lt;xs:enumeration value="absent"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_use" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="copy-accumulators" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_copy-accumulators" type="xs:string"/&gt; &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="document" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="decimal-separator" type="xsl:char" default="."/&gt; &lt;xs:attribute name="grouping-separator" type="xsl:char" default=","/&gt; &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt; &lt;xs:attribute name="minus-sign" type="xsl:char" default="-"/&gt; &lt;xs:attribute name="exponent-separator" type="xsl:char" default="e"/&gt; &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt; &lt;xs:attribute name="percent" type="xsl:char" default="%"/&gt; &lt;xs:attribute name="per-mille" type="xsl:char" default="~"/&gt; &lt;xs:attribute name="zero-digit" type="xsl:zero-digit" default="0"/&gt; &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt; &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_decimal-separator" type="xs:string"/&gt; &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt; &lt;xs:attribute name="_infinity" type="xs:string"/&gt; &lt;xs:attribute name="_minus-sign" type="xs:string"/&gt; &lt;xs:attribute name="_exponent-separator" type="xs:string"/&gt; &lt;xs:attribute name="_NaN" type="xs:string"/&gt; &lt;xs:attribute name="_percent" type="xs:string"/&gt; &lt;xs:attribute name="_per-mille" type="xs:string"/&gt; &lt;xs:attribute name="_zero-digit" type="xs:string"/&gt; &lt;xs:attribute name="_digit" type="xs:string"/&gt; &lt;xs:attribute name="_pattern-separator" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType mixed="true"&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="namespace" type="xsl:avt"/&gt; &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_namespace" type="xs:string"/&gt; &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt; &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="evaluate" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:with-param"/&gt; &lt;xs:element ref="xsl:fallback"/&gt; &lt;/xs:choice&gt; &lt;xs:attribute name="xpath" type="xsl:expression"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="base-uri" type="xsl:avt"/&gt; &lt;xs:attribute name="context-item" type="xsl:expression"/&gt; &lt;xs:attribute name="namespace-context" type="xsl:expression"/&gt; &lt;xs:attribute name="schema-aware" type="xsl:avt"/&gt; &lt;xs:attribute name="with-params" type="xsl:expression"/&gt; &lt;xs:attribute name="_xpath" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_base-uri" type="xs:string"/&gt; &lt;xs:attribute name="_context-item" type="xs:string"/&gt; &lt;xs:attribute name="_namespace-context" type="xs:string"/&gt; &lt;xs:attribute name="_schema-aware" type="xs:string"/&gt; &lt;xs:attribute name="_with-params" type="xs:string"/&gt; &lt;xs:assert test="exists(@xpath | @_xpath)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="expose"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:use-package and defines the visibility of components that are made available (or not) by this package to other using packages. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt; &lt;xs:attribute name="names" type="xsl:EQNames"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt; &lt;xs:attribute name="_component" type="xs:string"/&gt; &lt;xs:attribute name="_names" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="fallback" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="group-by" type="xsl:expression"/&gt; &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt; &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt; &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt; &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="collation" type="xsl:avt"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_group-by" type="xs:string"/&gt; &lt;xs:attribute name="_group-adjacent" type="xs:string"/&gt; &lt;xs:attribute name="_group-starting-with" type="xs:string"/&gt; &lt;xs:attribute name="_group-ending-with" type="xs:string"/&gt; &lt;xs:attribute name="_composite" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="count(((@group-by|@_group-by)[1], (@group-adjacent|@_group-adjacent)[1], (@group-starting-with|@_group-starting-with)[1], (@group-ending-with|@_group-ending-with)[1])) = 1"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; These four attributes are mutually exclusive: it is a static error if none of these four attributes is present or if more than one of them is present. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (exists(@collation|@_collation) or exists(@composite|@_composite)) then (exists(@group-by|@_group-by) or exists(@group-adjacent|@_group-adjacent)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is an error to specify the collation attribute or the composite attribute if neither the group-by attribute nor group-adjacent attribute is specified. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="fork" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:choice&gt; &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:sequence"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:for-each-group"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xsl:EQName-in-namespace"/&gt; &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="streamability" type="xsl:streamability-type"/&gt; &lt;xs:attribute name="override-extension-function" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="new-each-time" type="xsl:yes-or-no-or-maybe"/&gt; &lt;xs:attribute name="cache" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_override" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:attribute name="_streamability" type="xs:string"/&gt; &lt;xs:attribute name="_override-extension-function" type="xs:string"/&gt; &lt;xs:attribute name="_identity-sensitive" type="xs:string"/&gt; &lt;xs:attribute name="_cache" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="every $e in xsl:param satisfies (empty($e/(@select | @_select)) and empty($e/child::node()))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a function must have no default value. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a function must have no visibility attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@required | @_required))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a function must have no required attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="global-context-item" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="as" type="xsl:item-type"/&gt; &lt;xs:attribute name="use"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="required"/&gt; &lt;xs:enumeration value="optional"/&gt; &lt;xs:enumeration value="absent"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_use" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="test" type="xsl:expression"/&gt; &lt;xs:attribute name="then" type="xsl:expression"/&gt; &lt;xs:attribute name="else" type="xsl:expression"/&gt; &lt;xs:attribute name="_test" type="xs:string"/&gt; &lt;xs:attribute name="_then" type="xs:string"/&gt; &lt;xs:attribute name="_else" type="xs:string"/&gt; &lt;xs:assert test="exists(@test | @_test)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="import" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="href" type="xs:anyURI"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:assert test="exists(@href | @_href)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt; &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt; &lt;xs:attribute name="_namespace" type="xs:string"/&gt; &lt;xs:attribute name="_schema-location" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@schema-location | @_schema-location) and exists(xs:schema))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; XTSE0215: It is a static error if an xsl:import-schema element that contains an xs:schema element has a schema-location attribute &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="href" type="xs:anyURI"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:assert test="exists(@href | @_href)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="item-type" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="name" type="xs:QName"/&gt; &lt;xs:attribute name="as" type="xsl:item-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:assert test="exists(@href | @_href)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="iterate" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:on-completion" minOccurs="0" maxOccurs="1"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="match" type="xsl:pattern"/&gt; &lt;xs:attribute name="use" type="xsl:expression"/&gt; &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="collation" type="xs:anyURI"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_match" type="xs:string"/&gt; &lt;xs:attribute name="_use" type="xs:string"/&gt; &lt;xs:attribute name="_composite" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="exists(@match | @_match)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="map" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="on-duplicates" type="xsl:expression"/&gt; &lt;xs:attribute name="_on-duplicates" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="map-entry" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt; &lt;xs:attribute name="key" type="xsl:expression"/&gt; &lt;xs:attribute name="_key" type="xs:string"/&gt; &lt;xs:assert test="exists(@key | @_key)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="matching-substring" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="merge" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:merge-source" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:merge-action" minOccurs="1" maxOccurs="1"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="merge-action" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="merge-key" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="lang" type="xsl:avt"/&gt; &lt;xs:attribute name="order" type="xsl:avt"/&gt; &lt;xs:attribute name="collation" type="xs:anyURI"/&gt; &lt;xs:attribute name="case-order" type="xsl:avt"/&gt; &lt;xs:attribute name="data-type" type="xsl:avt"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_lang" type="xs:string"/&gt; &lt;xs:attribute name="_order" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:attribute name="_case-order" type="xs:string"/&gt; &lt;xs:attribute name="_data-type" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="merge-source"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:merge-key" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="name" type="xs:NCName"/&gt; &lt;xs:attribute name="for-each-item" type="xsl:expression"/&gt; &lt;xs:attribute name="for-each-source" type="xsl:expression"/&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt; &lt;xs:attribute name="sort-before-merge" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_for-each-item" type="xs:string"/&gt; &lt;xs:attribute name="_for-each-source" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt; &lt;xs:attribute name="_sort-before-merge" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="exists(@select | @_select)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt; &lt;xs:attribute name="error-code" type="xsl:avt"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_terminate" type="xs:string"/&gt; &lt;xs:attribute name="_error-code" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="mode" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="false"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt; &lt;xs:attribute name="on-no-match" type="xsl:on-no-match-type" default="shallow-skip"/&gt; &lt;xs:attribute name="on-multiple-match" type="xsl:on-multiple-match-type" default="use-last"/&gt; &lt;xs:attribute name="warning-on-no-match" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="warning-on-multiple-match" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="typed" type="xsl:typed-type"/&gt; &lt;xs:attribute name="visibility"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xsl:visibility-type"&gt; &lt;xs:enumeration value="public"/&gt; &lt;xs:enumeration value="private"/&gt; &lt;xs:enumeration value="final"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:attribute&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_on-no-match" type="xs:string"/&gt; &lt;xs:attribute name="_on-multiple-match" type="xs:string"/&gt; &lt;xs:attribute name="_warning-on-no-match" type="xs:string"/&gt; &lt;xs:attribute name="_warning-on-multiple-match" type="xs:string"/&gt; &lt;xs:attribute name="_typed" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default"/&gt; &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default"/&gt; &lt;xs:attribute name="_stylesheet-prefix" type="xs:string"/&gt; &lt;xs:attribute name="_result-prefix" type="xs:string"/&gt; &lt;xs:assert test="exists(@stylesheet-prefix | @_stylesheet-prefix)"/&gt; &lt;xs:assert test="exists(@result-prefix | @_result-prefix)"/&gt; &lt;xs:assert test="every $prefix in (@stylesheet-prefix, @result-prefix) /normalize-space(.)[. ne '#default'] satisfies $prefix = in-scope-prefixes(.)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="next-iteration" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:with-param"/&gt; &lt;xs:element ref="xsl:fallback"/&gt; &lt;/xs:choice&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="note" type="xsl:versioned-element-type" substitutionGroup="xsl:instruction xsl:declaration"/&gt; &lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:attribute name="value" type="xsl:expression"/&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt; &lt;xs:attribute name="count" type="xsl:pattern"/&gt; &lt;xs:attribute name="from" type="xsl:pattern"/&gt; &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt; &lt;xs:attribute name="lang" type="xsl:avt"/&gt; &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt; &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt; &lt;xs:attribute name="start-at" type="xsl:avt"/&gt; &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt; &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt; &lt;xs:attribute name="_value" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;xs:attribute name="_level" type="xs:string"/&gt; &lt;xs:attribute name="_count" type="xs:string"/&gt; &lt;xs:attribute name="_from" type="xs:string"/&gt; &lt;xs:attribute name="_format" type="xs:string"/&gt; &lt;xs:attribute name="_lang" type="xs:string"/&gt; &lt;xs:attribute name="_letter-value" type="xs:string"/&gt; &lt;xs:attribute name="_ordinal" type="xs:string"/&gt; &lt;xs:attribute name="_start-at" type="xs:string"/&gt; &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt; &lt;xs:attribute name="_grouping-size" type="xs:string"/&gt; &lt;xs:assert test="if (exists(@value | @_value)) then empty((@select | @_select, @count | @_count, @from | @_from)) and (exists(@_level) or normalize-space(@level)='single') else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if the value attribute of xsl:number is present unless the select, level, count, and from attributes are all absent. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="on-completion" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="on-empty" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="on-non-empty" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="otherwise" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:generic-element-type"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="method" type="xsl:method"/&gt; &lt;xs:attribute name="allow-duplicate-names" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="build-tree" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="cdata-section-elements" type="xsl:EQNames"/&gt; &lt;xs:attribute name="doctype-public" type="xs:string"/&gt; &lt;xs:attribute name="doctype-system" type="xs:string"/&gt; &lt;xs:attribute name="encoding" type="xs:string"/&gt; &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="html-version" type="xs:decimal"/&gt; &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="item-separator" type="xs:string"/&gt; &lt;xs:attribute name="json-node-output-method" type="xsl:method"/&gt; &lt;xs:attribute name="media-type" type="xs:string"/&gt; &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt; &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="parameter-document" type="xs:anyURI"/&gt; &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt; &lt;xs:attribute name="suppress-indentation" type="xsl:EQNames"/&gt; &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt; &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_method" type="xs:string"/&gt; &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt; &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt; &lt;xs:attribute name="_encoding" type="xs:string"/&gt; &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt; &lt;xs:attribute name="_html-version" type="xs:string"/&gt; &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt; &lt;xs:attribute name="_indent" type="xs:string"/&gt; &lt;xs:attribute name="_item-separator" type="xs:string"/&gt; &lt;xs:attribute name="_media-type" type="xs:string"/&gt; &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt; &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt; &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt; &lt;xs:attribute name="_standalone" type="xs:string"/&gt; &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt; &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt; &lt;xs:attribute name="_version" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="output-character"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="character" type="xsl:char"/&gt; &lt;xs:attribute name="string" type="xs:string"/&gt; &lt;xs:attribute name="_character" type="xs:string"/&gt; &lt;xs:attribute name="_string" type="xs:string"/&gt; &lt;xs:assert test="exists(@character | @_character)"/&gt; &lt;xs:assert test="exists(@string | @_string)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="override"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:use-package and defines any overriding definitions of components that the containing package wishes to make to the components made available from a library package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:template"/&gt; &lt;xs:element ref="xsl:function"/&gt; &lt;xs:element ref="xsl:variable"/&gt; &lt;xs:element ref="xsl:param"/&gt; &lt;xs:element ref="xsl:attribute-set"/&gt; &lt;/xs:choice&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="package"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:expose"/&gt; &lt;xs:element ref="xsl:declaration"/&gt; &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="declared-modes" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="id" type="xs:ID"/&gt; &lt;xs:attribute name="name" type="xs:anyURI"/&gt; &lt;xs:attribute name="package-version" type="xs:string"/&gt; &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"/&gt; &lt;xs:attribute name="_declared-modes" type="xs:string"/&gt; &lt;xs:attribute name="_id" type="xs:string"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_package-version" type="xs:string"/&gt; &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="param" substitutionGroup="xsl:declaration"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Declaration of the xsl:param element, used both defining function parameters, template parameters, parameters to xsl:iterate, and global stylesheet parameters. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_required" type="xs:string"/&gt; &lt;xs:attribute name="_tunnel" type="xs:string"/&gt; &lt;xs:attribute name="_static" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) then empty((*,text())) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; When the attribute static="yes" is specified, the xsl:param element must have empty content. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) satisfies empty($e/(@stable | @_stable))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; It is a static error if an xsl:sort element other than the first in a sequence of sibling xsl:sort elements has a stable attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="elements" type="xsl:nametests"/&gt; &lt;xs:attribute name="_elements" type="xs:string"/&gt; &lt;xs:assert test="exists(@elements | @_elements)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:avt"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="format" type="xsl:avt"/&gt; &lt;xs:attribute name="href" type="xsl:avt"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="method" type="xsl:avt"/&gt; &lt;xs:attribute name="allow-duplicate-names" type="xsl:avt"/&gt; &lt;xs:attribute name="build-tree" type="xsl:avt"/&gt; &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt; &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt; &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt; &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt; &lt;xs:attribute name="encoding" type="xsl:avt"/&gt; &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt; &lt;xs:attribute name="html-version" type="xsl:avt"/&gt; &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt; &lt;xs:attribute name="indent" type="xsl:avt"/&gt; &lt;xs:attribute name="item-separator" type="xsl:avt"/&gt; &lt;xs:attribute name="json-node-output-method" type="xsl:avt"/&gt; &lt;xs:attribute name="media-type" type="xsl:avt"/&gt; &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt; &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt; &lt;xs:attribute name="parameter-document" type="xsl:avt"/&gt; &lt;xs:attribute name="standalone" type="xsl:avt"/&gt; &lt;xs:attribute name="suppress-indentation" type="xsl:avt"/&gt; &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt; &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt; &lt;xs:attribute name="output-version" type="xsl:avt"/&gt; &lt;xs:attribute name="_format" type="xs:string"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:attribute name="_method" type="xs:string"/&gt; &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt; &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt; &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt; &lt;xs:attribute name="_encoding" type="xs:string"/&gt; &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt; &lt;xs:attribute name="_html-version" type="xs:string"/&gt; &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt; &lt;xs:attribute name="_indent" type="xs:string"/&gt; &lt;xs:attribute name="_item-separator" type="xs:string"/&gt; &lt;xs:attribute name="_media-type" type="xs:string"/&gt; &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt; &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt; &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt; &lt;xs:attribute name="_standalone" type="xs:string"/&gt; &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt; &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt; &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt; &lt;xs:attribute name="_output-version" type="xs:string"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="sequence" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor-or-select"/&gt; &lt;xs:element name="sort"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="lang" type="xsl:avt"/&gt; &lt;xs:attribute name="data-type" type="xsl:avt" default="text"/&gt; &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt; &lt;xs:attribute name="case-order" type="xsl:avt"/&gt; &lt;xs:attribute name="collation" type="xsl:avt"/&gt; &lt;xs:attribute name="stable" type="xsl:avt"/&gt; &lt;xs:attribute name="_lang" type="xs:string"/&gt; &lt;xs:attribute name="_data-type" type="xs:string"/&gt; &lt;xs:attribute name="_order" type="xs:string"/&gt; &lt;xs:attribute name="_case-order" type="xs:string"/&gt; &lt;xs:attribute name="_collation" type="xs:string"/&gt; &lt;xs:attribute name="_stable" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="source-document" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:sequence-constructor"&gt; &lt;xs:attribute name="href" type="xsl:avt"/&gt; &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt; &lt;xs:attribute name="type" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt; &lt;xs:attribute name="_href" type="xs:string"/&gt; &lt;xs:attribute name="_streamable" type="xs:string"/&gt; &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt; &lt;xs:attribute name="_type" type="xs:string"/&gt; &lt;xs:attribute name="_validation" type="xs:string"/&gt; &lt;xs:assert test="exists(@href | @_href)"/&gt; &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The type and validation attributes are mutually exclusive (if one is present, the other must be absent). &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="elements" type="xsl:nametests"/&gt; &lt;xs:attribute name="_elements" type="xs:string"/&gt; &lt;xs:assert test="exists(@elements | @_elements)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt; &lt;xs:element name="switch" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt; &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="select" type="xsl:expression"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="1"/&gt; &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="match" type="xsl:pattern"/&gt; &lt;xs:attribute name="priority" type="xs:decimal"/&gt; &lt;xs:attribute name="mode" type="xsl:modes"/&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="_match" type="xs:string"/&gt; &lt;xs:attribute name="_priority" type="xs:string"/&gt; &lt;xs:attribute name="_mode" type="xs:string"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:assert test="exists(@match | @_match) or exists(@name | @_name)"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An xsl:template element must have either a match attribute or a name attribute, or both. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (empty(@match | @_match)) then (empty(@mode | @_mode) and empty(@priority | @_priority)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An xsl:template element that has no match attribute must have no mode attribute and no priority attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="not(exists(@visibility | @_visibility) and empty(@name | @_name))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An xsl:template element that has no name attribute must have no visibility attribute &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (normalize-space(@visibility) = 'abstract') then empty(* except (xsl:context-item, xsl:param)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; If the visibility attribute is present with the value abstract then (a) the sequence constructor defining the template body must be empty: that is, the only permitted children are xsl:context-item and xsl:param &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="not(normalize-space(@visibility) = 'abstract' and exists(@match))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; If the visibility attribute is present with the value abstract then there must be no match attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A parameter for a template must have no visibility attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:complexType name="text-element-base-type"&gt; &lt;xs:simpleContent&gt; &lt;xs:restriction base="xsl:versioned-element-type"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:string"/&gt; &lt;/xs:simpleType&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;xs:complexType name="text-element-type"&gt; &lt;xs:simpleContent&gt; &lt;xs:extension base="xsl:text-element-base-type"&gt; &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:simpleContent&gt; &lt;/xs:complexType&gt; &lt;xs:element name="text" substitutionGroup="xsl:instruction" type="xsl:text-element-type"/&gt; &lt;xs:complexType name="transform-element-base-type"&gt; &lt;xs:complexContent&gt; &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt; &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt; &lt;xs:attribute name="_version" type="xs:string"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The version attribute indicates the version of XSLT that the stylesheet module requires. The attribute is required, unless the xsl:stylesheet element is a child of an xsl:package element, in which case it is optional: the default is then taken from the parent xsl:package element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:attribute&gt; &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt; &lt;/xs:restriction&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;xs:element name="transform"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent&gt; &lt;xs:extension base="xsl:transform-element-base-type"&gt; &lt;xs:sequence&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:declaration"/&gt; &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;!-- weaker than XSLT 1.0 --&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="id" type="xs:ID"/&gt; &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type" default="unspecified"/&gt; &lt;xs:attribute name="_id" type="xs:string"/&gt; &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt; &lt;!--* The 'static' attribute may be used on 'param' and 'variable' * only when they are top-level elements. *--&gt; &lt;xs:assert test="every $v in (.//xsl:param, .//xsl:variable)[exists(@static | @_static)] satisfies $v[parent::xsl:stylesheet or parent::xsl:transform or parent::xsl:override]"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The static attribute must not be present on an xsl:variable or xsl:param element unless it is a top-level element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="every $prefix in (@exclude-result-prefixes[not(. = '#all')], @extension-element-prefixes) satisfies ((if ($prefix = '#default') then '' else $prefix) = in-scope-prefixes(.))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; XTSE0808: It is a static error if a namespace prefix is used within the [xsl:]exclude-result-prefixes attribute and there is no namespace binding in scope for that prefix. &lt;/p&gt; &lt;p&gt; XTSE0809: It is a static error if the value #default is used within the [xsl:]exclude-result-prefixes attribute and the parent element of the [xsl:]exclude-result-prefixes attribute has no default namespace. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="try" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:versioned-element-type"&gt; &lt;xs:sequence&gt; &lt;xs:group ref="xsl:sequence-constructor-group" minOccurs="0" maxOccurs="unbounded"/&gt; &lt;xs:element ref="xsl:catch" minOccurs="1" maxOccurs="1"/&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:catch"/&gt; &lt;xs:element ref="xsl:fallback"/&gt; &lt;/xs:choice&gt; &lt;/xs:sequence&gt; &lt;xs:attribute name="rollback-output" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt; &lt;xs:attribute name="_rollback-output" type="xs:string"/&gt; &lt;xs:attribute name="_select" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="use-package" substitutionGroup="xsl:declaration"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This element appears as a child of xsl:package and defines a dependency of the containing package on another package, identified by URI in the name attribute. The package-version attribute indicates which version of the library package is required, or may indicate a range of versions. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="false"&gt; &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt; &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt; &lt;xs:element ref="xsl:accept"/&gt; &lt;xs:element ref="xsl:override"/&gt; &lt;/xs:choice&gt; &lt;xs:attribute name="name" type="xs:anyURI"/&gt; &lt;xs:attribute name="package-version" type="xs:string"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_package-version" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="separator" type="xsl:avt"/&gt; &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt; &lt;xs:attribute name="_separator" type="xs:string"/&gt; &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="variable" substitutionGroup="xsl:declaration xsl:instruction"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Declaration of the xsl:variable element, used both for local and global variable bindings. &lt;/p&gt; &lt;p&gt; This definition takes advantage of the ability in XSD 1.1 for an element to belong to more than one substitution group. A global variable is a declaration, while a local variable can appear as an instruction in a sequence constructor. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt; &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_visibility" type="xs:string"/&gt; &lt;xs:attribute name="_static" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) then (exists(@_visibility) or normalize-space(@visibility) = ('', 'private', 'final')) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; When the static attribute is present with the value yes, the visibility attribute must not have a value other than private or final. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) then (empty((*, text())) and exists(@select | @_select)) else true()"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; When the attribute static="yes" is specified, the xsl:variable element must have empty content, and the select attribute must be present to define the value of the variable. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assert&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="when"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="test" type="xsl:expression"/&gt; &lt;xs:attribute name="_test" type="xs:string"/&gt; &lt;xs:assert test="exists(@test | @_test)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;xs:element name="where-populated" substitutionGroup="xsl:instruction" type="xsl:sequence-constructor"/&gt; &lt;xs:element name="with-param"&gt; &lt;xs:complexType&gt; &lt;xs:complexContent mixed="true"&gt; &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt; &lt;xs:attribute name="name" type="xsl:EQName"/&gt; &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt; &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="_name" type="xs:string"/&gt; &lt;xs:attribute name="_as" type="xs:string"/&gt; &lt;xs:attribute name="_tunnel" type="xs:string"/&gt; &lt;xs:assert test="exists(@name | @_name)"/&gt; &lt;/xs:extension&gt; &lt;/xs:complexContent&gt; &lt;/xs:complexType&gt; &lt;/xs:element&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART C: definition of literal result elements There are three ways to define the literal result elements permissible in a stylesheet. (a) do nothing. This allows any element to be used as a literal result element, provided it is not in the XSLT namespace (b) declare all permitted literal result elements as members of the xsl:literal-result-element substitution group (c) redefine the model group xsl:result-elements to accommodate all permitted literal result elements. Literal result elements are allowed to take certain attributes in the XSLT namespace. These are defined in the attribute group literal-result-element-attributes, which can be included in the definition of any literal result element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt; &lt;xs:attributeGroup name="literal-result-element-attributes"&gt; &lt;xs:attribute name="default-collation" form="qualified" type="xsl:uri-list"/&gt; &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt; &lt;xs:attribute name="default-validation" type="xsl:validation-strip-or-preserve" default="strip"/&gt; &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt; &lt;xs:attribute name="extension-element-prefixes" form="qualified" type="xsl:prefixes"/&gt; &lt;xs:attribute name="exclude-result-prefixes" form="qualified" type="xsl:prefixes"/&gt; &lt;xs:attribute name="xpath-default-namespace" form="qualified" type="xs:anyURI"/&gt; &lt;xs:attribute name="inherit-namespaces" form="qualified" type="xsl:yes-or-no" default="yes"/&gt; &lt;xs:attribute name="use-attribute-sets" form="qualified" type="xsl:EQNames" default=""/&gt; &lt;xs:attribute name="use-when" form="qualified" type="xsl:expression"/&gt; &lt;xs:attribute name="version" form="qualified" type="xs:decimal"/&gt; &lt;xs:attribute name="type" form="qualified" type="xsl:EQName"/&gt; &lt;xs:attribute name="validation" form="qualified" type="xsl:validation-type"/&gt; &lt;/xs:attributeGroup&gt; &lt;xs:group name="result-elements"&gt; &lt;xs:choice&gt; &lt;xs:element ref="xsl:literal-result-element"/&gt; &lt;xs:any namespace="##other" processContents="lax"/&gt; &lt;xs:any namespace="##local" processContents="lax"/&gt; &lt;/xs:choice&gt; &lt;/xs:group&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; PART D: definitions of simple types used in stylesheet attributes &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt; &lt;xs:simpleType name="accumulator-names"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The use-accumulators attribute of xsl:source-document, xsl:merge-source, or xsl:global-context-item: either a list, each member being a QName; or the value #all &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union&gt; &lt;xs:simpleType&gt; &lt;xs:list itemType="xsl:EQName"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#all"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="avt"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; This type is used for all attributes that allow an attribute value template. The general rules for the syntax of attribute value templates, and the specific rules for each such attribute, are described in the XSLT 2.1 Recommendation. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:string"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="char"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A string containing exactly one character. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:string"&gt; &lt;xs:length value="1"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="component-kind-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes a kind of component within a package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="template"/&gt; &lt;xs:enumeration value="function"/&gt; &lt;xs:enumeration value="variable"/&gt; &lt;xs:enumeration value="attribute-set"/&gt; &lt;xs:enumeration value="mode"/&gt; &lt;xs:enumeration value="*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="default-mode-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The default-mode attribute of xsl:stylesheet, xsl:transform, xsl:package (or any other xsl:* element): either a QName or #unnamed. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#unnamed"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="expression"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An XPath 2.0 expression. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value=".+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="item-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An XPath ItemType &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value=".+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="input-type-annotations-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes how type annotations in source documents are handled. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="preserve"/&gt; &lt;xs:enumeration value="strip"/&gt; &lt;xs:enumeration value="unspecified"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="level"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The level attribute of xsl:number: one of single, multiple, or any. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="single"/&gt; &lt;xs:enumeration value="multiple"/&gt; &lt;xs:enumeration value="any"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="mode"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The mode attribute of xsl:apply-templates: either a QName, or #current, or #unnamed, or #default. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#default"/&gt; &lt;xs:enumeration value="#unnamed"/&gt; &lt;xs:enumeration value="#current"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="modes"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The mode attribute of xsl:template: either a list, each member being either a QName or #default or #unnamed; or the value #all &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union&gt; &lt;xs:simpleType&gt; &lt;xs:restriction&gt; &lt;xs:simpleType&gt; &lt;xs:list&gt; &lt;xs:simpleType&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#default"/&gt; &lt;xs:enumeration value="#unnamed"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;/xs:list&gt; &lt;/xs:simpleType&gt; &lt;xs:assertion test="count($value) = count(distinct-values($value))"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; XTSE0550: It is a static error if the same token is included more than once in the list. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;/xs:assertion&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#all"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="nametests"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A list of NameTests, as defined in the XPath 2.0 Recommendation. Each NameTest is either a QName, or "*", or "prefix:*", or "*:localname" &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:list&gt; &lt;xs:simpleType&gt; &lt;xs:union memberTypes="xsl:EQName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value="\i\c*:\*"/&gt; &lt;xs:pattern value="\*:\i\c*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;/xs:list&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="on-multiple-match-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the action to be taken when there are several template rules to match an item in a given mode. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="use-last"/&gt; &lt;xs:enumeration value="fail"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="on-no-match-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the action to be taken when there is no template rule to match an item in a given mode. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="deep-copy"/&gt; &lt;xs:enumeration value="shallow-copy"/&gt; &lt;xs:enumeration value="deep-skip"/&gt; &lt;xs:enumeration value="shallow-skip"/&gt; &lt;xs:enumeration value="text-only-copy"/&gt; &lt;xs:enumeration value="fail"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefixes"&gt; &lt;xs:list itemType="xs:NCName"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefix-list-or-all"&gt; &lt;xs:union memberTypes="xsl:prefix-list"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#all"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefix-list"&gt; &lt;xs:list itemType="xsl:prefix-or-default"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="method"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The method attribute of xsl:output: Either one of the recognized names "xml", "xhtml", "html", "text", or a QName that must include a prefix. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="xml"/&gt; &lt;xs:enumeration value="xhtml"/&gt; &lt;xs:enumeration value="html"/&gt; &lt;xs:enumeration value="text"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xsl:EQName"&gt; &lt;xs:pattern value="\c*:\c*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="pattern"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A match pattern as defined in the XSLT 2.1 Recommendation. The syntax for patterns is a restricted form of the syntax for XPath 2.0 expressions. Change since XSLT 2.0: Patterns may now match any item (not only nodes) &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:expression"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="prefix-or-default"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Either a namespace prefix, or #default. Used in the xsl:namespace-alias element. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xs:NCName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="#default"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="EQNames"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A list of QNames. Used in the [xsl:]use-attribute-sets attribute of various elements, and in the cdata-section-elements attribute of xsl:output &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:list itemType="xsl:EQName"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="EQName"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; An extended QName. This schema does not use the built-in type xs:QName, but rather defines its own QName type. This may be either a local name, or a prefixed QName, or a name written using the extended QName notation Q{uri}local &lt;/p&gt; &lt;p&gt; Although xs:QName would define the correct validation on these attributes, a schema processor would expand unprefixed QNames incorrectly when constructing the PSVI, because (as defined in XML Schema errata) an unprefixed xs:QName is assumed to be in the default namespace, which is not the correct assumption for XSLT. The datatype is therefore defined as a union of NCName and QName, so that an unprefixed name will be validated as an NCName and will therefore not be treated as having the semantics of an unprefixed xs:QName. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xs:NCName xs:QName"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value="Q\{[^{}]*\}[\i-[:]][\c-[:]]*"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="EQName-in-namespace"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A subtype of EQNames that excludes no-namespace names &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:EQName"&gt; &lt;xs:pattern value="Q\{.+\}.+|\i\c*:.+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="sequence-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; The description of a datatype, conforming to the SequenceType production defined in the XPath 2.0 Recommendation &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:pattern value=".+"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="streamability-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the category to which a function belongs, with regards to its streaming behavior. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt; &lt;xs:simpleType&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="unclassified"/&gt; &lt;xs:enumeration value="absorbing"/&gt; &lt;xs:enumeration value="inspection"/&gt; &lt;xs:enumeration value="filter"/&gt; &lt;xs:enumeration value="shallow-descent"/&gt; &lt;xs:enumeration value="deep-descent"/&gt; &lt;xs:enumeration value="ascent"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:union&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="typed-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes whether a mode is designed to match typed or untyped nodes. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;xs:enumeration value="strict"/&gt; &lt;xs:enumeration value="lax"/&gt; &lt;xs:enumeration value="unspecified"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="uri-list"&gt; &lt;xs:list itemType="xs:anyURI"/&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="validation-strip-or-preserve"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes different ways of type-annotating an element or attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:validation-type"&gt; &lt;xs:enumeration value="preserve"/&gt; &lt;xs:enumeration value="strip"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="validation-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes different ways of type-annotating an element or attribute. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="strict"/&gt; &lt;xs:enumeration value="lax"/&gt; &lt;xs:enumeration value="preserve"/&gt; &lt;xs:enumeration value="strip"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="visibility-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the visibility of a component within a package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="public"/&gt; &lt;xs:enumeration value="private"/&gt; &lt;xs:enumeration value="final"/&gt; &lt;xs:enumeration value="abstract"/&gt; &lt;xs:enumeration value="hidden"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="visibility-not-hidden-type"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; Describes the visibility of a component within a package. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:visibility-type"&gt; &lt;xs:enumeration value="public"/&gt; &lt;xs:enumeration value="private"/&gt; &lt;xs:enumeration value="final"/&gt; &lt;xs:enumeration value="abstract"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="yes-or-no"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; One of the values "yes" or "no": the values "true" or "false", or "1" or "0" are accepted as synonyms. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="yes-or-no-or-maybe"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; One of the values "yes" or "no" or "maybe". The values "true" or "false", or "1" or "0" are accepted as synonyms of "yes" and "no" respectively. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;xs:enumeration value="maybe"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="yes-or-no-or-omit"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; One of the values "yes" or "no" or "omit". The values "true" or "false", or "1" or "0" are accepted as synonyms of "yes" and "no" respectively. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xs:token"&gt; &lt;xs:enumeration value="yes"/&gt; &lt;xs:enumeration value="no"/&gt; &lt;xs:enumeration value="true"/&gt; &lt;xs:enumeration value="false"/&gt; &lt;xs:enumeration value="1"/&gt; &lt;xs:enumeration value="0"/&gt; &lt;xs:enumeration value="omit"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;xs:simpleType name="zero-digit"&gt; &lt;xs:annotation&gt; &lt;xs:documentation&gt; &lt;p&gt; A digit that has the numerical value zero. &lt;/p&gt; &lt;/xs:documentation&gt; &lt;/xs:annotation&gt; &lt;xs:restriction base="xsl:char"&gt; &lt;xs:pattern value="\p{Nd}"/&gt; &lt;xs:assertion test="matches(string-join(codepoints-to-string( for $i in 0 to 9 return string-to-codepoints($value) + $i), ''), '\p{Nd}{10}')"/&gt; &lt;/xs:restriction&gt; &lt;/xs:simpleType&gt; &lt;/xs:schema&gt; </span></pre></div><div class="div2"><h3><a id="relax-ng-schema-for-xslt"></a>H.2 <a href="#relax-ng-schema-for-xslt" style="text-decoration: none">Relax-NG Schema for XSLT Stylesheets</a></h3><p>The following Relax-NG schema may be used to validate XSLT <span class="deltaxml-old" style="background:#FF5555">3.0</span><span class="deltaxml-new" style="background:#90EE90">4.0</span> stylesheet modules. Similar caveats apply as for the XSD 1.1 version.</p><p>A copy of this schema is available at <a href="schema-for-xslt30.rnc">schema-for-xslt30.rnc</a></p><p><span class="deltaxml-new" style="background:#90EE90">TODO: Needs updating for 4.0.</span></p><pre class="font-size: small"># XSLT 3.0 Relax NG Schema # # Copyright (c) 2010-2016, Mohamed ZERGAOUI (Innovimax) # # All rights reserved. # # Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: # Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer. # Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution. # Neither the name of the Mohamed ZERGAOUI or Innovimax nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission. # # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS # FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, # STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. # namespace local = "" default namespace xsl = "http://www.w3.org/1999/XSL/Transform" namespace xs = "http://www.w3.org/2001/XMLSchema" start = stylesheet.element | transform.element | package.element | literal-result-element-as-stylesheet sequence-constructor.model = (instruction.category | literal-result-element | text)* literal-result-element-as-stylesheet = element * - xsl:* { attribute xsl:version { decimal.datatype }, literal-result-element-no-version.atts, sequence-constructor.model } literal-result-element = element * - xsl:* { literal-result-element.atts, sequence-constructor.model } literal-result-element.atts = literal-result-element-no-version.atts, attribute xsl:version { text }? # These attributes may also appear on a literal result element, but in this case, to distinguish them from user-defined attributes, # the names of the attributes are in the XSLT namespace. They are thus typically written as # xsl:default-collation, # xsl:default-mode, # xsl:default-validation, # xsl:exclude-result-prefixes, # xsl:expand-text, # xsl:extension-element-prefixes, # xsl:use-when, # xsl:version, # or xsl:xpath-default-namespace. literal-result-element-no-version.atts = attribute * - xsl:* { avt.datatype }* &amp; attribute xsl:default-collation { uris.datatype }? &amp; attribute xsl:default-mode { eqname.datatype | '#unnamed' }? &amp; attribute xsl:default-validation { "preserve" | "strip" }? &amp; attribute xsl:exclude-result-prefixes { exclude.prefixes.datatype }? # or prefixes.datatype ? &amp; attribute xsl:expand-text { boolean.datatype }? &amp; attribute xsl:extension-element-prefixes { extension.prefixes.datatype }? # or prefixes.datatype ? &amp; attribute xsl:inherit-namespaces { boolean.datatype }? &amp; attribute xsl:on-empty { expression.datatype }? &amp; attribute xsl:use-attribute-sets { eqnames.datatype }? &amp; attribute xsl:use-when { expression.datatype }? &amp; attribute xsl:xpath-default-namespace { xsd:anyURI }? &amp; (attribute xsl:type { eqname.datatype } | attribute xsl:validation { "strict" | "lax" | "preserve" | "strip" })? top-level-extension = element * - (xsl:* | local:*) { anyElement } anyElement = grammar { start = any any = (attribute * { text } | text | element * { any })* } extension.atts = attribute * - (xsl:* | local:*) { text }* declarations.model = (declaration.category | top-level-extension)* # [Definition: There are a number of standard attributes that may appear on any XSLT element: specifically # default-collation, # default-mode, # default-validation, # exclude-result-prefixes, # expand-text, # extension-element-prefixes, # use-when, # version, # and xpath-default-namespace.] global.atts = attribute default-collation { uris.datatype }?, attribute _default-collation { avt.datatype }?, attribute default-mode { eqname.datatype | '#unnamed' }?, attribute _default-mode { avt.datatype }?, attribute default-validation { "preserve" | "strip" }?, attribute _default-validation { avt.datatype }?, attribute exclude-result-prefixes { exclude.prefixes.datatype }?, attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ? attribute expand-text { boolean.datatype }?, attribute _expand-text { avt.datatype }?, attribute extension-element-prefixes { extension.prefixes.datatype }?, attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ? attribute use-when { expression.datatype }?, attribute _use-when { avt.datatype }?, attribute version { decimal.datatype }?, attribute _version { avt.datatype }?, attribute xpath-default-namespace { uri.datatype }?, attribute _xpath-default-namespace { avt.datatype }? global.atts.except.version = attribute default-collation { uris.datatype }?, attribute _default-collation { avt.datatype }?, attribute exclude-result-prefixes { exclude.prefixes.datatype }?, attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ? attribute expand-text { boolean.datatype }?, attribute _expand-text { avt.datatype }?, attribute extension-element-prefixes { extension.prefixes.datatype }?, attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ? attribute use-when { expression.datatype }?, attribute _use-when { avt.datatype }?, attribute xpath-default-namespace { uri.datatype }?, attribute _xpath-default-namespace { avt.datatype }? qname.datatype = xsd:QName # Extract from XPath 3.0 #[94] EQName ::= QName | URIQualifiedName #[104] QName ::= [http://www.w3.org/TR/REC-xml-names/#NT-QName]Names #[105] NCName ::= [http://www.w3.org/TR/REC-xml-names/#NT-NCName]Names #[99] URIQualifiedName ::= BracedURILiteral NCName #[100] BracedURILiteral ::= "Q" "{" [^{}]* "}" uri.qualified.name = xsd:token { pattern = "Q\{[^\{\}]*\}[\i-[:]][\c-[:]]*" } qname.strict = xsd:token { pattern = "[\i-[:]][\c-[:]]:[\i-[:]][\c-[:]]" } eqname.datatype = xsd:QName | uri.qualified.name | qname.strict qnames.datatype = list { qname.datatype* } eqnames.datatype = list { eqname.datatype* } ncname.datatype = xsd:NCName prefix.datatype = xsd:NCName boolean.datatype = "yes" | "no" | "true" | "false" | "0" | "1" expression.datatype = text char.datatype = xsd:string { length = "1" } string.datatype = text id.datatype = xsd:NCName tokens.datatype = list { token* } prefixes.datatype = list { token* } extension.prefixes.datatype = list { xsd:NCName* } exclude.prefixes.datatype = list { "#all" | (xsd:NCName | "#default")* } token.datatype = token language.datatype = xsd:language nmtoken.datatype = xsd:NMTOKEN decimal.datatype = xsd:decimal integer.datatype = xsd:integer uri.datatype = xsd:anyURI uris.datatype = list { xsd:anyURI* } pattern.datatype = text qname-but-not-ncname.datatype = xsd:QName { pattern = ".*:.*" } xs_schema.element = element xs:schema { anyElement* } item-type.datatype = text sequence-type.datatype = text declaration.category = use-package.element | include.element | import.element | import-schema.element | strip-space.element | preserve-space.element | decimal-format.element | template.element | mode.element | global-context-item.element | variable.element | param.element | attribute-set.element | function.element | namespace-alias.element | accumulator.element | key.element | output.element | character-map.element instruction.category = apply-templates.element | apply-imports.element | next-match.element | for-each.element | iterate.element | next-iteration.element | break.element | if.element | choose.element | try.element | variable.element | call-template.element | evaluate.element | element.element | attribute.element | text.element | value-of.element | document.element | processing-instruction.element | namespace.element | comment.element | copy.element | copy-of.element | sequence.element | where-populated.element | on-empty.element | on-non-empty.element | number.element | perform-sort.element | for-each-group.element | merge.element | fork.element | analyze-string.element | source-document.element | map.element | map-entry.element | message.element | assert.element | fallback.element | result-document.element package.element = element package { extension.atts, attribute id { id.datatype }?, attribute _id { avt.datatype }?, attribute name { uri.datatype }?, attribute _name { avt.datatype }?, attribute package-version { string.datatype }?, attribute _package-version { avt.datatype }?, attribute version { decimal.datatype }?, attribute _version { avt.datatype }?, attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?, attribute _input-type-annotations { avt.datatype }?, attribute declared-modes { boolean.datatype }?, attribute _declared-modes { avt.datatype }?, attribute default-mode { eqname.datatype | "#unnamed" }?, attribute _default-mode { avt.datatype }?, attribute default-validation { "preserve" | "strip" }?, attribute _default-validation { avt.datatype }?, attribute default-collation { uris.datatype }?, attribute _default-collation { avt.datatype }?, attribute extension-element-prefixes { prefixes.datatype }?, attribute _extension-element-prefixes { avt.datatype }?, attribute exclude-result-prefixes { prefixes.datatype }?, attribute _exclude-result-prefixes { avt.datatype }?, attribute expand-text { boolean.datatype }?, attribute _expand-text { avt.datatype }?, attribute use-when { expression.datatype }?, attribute _use-when { avt.datatype }?, attribute xpath-default-namespace { uri.datatype }?, attribute _xpath-default-namespace { avt.datatype }?, ((expose.element | declarations.model)*) } use-package.element = element use-package { extension.atts, global.atts, attribute name { uri.datatype }?, attribute _name { avt.datatype }?, attribute package-version { string.datatype }?, attribute _package-version { avt.datatype }?, (accept.element | override.element)* } expose.element = element expose { extension.atts, global.atts, attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" }?, attribute _component { avt.datatype }?, attribute names { tokens.datatype }?, attribute _names { avt.datatype }?, attribute visibility { "public" | "private" | "final" | "abstract" }?, attribute _visibility { avt.datatype }?, empty } accept.element = element accept { extension.atts, global.atts, (attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" } | attribute _component { avt.datatype })+, (attribute names { tokens.datatype } | attribute _names { avt.datatype })+, (attribute visibility { "public" | "private" | "final" | "abstract" | "hidden" } | attribute _visibility { avt.datatype })+, empty } override.element = element override { extension.atts, global.atts, (template.element | function.element | variable.element | param.element | attribute-set.element)* } stylesheet.element = element stylesheet { extension.atts, attribute id { id.datatype }?, attribute _id { avt.datatype }?, attribute version { decimal.datatype }?, attribute _version { avt.datatype }?, attribute default-mode { eqname.datatype | "#unnamed" }?, attribute _default-mode { avt.datatype }?, attribute default-validation { "preserve" | "strip" }?, attribute _default-validation { avt.datatype }?, attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?, attribute _input-type-annotations { avt.datatype }?, attribute default-collation { uris.datatype }?, attribute _default-collation { avt.datatype }?, attribute extension-element-prefixes { prefixes.datatype }?, attribute _extension-element-prefixes { avt.datatype }?, attribute exclude-result-prefixes { prefixes.datatype }?, attribute _exclude-result-prefixes { avt.datatype }?, attribute expand-text { boolean.datatype }?, attribute _expand-text { avt.datatype }?, attribute use-when { expression.datatype }?, attribute _use-when { avt.datatype }?, attribute xpath-default-namespace { uri.datatype }?, attribute _xpath-default-namespace { avt.datatype }?, (declarations.model) } transform.element = element transform { extension.atts, attribute id { id.datatype }?, attribute _id { avt.datatype }?, attribute version { decimal.datatype }?, attribute _version { avt.datatype }?, attribute default-mode { eqname.datatype | "#unnamed" }?, attribute _default-mode { avt.datatype }?, attribute default-validation { "preserve" | "strip" }?, attribute _default-validation { avt.datatype }?, attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?, attribute _input-type-annotations { avt.datatype }?, attribute default-collation { uris.datatype }?, attribute _default-collation { avt.datatype }?, attribute extension-element-prefixes { prefixes.datatype }?, attribute _extension-element-prefixes { avt.datatype }?, attribute exclude-result-prefixes { prefixes.datatype }?, attribute _exclude-result-prefixes { avt.datatype }?, attribute expand-text { boolean.datatype }?, attribute _expand-text { avt.datatype }?, attribute use-when { expression.datatype }?, attribute _use-when { avt.datatype }?, attribute xpath-default-namespace { uri.datatype }?, attribute _xpath-default-namespace { avt.datatype }?, (declarations.model) } include.element = element include { extension.atts, global.atts, attribute href { uri.datatype }?, attribute _href { avt.datatype }?, empty } import.element = element import { extension.atts, global.atts, (attribute href { uri.datatype } | attribute _href { avt.datatype })+, empty } import-schema.element = element import-schema { extension.atts, global.atts, attribute namespace { uri.datatype }?, attribute _namespace { avt.datatype }?, attribute schema-location { uri.datatype }?, attribute _schema-location { avt.datatype }?, xs_schema.element? } strip-space.element = element strip-space { extension.atts, global.atts, (attribute elements { tokens.datatype } | attribute _elements { avt.datatype })+, empty } preserve-space.element = element preserve-space { extension.atts, global.atts, (attribute elements { tokens.datatype } | attribute _elements { avt.datatype })+, empty } decimal-format.element = element decimal-format { extension.atts, global.atts, attribute name { eqname.datatype }?, attribute _name { avt.datatype }?, attribute decimal-separator { char.datatype }?, attribute _decimal-separator { avt.datatype }?, attribute grouping-separator { char.datatype }?, attribute _grouping-separator { avt.datatype }?, attribute infinity { string.datatype }?, attribute _infinity { avt.datatype }?, attribute minus-sign { char.datatype }?, attribute _minus-sign { avt.datatype }?, attribute exponent-separator { char.datatype }?, attribute _exponent-separator { avt.datatype }?, attribute NaN { string.datatype }?, attribute _NaN { avt.datatype }?, attribute percent { char.datatype }?, attribute _percent { avt.datatype }?, attribute per-mille { char.datatype }?, attribute _per-mille { avt.datatype }?, attribute zero-digit { char.datatype }?, attribute _zero-digit { avt.datatype }?, attribute digit { char.datatype }?, attribute _digit { avt.datatype }?, attribute pattern-separator { char.datatype }?, attribute _pattern-separator { avt.datatype }?, empty } template.element = element template { extension.atts, global.atts, (attribute match { pattern.datatype } | attribute _match { avt.datatype } | attribute name { eqname.datatype } | attribute _name { avt.datatype })+, attribute priority { decimal.datatype }?, attribute _priority { avt.datatype }?, attribute mode { list { '#all' | ('#default' | '#unnamed' | eqname.datatype)* } }?, attribute _mode { avt.datatype }?, attribute as { sequence-type.datatype }?, attribute _as { avt.datatype }?, attribute visibility { "public" | "private" | "final" | "abstract" }?, attribute _visibility { avt.datatype }?, (context-item.element?, param.element*, sequence-constructor.model) } apply-templates.element = element apply-templates { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute mode { (eqname.datatype | '#unnamed' | '#default' | '#current') }?, attribute _mode { avt.datatype }?, (sort.element | with-param.element)* } mode.element = element mode { extension.atts, global.atts, attribute name { eqname.datatype }?, attribute _name { avt.datatype }?, attribute streamable { boolean.datatype }?, attribute _streamable { avt.datatype }?, attribute on-no-match { "deep-copy" | "shallow-copy" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail" }?, attribute _on-no-match { avt.datatype }?, attribute on-multiple-match { "use-last" | "fail" }?, attribute _on-multiple-match { avt.datatype }?, attribute warning-on-no-match { boolean.datatype }?, attribute _warning-on-no-match { avt.datatype }?, attribute warning-on-multiple-match { boolean.datatype }?, attribute _warning-on-multiple-match { avt.datatype }?, attribute typed { boolean.datatype | "strict" | "lax" | "unspecified" }?, attribute _typed { avt.datatype }?, attribute visibility { "public" | "private" | "final" }?, attribute _visibility { avt.datatype }?, attribute use-accumulators { tokens.datatype }?, attribute _use-accumulators { avt.datatype }?, empty } context-item.element = element context-item { extension.atts, global.atts, attribute as { item-type.datatype }?, attribute _as { avt.datatype }?, attribute use { "required" | "optional" | "absent" }?, attribute _use { avt.datatype }?, empty } global-context-item.element = element global-context-item { extension.atts, global.atts, attribute as { item-type.datatype }?, attribute _as { avt.datatype }?, attribute use { "required" | "optional" | "absent" }?, attribute _use { avt.datatype }?, empty } apply-imports.element = element apply-imports { extension.atts, global.atts, with-param.element* } next-match.element = element next-match { extension.atts, global.atts, (with-param.element | fallback.element)* } for-each.element = element for-each { extension.atts, global.atts, (attribute select { expression.datatype } | attribute _select { avt.datatype })+, (sort.element*, sequence-constructor.model) } iterate.element = element iterate { extension.atts, global.atts, (attribute select { expression.datatype } | attribute _select { avt.datatype })+, (param.element*, on-completion.element?, sequence-constructor.model) } next-iteration.element = element next-iteration { extension.atts, global.atts, (with-param.element*) } break.element = element break { extension.atts, global.atts, (attribute select { expression.datatype } | attribute _select { avt.datatype })?, sequence-constructor.model } on-completion.element = element on-completion { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } if.element = element if { extension.atts, global.atts, (attribute test { expression.datatype } | attribute _test { avt.datatype })+, sequence-constructor.model } choose.element = element choose { extension.atts, global.atts, (when.element+, otherwise.element?) } when.element = element when { extension.atts, global.atts, (attribute test { expression.datatype } | attribute _test { avt.datatype })+, sequence-constructor.model } otherwise.element = element otherwise { extension.atts, global.atts, sequence-constructor.model } try.element = element try { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute rollback-output { boolean.datatype }?, attribute _rollback-output { avt.datatype }?, (sequence-constructor.model, catch.element, (catch.element | fallback.element)*) } catch.element = element catch { extension.atts, global.atts, attribute errors { tokens.datatype }?, attribute _errors { avt.datatype }?, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } variable.element = element variable { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute as { sequence-type.datatype }?, attribute _as { avt.datatype }?, attribute static { boolean.datatype }?, attribute _static { avt.datatype }?, attribute visibility { "public" | "private" | "final" | "abstract" }?, attribute _visibility { avt.datatype }?, sequence-constructor.model } param.element = element param { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute as { sequence-type.datatype }?, attribute _as { avt.datatype }?, attribute required { boolean.datatype }?, attribute _required { avt.datatype }?, attribute tunnel { boolean.datatype }?, attribute _tunnel { avt.datatype }?, attribute static { boolean.datatype }?, attribute _static { avt.datatype }?, sequence-constructor.model } with-param.element = element with-param { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute as { sequence-type.datatype }?, attribute _as { avt.datatype }?, attribute tunnel { boolean.datatype }?, attribute _tunnel { avt.datatype }?, sequence-constructor.model } call-template.element = element call-template { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, with-param.element* } attribute-set.element = element attribute-set { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, attribute use-attribute-sets { eqnames.datatype }?, attribute _use-attribute-sets { avt.datatype }?, attribute visibility { "public" | "private" | "final" | "abstract" }?, attribute _visibility { avt.datatype }?, attribute streamable { boolean.datatype }?, attribute _streamable { avt.datatype }?, attribute.element* } function.element = element function { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, attribute as { sequence-type.datatype }?, attribute _as { avt.datatype }?, attribute visibility { "public" | "private" | "final" | "abstract" }?, attribute _visibility { avt.datatype }?, attribute streamability { "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | eqname.datatype }?, attribute _streamability { avt.datatype }?, attribute override-extension-function { boolean.datatype }?, attribute _override-extension-function { avt.datatype }?, attribute override { boolean.datatype }?, attribute _override { avt.datatype }?, attribute new-each-time { "yes" | "true" | "1" | "no" | "false" | "0" | "maybe" }?, attribute _new-each-time { avt.datatype }?, attribute cache { boolean.datatype }?, attribute _cache { avt.datatype }?, (param.element*, sequence-constructor.model) } evaluate.element = element evaluate { extension.atts, global.atts, (attribute xpath { expression.datatype } | attribute _xpath { avt.datatype })+, attribute as { sequence-type.datatype }?, attribute _as { avt.datatype }?, attribute base-uri { uri.datatype | avt.datatype }?, attribute _base-uri { avt.datatype }?, attribute with-params { expression.datatype }?, attribute _with-params { avt.datatype }?, attribute context-item { expression.datatype }?, attribute _context-item { avt.datatype }?, attribute namespace-context { expression.datatype }?, attribute _namespace-context { avt.datatype }?, attribute schema-aware { boolean.datatype | avt.datatype }?, attribute _schema-aware { avt.datatype }?, (with-param.element | fallback.element)* } namespace-alias.element = element namespace-alias { extension.atts, global.atts, (attribute stylesheet-prefix { prefix.datatype | "#default" } | attribute _stylesheet-prefix { avt.datatype })+, (attribute result-prefix { prefix.datatype | "#default" } | attribute _result-prefix { avt.datatype })+, empty } element.element = element element { extension.atts, global.atts, (attribute name { qname.datatype | avt.datatype } | attribute _name { avt.datatype })+, attribute namespace { uri.datatype | avt.datatype }?, attribute _namespace { avt.datatype }?, attribute inherit-namespaces { boolean.datatype }?, attribute _inherit-namespaces { avt.datatype }?, attribute use-attribute-sets { eqnames.datatype }?, attribute _use-attribute-sets { avt.datatype }?, ((attribute type { eqname.datatype }?, attribute _type { avt.datatype }?) | (attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive sequence-constructor.model } attribute.element = element attribute { extension.atts, global.atts, (attribute name { qname.datatype | avt.datatype } | attribute _name { avt.datatype })+, attribute namespace { uri.datatype | avt.datatype }?, attribute _namespace { avt.datatype }?, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute separator { string.datatype | avt.datatype }?, attribute _separator { avt.datatype }?, ((attribute type { eqname.datatype }?, attribute _type { avt.datatype }?) | (attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive sequence-constructor.model } text.element = element text { extension.atts, global.atts, attribute disable-output-escaping { boolean.datatype }?, attribute _disable-output-escaping { avt.datatype }?, text } value-of.element = element value-of { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute separator { string.datatype | avt.datatype }?, attribute _separator { avt.datatype }?, attribute disable-output-escaping { boolean.datatype }?, attribute _disable-output-escaping { avt.datatype }?, sequence-constructor.model } document.element = element document { extension.atts, global.atts, ((attribute type { eqname.datatype }?, attribute _type { avt.datatype }?) | (attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive sequence-constructor.model } processing-instruction.element = element processing-instruction { extension.atts, global.atts, (attribute name { ncname.datatype | avt.datatype } | attribute _name { avt.datatype })+, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } namespace.element = element namespace { extension.atts, global.atts, (attribute name { ncname.datatype | avt.datatype } | attribute _name { avt.datatype })+, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } comment.element = element comment { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } copy.element = element copy { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute copy-namespaces { boolean.datatype }?, attribute _copy-namespaces { avt.datatype }?, attribute inherit-namespaces { boolean.datatype }?, attribute _inherit-namespaces { avt.datatype }?, attribute use-attribute-sets { eqnames.datatype }?, attribute _use-attribute-sets { avt.datatype }?, ((attribute type { eqname.datatype }?, attribute _type { avt.datatype }?) | (attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive sequence-constructor.model } copy-of.element = element copy-of { extension.atts, global.atts, (attribute select { expression.datatype } | attribute _select { avt.datatype })+, attribute copy-accumulators { boolean.datatype }?, attribute _copy-accumulators { avt.datatype }?, attribute copy-namespaces { boolean.datatype }?, attribute _copy-namespaces { avt.datatype }?, ((attribute type { eqname.datatype }?, attribute _type { avt.datatype }?) | (attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive empty } sequence.element = element sequence { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } where-populated.element = element where-populated { extension.atts, global.atts, sequence-constructor.model } on-empty.element = element on-empty { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } on-non-empty.element = element on-non-empty { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } number.element = element number { extension.atts, global.atts, attribute value { expression.datatype }?, attribute _value { avt.datatype }?, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute level { "single" | "multiple" | "any" }?, attribute _level { avt.datatype }?, attribute count { pattern.datatype }?, attribute _count { avt.datatype }?, attribute from { pattern.datatype }?, attribute _from { avt.datatype }?, attribute format { string.datatype | avt.datatype }?, attribute _format { avt.datatype }?, attribute lang { language.datatype | avt.datatype }?, attribute _lang { avt.datatype }?, attribute letter-value { "alphabetic" | "traditional" | avt.datatype }?, attribute _letter-value { avt.datatype }?, attribute ordinal { string.datatype | avt.datatype }?, attribute _ordinal { avt.datatype }?, attribute start-at { integer.datatype | avt.datatype }?, attribute _start-at { avt.datatype }?, attribute grouping-separator { char.datatype | avt.datatype }?, attribute _grouping-separator { avt.datatype }?, attribute grouping-size { integer.datatype | avt.datatype }?, attribute _grouping-size { avt.datatype }?, empty } sort.element = element sort { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute lang { language.datatype | avt.datatype }?, attribute _lang { avt.datatype }?, attribute order { "ascending" | "descending" | avt.datatype }?, attribute _order { avt.datatype }?, attribute collation { uri.datatype | avt.datatype }?, attribute _collation { avt.datatype }?, attribute stable { boolean.datatype | avt.datatype }?, attribute _stable { avt.datatype }?, attribute case-order { "upper-first" | "lower-first" | avt.datatype }?, attribute _case-order { avt.datatype }?, attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?, attribute _data-type { avt.datatype }?, sequence-constructor.model } perform-sort.element = element perform-sort { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, (sort.element+, sequence-constructor.model) } for-each-group.element = element for-each-group { extension.atts, global.atts, (attribute select { expression.datatype } | attribute _select { avt.datatype })+, ((attribute group-by { expression.datatype }?, attribute _group-by { avt.datatype }?) | (attribute group-adjacent { expression.datatype }?, attribute _group-adjacent { avt.datatype }?) | (attribute group-starting-with { pattern.datatype }?, attribute _group-starting-with { avt.datatype }?) | (attribute group-ending-with { pattern.datatype }?, attribute _group-ending-with { avt.datatype }?)), attribute composite { boolean.datatype }?, attribute _composite { avt.datatype }?, attribute collation { uri.datatype | avt.datatype }?, attribute _collation { avt.datatype }?, (sort.element*, sequence-constructor.model) } merge.element = element merge { extension.atts, global.atts, (merge-source.element+, merge-action.element, fallback.element*) } merge-source.element = element merge-source { extension.atts, global.atts, attribute name { ncname.datatype }?, attribute _name { avt.datatype }?, attribute for-each-item { expression.datatype }?, attribute _for-each-item { avt.datatype }?, attribute for-each-stream { expression.datatype }?, attribute _for-each-stream { avt.datatype }?, (attribute select { expression.datatype } | attribute _select { avt.datatype })+, attribute streamable { boolean.datatype }?, attribute _streamable { avt.datatype }?, attribute use-accumulators { tokens.datatype }?, attribute _use-accumulators { avt.datatype }?, attribute sort-before-merge { boolean.datatype }?, attribute _sort-before-merge { avt.datatype }?, attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }?, attribute type { eqname.datatype }?, attribute _type { avt.datatype }?, attribute for-each-source { expression.datatype }?, attribute _for-each-source { avt.datatype }?, merge-key.element+ } merge-key.element = element merge-key { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute lang { language.datatype | avt.datatype }?, attribute _lang { avt.datatype }?, attribute order { "ascending" | "descending" | avt.datatype }?, attribute _order { avt.datatype }?, attribute collation { uri.datatype | avt.datatype }?, attribute _collation { avt.datatype }?, attribute case-order { "upper-first" | "lower-first" | avt.datatype }?, attribute _case-order { avt.datatype }?, attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?, attribute _data-type { avt.datatype }?, sequence-constructor.model } merge-action.element = element merge-action { extension.atts, global.atts, sequence-constructor.model } fork.element = element fork { extension.atts, global.atts, (fallback.element*, ((sequence.element, fallback.element*)* | (for-each-group.element, fallback.element*))) } analyze-string.element = element analyze-string { extension.atts, global.atts, (attribute select { expression.datatype } | attribute _select { avt.datatype })+, (attribute regex { string.datatype | avt.datatype } | attribute _regex { avt.datatype })+, attribute flags { string.datatype | avt.datatype }?, attribute _flags { avt.datatype }?, (matching-substring.element?, non-matching-substring.element?, fallback.element*) } matching-substring.element = element matching-substring { extension.atts, global.atts, sequence-constructor.model } non-matching-substring.element = element non-matching-substring { extension.atts, global.atts, sequence-constructor.model } source-document.element = element source-document { extension.atts, global.atts, (attribute href { uri.datatype | avt.datatype } | attribute _href { avt.datatype })+, attribute use-accumulators { tokens.datatype }?, attribute _use-accumulators { avt.datatype }?, ((attribute type { eqname.datatype }?, attribute _type { avt.datatype }?) | (attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive attribute streamable { boolean.datatype }?, attribute _streamable { avt.datatype }?, sequence-constructor.model } accumulator.element = element accumulator { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype }), (attribute initial-value { expression.datatype } | attribute _initial-value { avt.datatype }), attribute as { sequence-type.datatype }?, attribute _as { avt.datatype }?, attribute streamable { boolean.datatype }?, attribute _streamable { avt.datatype }?, accumulator-rule.element+ } accumulator-rule.element = element accumulator-rule { extension.atts, global.atts, (attribute match { pattern.datatype } | attribute _match { avt.datatype })+, attribute phase { "start" | "end" }?, attribute _phase { avt.datatype }?, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } key.element = element key { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, (attribute match { pattern.datatype } | attribute _match { avt.datatype })+, attribute use { expression.datatype }?, attribute _use { avt.datatype }?, attribute composite { boolean.datatype }?, attribute _composite { avt.datatype }?, attribute collation { uri.datatype }?, attribute _collation { avt.datatype }?, sequence-constructor.model } map.element = element map { extension.atts, global.atts, sequence-constructor.model } map-entry.element = element map-entry { extension.atts, global.atts, (attribute key { expression.datatype } | attribute _key { avt.datatype }), attribute select { expression.datatype }?, attribute _select { avt.datatype }?, sequence-constructor.model } message.element = element message { extension.atts, global.atts, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute terminate { boolean.datatype | avt.datatype }?, attribute _terminate { avt.datatype }?, attribute error-code { eqname.datatype | avt.datatype }?, attribute _error-code { avt.datatype }?, sequence-constructor.model } assert.element = element assert { extension.atts, global.atts, (attribute test { expression.datatype } | attribute _test { avt.datatype })+, attribute select { expression.datatype }?, attribute _select { avt.datatype }?, attribute error-code { eqname.datatype | avt.datatype }?, attribute _error-code { avt.datatype }?, sequence-constructor.model } fallback.element = element fallback { extension.atts, global.atts, sequence-constructor.model } result-document.element = element result-document { extension.atts, global.atts, attribute format { eqname.datatype | avt.datatype }?, attribute _format { avt.datatype }?, attribute href { uri.datatype | avt.datatype }?, attribute _href { avt.datatype }?, ((attribute type { eqname.datatype }?, attribute _type { avt.datatype }?) | (attribute validation { "strict" | "lax" | "preserve" | "strip" }?, attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype | avt.datatype }?, attribute _method { avt.datatype }?, attribute allow-duplicate-names { boolean.datatype | avt.datatype }?, attribute _allow-duplicate-names { avt.datatype }?, attribute build-tree { boolean.datatype | avt.datatype }?, attribute _build-tree { avt.datatype }?, attribute byte-order-mark { boolean.datatype | avt.datatype }?, attribute _byte-order-mark { avt.datatype }?, attribute cdata-section-elements { eqnames.datatype | avt.datatype }?, attribute _cdata-section-elements { avt.datatype }?, attribute doctype-public { string.datatype | avt.datatype }?, attribute _doctype-public { avt.datatype }?, attribute doctype-system { string.datatype | avt.datatype }?, attribute _doctype-system { avt.datatype }?, attribute encoding { string.datatype | avt.datatype }?, attribute _encoding { avt.datatype }?, attribute escape-uri-attributes { boolean.datatype | avt.datatype }?, attribute _escape-uri-attributes { avt.datatype }?, attribute html-version { decimal.datatype | avt.datatype }?, attribute _html-version { avt.datatype }?, attribute include-content-type { boolean.datatype | avt.datatype }?, attribute _include-content-type { avt.datatype }?, attribute indent { boolean.datatype | avt.datatype }?, attribute _indent { avt.datatype }?, attribute item-separator { string.datatype | avt.datatype }?, attribute _item-separator { avt.datatype }?, attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype | avt.datatype }?, attribute _json-node-output-method { avt.datatype }?, attribute media-type { string.datatype | avt.datatype }?, attribute _media-type { avt.datatype }?, attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype | avt.datatype }?, attribute _normalization-form { avt.datatype }?, attribute omit-xml-declaration { boolean.datatype | avt.datatype }?, attribute _omit-xml-declaration { avt.datatype }?, attribute parameter-document { uri.datatype | avt.datatype }?, attribute _parameter-document { avt.datatype }?, attribute standalone { boolean.datatype | "omit" | avt.datatype }?, attribute _standalone { avt.datatype }?, attribute suppress-indentation { eqnames.datatype | avt.datatype }?, attribute _suppress-indentation { avt.datatype }?, attribute undeclare-prefixes { boolean.datatype | avt.datatype }?, attribute _undeclare-prefixes { avt.datatype }?, attribute use-character-maps { eqnames.datatype }?, attribute _use-character-maps { avt.datatype }?, attribute output-version { nmtoken.datatype | avt.datatype }?, attribute _output-version { avt.datatype }?, sequence-constructor.model } output.element = element output { extension.atts, global.atts.except.version, attribute name { eqname.datatype }?, attribute _name { avt.datatype }?, attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype }?, attribute _method { avt.datatype }?, attribute allow-duplicate-names { boolean.datatype }?, attribute _allow-duplicate-names { avt.datatype }?, attribute build-tree { boolean.datatype }?, attribute _build-tree { avt.datatype }?, attribute byte-order-mark { boolean.datatype }?, attribute _byte-order-mark { avt.datatype }?, attribute cdata-section-elements { eqnames.datatype }?, attribute _cdata-section-elements { avt.datatype }?, attribute doctype-public { string.datatype }?, attribute _doctype-public { avt.datatype }?, attribute doctype-system { string.datatype }?, attribute _doctype-system { avt.datatype }?, attribute encoding { string.datatype }?, attribute _encoding { avt.datatype }?, attribute escape-uri-attributes { boolean.datatype }?, attribute _escape-uri-attributes { avt.datatype }?, attribute html-version { decimal.datatype }?, attribute _html-version { avt.datatype }?, attribute include-content-type { boolean.datatype }?, attribute _include-content-type { avt.datatype }?, attribute indent { boolean.datatype }?, attribute _indent { avt.datatype }?, attribute item-separator { string.datatype }?, attribute _item-separator { avt.datatype }?, attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype }?, attribute _json-node-output-method { avt.datatype }?, attribute media-type { string.datatype }?, attribute _media-type { avt.datatype }?, attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype }?, attribute _normalization-form { avt.datatype }?, attribute omit-xml-declaration { boolean.datatype }?, attribute _omit-xml-declaration { avt.datatype }?, attribute parameter-document { uri.datatype }?, attribute _parameter-document { avt.datatype }?, attribute standalone { boolean.datatype | "omit" }?, attribute _standalone { avt.datatype }?, attribute suppress-indentation { eqnames.datatype }?, attribute _suppress-indentation { avt.datatype }?, attribute undeclare-prefixes { boolean.datatype }?, attribute _undeclare-prefixes { avt.datatype }?, attribute use-character-maps { eqnames.datatype }?, attribute _use-character-maps { avt.datatype }?, attribute version { nmtoken.datatype }?, attribute _version { avt.datatype }?, empty } character-map.element = element character-map { extension.atts, global.atts, (attribute name { eqname.datatype } | attribute _name { avt.datatype })+, attribute use-character-maps { eqnames.datatype }?, attribute _use-character-maps { avt.datatype }?, (output-character.element*) } output-character.element = element output-character { extension.atts, global.atts, (attribute character { char.datatype } | attribute _character { avt.datatype })+, (attribute string { string.datatype } | attribute _string { avt.datatype })+, empty } avt.datatype = xsd:string # { # pattern = # """([^\{\}]|\{\{|\}\}|\{([^"'\{\}]|"[^"]*"|'[^']*')+\})*""" # this regexp will not work in all the case. # }</pre></div></div><div class="div1"><h2><a id="acknowledgements"></a><span class="deltaxml-old" style="background:#FF5555">I Acknowledgements (Non-Normative)</span></h2><p><span class="deltaxml-old" style="background:#FF5555">This specification was developed and approved for publication by the W3C XSLT Working Group (WG).</span></p><p><span class="deltaxml-old" style="background:#FF5555">The chair of the XSLT WG is Sharon Adler. The active membership of the XSLT WG during the final stages of the preparation of this specification included:</span></p><blockquote><p><span class="deltaxml-old" style="background:#FF5555">Sharon Adler (Chair)</span><span class="deltaxml-old" style="background:#FF5555">Anders Berglund</span><span class="deltaxml-old" style="background:#FF5555">Carine Bournez (W3C team)</span><span class="deltaxml-old" style="background:#FF5555">Abel Braaksma</span><span class="deltaxml-old" style="background:#FF5555">Charles Foster</span><span class="deltaxml-old" style="background:#FF5555">Florent Georges</span><span class="deltaxml-old" style="background:#FF5555">Michael Kay (Editor)</span><span class="deltaxml-old" style="background:#FF5555">Jirka Kosek</span><span class="deltaxml-old" style="background:#FF5555">Luis Ibhiabor</span><span class="deltaxml-old" style="background:#FF5555">Michael Sperberg-McQueen</span><span class="deltaxml-old" style="background:#FF5555">Norm Walsh</span><span class="deltaxml-old" style="background:#FF5555">Mohamed Zergaoui</span></p></blockquote><p><span class="deltaxml-old" style="background:#FF5555">The Working Group wishes to acknowledge the contribution of those who have participated in the work at earlier stages, as well as the pioneering work of the developers of STX (see </span><a href="#STX"><span class="deltaxml-old" style="background:#FF5555">[STX]</span></a><span class="deltaxml-old" style="background:#FF5555">) which formed an important intellectual input to the design of XSLT 3.0 and demonstrated the feasibility of creating a streaming transformation language based on the core XSLT concept of recursive descent of the source tree using rule-based templates.</span></p><p><span class="deltaxml-old" style="background:#FF5555">The Working Group also wishes to thank external reviewers who have provided feedback during the development of the specification.</span></p></div><div class="div1"><h2><a id="changes-since-3.0"></a><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span> Changes since XSLT 3.0 (Non-Normative)</h2><div class="div2"><h3><a id="xslt-changes-since-3.0"></a><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.1 <a href="#xslt-changes-since-3.0" style="text-decoration: none">Changes in successive Drafts</a></h3><p>The following sections list changes in successive drafts of this specification.</p><div class="div3"><h4><a id="changes-in-draft-A"></a><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.1.1 <a href="#changes-in-draft-A" style="text-decoration: none">Changes in this Specification: draft A (12 April 2021)</a></h4><ol class="enumar"><li><p>Errata agreed against XSLT 3.0 have been applied.</p></li><li><p>Support for XPath 4.0 and Functions and Operators 4.0 is required. This notably means that support for XDM arrays is now required.</p></li><li><p>The <a href="#element-if"><code>xsl:if</code></a> instruction acquires attributes <code>then</code> and <code>else</code>.</p></li><li><p>The <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a> elements can be evaluated using a <code>select</code> expression rather than a contained sequence constructor.</p></li><li><p>A new <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced.</p></li><li><p>The <a href="#element-item-type"><code>xsl:item-type</code></a> declaration allows names to be given to item types, which can then be referenced by name. This is particularly useful with record types, introduced in XPath 4.0.</p></li><li><p>A new <a href="#element-function-library"><code>xsl:function-library</code></a> declaration is introduced, allowing functions from multiple different namespaces to be called without using a namespace prefix.</p></li><li><p>The default namespace for element names and the default namespace for types can now be different, allowing built-in types to be referenced in unprefixed form (<code>as="integer"</code>).</p></li><li><p>The new instruction <a href="#element-array"><code>xsl:array</code></a> allows the construction of arrays.</p></li><li><p>New pattern syntax ( <code>type(T)</code>, <code>record(N, M, N)</code>) allows matching of items by item type.</p></li><li><p>The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute <code>as="sequence-type"</code> which declares the return type of all template rules in that mode.</p></li><li><p>The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions acquire a <code>separator</code> attribute to allow separators to be inserted into the output.</p></li><li><p>The <a href="#element-map"><code>xsl:map</code></a> instruction acquires a new attribute <code>on-duplicates</code>.</p></li><li><p>The <a href="#element-function"><code>xsl:function</code></a> declaration allows parameters to be declared as optional, so a single <a href="#element-function"><code>xsl:function</code></a> declaration can declare functions with multiple arities.</p></li><li><p>Enclosing modes: The <a href="#element-mode"><code>xsl:mode</code></a> declaration allows contained <a href="#element-template"><code>xsl:template</code></a> declarations.</p></li><li><p>Functions that accept a lexical QName as an argument, such as <a href="https://www.w3.org/TR/xpath-functions-30/#func-key"><code>key</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-function-available"><code>function-available</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-element-available"><code>element-available</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-type-available"><code>type-available</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-system-property"><code>system-property</code></a><sup><small>FO30</small></sup>, <a href="https://www.w3.org/TR/xpath-functions-30/#func-accumulator-before"><code>accumulator-before</code></a><sup><small>FO30</small></sup>, and <a href="https://www.w3.org/TR/xpath-functions-30/#func-accumulator-after"><code>accumulator-after</code></a><sup><small>FO30</small></sup>, now have the option of supplying an <code>xs:QName</code> value instead.</p></li></ol></div><div class="div3"><h4><a id="changes-in-draft-B"></a><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.1.2 <a href="#changes-in-draft-B" style="text-decoration: none">Changes in this Specification: draft B (date TBA)</a></h4><ol class="enumar"><li><p>The proposed <code>array</code> and <code>map</code> attributes of <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a>, and <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> have been dropped. Instead, to iterate over the contents of an array or map, use functions such as <code>array:members</code> and <code>map:key-value-pairs</code>.</p></li><li><p>The descriptions of basic data types for attributes now avoid using the term <em>lexical space</em>, since in XSD the lexical space contains values after whitespace normalization whereas these descriptions relate to the values as written.</p></li><li><p>The rules for <a title="enclosing mode" class="termref" href="#dt-enclosing-mode">enclosing modes</a> are corrected: the restriction on referring to the enclosing mode from outside applies to the package, not just to the stylesheet module. In addition, an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction within an enclosing mode defaults its <code>mode</code> attribute to the enclosing mode.</p></li><li><p>Support for higher-order functions is now mandatory (in XSLT 3.0 it was an optional feature).</p></li><li><p>An <a href="#element-note"><code>xsl:note</code></a> element is defined to enable structured documentation. It may appear anywhere.</p></li><li><p>A new attribute, <code>main-module</code>, is defined on <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> and <a href="#element-transform"><code>xsl:transform</code></a>, enabling an XSLT editing tool to identify the top-level module of a stylesheet, and hence the declarations of functions, templates, and global variables available to a module that is being edited.</p></li></ol></div></div><div class="div2"><h3><a id="xpath-changes-since-3.1"></a><span class="deltaxml-old" style="background:#FF5555">J</span><span class="deltaxml-new" style="background:#90EE90">I</span>.2 <a href="#xpath-changes-since-3.1" style="text-decoration: none">Changes in Other Related Specifications</a></h3><p>A number of changes affecting XSLT 4.0 have been made in other related specifications. Some of the more significant changes are as follows:</p><ol class="enumar"><li><p>A number of new kinds of ItemType are introduced, for example union types, record types, and enumeration types.</p></li><li><p>The coercion rules (previously "function conversion rules") allow atomic values of primitive types to be supplied where a restricted type is required: for example if the required type is <code>xs:positiveInteger</code>, it is now acceptable to supply the value <code>42</code>.</p></li><li><p>XPath 4.0 introduces abbreviated syntax for inline functions (for example <code>-&gt; ($x, $y) {$x + $y}</code>).</p></li></ol></div></div><div class="div1"><h2><a id="todo-list"></a><span class="deltaxml-old" style="background:#FF5555">K</span><span class="deltaxml-new" style="background:#90EE90">J</span> Changes Pending (Non-Normative)</h2><p>Further work is needed in the following areas:</p><ol class="enumar"><li><p>Streamability implications of new constructs</p></li><li><p>Details of error codes</p></li><li><p>Default priorites for new kinds of pattern</p></li><li><p>Add built-in template rules suitable for JSON processing</p></li><li><p>Default namespace for elements: allow matching on local-name only, or on "XHTML or nothing".</p></li><li class="add_version" style="display: none;"><p>Completing the XSD and RNG schemas for stylesheet modules.</p></li><li class="modify_version"><p><span class="deltaxml-new" style="background:#90EE90">Completing the XSD and RNG schemas for stylesheet modules.</span></p></li></ol></div><div class="div1"><h2><a id="incompatibilities"></a><span class="deltaxml-old" style="background:#FF5555">L</span><span class="deltaxml-new" style="background:#90EE90">K</span> Incompatibilities with XSLT 3.0 (Non-Normative)</h2><p>This section lists all known incompatibilities with XSLT 3.0, that is, situations where a stylesheet that is error-free according to the XSLT 3.0 specification and where all elements have an effective version of <code>3.0</code> or less, will produce different results depending on whether it is run under an XSLT 3.0 processor or an XSLT 4.0 processor.</p><ol class="enumar"><li><p>The rules for comparing values in <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> now reference the rules for <a href="#func-distinct-values"><code>distinct-values</code></a>, which have themselves changed <span>to be compatible with <a href="#func-fn-atomic-equal"><code>fn:atomic-equal</code></a></span>. This change eliminates the intransitivity in the previous specification, which meant that in edge cases involving rounding of numeric values of different types, two items in different groups could compare equal. Any change in behavior is confined to this edge case.</p></li></ol><p>This specification also corrects a number of errors and omissions in XSLT 3.0, in a way that might create incompatibilities for some processors, depending on how they interpreted the XSLT 3.0 specification:</p><ol class="enumar"><li><p>XSLT 3.0 (and earlier releases) did not fully define the evaluation context for the default values of template parameters. For example, if the default value of a parameter of a template rule invoked <a href="#element-next-match"><code>xsl:next-match</code></a>, it was not specified whether the current template rule should be the calling template or the called template. This omission has been corrected.</p></li></ol></div></div><p role="navigation" id="back-to-top"><a href="#title"><abbr title="Back to top">↑</abbr></a></p><script src="//www.w3.org/scripts/TR/2016/fixup.js"></script><script src="/js/scroll.js"></script></body></html>