<!DOCTYPE HTML>
<html lang="EN">
   <head>
      <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
      <title>XSL Transformations (XSLT) Version 4.0</title>
      <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
      <link rel="stylesheet" type="text/css" href="css/w3c-base.css">
      <link rel="stylesheet" href="css/qtspecs.css">
      <link rel="stylesheet" href="css/xslt-40.css"><script src="js/xsl-datalist.js"></script></head>
   <body>
      <div class="head">
         <p><a href="https://www.w3.org/"><img src="https://www.w3.org/StyleSheets/TR/2016/logos/W3C" alt="W3C" height="48" width="72"></a></p>
         
         <h1><a id="title"></a>XSL Transformations (XSLT) Version 4.0</h1>
         
         <h2><a id="w3c-doctype"></a>W3C Editor's Draft 20 February 2026</h2>
         <dl>
            <dt>This version:</dt>
            <dd><a href="https://qt4cg.org/pr/2481/xslt-40//">https://qt4cg.org/pr/2481/xslt-40/</a></dd>
            <dt>Latest version:</dt>
            <dd>
               <a href="https://qt4cg.org/specifications/xslt-40/">https://qt4cg.org/specifications/xslt-40/</a>
               </dd>
            <dt>Most recent Recommendation of XSL Transformations (XSLT):</dt>
            <dd>
               <a href="https://www.w3.org/TR/xslt-30/">https://www.w3.org/TR/xslt-30/</a>
               </dd>
            <dt>Editor:</dt>
            <dd>Michael Kay, Saxonica <a href="http://www.saxonica.com/">&lt;http://www.saxonica.com/&gt;</a></dd>
         </dl>
         <p>The following associated resources are available:
    <a href="xslt-40.xml">Specification in XML format</a>, <a href="schema-for-xslt40.xsd">XSD 1.1 Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="schema-for-xslt40.rnc">Relax-NG Schema for XSLT 4.0 Stylesheets (non-normative)</a>, <a href="xml-to-json.xsl">Stylesheet for XML-to-JSON conversion (non-normative)</a></p>
         <p class="copyright"><a href="https://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a>&nbsp;©&nbsp;2026&nbsp;<a href="https://www.w3.org/"><abbr title="World Wide Web Consortium">W3C</abbr></a><sup>®</sup> (<a href="https://www.csail.mit.edu/"><abbr title="Massachusetts Institute of Technology">MIT</abbr></a>, <a href="https://www.ercim.eu/"><abbr title="European Research Consortium for Informatics and Mathematics">ERCIM</abbr></a>, <a href="https://www.keio.ac.jp/">Keio</a>, <a href="http://ev.buaa.edu.cn/">Beihang</a>). W3C <a href="https://www.w3.org/Consortium/Legal/ipr-notice#Legal_Disclaimer">liability</a>, <a href="https://www.w3.org/Consortium/Legal/ipr-notice#W3C_Trademarks">trademark</a> and <a href="https://www.w3.org/Consortium/Legal/copyright-documents">document use</a> rules apply.</p>
         <hr>
      </div>
      <div>
         
         <h2><a id="abstract"></a>Abstract</h2>
         <p>This specification defines the syntax and semantics of XSLT 4.0, a language designed
               primarily for transforming XML documents into other XML documents, but
               also offering support for other data formats including JSON, HTML, and CSV.</p>
         <p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <a href="#xslt-30">[XSLT 3.0]</a>
            published on 8 June 2017. Changes are presented in <a href="#whats-new-in-xslt4"><i>1.2 What’s New in XSLT 4.0?</i></a>. </p>
         <p>XSLT 4.0 is designed to be used in conjunction with XPath 4.0, which is defined in
               <a href="#xpath-40">[XPath 4.0]</a>. XSLT shares the same data model as XPath 4.0, which is
            defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>, and it uses the library of functions and
            operators defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. XPath 4.0 and the underlying
            function library introduce a number of enhancements, for example the availability of
            union and record types. </p>
         <p>
            <em>This document contains hyperlinks to specific sections or definitions within other
               documents in this family of specifications. These links are indicated visually by a
               superscript identifying the target specification: for example XP for XPath 4.0,
               DM for the XDM data model version 4.0, FO for Functions and Operators version
               4.0, SG for XSLT Streaming version 4.0.</em>
         </p>
         <p>An optional feature of the XSLT language is support for streamed transformations.
         The XSLT 4.0 specification has been modularized so that streaming is now described
         in a separate specification document. This has been done in order to make the
         specifications more manageable, both for editors and readers: it does not alter
         the status of streaming as an optional feature, available in some processors
         and not others.</p>
      </div>
      <div>
         
         <h2><a id="status"></a>Status of this Document</h2>
         <p><em>This section describes the status of this document at the time of its publication.
               Other documents may supersede this document.</em></p>
         <p>This document is a working draft developed and maintained by a W3C Community Group,
            the <a href="https://www.w3.org/community/xslt-40/">XQuery and XSLT Extensions Community Group</a>
            unofficially known as QT4CG (where "QT" denotes Query and Transformation). This draft
            is work in progress and should not be considered either stable or complete.
            Standard W3C copyright and patent conditions apply.</p>
         <p>The community group welcomes comments on the specification. Comments are best submitted
         as issues on the group's <a href="https://github.com/qt4cg/qtspecs/issues">GitHub repository</a>.</p>
         <p>The community group maintains two extensive test suites, 
            one oriented to XQuery and XPath, the other to XSLT.
         These can be found at <a href="https://github.com/qt4cg/qt4tests">qt4tests</a> and
         <a href="https://github.com/qt4cg/xslt40-test">xslt40-test</a> respectively. New tests,
         or suggestions for correcting existing tests, are welcome. The test suites include extensive metadata
         describing the conditions for applicability of each test case as well as the expected results. They
         do not include any test drivers for executing the tests: each implementation is expected to provide
         its own test driver.</p>
         <div class="dedication" id="dedication">
            <h3>Dedication</h3>
            <p>The publications of this community group 
<a href="../xquery-40/xpath-40.html#dedication">are dedicated</a> to our co-chair,
Michael Sperberg-McQueen&nbsp;(1954–2024).</p>
         </div>
      </div>
      <nav id="toc">
         
         <div id="function-finder">
            <div class="ffheader">INSTRUCTION &amp; FUNCTION FINDER</div>
            <div><span>Search: <input id="select-fn" list="fn-list" type="text"> <button id="help-select-fn-button">?</button></span><p id="help-select-fn" style="display:none;">Type a name, or press down arrow for a list.</p><datalist id="fn-list">
                  <option>xsl:accept⁣</option>
                  <option>xsl:accumulator⁣</option>
                  <option>xsl:accumulator-rule⁣</option>
                  <option>xsl:analyze-string⁣</option>
                  <option>xsl:apply-imports⁣</option>
                  <option>xsl:apply-templates⁣</option>
                  <option>xsl:array⁣</option>
                  <option>xsl:array-member⁣</option>
                  <option>xsl:assert⁣</option>
                  <option>xsl:attribute⁣</option>
                  <option>xsl:attribute-set⁣</option>
                  <option>xsl:break⁣</option>
                  <option>xsl:call-template⁣</option>
                  <option>xsl:catch⁣</option>
                  <option>xsl:character-map⁣</option>
                  <option>xsl:choose⁣</option>
                  <option>xsl:comment⁣</option>
                  <option>xsl:context-item⁣</option>
                  <option>xsl:copy⁣</option>
                  <option>xsl:copy-of⁣</option>
                  <option>xsl:decimal-format⁣</option>
                  <option>xsl:document⁣</option>
                  <option>xsl:element⁣</option>
                  <option>xsl:evaluate⁣</option>
                  <option>xsl:example-element⁣</option>
                  <option>xsl:expose⁣</option>
                  <option>xsl:fallback⁣</option>
                  <option>xsl:field⁣</option>
                  <option>xsl:for-each⁣</option>
                  <option>xsl:for-each-group⁣</option>
                  <option>xsl:fork⁣</option>
                  <option>xsl:function⁣</option>
                  <option>xsl:global-context-item⁣</option>
                  <option>xsl:if⁣</option>
                  <option>xsl:import⁣</option>
                  <option>xsl:import-schema⁣</option>
                  <option>xsl:include⁣</option>
                  <option>xsl:item-type⁣</option>
                  <option>xsl:iterate⁣</option>
                  <option>xsl:key⁣</option>
                  <option>xsl:map⁣</option>
                  <option>xsl:map-entry⁣</option>
                  <option>xsl:matching-substring⁣</option>
                  <option>xsl:merge⁣</option>
                  <option>xsl:merge-action⁣</option>
                  <option>xsl:merge-key⁣</option>
                  <option>xsl:merge-source⁣</option>
                  <option>xsl:message⁣</option>
                  <option>xsl:mode⁣</option>
                  <option>xsl:namespace⁣</option>
                  <option>xsl:namespace-alias⁣</option>
                  <option>xsl:next-iteration⁣</option>
                  <option>xsl:next-match⁣</option>
                  <option>xsl:non-matching-substring⁣</option>
                  <option>xsl:note⁣</option>
                  <option>xsl:number⁣</option>
                  <option>xsl:on-completion⁣</option>
                  <option>xsl:on-empty⁣</option>
                  <option>xsl:on-non-empty⁣</option>
                  <option>xsl:otherwise⁣</option>
                  <option>xsl:output⁣</option>
                  <option>xsl:output-character⁣</option>
                  <option>xsl:override⁣</option>
                  <option>xsl:package⁣</option>
                  <option>xsl:package-location⁣</option>
                  <option>xsl:param⁣</option>
                  <option>xsl:perform-sort⁣</option>
                  <option>xsl:preserve-space⁣</option>
                  <option>xsl:processing-instruction⁣</option>
                  <option>xsl:record⁣</option>
                  <option>xsl:record-type⁣</option>
                  <option>xsl:result-document⁣</option>
                  <option>xsl:select⁣</option>
                  <option>xsl:sequence⁣</option>
                  <option>xsl:sort⁣</option>
                  <option>xsl:source-document⁣</option>
                  <option>xsl:strip-space⁣</option>
                  <option>xsl:stylesheet⁣</option>
                  <option>xsl:switch⁣</option>
                  <option>xsl:template⁣</option>
                  <option>xsl:text⁣</option>
                  <option>xsl:transform⁣</option>
                  <option>xsl:try⁣</option>
                  <option>xsl:use-package⁣</option>
                  <option>xsl:value-of⁣</option>
                  <option>xsl:variable⁣</option>
                  <option>xsl:when⁣</option>
                  <option>xsl:where-populated⁣</option>
                  <option>xsl:with-param⁣</option>
                  <option value="fn:accumulator-after⁣"></option>
                  <option value="fn:accumulator-before⁣"></option>
                  <option value="fn:apply-templates⁣"></option>
                  <option value="fn:available-system-properties⁣"></option>
                  <option value="fn:character-map⁣"></option>
                  <option value="fn:copy-of⁣"></option>
                  <option value="fn:current⁣"></option>
                  <option value="fn:current-group⁣"></option>
                  <option value="fn:current-grouping-key⁣"></option>
                  <option value="fn:current-merge-group⁣"></option>
                  <option value="fn:current-merge-key⁣"></option>
                  <option value="fn:current-merge-key-array⁣"></option>
                  <option value="fn:current-output-uri⁣"></option>
                  <option value="fn:document⁣"></option>
                  <option value="fn:element-available⁣"></option>
                  <option value="fn:function-available⁣"></option>
                  <option value="fn:key⁣"></option>
                  <option value="fn:map-for-key⁣"></option>
                  <option value="fn:regex-group⁣"></option>
                  <option value="fn:regex-groups⁣"></option>
                  <option value="fn:snapshot⁣"></option>
                  <option value="fn:stream-available⁣"></option>
                  <option value="fn:system-property⁣"></option>
                  <option value="fn:type-available⁣"></option>
                  <option value="fn:unparsed-entity-public-id⁣"></option>
                  <option value="fn:unparsed-entity-uri⁣"></option></datalist></div>
         </div>
         <h2><a id="contents"></a>Table of Contents<span class="expalltoc collapsed"> ▶</span></h2>
         <ol class="toc">
            <li>
               <details>
                  <summary><a href="#introduction"><span class="secno">1 </span><span class="content">Introduction</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#what-is-xslt"><span class="secno">1.1 </span><span class="content">What is XSLT?</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#whats-new-in-xslt4"><span class="secno">1.2 </span><span class="content toc-chg">What’s New in XSLT 4.0?</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#concepts"><span class="secno">2 </span><span class="content">Concepts</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#terminology"><span class="secno">2.1 </span><span class="content toc-chg">Terminology</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#notation"><span class="secno">2.2 </span><span class="content">Notation</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#initiating"><span class="secno">2.3 </span><span class="content">Initiating a Transformation</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#info-for-static-analysis"><span class="secno">2.3.1 </span><span class="content">Information needed for Static Analysis</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#priming-stylesheet"><span class="secno">2.3.2 </span><span class="content">Priming a Stylesheet</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#invoking-initial-mode"><span class="secno">2.3.3 </span><span class="content">Apply-Templates Invocation</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#invoking-initial-template"><span class="secno">2.3.4 </span><span class="content">Call-Template Invocation</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#invoking-initial-function"><span class="secno">2.3.5 </span><span class="content">Function Call Invocation</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#post-processing"><span class="secno">2.3.6 </span><span class="content">Post-processing the Raw Result</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#result-tree-construction"><span class="secno">2.3.6.1 </span><span class="content">Result Tree Construction</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#result-serialization"><span class="secno">2.3.6.2 </span><span class="content">Serializing the Result</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#executing-a-transformation"><span class="secno">2.4 </span><span class="content">Instructions</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#rule-based-processing"><span class="secno">2.5 </span><span class="content">Rule-Based Processing</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#context"><span class="secno">2.6 </span><span class="content">The Evaluation Context</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#parsing-and-serialization"><span class="secno">2.7 </span><span class="content">Parsing and Serialization</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#packages-and-modules"><span class="secno">2.8 </span><span class="content">Packages and Modules</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#extensibility"><span class="secno">2.9 </span><span class="content">Extensibility</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#stylesheets-and-schemas"><span class="secno">2.10 </span><span class="content toc-chg">Stylesheets and XML Schemas</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#streaming-concepts"><span class="secno">2.11 </span><span class="content">Streaming</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#errors"><span class="secno">2.12 </span><span class="content">Error Handling</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#stylesheet-structure"><span class="secno">3 </span><span class="content">Stylesheet Structure</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#namespaces"><span class="secno">3.1 </span><span class="content">Namespaces</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#xslt-namespace"><span class="secno">3.1.1 </span><span class="content">XSLT Namespace</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#xslt-media-type"><span class="secno">3.2 </span><span class="content">XSLT Media Type</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#standard-attributes"><span class="secno">3.3 </span><span class="content toc-chg">Standard Attributes</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#packages"><span class="secno">3.4 </span><span class="content">Packages</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#package-versions"><span class="secno">3.4.1 </span><span class="content">Versions of a Package</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#package-dependencies"><span class="secno">3.4.2 </span><span class="content">Dependencies between Packages</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#package-locations"><span class="secno">3.4.3 </span><span class="content toc-chg">Locating Packages</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#named-components"><span class="secno">3.4.4 </span><span class="content">Named Components in Packages</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#visibility"><span class="secno">3.4.4.1 </span><span class="content">Visibility of Components</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#accepting-components"><span class="secno">3.4.4.2 </span><span class="content">Accepting Components</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#package-overriding-components"><span class="secno">3.4.4.3 </span><span class="content">Overriding Components from a Used Package</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#refer-to-overridden"><span class="secno">3.4.4.4 </span><span class="content">Referring to Overridden Components</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#component-references"><span class="secno">3.4.4.5 </span><span class="content">Binding References to Components</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#dynamic-component-references"><span class="secno">3.4.4.6 </span><span class="content">Dynamic References to Components</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#modes-and-packages"><span class="secno">3.4.5 </span><span class="content">Overriding Template Rules from a Used Package</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#requiring-explicit-modes"><span class="secno">3.4.5.1 </span><span class="content">Requiring Explicit Mode Declarations</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#package-local-declarations"><span class="secno">3.4.6 </span><span class="content">Declarations Local to a Package</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#declaring-global-context-item"><span class="secno">3.4.7 </span><span class="content">Declaring the Global Context Item</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#packages-csv-library-example"><span class="secno">3.4.8 </span><span class="content">Worked Example of a Library Package</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-default-functionality"><span class="secno">3.4.8.1 </span><span class="content">Default Functionality of the CSV Package</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-package-structure"><span class="secno">3.4.8.2 </span><span class="content">Package Structure</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-customizing-parse"><span class="secno">3.4.8.3 </span><span class="content">The csv:parse Function and its User-customization Hooks</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-line-breaking"><span class="secno">3.4.8.4 </span><span class="content">Breaking the Input into Lines</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-preprocessing-lines"><span class="secno">3.4.8.5 </span><span class="content">Pre-processing the Lines</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#example-csv-mode-parse-line"><span class="secno">3.4.8.6 </span><span class="content">The Mode csv:parse-line</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-mode"><span class="secno">3.4.8.7 </span><span class="content">Mode csv:parse-field</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-variable"><span class="secno">3.4.8.8 </span><span class="content">The csv:quote Variable</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-preprocess-field"><span class="secno">3.4.8.9 </span><span class="content">The csv:preprocess-field Function</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-postprocess"><span class="secno">3.4.8.10 </span><span class="content">The Mode csv:post-process</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#csv-example-overriding"><span class="secno">3.4.8.11 </span><span class="content">Overriding the Default Behavior</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#stylesheet-modules"><span class="secno">3.5 </span><span class="content">Stylesheet Modules</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#stylesheet-element"><span class="secno">3.6 </span><span class="content toc-chg">Stylesheet Element</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#fixed-namespaces"><span class="secno">3.6.1 </span><span class="content toc-chg">The fixed-namespaces Attribute</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#default-collation-attribute"><span class="secno">3.6.2 </span><span class="content">The default-collation Attribute</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#default-mode"><span class="secno">3.6.3 </span><span class="content">The default-mode Attribute</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#user-defined-top-level"><span class="secno">3.6.4 </span><span class="content">User-defined Data Elements</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#simplified-stylesheet"><span class="secno">3.7 </span><span class="content toc-chg">Simplified Stylesheet Modules</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#backwards"><span class="secno">3.8 </span><span class="content">Backwards Compatible Processing</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#backwards-1.0"><span class="secno">3.8.1 </span><span class="content">XSLT 1.0 Compatibility Mode</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#backwards-2.0"><span class="secno">3.8.2 </span><span class="content">XSLT 2.0 Compatibility Mode</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#backwards-3.0"><span class="secno">3.8.3 </span><span class="content">XSLT 3.0 Compatibility Mode</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#forwards"><span class="secno">3.9 </span><span class="content">Forwards Compatible Processing</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#combining-modules"><span class="secno">3.10 </span><span class="content">Combining Stylesheet Modules</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#locating-modules"><span class="secno">3.10.1 </span><span class="content">Locating Stylesheet Modules</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#include"><span class="secno">3.10.2 </span><span class="content toc-chg">Stylesheet Inclusion</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#import"><span class="secno">3.10.3 </span><span class="content">Stylesheet Import</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#preprocessing"><span class="secno">3.11 </span><span class="content">Stylesheet Preprocessing</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#stylesheet-stripping"><span class="secno">3.11.1 </span><span class="content">Stripping Whitespace and Commentary from the Stylesheet</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#xsl-note-elements"><span class="secno">3.11.2 </span><span class="content toc-chg">The xsl:note element</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#conditional-inclusion"><span class="secno">3.11.3 </span><span class="content">Conditional Element Inclusion</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#shadow-attributes"><span class="secno">3.11.4 </span><span class="content">Shadow Attributes</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#built-in-types"><span class="secno">3.12 </span><span class="content">Built-in Types</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#import-schema"><span class="secno">3.13 </span><span class="content toc-chg">Importing Schema Components</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#multiple-schemas"><span class="secno">3.13.1 </span><span class="content toc-chg">Multiple Schemas</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#data-model"><span class="secno">4 </span><span class="content">Data Model</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#xml-versions"><span class="secno">4.1 </span><span class="content">XML Versions</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#preprocessing-source-docs"><span class="secno">4.2 </span><span class="content">Preprocessing Source Documents</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#stripping-annotations"><span class="secno">4.2.1 </span><span class="content">Stripping Type Annotations from a Source Tree</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#strip"><span class="secno">4.2.2 </span><span class="content">Stripping Whitespace from a Source Tree</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#id-in-data-model"><span class="secno">4.3 </span><span class="content">Attribute Types and DTD Validation</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#limits"><span class="secno">4.4 </span><span class="content">Limits</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#d-o-e-in-data-model"><span class="secno">4.5 </span><span class="content">Disable Output Escaping</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#constructs"><span class="secno">5 </span><span class="content">Features of the XSLT Language</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#names"><span class="secno">5.1 </span><span class="content">Names</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#qname"><span class="secno">5.1.1 </span><span class="content">Qualified Names</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#unprefixed-qnames"><span class="secno">5.1.2 </span><span class="content toc-chg">Unprefixed Lexical QNames in Expressions and Patterns</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#unprefixed-element-names"><span class="secno">5.1.2.1 </span><span class="content">Unprefixed Element Names</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#unprefixed-function-names"><span class="secno">5.1.2.2 </span><span class="content">Unprefixed Function Names</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#other-unprefixed-names"><span class="secno">5.1.2.3 </span><span class="content">Other Unprefixed Names</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#reserved-namespaces"><span class="secno">5.1.3 </span><span class="content">Reserved Namespaces</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#expressions"><span class="secno">5.2 </span><span class="content">Expressions</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#static-and-dynamic-context"><span class="secno">5.3 </span><span class="content">The Static and Dynamic Context</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#static-context"><span class="secno">5.3.1 </span><span class="content">Initializing the Static Context</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#additional-static-context"><span class="secno">5.3.2 </span><span class="content">Additional Static Context Components used by XSLT</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#xpath-dynamic-context"><span class="secno">5.3.3 </span><span class="content">Initializing the Dynamic Context</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#focus"><span class="secno">5.3.3.1 </span><span class="content">Maintaining Position: the Focus</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#evaluation-context"><span class="secno">5.3.3.2 </span><span class="content">Other Components of the XPath Dynamic Context</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#additional-dynamic-context"><span class="secno">5.3.4 </span><span class="content toc-chg">Additional Dynamic Context Components used by XSLT</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#named-types"><span class="secno">5.4 </span><span class="content">Named Types</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#named-item-types"><span class="secno">5.4.1 </span><span class="content toc-chg">Named Item Types</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#named-record-types"><span class="secno">5.4.2 </span><span class="content toc-chg">Named Record Types</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#id-atomic-set-example"><span class="secno">5.4.3 </span><span class="content">Example: Defining an Atomic Set</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#defining-decimal-format"><span class="secno">5.5 </span><span class="content toc-chg">Defining a Decimal Format</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#value-templates"><span class="secno">5.6 </span><span class="content">Value Templates</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#attribute-value-templates"><span class="secno">5.6.1 </span><span class="content">Attribute Value Templates</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#text-value-templates"><span class="secno">5.6.2 </span><span class="content">Text Value Templates</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#sequence-constructors"><span class="secno">5.7 </span><span class="content">Sequence Constructors</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#constructing-complex-content"><span class="secno">5.7.1 </span><span class="content">Constructing Complex Content</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#constructing-simple-content"><span class="secno">5.7.2 </span><span class="content">Constructing Simple Content</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#namespace-fixup"><span class="secno">5.7.3 </span><span class="content">Namespace Fixup</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#uri-references"><span class="secno">5.8 </span><span class="content">URI References</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#rules"><span class="secno">6 </span><span class="content">Template Rules</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#defining-templates"><span class="secno">6.1 </span><span class="content">Defining Templates</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#defining-template-rules"><span class="secno">6.2 </span><span class="content">Defining Template Rules</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#patterns"><span class="secno">6.3 </span><span class="content">Patterns</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#pattern-examples"><span class="secno">6.3.1 </span><span class="content">Examples of Patterns</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#pattern-syntax"><span class="secno">6.3.2 </span><span class="content">Syntax of Patterns</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#predicate-patterns"><span class="secno">6.3.2.1 </span><span class="content">Predicate Patterns</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#type-patterns"><span class="secno">6.3.2.2 </span><span class="content toc-chg">Type Patterns</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#node-patterns"><span class="secno">6.3.2.3 </span><span class="content toc-chg">GNode Patterns</span></a><span class="exptoc collapsed"></span></summary>
                                             <ol class="toc">
                                                <li>
                                                   <details>
                                                      <summary><a href="#pattern-semantics"><span class="secno">6.3.2.3.1 </span><span class="content">The Meaning of a GNode Pattern</span></a></summary>
                                                   </details>
                                                </li>
                                             </ol>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#default-priority"><span class="secno">6.3.3 </span><span class="content toc-chg">Default Priority for Patterns</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#default-priority-for-predicate-patterns"><span class="secno">6.3.3.1 </span><span class="content">Default Priority for Predicate Patterns</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#default-priority-for-type-patterns"><span class="secno">6.3.3.2 </span><span class="content">Default Priority for Type Patterns</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#default-priority-for-gnode-patterns"><span class="secno">6.3.3.3 </span><span class="content">Default Priority for GNode Patterns</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#pattern-errors"><span class="secno">6.3.4 </span><span class="content">Errors in Patterns</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#applying-templates"><span class="secno">6.4 </span><span class="content toc-chg">Applying Template Rules</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#apply-templates-separator"><span class="secno">6.5 </span><span class="content">The separator attribute</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#conflict"><span class="secno">6.6 </span><span class="content">Conflict Resolution for Template Rules</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#modes"><span class="secno">6.7 </span><span class="content">Modes</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#declaring-modes"><span class="secno">6.7.1 </span><span class="content toc-chg">Declaring Modes</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#using-modes"><span class="secno">6.7.2 </span><span class="content">Using Modes</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#apply-templates-function"><span class="secno">6.7.3 </span><span class="content toc-chg">The apply-templates Function</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#func-apply-templates"><span class="secno">6.7.3.1 </span><span class="content toc-new">fn:apply-templates</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#xsl-mode-typed"><span class="secno">6.7.4 </span><span class="content toc-chg">Declaring the Type of Values Processed by a Mode</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#mode-result-type"><span class="secno">6.7.5 </span><span class="content toc-chg">Declaring the Result Type of a Mode</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#enclosing-modes"><span class="secno">6.7.6 </span><span class="content toc-chg">Enclosing Modes</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#built-in-rule"><span class="secno">6.8 </span><span class="content toc-chg">Built-in Template Rules</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#built-in-templates-text-only-copy"><span class="secno">6.8.1 </span><span class="content">Built-in Templates: Text-only Copy</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#built-in-templates-deep-copy"><span class="secno">6.8.2 </span><span class="content">Built-in Templates: Deep Copy</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#built-in-templates-shallow-copy"><span class="secno">6.8.3 </span><span class="content">Built-in Templates: Shallow Copy</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#built-in-templates-shallow-copy-all"><span class="secno">6.8.4 </span><span class="content">Built-in Templates: Shallow Copy All</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#built-in-templates-deep-skip"><span class="secno">6.8.5 </span><span class="content">Built-in Templates: Deep Skip</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#built-in-templates-shallow-skip"><span class="secno">6.8.6 </span><span class="content">Built-in Templates: Shallow Skip</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#built-in-templates-fail"><span class="secno">6.8.7 </span><span class="content">Built-in Templates: Fail</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#apply-imports"><span class="secno">6.9 </span><span class="content toc-chg">Overriding Template Rules</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#parameters-to-template-rules"><span class="secno">6.10 </span><span class="content">Passing Parameters to Template Rules</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#repetition"><span class="secno">7 </span><span class="content">Repetition</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#for-each"><span class="secno">7.1 </span><span class="content toc-chg">The xsl:for-each instruction</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#for-each-separator"><span class="secno">7.1.1 </span><span class="content">The separator attribute</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#iterate"><span class="secno">7.2 </span><span class="content">The xsl:iterate Instruction</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#conditionals"><span class="secno">8 </span><span class="content">Conditional Processing</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#xsl-if"><span class="secno">8.1 </span><span class="content toc-chg">Conditional Processing with xsl:if</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#xsl-choose"><span class="secno">8.2 </span><span class="content toc-chg">Conditional Processing with xsl:choose</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#xsl-switch"><span class="secno">8.3 </span><span class="content toc-chg">Conditional Processing with xsl:switch</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#try-catch"><span class="secno">8.4 </span><span class="content toc-chg">Try/Catch</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#recovery"><span class="secno">8.4.1 </span><span class="content">Recovery of Result Trees</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#try-catch-examples"><span class="secno">8.4.2 </span><span class="content">Try/Catch Examples</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#conditional-content-construction"><span class="secno">8.5 </span><span class="content">Conditional Content Construction</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#where-populated"><span class="secno">8.5.1 </span><span class="content">The xsl:where-populated instruction</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#on-empty"><span class="secno">8.5.2 </span><span class="content">The xsl:on-empty instruction</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#on-non-empty"><span class="secno">8.5.3 </span><span class="content">The xsl:on-non-empty instruction</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#variables-and-parameters"><span class="secno">9 </span><span class="content">Variables and Parameters</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#variables"><span class="secno">9.1 </span><span class="content">Variables</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#parameters"><span class="secno">9.2 </span><span class="content">Parameters</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#parameter-type"><span class="secno">9.2.1 </span><span class="content">The Required Type of a Parameter</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#default-values-of-parameters"><span class="secno">9.2.2 </span><span class="content toc-chg">Default Values of Parameters</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#variable-values"><span class="secno">9.3 </span><span class="content toc-chg">Values of Variables and Parameters</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#temporary-trees"><span class="secno">9.4 </span><span class="content">Creating Implicit Document Nodes</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#global-variables"><span class="secno">9.5 </span><span class="content toc-chg">Global Variables and Parameters</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#static-params"><span class="secno">9.6 </span><span class="content">Static Variables and Parameters</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#static-expression"><span class="secno">9.7 </span><span class="content">Static Expressions</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#local-variables"><span class="secno">9.8 </span><span class="content">Local Variables and Parameters</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#scope-of-variables"><span class="secno">9.9 </span><span class="content">Scope of Variables</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#with-param"><span class="secno">9.10 </span><span class="content">Setting Parameter Values</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#circularity"><span class="secno">9.11 </span><span class="content">Circular Definitions</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#callable-components"><span class="secno">10 </span><span class="content">Callable Components</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#named-templates"><span class="secno">10.1 </span><span class="content">Named Templates</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#declaring-named-templates"><span class="secno">10.1.1 </span><span class="content">Declaring Named Templates</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#invoking-named-templates"><span class="secno">10.1.2 </span><span class="content">Invoking Named Templates</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#invoking-templates-with-extension-instructions"><span class="secno">10.1.3 </span><span class="content toc-chg">Invoking Named Templates using Extension Instructions</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#declaring-context-item"><span class="secno">10.1.4 </span><span class="content">Declaring the Context Item for a Template</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#call-template-params"><span class="secno">10.1.5 </span><span class="content">Passing Parameters to Named Templates</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#tunnel-params"><span class="secno">10.1.6 </span><span class="content">Tunnel Parameters</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#attribute-sets"><span class="secno">10.2 </span><span class="content">Named Attribute Sets</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#using-attribute-sets"><span class="secno">10.2.1 </span><span class="content">Using Attribute Sets</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#visibility-of-attribute-sets"><span class="secno">10.2.2 </span><span class="content">Visibility of Attribute Sets</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#evaluating-attribute-sets"><span class="secno">10.2.3 </span><span class="content">Evaluating Attribute Sets</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#attribute-sets-examples"><span class="secno">10.2.4 </span><span class="content">Attribute Sets: Examples</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#stylesheet-functions"><span class="secno">10.3 </span><span class="content toc-chg">Stylesheet Functions</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#xsl-function-name"><span class="secno">10.3.1 </span><span class="content toc-chg">Function Name and Arity</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#function-arguments"><span class="secno">10.3.2 </span><span class="content">Parameters</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#function-result"><span class="secno">10.3.3 </span><span class="content">Function Result</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#function-visibility-and-overriding"><span class="secno">10.3.4 </span><span class="content">Visibility and Overriding of Functions</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#function-overriding-within-package"><span class="secno">10.3.4.1 </span><span class="content">Overriding Functions within a Package</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#overriding-extension-functions"><span class="secno">10.3.4.2 </span><span class="content">Overriding Extension Functions</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#overriding-functions-in-used-packages"><span class="secno">10.3.4.3 </span><span class="content">Overriding Functions in a Used Package</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#function-lookup"><span class="secno">10.3.5 </span><span class="content">Dynamic Access to Functions</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#function-determinism"><span class="secno">10.3.6 </span><span class="content">Determinism of Functions</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#memoization"><span class="secno">10.3.7 </span><span class="content">Memoization</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#function-examples"><span class="secno">10.3.8 </span><span class="content">Examples of Stylesheet Functions</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#static-xpath-evaluation"><span class="secno">10.4 </span><span class="content">Static XPath Evaluation</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#constructing-sequences"><span class="secno">10.4.1 </span><span class="content toc-chg">The xsl:sequence Instruction</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#select-instruction"><span class="secno">10.4.2 </span><span class="content toc-chg">The xsl:select Instruction</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#dynamic-xpath"><span class="secno">10.5 </span><span class="content toc-chg">Dynamic XPath Evaluation</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#evaluate-static-context"><span class="secno">10.5.1 </span><span class="content">Static context for the target expression</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#evaluate-dynamic-context"><span class="secno">10.5.2 </span><span class="content">Dynamic context for the target expression</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#evaluate-effect"><span class="secno">10.5.3 </span><span class="content">The effect of the xsl:evaluate instruction</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#evaluation-as-optional-feature"><span class="secno">10.5.4 </span><span class="content">Disabling xsl:evaluate</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#evaluate-examples"><span class="secno">10.5.5 </span><span class="content">Examples of xsl:evaluate</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#creating-new-nodes"><span class="secno">11 </span><span class="content">Creating Nodes</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#literal-result-element"><span class="secno">11.1 </span><span class="content">Literal Result Elements</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#setting-annotation-for-lre"><span class="secno">11.1.1 </span><span class="content">Setting the Type Annotation for Literal Result Elements</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#attributes-for-lres"><span class="secno">11.1.2 </span><span class="content">Attribute Nodes for Literal Result Elements</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#lre-namespaces"><span class="secno">11.1.3 </span><span class="content">Namespace Nodes for Literal Result Elements</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#namespace-aliasing"><span class="secno">11.1.4 </span><span class="content">Namespace Aliasing</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#xsl-element"><span class="secno">11.2 </span><span class="content">Creating Element Nodes Using xsl:element</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#xsl-element-content"><span class="secno">11.2.1 </span><span class="content">The Content of the Constructed Element Node</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#xsl-element-name"><span class="secno">11.2.2 </span><span class="content">The Name of the Constructed Element Node</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#xsl-element-properties"><span class="secno">11.2.3 </span><span class="content">Other Properties of the Constructed Element Node</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#annotation-for-constructed-element"><span class="secno">11.2.4 </span><span class="content">The Type Annotation of the Constructed Element Node</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#creating-attributes"><span class="secno">11.3 </span><span class="content">Creating Attribute Nodes Using xsl:attribute</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#annotation-for-constructed-attribute"><span class="secno">11.3.1 </span><span class="content">Setting the Type Annotation for a Constructed Attribute Node</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#creating-text-nodes"><span class="secno">11.4 </span><span class="content toc-chg">Creating Text Nodes</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#literal-text-nodes"><span class="secno">11.4.1 </span><span class="content">Literal Text Nodes</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#xsl-text"><span class="secno">11.4.2 </span><span class="content toc-chg">The xsl:text and xsl:value-of instructions</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#generating-cdata"><span class="secno">11.4.3 </span><span class="content toc-chg">Generating CDATA Sections</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#creating-document-nodes"><span class="secno">11.5 </span><span class="content">Creating Document Nodes</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#creating-processing-instructions"><span class="secno">11.6 </span><span class="content">Creating Processing Instructions</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#creating-namespace-nodes"><span class="secno">11.7 </span><span class="content">Creating Namespace Nodes</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#creating-comments"><span class="secno">11.8 </span><span class="content">Creating Comments</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#copying"><span class="secno">11.9 </span><span class="content">Copying Nodes</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#shallow-copy"><span class="secno">11.9.1 </span><span class="content">Shallow Copy</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#copy-of"><span class="secno">11.9.2 </span><span class="content">Deep Copy</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#number"><span class="secno">12 </span><span class="content">Numbering</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#start-at"><span class="secno">12.1 </span><span class="content">The start-at Attribute</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#formatting-supplied-number"><span class="secno">12.2 </span><span class="content">Formatting a Supplied Number</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#numbering-based-on-position"><span class="secno">12.3 </span><span class="content">Numbering based on Position in a Document </span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#convert"><span class="secno">12.4 </span><span class="content">Number to String Conversion Attributes</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#sorting"><span class="secno">13 </span><span class="content">Sorting</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#xsl-sort"><span class="secno">13.1 </span><span class="content">The xsl:sort Element</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#sorting-process"><span class="secno">13.1.1 </span><span class="content">The Sorting Process</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#comparing-sort-keys"><span class="secno">13.1.2 </span><span class="content toc-chg">Comparing Sort Key Values</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#collating-sequences"><span class="secno">13.1.3 </span><span class="content">Sorting Using Collations</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#creating-sorted-sequence"><span class="secno">13.2 </span><span class="content">Creating a Sorted Sequence</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#sorted-iteration"><span class="secno">13.3 </span><span class="content">Processing a Sequence in Sorted Order</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#grouping"><span class="secno">14 </span><span class="content toc-chg">Grouping</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#xsl-for-each-group"><span class="secno">14.1 </span><span class="content">The xsl:for-each-group Element</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#information-about-group"><span class="secno">14.2 </span><span class="content">Accessing Information about the Current Group Value</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#func-current-group"><span class="secno">14.2.1 </span><span class="content toc-new">fn:current-group</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-current-grouping-key"><span class="secno">14.2.2 </span><span class="content toc-new">fn:current-grouping-key</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#order-of-groups"><span class="secno">14.3 </span><span class="content">Ordering among Groups</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#grouping-examples"><span class="secno">14.4 </span><span class="content">Examples of Grouping</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#merging"><span class="secno">15 </span><span class="content toc-chg">Merging</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#merge-terminology"><span class="secno">15.1 </span><span class="content">Terminology for Merging</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#merge-instruction"><span class="secno">15.2 </span><span class="content">The xsl:merge Instruction</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#merge-input-sequences"><span class="secno">15.3 </span><span class="content">Selecting the Sequences to be Merged</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#merge-keys"><span class="secno">15.4 </span><span class="content">Defining the Merge Keys</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#current-merge-group-and-key"><span class="secno">15.5 </span><span class="content">The Current Merge Group and Key</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#func-current-merge-group"><span class="secno">15.5.1 </span><span class="content toc-new">fn:current-merge-group</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-current-merge-key-array"><span class="secno">15.5.2 </span><span class="content toc-new">fn:current-merge-key-array</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-current-merge-key"><span class="secno">15.5.3 </span><span class="content toc-new">fn:current-merge-key</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#merge-action"><span class="secno">15.6 </span><span class="content">The xsl:merge-action Element</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#merge-examples"><span class="secno">15.7 </span><span class="content">Examples of xsl:merge</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#splitting"><span class="secno">16 </span><span class="content">Splitting</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#fork-instruction"><span class="secno">16.1 </span><span class="content">The xsl:fork Instruction</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#splitting-examples"><span class="secno">16.2 </span><span class="content">Examples of Splitting with Streamed Data</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#regular-expressions"><span class="secno">17 </span><span class="content">Regular Expressions</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#analyze-string"><span class="secno">17.1 </span><span class="content toc-chg">The xsl:analyze-string Instruction</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#func-regex-group-functions"><span class="secno">17.2 </span><span class="content toc-new">Captured Groups</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#func-regex-groups"><span class="secno">17.2.1 </span><span class="content toc-new">fn:regex-groups</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-regex-group"><span class="secno">17.2.2 </span><span class="content toc-new">fn:regex-group</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#regex-examples"><span class="secno">17.3 </span><span class="content">Examples of Regular Expression Matching</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#source-document-instruction"><span class="secno">18 </span><span class="content">The xsl:source-document instruction</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#source-document-validation"><span class="secno">18.1 </span><span class="content">Validation of Source Documents</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#func-stream-available"><span class="secno">18.2 </span><span class="content toc-new">fn:stream-available</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#accumulators"><span class="secno">19 </span><span class="content">Accumulators</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#accumulator-declaration"><span class="secno">19.1 </span><span class="content">Declaring an Accumulator</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#applicability-of-accumulators"><span class="secno">19.2 </span><span class="content">Applicability of Accumulators</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#accumulator-informal-rules"><span class="secno">19.3 </span><span class="content">Informal Model for Accumulators</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#accumulator-formal-rules"><span class="secno">19.4 </span><span class="content">Formal Model for Accumulators</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#errors-in-accumulators"><span class="secno">19.5 </span><span class="content">Dynamic Errors in Accumulators</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#func-accumulator-before"><span class="secno">19.6 </span><span class="content toc-new">fn:accumulator-before</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#func-accumulator-after"><span class="secno">19.7 </span><span class="content toc-new">fn:accumulator-after</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#accumulators-visibility-and-overriding"><span class="secno">19.8 </span><span class="content">Importing of Accumulators</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#capturing-accumulators"><span class="secno">19.9 </span><span class="content toc-chg">Capturing Accumulators</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#copying-accumulators"><span class="secno">19.10 </span><span class="content">Copying Accumulator Values</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#accumulator-examples"><span class="secno">19.11 </span><span class="content">Examples of Accumulators</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#add-func"><span class="secno">20 </span><span class="content toc-chg">Additional Functions</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#func-document"><span class="secno">20.1 </span><span class="content toc-new">fn:document</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#key"><span class="secno">20.2 </span><span class="content">Keys</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#xsl-key"><span class="secno">20.2.1 </span><span class="content">The xsl:key Declaration</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-key"><span class="secno">20.2.2 </span><span class="content toc-new">fn:key</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-map-for-key"><span class="secno">20.2.3 </span><span class="content toc-new">fn:map-for-key</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#func-copy-of"><span class="secno">20.3 </span><span class="content toc-new">fn:copy-of</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#func-snapshot"><span class="secno">20.4 </span><span class="content toc-new">fn:snapshot</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#misc-func"><span class="secno">20.5 </span><span class="content">Miscellaneous Additional Functions</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#func-current"><span class="secno">20.5.1 </span><span class="content toc-new">fn:current</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-unparsed-entity-uri"><span class="secno">20.5.2 </span><span class="content toc-new">fn:unparsed-entity-uri</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-unparsed-entity-public-id"><span class="secno">20.5.3 </span><span class="content toc-new">fn:unparsed-entity-public-id</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-system-property"><span class="secno">20.5.4 </span><span class="content toc-new">fn:system-property</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-available-system-properties"><span class="secno">20.5.5 </span><span class="content toc-new">fn:available-system-properties</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#map"><span class="secno">21 </span><span class="content">Maps</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#map-instructions"><span class="secno">21.1 </span><span class="content toc-chg">Map Instructions</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#record-instructions"><span class="secno">21.1.1 </span><span class="content toc-chg">Record Instruction</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#duplicate-keys"><span class="secno">21.1.2 </span><span class="content toc-chg">Handling of duplicate keys</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#map-examples"><span class="secno">21.2 </span><span class="content">Examples using Maps</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#arrays"><span class="secno">22 </span><span class="content">Arrays</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#array-construction"><span class="secno">22.1 </span><span class="content toc-chg">Array Construction</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#arrays-streaming"><span class="secno">22.2 </span><span class="content">Arrays and Streaming</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#diagnostics"><span class="secno">23 </span><span class="content">Diagnostics</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#message"><span class="secno">23.1 </span><span class="content">Messages</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#assertions"><span class="secno">23.2 </span><span class="content">Assertions</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#extension"><span class="secno">24 </span><span class="content toc-chg">Extensibility and Fallback</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#extension-attributes"><span class="secno">24.1 </span><span class="content toc-chg">Extension Attributes</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#extension-functions"><span class="secno">24.2 </span><span class="content">Extension Functions</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#func-function-available"><span class="secno">24.2.1 </span><span class="content toc-new">fn:function-available</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#calling-extension-functions"><span class="secno">24.2.2 </span><span class="content">Calling Extension Functions</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#external-objects"><span class="secno">24.2.3 </span><span class="content">External Objects</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-type-available"><span class="secno">24.2.4 </span><span class="content toc-new">fn:type-available</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#extension-instruction"><span class="secno">24.3 </span><span class="content toc-chg">Extension Instructions</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#designating-extension-namespace"><span class="secno">24.3.1 </span><span class="content">Designating an Extension Namespace</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#func-element-available"><span class="secno">24.3.2 </span><span class="content toc-new">fn:element-available</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#fallback"><span class="secno">24.3.3 </span><span class="content">Fallback</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#result-trees"><span class="secno">25 </span><span class="content">Transformation Results</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#creating-result-trees"><span class="secno">25.1 </span><span class="content toc-chg">Creating Secondary Results</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#result-document-restrictions"><span class="secno">25.2 </span><span class="content">Restrictions on the use of xsl:result-document</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#current-output-uri"><span class="secno">25.3 </span><span class="content">The Current Output URI</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#func-current-output-uri"><span class="secno">25.3.1 </span><span class="content toc-new">fn:current-output-uri</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#validation"><span class="secno">25.4 </span><span class="content toc-chg">Validation</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#validating-constructed-nodes"><span class="secno">25.4.1 </span><span class="content">Validating Constructed Elements and Attributes</span></a><span class="exptoc collapsed"></span></summary>
                                    <ol class="toc">
                                       <li>
                                          <details>
                                             <summary><a href="#validating-using-validation-attribute"><span class="secno">25.4.1.1 </span><span class="content">Validation using the [xsl:]validation Attribute</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#validation-xsl-type"><span class="secno">25.4.1.2 </span><span class="content">Validation using the [xsl:]type Attribute</span></a></summary>
                                          </details>
                                       </li>
                                       <li>
                                          <details>
                                             <summary><a href="#id-xsi-schema-location"><span class="secno">25.4.1.3 </span><span class="content">The xsi:schemaLocation and xsi:noNamespaceSchemaLocation attributes</span></a></summary>
                                          </details>
                                       </li>
                                    </ol>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#validating-document-nodes"><span class="secno">25.4.2 </span><span class="content">Validating Document Nodes</span></a></summary>
                                 </details>
                              </li>
                              <li>
                                 <details>
                                    <summary><a href="#validating-xml-id"><span class="secno">25.4.3 </span><span class="content">Validating xml:id attributes</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#serialization"><span class="secno">26 </span><span class="content">Serialization</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#id-xsl-output-declaration"><span class="secno">26.1 </span><span class="content toc-chg">The xsl:output declaration</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#id-default-serialization-parameters"><span class="secno">26.2 </span><span class="content toc-chg">Serialization parameters</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#character-maps"><span class="secno">26.3 </span><span class="content">Character Maps</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#character-map-function"><span class="secno">26.4 </span><span class="content toc-chg">The character-map function</span></a><span class="exptoc collapsed"></span></summary>
                           <ol class="toc">
                              <li>
                                 <details>
                                    <summary><a href="#func-character-map"><span class="secno">26.4.1 </span><span class="content toc-new">fn:character-map</span></a></summary>
                                 </details>
                              </li>
                           </ol>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#disable-output-escaping"><span class="secno">26.5 </span><span class="content">Disabling Output Escaping</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#conformance"><span class="secno">27 </span><span class="content toc-chg">Conformance</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#basic-conformance"><span class="secno">27.1 </span><span class="content">Basic XSLT Processor</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#schema-aware-conformance"><span class="secno">27.2 </span><span class="content">Schema-Awareness Conformance Feature</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#serialization-feature"><span class="secno">27.3 </span><span class="content">Serialization Feature</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#backwards-compatibility-feature"><span class="secno">27.4 </span><span class="content">Compatibility Features</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#streaming-feature"><span class="secno">27.5 </span><span class="content">Streaming Feature</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#references"><span class="secno">A </span><span class="content">References</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#normative-references"><span class="secno">A.1 </span><span class="content">Normative References</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#other-references"><span class="secno">A.2 </span><span class="content">Other References</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#glossary"><span class="secno">B </span><span class="content">Glossary</span></a></summary>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#element-syntax-summary"><span class="secno">C </span><span class="content">Element Syntax Summary</span></a></summary>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#error-summary"><span class="secno">D </span><span class="content">Summary of Error Conditions</span></a></summary>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#pattern-syntax-summary"><span class="secno">E </span><span class="content">Pattern Syntax Summary</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#ebnf-for-patterns"><span class="secno">E.1 </span><span class="content"></span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#terminal-symbols"><span class="secno">E.2 </span><span class="content">Terminal Symbols</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#implementation-defined-features"><span class="secno">F </span><span class="content">Checklist of Implementation-Defined Features</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#imp-def-api"><span class="secno">F.1 </span><span class="content">Application Programming Interfaces</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#imp-def-ext"><span class="secno">F.2 </span><span class="content">Vendor and User Extensions</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#imp-def-feature"><span class="secno">F.3 </span><span class="content">Localization</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#imp-def-optional-feature"><span class="secno">F.4 </span><span class="content">Optional Features</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#imp-def-dependencies"><span class="secno">F.5 </span><span class="content">Dependencies</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#imp-def-defaults-and-limits"><span class="secno">F.6 </span><span class="content">Defaults and Limits</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#imp-def-errors"><span class="secno">F.7 </span><span class="content">Detection and Reporting of Errors</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#summary-list-of-functions"><span class="secno">G </span><span class="content">Summary of Available Functions</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#function-categories"><span class="secno">G.1 </span><span class="content">Function Classification</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#XSLT-defined-functions"><span class="secno">G.2 </span><span class="content">List of XSLT-defined functions</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#schema-for-xslt"><span class="secno">H </span><span class="content">Schemas for XSLT 4.0 Stylesheets</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#xsd11-schema-for-xslt"><span class="secno">H.1 </span><span class="content">XSD 1.1 Schema for XSLT Stylesheets</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#relax-ng-schema-for-xslt"><span class="secno">H.2 </span><span class="content">Relax-NG Schema for XSLT Stylesheets</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#changes-since-3.0"><span class="secno">I </span><span class="content">Changes since XSLT 3.0</span></a><span class="exptoc collapsed"></span></summary>
                  <ol class="toc">
                     <li>
                        <details>
                           <summary><a href="#xslt-changes-since-3.0"><span class="secno">I.1 </span><span class="content">Changes in this specification</span></a></summary>
                        </details>
                     </li>
                     <li>
                        <details>
                           <summary><a href="#xpath-changes-since-3.1"><span class="secno">I.2 </span><span class="content">Changes in Other Related Specifications</span></a></summary>
                        </details>
                     </li>
                  </ol>
               </details>
            </li>
            <li>
               <details>
                  <summary><a href="#incompatibilities"><span class="secno">J </span><span class="content">Incompatibilities with XSLT 3.0</span></a></summary>
               </details>
            </li>
         </ol>
      </nav>
      <hr>
      <div class="body">
         <div class="div1">
            
            <h2><a id="introduction"></a>1 <a href="#introduction" style="text-decoration: none">Introduction</a></h2>
            <div class="div2">
               
               <h3><a id="what-is-xslt"></a>1.1 <a href="#what-is-xslt" style="text-decoration: none">What is XSLT?</a></h3>
               <p>XSLT is a programming language designed principally to transform data.</p>
               <p>A transformation in the XSLT language is expressed in the
               form of a <b>stylesheet</b>. A stylesheet is made up of one or more well-formed
               XML <a href="#REC-xml">[XML 1.0]</a> documents conforming to the Namespaces in XML
               Recommendation <a href="#xml-names">[Namespaces in XML]</a>. </p>
               <p>A stylesheet generally includes elements that are defined by XSLT as well as elements
               that are not defined by XSLT. XSLT-defined elements are distinguished by use of the
               namespace <code>http://www.w3.org/1999/XSL/Transform</code> (see <a href="#xslt-namespace"><i>3.1.1 XSLT Namespace</i></a>), which is referred to in this specification as the
                  <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. Thus this specification
               is a definition of the syntax and semantics of the XSLT namespace.</p>
               <p>The term <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> reflects the fact that one
               of the important roles of XSLT is to add styling information to an XML source
               document, by transforming it into a document consisting of XSL formatting objects
               (see <a href="#xsl11">[XSL-FO]</a>), or into another presentation-oriented format such as
               HTML, XHTML, or SVG. However, XSLT is used for a wide range of transformation tasks,
               not exclusively for formatting and presentation applications.</p>
               <p>A transformation expressed in XSLT describes rules for transforming input data into output data. The inputs and outputs
                  will all be instances of the XDM data model, described in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. In the simplest and most common case, the input is
                  an XML document referred to as the source document or <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>, and the output is an XML document
                  referred to as the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. It is also possible to process multiple source
                  documents, to generate multiple result documents, and to handle formats other than
                  XML.</p>
               <p>The transformation is achieved by a set of
                  <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>. A template rule
               associates a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, which typically matches nodes in the source document, with a
                  <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. In many
               cases, evaluating the sequence constructor will cause new nodes to be constructed,
               which can be used to produce part of a result tree. The structure of the result trees
               can be completely different from the structure of the source trees. In constructing a
               result tree, nodes from the source trees can be filtered and reordered, and arbitrary
               structure can be added. Because <a title="pattern" class="termref" href="#dt-pattern">pattern</a>s can
               point to nodes according to typological features, a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> 
               can be applicable to a wide class of source documents that have similar tree structures.</p>
               <p>Stylesheets are modular; they may contain several packages developed
               independently of each other, and each package may consist of several stylesheet
               modules. </p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet" title="stylesheet"></a>A
                     <b>stylesheet</b> consists of one or more packages: specifically, one
                     <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> and zero or
                  more <a title="library package" class="termref" href="#dt-library-package">library packages</a>.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-top-level-package" title="top-level package"></a>For a given transformation, one <a title="package" class="termref" href="#dt-package">package</a> functions as the <b>top-level package</b>. The
                  complete <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is assembled by finding
                  the packages referenced directly or indirectly from the top-level package using
                     <a href="#element-use-package"><code>xsl:use-package</code></a> declarations: see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-library-package" title="library package"></a>Every <a title="package" class="termref" href="#dt-package">package</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, other than the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, is referred to as a
                     <b>library package</b>.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-principal-stylesheet-module" title="principal stylesheet module"></a>Within a <a title="package" class="termref" href="#dt-package">package</a>, one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> functions as the
                     <b>principal stylesheet module</b>. The complete package is assembled by
                  finding the stylesheet modules referenced directly or indirectly from the
                  principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and
                     <a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><i>3.10.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.10.3 Stylesheet Import</i></a>.<span class="definition">]</span></p>
            </div>
            <div class="div2">
               
               <h3><a id="whats-new-in-xslt4"></a>1.2 <a href="#whats-new-in-xslt4" style="text-decoration: none">What’s New in XSLT 4.0?</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#terminology">next</a>)</p>
                  <ol>
                     <li>
                        <p>If a section of this specification has been updated since version 3.0,
                   an overview of the changes is provided, along with links to
                   navigate to the next or previous change.</p>
                     </li>
                     <li>
                        <p>Sections with significant changes are marked with a ✭ symbol in the
                   table of contents.</p>
                     </li>
                  </ol>
               </div>
               <p>XSLT 4.0 is a revised version of the XSLT 3.0 Recommendation <a href="#xslt-30">[XSLT 3.0]</a>
               published on 8 June 2017.</p>
               <p>The changes in this version of the language are relatively minor usability enhancements. There
               are no changes to the data model or processing model. Instead, the specification attempts to fill
               a number of gaps in functionality resulting from feedback from XSLT 3.0 users. The main areas
               covered are:</p>
               <ul>
                  <li>
                     <p>Enhancements to the type system to allow more expressive constraints, especially
                  for maps and atomic items.</p>
                  </li>
                  <li>
                     <p>Additional functionality for processing arrays.</p>
                  </li>
                  <li>
                     <p>Exploitation of the power afforded by first-class function items.</p>
                  </li>
               </ul>
               <p>XSLT 4.0 also includes optional facilities to serialize the results of a transformation,
               by means of an interface to the serialization component described in 
               <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>.
            </p>
               <p>XSLT 4.0 requires support for XPath 4.0.</p>
               <p>A full list of changes is at <a href="#changes-since-3.0"><i>I Changes since XSLT 3.0</i></a>.</p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="concepts"></a>2 <a href="#concepts" style="text-decoration: none">Concepts</a></h2>
            <div class="div2">
               
               <h3><a id="terminology"></a>2.1 <a href="#terminology" style="text-decoration: none">Terminology</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#stylesheets-and-schemas">next</a> | <a href="#whats-new-in-xslt4">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The term <b>atomic value</b> has been replaced by <b>atomic item</b>.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1337">1337</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361</a>&nbsp;2 August 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p>For a full glossary of terms, see <a href="#glossary"><i>B Glossary</i></a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-processor" title="processor"></a>The software responsible for transforming
                  source trees into result trees using an XSLT stylesheet is referred to as the
                     <b>processor</b>. This is sometimes expanded to <em>XSLT
                     processor</em> to avoid any confusion with other processors, for example an
                  XML processor.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-implementation" title="implementation"></a>A specific product that
                  performs the functions of an <a title="processor" class="termref" href="#dt-processor">XSLT processor</a>
                  is referred to as an <b>implementation</b>.<span class="definition">]</span></p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-tree" title="tree"></a>The term <b>tree</b> is used (as in <a href="#xpath-datamodel-40">[XDM 4.0]</a>) to refer to the aggregate consisting of a
                  parentless node together with all its descendant nodes, plus all their attributes
                  and namespaces.<span class="definition">]</span>
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The use of the term <b>tree</b> in this document in phrases such as <b>source
                     tree</b>, <b>result tree</b>, and <b>temporary tree</b> does not imply the use
                     of a data structure in memory that holds the entire contents of the document at
                     one time. It implies rather a logical view of the XML input and output in which
                     elements have a hierarchic relationship to each other. When a source document
                     is being processed in a streaming manner, access to the nodes in this tree is
                     constrained, but it is still viewed and described as a tree.</p>
               </div>
               <p>The output of a transformation consists of the
               following:</p>
               <ol class="enumar">
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-principal-result" title="principal result"></a>A <b>principal
                           result</b>: this can be any sequence of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).<span class="definition">]</span> The principal result is the value
                     returned by the function or template in the stylesheet that is nominated as the
                     entry point, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.</p>
                  </li>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-secondary-result" title="secondary result"></a>Zero or more
                           <b>secondary results</b>: each secondary result can be any sequence
                        of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).<span class="definition">]</span> A
                     secondary result is the value returned by evaluating the body of an
                        <a href="#element-result-document"><code>xsl:result-document</code></a> instruction.</p>
                  </li>
                  <li>
                     <p>Zero or more messages. Messages are generated by the
                        <a href="#element-message"><code>xsl:message</code></a> and <a href="#element-assert"><code>xsl:assert</code></a> instructions, and are described in <a href="#message"><i>23.1 Messages</i></a> and <a href="#assertions"><i>23.2 Assertions</i></a>.</p>
                  </li>
                  <li>
                     <p>Static or dynamic errors: see <a href="#errors"><i>2.12 Error Handling</i></a>. </p>
                  </li>
               </ol>
               <p>The <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> and the <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a> may be post-processed as
               described in <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-result-tree" title="result tree"></a>The term <b>result tree</b> is
                  used to refer to any <a title="tree" class="termref" href="#dt-tree">tree</a> constructed by <a title="instruction" class="termref" href="#dt-instruction">instructions</a> in the stylesheet. A result tree is
                  either a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> or a
                     <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a>.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-final-result-tree" title="final result tree"></a>A <b>final result
                     tree</b> is a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that forms
                  part of the output of a transformation: specifically, a tree built by post-processing the items in the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or in a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. Once created, the contents of a final result tree are not
                  accessible within the stylesheet itself.<span class="definition">]</span>
                Any final result tree
                  <span class="verb">may</span> be serialized as described in <a href="#serialization"><i>26 Serialization</i></a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-source-tree" title="source tree"></a>The term <b>source tree</b>
                  means any tree provided as input to the transformation. This includes the document
                  containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if any, documents containing
                     nodes present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>,
                  documents containing nodes supplied as the values of <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, documents
                  obtained from the results of functions such as <a href="#func-document"><code>document</code></a>,
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a>, documents read using the <a href="#element-source-document"><code>xsl:source-document</code></a>
                     instruction, and documents returned by extension functions or
                  extension instructions. In the context of a particular XSLT instruction, the term
                     <b>source tree</b> means any tree provided as input to that instruction;
                  this may be a source tree of the transformation as a whole, or it may be a
                     <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> produced during the
                  course of the transformation.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-temporary-tree" title="temporary tree"></a>The term <b>temporary
                     tree</b> means any tree that is neither a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> nor a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                     tree</a>.<span class="definition">]</span> Temporary trees are used to hold intermediate results
               during the execution of the transformation.</p>
               <p>Unless otherwise stated, the term “tree” refers to a tree rooted
                  at a parentless node: that is, the term does not include subtrees of larger trees.
                  Every node therefore belongs to exactly one tree.</p>
               <p>In this specification the phrases <span class="verb">must</span>, <span class="verb">must
                  not</span>, <span class="verb">should</span>, <span class="verb">should not</span>,
                  <span class="verb">may</span>, <span class="verb">required</span>, and
                  <span class="verb">recommended</span>, when used in normative
                  text and rendered in small capitals, are to be interpreted as described in
                  <a href="#rfc2119">[RFC2119]</a>.</p>
               <p>Where the phrase <span class="verb">must</span>, <span class="verb">must not</span>, or
                  <span class="verb">required</span> relates to the behavior of the XSLT processor, then an
               implementation is not conformant unless it behaves as specified, subject to the more
               detailed rules in <a href="#conformance"><i>27 Conformance</i></a>. </p>
               <p>Where the phrase <span class="verb">must</span>, <span class="verb">must not</span>, or
                  <span class="verb">required</span> relates to a stylesheet then the processor
                  <span class="verb">must</span> enforce this constraint on stylesheets by raising an
               error if the constraint is not satisfied.</p>
               <p>Where the phrase <span class="verb">should</span>, <span class="verb">should not</span>, or
                  <span class="verb">recommended</span> relates to a stylesheet then a processor
                  <span class="verb">may</span> produce warning messages if the constraint is not
               satisfied, but <span class="verb">must not</span> treat this as an error.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-implementation-defined" title="implementation-defined"></a>In this
                  specification, the term <b>implementation-defined</b> refers to a feature
                  where the implementation is allowed some flexibility, and where the choices made
                  by the implementation <span class="verb">must</span> be described in documentation that
                  accompanies any conformance claim.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-implementation-dependent" title="implementation-dependent"></a>The term
                     <b>implementation-dependent</b> refers to a feature where the behavior
                     <span class="verb">may</span> vary from one implementation to another, and where the
                  vendor is not expected to provide a full specification of the behavior.<span class="definition">]</span>
               (This might apply, for example, to limits on the size of source documents that can be
               transformed.)</p>
               <p>In all cases where this specification leaves the behavior implementation-defined or
               implementation-dependent, the implementation has the option of providing mechanisms
               that allow the user to influence the behavior.</p>
               <p>A paragraph labeled as a <b>Note</b> or described as an <b>example</b> is
               non-normative.</p>
               <p>Many terms used in this document are defined in the XPath specification <a href="#xpath-40">[XPath 4.0]</a> or the XDM specification <a href="#xpath-datamodel-40">[XDM 4.0]</a>.
               Particular attention is drawn to the following:</p>
               <ul>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-atomization" title="atomize"></a>The term <b>atomization</b>
                        is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-atomization">2.6.3 Atomization</a>. It is a process that takes as input a sequence of
                        items, and returns a sequence of
                        atomic items, in which the nodes are replaced by their typed values as
                        defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. 
                         Arrays (see <a href="#arrays"><i>22 Arrays</i></a>) are atomized by atomizing their
                        members, recursively.<span class="definition">]</span> For some items (for example, elements with element-only
                     content, function items, and maps, atomization
                     raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>.</p>
                  </li>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-typed-value" title="typed value"></a>The term <b>typed
                           value</b> is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-typed-value">7.6.14 typed-value Accessor</a>.
                        Every node, other than an element whose type
                           annotation identifies it as having element-only content, has a
                           <a title="string value" class="termref" href="#dt-string-value">typed value</a>. For example, the
                           <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of an attribute of
                        type <code>xs:IDREFS</code> is a sequence of zero or more
                           <code>xs:IDREF</code> values.<span class="definition">]</span>
                  </p>
                  </li>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-string-value" title="string value"></a>The term <b>string
                           value</b> is defined in
                           <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-string-value">7.6.12 string-value Accessor</a>. Every node has a <a title="string value" class="termref" href="#dt-string-value">string value</a>. For example, the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an element is the concatenation of the
                           <a title="string value" class="termref" href="#dt-string-value">string values</a> of all its
                        descendant text nodes.<span class="definition">]</span>
                  </p>
                  </li>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-xpath-compat-mode" title="XPath 1.0 compatibility mode"></a>The term
                           <b>XPath 1.0 compatibility mode</b> is defined in 
                        <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. This is a setting in the static
                        context of an XPath expression; it has two values, <code>true</code> and
                           <code>false</code>. When the value is set to <code>true</code>, the semantics of
                        function calls and certain other operations are adjusted to give a greater
                        degree of backwards compatibility between XPath
                        <span>4.0</span> and XPath 1.0.<span class="definition">]</span>
                  </p>
                  </li>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-function-definition" title="function definition"></a>The term
                        <b>function definition</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. 
                        It is the definition of a function that can be called statically from within an XPath
                        expression: in the case of XSLT it typically means either a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>,
                        or a built-in function such as those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a><span class="definition">]</span>
                  </p>
                  </li>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-arity-range" title="arity range"></a>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a>
                        has an <b>arity range</b>, which defines the minimum and maximum number of arguments
                        that must be supplied in a call to the function. The static context can contain multiple
                        <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> with the same name, 
                        provided that their <b>arity ranges</b> do not overlap.<span class="definition">]</span>
                      
                  </p>
                  </li>
               </ul>
            </div>
            <div class="div2">
               
               <h3><a id="notation"></a>2.2 <a href="#notation" style="text-decoration: none">Notation</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-element" title="XSLT element"></a>An <b>XSLT element</b> is an
                  element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose
                  syntax and semantics are defined in this specification.<span class="definition">]</span> For a
               non-normative list of XSLT elements, see <a href="#element-syntax-summary"><i>C Element Syntax Summary</i></a>.</p>
               <p>In this document the specification of each <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT
                  element</a> is preceded by a summary of its syntax in the form of a model
               for elements of that element type. A full list of all these specifications can be
               found in <a href="#element-syntax-summary"><i>C Element Syntax Summary</i></a>. The meaning of the syntax summary
               notation is as follows:</p>
               <ul>
                  <li>
                     <p>An attribute that is <span class="verb">required</span> is shown with its name in
                     bold. An attribute that may be omitted is shown with a question mark following
                     its name.</p>
                  </li>
                  <li>
                     <p>An attribute that is <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a> is shown
                     in a grayed font within square brackets.</p>
                  </li>
                  <li>
                     <p>The string that occurs in the place of an attribute value specifies the allowed
                     values of the attribute. If this is surrounded by curly brackets
                        (<code>{...}</code>), then the attribute value is treated as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, and
                     the string occurring within curly brackets specifies the allowed values of the
                     result of evaluating the attribute value template. Alternative allowed values
                     are separated by <code>|</code>. A quoted string indicates a value equal to
                     that specific string. An unquoted, italicized name specifies a particular type
                     of value.</p>
                     <p>The types used, and their meanings, are as follows:</p>
                     <dl>
                        <dt class="label">
                           <code>boolean</code>
                           </dt>
                        <dd>
                           <p>One of the strings <code>"yes"</code>,
                              <code>"true"</code>, or <code>"1"</code> to indicate the value
                              <code>true</code>, or one of the strings <code>"no"</code>,
                              <code>"false"</code>, or <code>"0"</code> to indicate the value
                              <code>false</code>. Note: the values are synonyms; where this
                              specification uses a phrase such as “If <code>required='yes'</code> is
                              specified ...” this is to be interpreted as meaning “If the attribute
                              named <code>required</code> is present, and has the value
                              <code>yes</code>, <code>true</code>, or <code>1</code> (after
                              stripping leading and trailing whitespace) ...”.
                           </p>
                        </dd>
                        <dt class="label"><code>string</code></dt>
                        <dd>
                           <p>Any string.</p>
                        </dd>
                        <dt class="label"><code>expression</code></dt>
                        <dd>
                           <p>An XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p>
                        </dd>
                        <dt class="label"><code>pattern</code></dt>
                        <dd>
                           <p>A <a title="pattern" class="termref" href="#dt-pattern">pattern</a> as described in
                                 <a href="#patterns"><i>6.3 Patterns</i></a>.</p>
                        </dd>
                        <dt class="label"><code>item-type</code></dt>
                        <dd>
                           <p>An <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup> as defined in the XPath
                              <span>4.0</span> specification.</p>
                        </dd>
                        <dt class="label"><code>sequence-type</code></dt>
                        <dd>
                           <p>A <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>
                              as defined in the XPath <span>4.0</span> specification.</p>
                        </dd>
                        <dt class="label"><code>uri; uris</code></dt>
                        <dd>
                           <p>A URI, for example a namespace URI or a collation URI; a
                              whitespace-separated list of URIs.</p>
                        </dd>
                        <dt class="label"><code>qname</code></dt>
                        <dd>
                           <p>A <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> as defined
                              in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p>
                        </dd>
                        <dt class="label"><code>eqname; eqnames</code></dt>
                        <dd>
                           <p>An <a title="EQName" class="termref" href="#dt-eqname">EQName</a> as defined in <a href="#qname"><i>5.1.1 Qualified Names</i></a>; a whitespace-separated list of EQNames.</p>
                        </dd>
                        <dt class="label"><code>token; tokens</code></dt>
                        <dd>
                           <p>A string containing no significant whitespace; a whitespace-separated
                              list of such strings.</p>
                        </dd>
                        <dt class="label"><code>nmtoken; nmtokens</code></dt>
                        <dd>
                           <p>A string conforming to the XML schema rules for the type
                                 <code>xs:NMTOKEN</code>; a whitespace-separated list of such
                              strings.</p>
                        </dd>
                        <dt class="label"><code>char</code></dt>
                        <dd>
                           <p>A string comprising a single Unicode character.</p>
                        </dd>
                        <dt class="label"><code>language</code></dt>
                        <dd>
                           <p>A string in the value space of <code>xs:language</code>, or a zero-length string.</p>
                        </dd>
                        <dt class="label"><code>integer</code></dt>
                        <dd>
                           <p>An integer, that is, a string <span>that is castable to</span> the schema type
                                 <code>xs:integer</code>.</p>
                        </dd>
                        <dt class="label"><code>decimal</code></dt>
                        <dd>
                           <p>A decimal value, that is, a string <span>that is castable to</span> the schema
                              type <code>xs:decimal</code>.</p>
                        </dd>
                        <dt class="label"><code>ncname</code>; <span><code>ncnames</code></span></dt>
                        <dd>
                           <p>An unprefixed name: a string <span>that is castable to</span> the schema type
                                 <code>xs:NCName</code>; <span>a whitespace-separated list of such strings</span>.</p>
                        </dd>
                        <dt class="label"><code>prefix</code><span>; <code>prefixes</code></span></dt>
                        <dd>
                           <p>An <code>xs:NCName</code> representing a namespace prefix, which must
                              be in scope for the element on which it appears;
                              <span>a whitespace-separated list of such strings</span>.</p>
                        </dd>
                        <dt class="label"><code>id</code></dt>
                        <dd>
                           <p>An <code>xs:NCName</code> used as a unique identifier for an element
                              in the containing XML document.</p>
                        </dd>
                     </dl>
                     <p>Except where the set of allowed values of an attribute is specified using the
                     italicized name <em>string</em> or <em>char</em>, leading and trailing
                     whitespace in the attribute value is ignored. In the case of an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, this
                     applies to the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                     obtained when the attribute value template is expanded.</p>
                     <p>XPath comments (delimited by <code>(: ... :)</code>)
                  are permitted anywhere that inter-token whitespace is permitted in attributes whose
                  type is given as <em>expression</em>, <em>pattern</em>, <em>item-type</em>, 
                     or <em>sequence-type</em>, and are not permitted in attributes of other types
                     (other than within expressions enclosed by curly braces within an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>).</p>
                  </li>
                  <li>
                     <p>If an attribute has a simple default value, this is shown between tortoise-shell
                  brackets (for example <code>〔'no'〕</code>). Where no default is shown,
                  the consequence of omitting the attribute is explained in the prose narrative. 
                  Default values shown in the summary apply only where the attribute itself
                  is applicable; if an attribute is not permitted to appear in the particular context,
                  then its default value should be ignored. (For example, the <code>stable</code>
                     attribute of <a href="#element-sort"><code>xsl:sort</code></a> is shown as having a default value
                     of <code>'yes'</code>, but the attribute is allowed only on the
                     first of a sequence of adjacent <a href="#element-sort"><code>xsl:sort</code></a> elements.) 
                     The quotation marks around a default value are not part of the value.</p>
                  </li>
                  <li>
                     <p>Unless the element is <span class="verb">required</span> to be empty, the model
                     element contains a comment specifying the allowed content. The allowed content
                     is specified in a way similar to an element type declaration in XML;
                        <em>sequence constructor</em> means that any mixture of text nodes,
                        <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>,
                        <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>,
                     and <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a> from the <a title="instruction" class="termref" href="#dt-instruction">instruction</a> category is allowed;
                        <em>other-declarations</em> means that any mixture of XSLT elements from
                     the <a title="declaration" class="termref" href="#dt-declaration">declaration</a> category is allowed, together with <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>.</p>
                  </li>
                  <li>
                     <p>The element is prefaced by comments indicating if it belongs to the
                        <code>instruction</code> category or <code>declaration</code> category or
                     both. The category of an element affects only whether it is allowed in the
                     content of elements that allow a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> or <em>other-declarations</em>.</p>
                  </li>
               </ul>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e1013"></a>Example: Syntax Notation</div>
                  <p>This example illustrates the notation used to describe <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>.</p>
                  <p class="element-syntax"><a id="element-example-element"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:example-element<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;debug? = <var>boolean</var><br>&nbsp;&nbsp;validation? = { "strict" | "lax" }〔strict〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a>)*, <a href="#element-sequence">xsl:sequence</a>) --&gt;<br>&lt;/xsl:example-element&gt;</code></p>
                  <p>This example defines a (non-existent) element <code>xsl:example-element</code>.
                  The element is classified as an instruction. It takes the following
                  attributes:</p>
                  <ol class="enumar">
                     <li>
                        <p>A mandatory <code>select</code> attribute, whose value is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a></p>
                     </li>
                     <li>
                        <p>An optional <code>debug</code> attribute, whose
                        value <span class="verb">must</span> be <code>yes</code>, <code>true</code>, or
                           <code>1</code> to indicate <code>true</code>, or <code>no</code>,
                           <code>false</code>, or <code>0</code> to indicate <code>false</code>.</p>
                     </li>
                     <li>
                        <p>An optional <code>validation</code> attribute, whose value must be
                           <code>strict</code> or <code>lax</code>; the curly brackets indicate that
                        the value can be defined as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, allowing a value such as
                           <code>validation="{ $val }"</code>, where the <a title="variable" class="termref" href="#dt-variable">variable</a>
                        <code>val</code> is evaluated to yield <code>"strict"</code> or
                        <code>"lax"</code> at run-time. The value <code>strict</code> in tortoise-shell
                        brackets indicates the default value, if the attribute is not present.</p>
                     </li>
                  </ol>
                  <p>The content of an <code>xsl:example-element</code> instruction is defined to be a
                  sequence of zero or more <a href="#element-variable"><code>xsl:variable</code></a> and
                     <a href="#element-param"><code>xsl:param</code></a> elements, followed by an
                     <a href="#element-sequence"><code>xsl:sequence</code></a> element.</p>
               </div>
               <p>
               <a id="err-XTSE0010"><span class="error">[ERR XTSE0010] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                     XSLT-defined element is used in a context where it is not permitted, if a
                        <span class="verb">required</span> attribute is omitted, or if the content of the
                     element does not correspond to the content that is allowed for the element.
            </p>
               <p>The rules in the element syntax summary (both for the
               element structure and for its attributes) apply to the stylesheet content after
               preprocessing as described in <a href="#preprocessing"><i>3.11 Stylesheet Preprocessing</i></a>.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-effective-value" title="effective value"></a>The <b>effective value</b>
            of an attribute or text node in the stylesheet is the value after any required expansion or normalization.<span class="definition">]</span></p>
               <p>More specifically, the effective value is the value after:</p>
               <ul>
                  <li>
                     <p>Expanding shadow attributes as described in <a href="#shadow-attributes"><i>3.11.4 Shadow Attributes</i></a>;</p>
                  </li>
                  <li>
                     <p>Expanding defaults (for example, if an <a href="#element-message"><code>xsl:message</code></a> instruction has
                  no <code>terminate</code> attribute, then the effective value of the <code>terminate</code> attribute
                  is <code>no</code>);</p>
                  </li>
                  <li>
                     <p>Stripping ignored whitespace (for example, the effective value of a boolean attribute written as
                  <code>terminate="  no  "</code> is <code>no</code>);</p>
                  </li>
                  <li>
                     <p>Replacing synonyms (for example in boolean attributes, <code>1</code> and <code>true</code>
                  are synonyms of <code>yes</code>);</p>
                  </li>
                  <li>
                     <p>Expanding <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> and 
                  <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>.</p>
                  </li>
                  <li>
                     <p>Applying rules from the static context: for example, the effective value of a <code>collation</code>
                  attribute is the value after expanding a relative URI against the static base URI.</p>
                  </li>
               </ul>
               <p>Attributes are validated as follows. These rules apply to the value of the attribute
               after removing leading and trailing whitespace.</p>
               <ul>
                  <li>
                     <p>
                     <a id="err-XTSE0020"><span class="error">[ERR XTSE0020] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                           attribute (other than an attribute written using curly brackets in a
                           position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute
                              value template</a> is permitted) contains a value that is not
                           one of the permitted values for that attribute.
                  </p>
                  </li>
                  <li>
                     <p>
                     <a id="err-XTDE0030"><span class="error">[ERR XTDE0030] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute
                           written using curly brackets, in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>
                           is permitted, is a value that is not one of the permitted values for that
                           attribute. If the processor is able to detect the error statically (for
                           example, when any XPath expressions within the curly brackets can be
                           evaluated statically), then the processor may optionally raise this as a
                           static error.
                  </p>
                  </li>
               </ul>
               <p>Special rules apply if the construct appears in part of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that is processed with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>: see <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-deprecated" title="deprecated"></a>Some constructs defined in this
                  specification are described as being <b>deprecated</b>. The use of this term
                  implies that stylesheet authors <span class="verb">should not</span> use the construct,
                  and that the construct may be removed in a later version of this
                  specification.<span class="definition">]</span></p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This specification includes a non-normative XML Schema for XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> (see <a href="#schema-for-xslt"><i>H Schemas for XSLT 4.0 Stylesheets</i></a>). The syntax summaries described in this section are
                  normative.</p>
               </div>
               <p>XSLT defines a set of standard functions which are additional to those defined in
                  <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. A list of these
                  functions appears in <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>. The
               signatures of these functions are described using the same notation as used in
                  <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. The names of many
                  of these functions are in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="initiating"></a>2.3 <a href="#initiating" style="text-decoration: none">Initiating a Transformation</a></h3>
               <p>This document does not specify any application programming interfaces or other
               interfaces for initiating a transformation. This section, however, describes the
               information that is supplied when a transformation is initiated. Except where
               otherwise indicated, the information is <span class="verb">required</span>.</p>
               <p>The execution of a stylesheet necessarily involves two activities: static analysis
               and dynamic evaluation. Static analysis consists of those tasks that can be performed
               by inspection of the stylesheet alone, including the
                  binding of <a title="static variable" class="termref" href="#dt-static-variable">static variables</a>,
               the evaluation of <code>[xsl:]use-when</code> expressions (see <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>) and shadow attributes
                  (see <a href="#shadow-attributes"><i>3.11.4 Shadow Attributes</i></a>), and the detection of <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Dynamic evaluation consists of
               tasks which in general cannot be carried out until a source document is
               available.</p>
               <p>Dynamic evaluation is further divided into two activities:
                  <b>priming</b> the stylesheet, and <b>invoking</b> a selected
               component. </p>
               <ul>
                  <li>
                     <p>Priming the stylesheet provides the dynamic context for evaluation, and
                     supplies all the information needed to establish the values of global
                     variables.</p>
                  </li>
                  <li>
                     <p>Invoking a component (such as a template or function) causes evaluation of that
                     template or function to produce a result, which is an arbitrary XDM value.</p>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-raw-result" title="raw result"></a>The result of invoking the
                        selected component, after any required conversion to the declared result
                        type of the component, is referred to as the <b>raw
                        result</b>.<span class="definition">]</span></p>
                     <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation
                  is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
                  contained in the target template or function, modified by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>
                     to convert the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> to the type declared in the <code>as</code>
                  attribute of the <a href="#element-template"><code>xsl:template</code></a> or <a href="#element-function"><code>xsl:function</code></a> declaration, if present.</p>
                     <p>This raw result may optionally be post-processed to construct a result tree, to
                     serialize the result, or both, as described in <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>.</p>
                  </li>
               </ul>
               <p>Implementations <span class="verb">may</span> allow static analysis and dynamic evaluation
               to be initiated independently, so that the cost of static analysis can be amortized
               over multiple transformations using the same stylesheet. Implementations <span class="verb">may</span> also allow priming of a stylesheet and
                  invocation of components to be initiated independently, in which case a single act
                  of priming the stylesheet may be followed by a series of independent component
                  invocations. Although this specification does not require such a separation, this
                  section distinguishes information that is needed before static analysis can
                  proceed, information that is needed to prime the stylesheet, and information that
                  is needed when invoking components.</p>
               <p>The language is designed to allow the static analysis of each
                  <a title="package" class="termref" href="#dt-package">package</a> to be performed independently of other packages, with
               only basic knowledge of the properties of components made available by used packages.
               Beyond this, the specification leaves it to implementations to decide how to organize
               this process. When packages are not used explicitly, the entire stylesheet is treated
               as a single package.</p>
               <div class="div3">
                  
                  <h4><a id="info-for-static-analysis"></a>2.3.1 <a href="#info-for-static-analysis" style="text-decoration: none">Information needed for Static Analysis</a></h4>
                  <p>The following information is needed prior to static analysis
                     of a package:</p>
                  <ul>
                     <li>
                        <p>The location of the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>,
                        or in the absence of a package manifest, the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is to act as
                        the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet
                           module</a>
                        of the <a title="package" class="termref" href="#dt-package">package</a>. The complete <a title="package" class="termref" href="#dt-package">package</a> is
                        assembled by recursively expanding the <a href="#element-import"><code>xsl:import</code></a> and
                           <a href="#element-include"><code>xsl:include</code></a> declarations in the principal stylesheet
                        module, as described in <a href="#include"><i>3.10.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.10.3 Stylesheet Import</i></a>. </p>
                     </li>
                     <li>
                        <p>Information about the packages referenced from this
                        package using <a href="#element-use-package"><code>xsl:use-package</code></a> declarations. The information
                        needed will include the names and signatures of public components exported
                        by the referenced package.</p>
                     </li>
                     <li>
                        <p>A set (possibly empty) of values for <a title="static parameter" class="termref" href="#dt-static-parameter">static parameters</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>). These values are available for use within
                           <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a> (notably
                        in <code>[xsl:]use-when</code> expressions and shadow attributes) as well as
                        non-static expressions in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. As a minimum, values <span class="verb">must</span> be
                        supplied for any static parameters declared with the attribute
                           <code>required="yes"</code>.</p>
                     </li>
                  </ul>
                  <p>Conceptually, the output of the static analysis of a package is
                  an object which might be referred to (without constraining the implementation) as
                  a compiled package. Prior to dynamic evaluation, all the compiled packages needed
                  for execution must be checked for consistency, and component references must be
                  resolved. This process may be referred to, again without constraining the
                  implementation, as linking.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="priming-stylesheet"></a>2.3.2 <a href="#priming-stylesheet" style="text-decoration: none">Priming a Stylesheet</a></h4>
                  <p>The information needed when priming a stylesheet is as
                  follows:</p>
                  <ul>
                     <li>
                        <p>A set (possibly empty) of values for non-static
                        <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> (see
                           <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>). These values are available for use
                        within <a title="expression" class="termref" href="#dt-expression">expressions</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. As a minimum, values
                           <span class="verb">must</span> be supplied for any parameters declared with the
                        attribute <code>required="yes"</code>.</p>
                        <p>A supplied value is converted if necessary to the declared
                        type of the stylesheet parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>Non-static stylesheet parameters are implicitly
                           <code>public</code>, which ensures that all the parameters in the
                           stylesheet for which values can be supplied externally have distinct
                           names. Static parameters, by contrast,
                              are local to a package.</p>
                        </div>
                     </li>
                     <li>
                        <p>
                        <span class="definition">[Definition:&nbsp;</span><a id="dt-global-context-item" title="global context item"></a>An item that is the <b>global
                                 context item</b> for the transformation acts
                           as the <a title="context item" class="termref" href="#dt-context-item">context item</a> when evaluating
                            the <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of a
                                 <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> <span>whose declaration is</span>
                           within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, as described in <a href="#focus"><i>5.3.3.1 Maintaining Position: the Focus</i></a>. The global context item may also be available in a <a title="named template" class="termref" href="#dt-named-template">named template</a>
                        when the stylesheet is invoked as described in <a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a><span class="definition">]</span>.
                        </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>In previous releases of this specification, a single node was typically
                           supplied to represent the source document for the transformation. This
                           node was used as the target node for the implicit call on
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> used to start the transformation
                           process (now called the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>), and
                           the root node of the containing tree was used as the context item for
                           evaluation of global variables (now called the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>). This relationship between the
                              <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> and the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is likely to be found for compatibility
                           reasons in a transformation API designed to work with earlier versions of
                           this specification, but it is no longer a necessary relationship; the two
                           values can in principle be completely independent of each other.</p>
                           <p>Stylesheet authors wanting to write code that can be invoked using legacy
                           APIs should not rely on the caller being able to supply different values
                           for the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> and the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p>
                           <p>In XPath 4.0, the concept of <a title="context item" class="termref" href="#dt-context-item">context item</a>
                        has been generalized and is now referred to as the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup>.
                        For XSLT 4.0, however, the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is still constrained to be
                        either a single item, or absent.</p>
                        </div>
                        <p>The value given to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>
                        (and the values given to <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>)
                     cannot be nodes in a streamed document. This rule ensures that all global variables can freely
                     navigate within the relevant tree, with no constraints imposed by the streamability rules.</p>
                        <p>The <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is potentially
                        used when initializing global variables and parameters. If the
                        initialization of any <a title="global variable" class="termref" href="#dt-global-variable">global
                           variables</a> or <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">parameter</a> depends on the context item, a dynamic error can
                        occur if the context item is absent. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether this error occurs during
                        priming of the stylesheet or subsequently when the variable is referenced;
                        and it is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether the error
                        occurs at all if the variable or parameter is never referenced. The error
                        can be suppressed by use of <a href="#element-try"><code>xsl:try</code></a> and
                           <a href="#element-catch"><code>xsl:catch</code></a> within the sequence constructor used to initialize the variable or parameter. It
                           cannot be suppressed by use of <a href="#element-try"><code>xsl:try</code></a> around a
                           reference to the global variable.
                     </p>
                        <p>In a <a title="library package" class="termref" href="#dt-library-package">library package</a>,
                           the <a title="context item" class="termref" href="#dt-context-item">context item</a>, <a title="context position" class="termref" href="#dt-context-position">context position</a>, and <a title="context size" class="termref" href="#dt-context-size">context size</a> used for evaluation of
                           global variables will be <a title="absent" class="termref" href="#dt-absent">absent</a>, and
                           the evaluation of any expression that references these values will result
                           in a dynamic error. 
                        This will also be the case in the
                              <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> if no <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is supplied.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>If a context item is available within a global variable declaration, then
                           the <a title="context position" class="termref" href="#dt-context-position">context position</a> and
                              <a title="context size" class="termref" href="#dt-context-size">context size</a> will always be 1
                           (one).</p>
                        </div>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>For maximum reusability of code, it is best to avoid use of the context
                           item when initializing global variables and parameters. Instead, all
                           external information should be supplied using named <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>,
                           ideally with namespaces, to avoid confusion and conflicts
                           in the information supplied externally to
                           different packages.</p>
                           <p>When a stylesheet parameter is defined in a library package, it is
                           possible for a using package to supply a value for the parameter by
                           overriding the parameter declaration within an
                              <a href="#element-override"><code>xsl:override</code></a> element. If the using package is the
                              <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> then the overriding declaration
                           can refer to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p>
                        </div>
                     </li>
                     <li>
                        <p>A mechanism for obtaining a document node and a media type, given an
                        absolute URI. The total set of available documents (modeled as a mapping
                        from URIs to document nodes) forms part of the context for evaluating XPath
                        expressions, specifically the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function. The XSLT
                           <a href="#func-document"><code>document</code></a> function additionally requires the media
                        type of the resource representation, for use in interpreting any fragment
                        identifier present within a URI Reference.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The set of documents that are available to the stylesheet is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>,
                           as is the processing that is carried out to construct a tree representing
                           the resource retrieved using a given URI. Some possible ways of
                           constructing a document (specifically, rules for constructing a document
                           from an Infoset or from a PSVI) are described in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p>
                        </div>
                     </li>
                  </ul>
                  <p>Once a stylesheet is primed, the values of global variables
                  remain stable through all component invocations. In addition, priming a stylesheet
                  creates an <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO</small></sup>
                  during which the dynamic context and all calls
                     on <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>
                     functions remain stable; for example two calls on the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>current-dateTime</code></a> function within an execution scope are
                  defined to return the same result.</p>
                  <p>Parameters passed to the transformation by the client application when a stylesheet is primed are matched against
                     <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> (see
                     <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>), not against the <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a> of any template
                  executed during the course of the transformation. </p>
                  <p>
                  <a id="err-XTDE0050"><span class="error">[ERR XTDE0050] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a
                        stylesheet declares a visible <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>
                        that is <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly</a> mandatory,
                        and no value for this parameter is supplied when the stylesheet is primed. A
                        stylesheet parameter is visible if it is not masked by another global
                        variable or parameter with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. If the parameter is a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a> then the value <span class="verb">must</span> be
                           supplied prior to the static analysis phase.
               </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="invoking-initial-mode"></a>2.3.3 <a href="#invoking-initial-mode" style="text-decoration: none">Apply-Templates Invocation</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-match-selection" title="initial match selection"></a>A stylesheet may be evaluated by supplying a
                     value to be processed, together with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. The
                     value (which can be any sequence of items) is referred to as the <b>initial
                        match selection</b>. The processing then corresponds to the effect of the
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.<span class="definition">]</span></p>
                  <p>The <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> will
                  often be a single document node, traditionally called the source document of the
                  transformation; but in general, it can be any sequence. If the initial match selection is the empty sequence, the result of the
                     transformation will be empty, since no template rules are
                  evaluated.</p>
                  <p>Processing proceeds by finding the <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> that match the items in the
                     <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, and evaluating these template
                  rules with a <a title="focus" class="termref" href="#dt-focus">focus</a> based on the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. The template rules are evaluated in
                     <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>.</p>
                  <p>The following information is needed when dynamic evaluation is
                  to start with a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>:</p>
                  <ul>
                     <li>
                        <p>The <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>.
                        An API that chooses to maintain compatibility with previous versions of this
                        specification <span class="verb">should</span> allow a method of invocation in which a singleton node is
                        provided, which is then used in two ways: the node itself acts as the
                           <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, and the root node of the
                        containing tree acts as the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>. </p>
                     </li>
                     <li>
                        <p>Optionally, an initial <a title="mode" class="termref" href="#dt-mode">mode</a>.</p>
                        <p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-mode" title="initial mode"></a>The <b>initial mode</b>
                        is the <a title="mode" class="termref" href="#dt-mode">mode</a> used to select <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>
                     for processing items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> when
                     apply-templates invocation is used to initiate a transformation.<span class="definition">]</span></p>
                        <p>In searching
                           for the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that best
                           matches the items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, the processor
                           considers only those rules that apply to the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>.</p>
                        <p>If no <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> is supplied explicitly, then the initial mode is that named in the
                              <code>default-mode</code> attribute of the (explicit or implicit) <a href="#element-package"><code>xsl:package</code></a>
                              element of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> or in
                           the absence of such an attribute, the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p>
                        <p>
                        <a id="err-XTDE0044"><span class="error">[ERR XTDE0044] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                              invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                              specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> when no <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> is
                                 supplied (either explicitly, or defaulted to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>).
                     </p>
                        <p>A (named or unnamed) <a title="mode" class="termref" href="#dt-mode">mode</a> <var>M</var> is <b>eligible as an initial mode</b> if one of the
                        following conditions applies, where <var>P</var> is the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> of the stylesheet:</p>
                        <ol class="enumar">
                           <li>
                              <p><var>M</var> is explicitly declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration
                           within <var>P</var>, and has <code>public</code> or <code>final</code> <a title="visibility" class="termref" href="#dt-visibility">visibility</a> (either by virtue
                           of its <code>visibility</code> attribute, or by virtue of an <a href="#element-expose"><code>xsl:expose</code></a> declaration).</p>
                           </li>
                           <li>
                              <p><var>M</var> is the unnamed mode.</p>
                           </li>
                           <li>
                              <p><var>M</var> is named in the <code>default-mode</code> attribute of the (explicit or implicit) 
                           <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var>.</p>
                           </li>
                           <li>
                              <p><var>M</var> is declared in a package used by <var>P</var>, and is given <code>public</code> or <code>final</code>
                           <a title="visibility" class="termref" href="#dt-visibility">visibility</a> in <var>P</var> by means of an <a href="#element-accept"><code>xsl:accept</code></a> declaration.</p>
                           </li>
                           <li>
                              <p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of the explicit or implicit
                        <a href="#element-package"><code>xsl:package</code></a> element of <var>P</var> is <code>no</code>, and <var>M</var> appears as 
                        a mode-name in the <code>mode</code> attribute of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within <var>P</var>.</p>
                           </li>
                        </ol>
                        <p>
                        <a id="err-XTDE0045"><span class="error">[ERR XTDE0045] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                              invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                              specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> and the
                              specified mode is not eligible as an initial mode (as defined above).
                     </p>
                     </li>
                     <li>
                        <p>Parameters, which will be passed to the template rules
                        used to process items in the input sequence. The parameters consist of two
                        sets of (QName, value) pairs, one set for <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> and one for non-tunnel parameters, in which
                        the QName identifies the name of a parameter and the value provides the
                        value of the parameter. Either or both sets of parameters may be empty. The
                        effect is the same as when a template is invoked using
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with an
                           <a href="#element-with-param"><code>xsl:with-param</code></a> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <em>not</em> used to set <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>.</p>
                        <p>A supplied value is converted if necessary to the declared
                        type of the template parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                     </li>
                     <li>
                        <p>Details of how the result of the initial template is to be returned.
                     For details, see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a></p>
                     </li>
                  </ul>
                  <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the
                  result of processing the supplied input sequence as if by a call on
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> in the specified mode: specifically, each
                  item in the input sequence is processed by selecting and evaluating the best
                  matching template rule, and converting the result (if necessary) to the type
                  declared in the <code>as</code> attribute of that template using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>; and the results of processing each item
                  are then concatenated into a single sequence, respecting the order of items in the
                  input sequence.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The design of the API for invoking a transformation should provide some means
                     for users to designate the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> as the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> 
                     in cases where it is not the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a>.</p>
                  </div>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>
                  <span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> selected for processing any item in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> defines a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> that specifies <code>required="yes"</code>
                  and no value is supplied for that
                  parameter.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can process further source
                     documents in addition to those supplied when the transformation is invoked.
                     These additional documents can be loaded using the functions
                        <a href="#func-document"><code>document</code></a> (see <a href="#func-document"><i>20.1 fn:document</i></a>); or
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text"><code>unparsed-text</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-unparsed-text-lines"><code>unparsed-text-lines</code></a>, or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>); or using the
                           <a href="#element-source-document"><code>xsl:source-document</code></a> instruction; alternatively, they can
                     be supplied as <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet
                        parameters</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>), or returned as
                     the result of an <a title="extension function" class="termref" href="#dt-extension-function">extension
                        function</a> (see <a href="#extension-functions"><i>24.2 Extension Functions</i></a>).</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="invoking-initial-template"></a>2.3.4 <a href="#invoking-initial-template" style="text-decoration: none">Call-Template Invocation</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-named-template" title="initial named template"></a>A stylesheet may be evaluated by selecting a
                     named template to be evaluated; this is referred to as the <b>initial named
                        template</b>.<span class="definition">]</span> The effect is analogous to the effect of
                  executing an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. The following
                  information is needed in this case:</p>
                  <ul>
                     <li>
                        <p>Optionally, the name of the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial
                           named template</a> which is to be executed as the entry point to
                        the transformation. If no template name is
                           supplied, the default template name is
                           <code>xsl:initial-template</code>. The selected template
                           <span class="verb">must</span> exist within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. </p>
                     </li>
                     <li>
                        <p>Optionally, a context item for evaluation of this named
                        template, defaulting to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if it
                        exists. This is constrained by any
                              <a href="#element-context-item"><code>xsl:context-item</code></a> element appearing within the
                           selected <a href="#element-template"><code>xsl:template</code></a> element. The initial named
                           template is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on
                           this context item if it exists, or with an <a title="absent" class="termref" href="#dt-absent">absent</a>
                           focus otherwise.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The context item for evaluation of the named
                     template must be either a single item or absent; it cannot be an arbitrary value.</p>
                        </div>
                     </li>
                     <li>
                        <p>Parameters, which will be passed to the selected template
                        rule. The parameters consist of two sets of (QName, value) pairs, one set
                        for <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> and one
                        for non-tunnel parameters, in which the QName identifies the name of a
                        parameter and the value provides the value of the parameter. Either or both
                        sets of parameters may be empty. The effect is the same as when a template
                        is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a> with an
                           <a href="#element-with-param"><code>xsl:with-param</code></a> child specifying
                           <code>tunnel="yes"</code> or <code>tunnel="no"</code> as appropriate. If
                        a parameter is supplied that is not declared or used, the value is simply
                        ignored. These parameters are <em>not</em> used to set <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>.</p>
                        <p>A supplied value is converted if necessary to the declared
                        type of the template parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                     </li>
                     <li>
                        <p>Details of how the result of the initial named template is to be returned.
                        For details, see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a></p>
                     </li>
                  </ul>
                  <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the
                  result of evaluating the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a>, after
                  conversion of the result to the type declared in the <code>as</code> attribute of
                  that template using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, if such
                  conversion is necessary.</p>
                  <p>The <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a> is
                  evaluated in <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>.</p>
                  <p>
                  <a id="err-XTDE0040"><span class="error">[ERR XTDE0040] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the invocation of
                        the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a template
                        name that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> of a named template defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose
                           visibility is <code>public</code> or <code>final</code>.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>When the top-level package is rooted at an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or 
                     <a href="#element-transform"><code>xsl:transform</code></a> element, named templates having no explicit 
                     <code>visibility</code> attribute are automatically exposed as public components. 
                     (This is a consequence of the transformation applied to a package written using 
                     “simplified syntax”, described in <a href="#packages"><i>3.4 Packages</i></a>.) </p>
                  </div>
                  <p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a>
                  <span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a>, or any of the template rules invoked to
                  process items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, defines a
                     <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> that
                  specifies <code>required="yes"</code>
                  and no value is supplied for that parameter.
               </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="invoking-initial-function"></a>2.3.5 <a href="#invoking-initial-function" style="text-decoration: none">Function Call Invocation</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-function" title="initial function"></a>A stylesheet may be evaluated by calling a named
                        <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, referred to as the <b>initial
                        function</b>.<span class="definition">]</span> The following additional information is needed in
                  this case:</p>
                  <ul>
                     <li>
                        <p>The name and arity of a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> which is to
                        be executed as the entry point to the transformation.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>In the design of a concrete API, the arity may be inferred from the
                           length of the parameter list.</p>
                        </div>
                     </li>
                     <li>
                        <p>A list of values to act as parameters to the <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>. The number of values in the list must be the
                        same as the arity of the function.</p>
                        <p>A supplied value is converted if necessary to the declared
                        type of the function parameter using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                     </li>
                     <li>
                        <p>Details of how the result of the initial function is to be returned.
                        For details, see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a></p>
                     </li>
                  </ul>
                  <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the invocation is the
                  result of evaluating the <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>, after conversion of
                  the result to the type declared in the <code>as</code> attribute of that function
                  using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, if such conversion is
                  necessary.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p> The <a title="initial function" class="termref" href="#dt-initial-function">initial function</a> (like all stylesheet functions) is
                     evaluated with an <a title="absent" class="termref" href="#dt-absent">absent</a>
                     <a title="focus" class="termref" href="#dt-focus">focus</a>.</p>
                  </div>
                  <p>If the <a title="initial function" class="termref" href="#dt-initial-function">initial function</a> is 
                  <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-declared-streamable">declared-streamable</a><sup><small>SG</small></sup>, a streaming processor <span class="verb">should</span> 
                  allow the value of the first argument to be supplied in streamable form, and if it is 
                  supplied in this form, then it <span class="verb">must</span> be processed using streaming.</p>
                  <p>
                  <a id="err-XTDE0041"><span class="error">[ERR XTDE0041] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a function name and
                        arity that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> and arity of a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is
                           <code>public</code> or <code>final</code>.
               </p>
                  <p>When a transformation is invoked by calling an <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>, the entire transformation executes in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>, which means that calls on
                     <a href="#element-result-document"><code>xsl:result-document</code></a> are not permitted.</p>
                  <p>[TODO: Generalize the above description to allow for the possibility of keyword-based and optional arguments.]</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="post-processing"></a>2.3.6 <a href="#post-processing" style="text-decoration: none">Post-processing the Raw Result</a></h4>
                  <p>There are three ways the result of a transformation
               may be delivered. (This applies both to the principal result, described here, and
               also to secondary results, generated using <a href="#element-result-document"><code>xsl:result-document</code></a>.)</p>
                  <ol class="enumar">
                     <li>
                        <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> (a sequence of values) may be returned
                  directly to the calling application.</p>
                     </li>
                     <li>
                        <p>A result tree may be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>.
                     By default, a result tree is constructed if the <code>build-tree</code>
                     attribute of the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>
                     has the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>yes</code>. An API for invoking transformations <span class="verb">may</span>
                     allow this setting to be overridden by the calling application. If result tree construction
                     is requested, it is performed as described in <a href="#result-tree-construction"><i>2.3.6.1 Result Tree Construction</i></a>.
                   </p>
                     </li>
                     <li>
                        <p>Alternatively, the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be serialized
                  as described in <a href="#result-serialization"><i>2.3.6.2 Serializing the Result</i></a>. The decision whether or not to
                  serialize the result is determined by the rules of transformation API provided by the
                  <a title="processor" class="termref" href="#dt-processor">processor</a>, and is not influenced by anything in the stylesheet.</p>
                     </li>
                  </ol>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This specification does not constrain the design of application programming
                     interfaces or the choice of defaults. In previous versions of this
                     specification, result tree construction was a mandatory process, while
                     serialization was optional. When invoking stylesheet functions directly,
                     however, result tree construction and serialization may be inappropriate as
                     defaults. These considerations may affect the design of APIs.</p>
                     <p>In previous versions of XSLT, results were delivered either
                  in serialized form (as a character or byte stream), or as a tree. In the latter case processors
                  typically would use either their own tree representation, or a standardized tree
                  representation such as the W3C Document Object Model (DOM) (see <a href="#DOM-Level-2-Core">[DOM Level 2]</a>),
                     adapted to the data structures offered by the programming language in which the API is defined.
                  To deliver a raw result, processors need to define a representation not only of XDM nodes but
                  also of sequences, atomic items, maps, arrays, and even functions. As with the return of a simple tree, 
                  this may involve a trade-off between strict fidelity to the XDM data model and usability in the particular 
                  programming language environment. It is <em>not</em> a requirement that an API should return results 
                     in a way that exposes every property of the XDM data model; for example there may be APIs that do not expose
                  the precise type annotation of a returned node or atomic item, or that fail to expose the base URI
                  or document URI of a node, or that provide no way of determining whether two nodes in the result
                  sequence are the same node in the sense of the XPath <code>is</code> operator.
                     The way in which maps, arrays, and functions 
                  are returned requires careful design choices. It is <span class="verb">recommended</span> that an API should be capable
                  of returning any XDM value without error, and that there should be minimal loss of information if
                  the raw results output by one transformation are subsequently used as input to another transformation.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="result-tree-construction"></a>2.3.6.1 <a href="#result-tree-construction" style="text-decoration: none">Result Tree Construction</a></h5>
                     <p>If a result tree is to be constructed from the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>, then this is done
    by applying the rules for the process of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup> as defined in 
       <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>. This process takes as input the serialization parameters defined in the
    unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>; though the only parameter
    that is actually used by this process is <code>item-separator</code>. 
    </p>
                     <p>The sequence normalization process either returns a document node, or raises
    a serialization error. The content of the document node is not necessarily well-formed (the document node may have any number
    of element or text nodes among its children).</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>More specifically, the process raises a serialization error if any item in the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is
    an attribute node, a namespace node, or a function (including a map, but not an array: arrays are flattened).</p>
                     </div>
                     <p>The tree that is constructed is referred to as a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p>
                     <p>If the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is the empty sequence, the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> will consist
    of a document node with no children.</p>
                     <p>The base URI of the document node is set to the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The <code>item-separator</code> property has no effect if the raw result of the transformation is a sequence
       of length zero or one, which in practice will often be the case, especially in a traditional scenario such as
       transformation of an XML document to HTML.</p>
                        <p>If there is no <code>item-separator</code>, then a single space is inserted between adjacent atomic items;
       for example if the raw result is the sequence <code>1 to 5</code>, then sequence normalization produces a tree
       comprising a document node with a single child, the child being a text node with the string value 
       <code>1 2 3 4 5</code>.</p>
                        <p>If there is an <code>item-separator</code>, then it is used not only between adjacent atomic items,
       but between any pair of items in the raw result. For example if the raw result is a sequence of two
       element nodes <code>A</code> and <code>B</code>, and the <code>item-separator</code> is a comma,
       then the result of sequence normalization will be a document node with three children: a copy of <code>A</code>,
       a text node whose string value is a single comma, and a copy of <code>B</code>.</p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="result-serialization"></a>2.3.6.2 <a href="#result-serialization" style="text-decoration: none">Serializing the Result</a></h5>
                     <p>See <a href="#parsing-and-serialization"><i>2.7 Parsing and Serialization</i></a>.</p>
                     <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>
                        may optionally be serialized as described in <a href="#serialization"><i>26 Serialization</i></a>. The serialization is controlled by the serialization
                     parameters defined in the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> of the
                     <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The first phase of serialization, called <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>,
                     takes place for some output methods but not others. For example, if the <code>json</code> output method
                        (defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>) is selected, then the process of constructing
                     a tree is bypassed.</p>
                     </div>
                     <p>The effect of serialization is to generate a sequence of octets, representing the serialized result
                     in some character encoding. The processor’s API may define mechanisms enabling this sequence of octets
                  to be written to persistent storage at some location. The default location is the location identified
                  by the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p>
                     <p>In previous versions of this specification it was stated that
                  when the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> of the initial template or function is the empty sequence,
                  a result tree should be produced if and only if the transformation generates no secondary results
                  (that is, if it does not invoke <a href="#element-result-document"><code>xsl:result-document</code></a>). This provision is most likely
                  to have a noticeable effect if the transformation produces serialized results, and these results
                  are written to persistent storage: the effect is then that a transformation producing the empty
                  principal result will overwrite any existing content at the base output URI location if and only
                  if the transformation produces no other output. Processor APIs offering backwards compatibility
                  with earlier versions of XSLT must respect this behavior, but there is no requirement for new
                  processor APIs to do so.</p>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-base-output-uri" title="base output URI"></a> The <b>base output URI</b> is a URI to be used as the base URI when
                     resolving a relative URI reference allocated
                     to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. If the
                     transformation generates more than one final result tree, then typically each
                     one will be allocated a URI relative to this base URI.<span class="definition">]</span> The way in
                  which a base output URI is established is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Each invocation of the stylesheet may supply
                  a different base output URI. It is acceptable for the base output URI to be
                     <a title="absent" class="termref" href="#dt-absent">absent</a>, provided no constructs (such as
                     <a href="#element-result-document"><code>xsl:result-document</code></a>) are evaluated that depend on the value of
                  the base output URI.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>It will often be convenient for the base output URI to be the same as the
                     location to which the principal result document is serialized, but this
                     relationship is not a necessary one.</p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="executing-a-transformation"></a>2.4 <a href="#executing-a-transformation" style="text-decoration: none">Instructions</a></h3>
               <p>The main executable components of a stylesheet are templates and functions. The body of
            a template or function is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, which is a sequence of elements
            and text nodes that can be evaluated to produce a result.</p>
               <p>A <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is a sequence of sibling nodes in the
               stylesheet, each of which is either an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT
                  instruction</a>, a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result
                     element</a>, a text node, or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-instruction" title="instruction"></a>An <b>instruction</b> is either
                  an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-instruction" title="XSLT instruction"></a>An <b>XSLT
                  instruction</b> is an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>
                  whose syntax summary in this specification contains the annotation <code>&lt;!--
                     category: instruction --&gt;</code>.<span class="definition">]</span>
            </p>
               <p>
               <a title="extension instruction" class="termref" href="#dt-extension-instruction">Extension instructions</a> are
               described in <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>.</p>
               <p>The main categories of <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a>
               are as follows:</p>
               <ul>
                  <li>
                     <p>instructions that create new nodes: <a href="#element-document"><code>xsl:document</code></a>,
                     <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                     <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, <a href="#element-comment"><code>xsl:comment</code></a>,
                     <a href="#element-value-of"><code>xsl:value-of</code></a>, <a href="#element-text"><code>xsl:text</code></a>,
                     <a href="#element-namespace"><code>xsl:namespace</code></a>;</p>
                  </li>
                  <li>
                     <p>instructions that construct maps and arrays: <a href="#element-array"><code>xsl:array</code></a>,
                      <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-record"><code>xsl:record</code></a>;</p>
                  </li>
                  <li>
                     <p>instructions that copy nodes: <a href="#element-copy"><code>xsl:copy</code></a>,
                     <a href="#element-copy-of"><code>xsl:copy-of</code></a>;</p>
                  </li>
                  <li>
                     <p>instructions that returns an arbitrary sequence by evaluating an XPath
                     expression: <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-select"><code>xsl:select</code></a>,
                     <a href="#element-evaluate"><code>xsl:evaluate</code></a>;</p>
                  </li>
                  <li>
                     <p>instructions that cause conditional or repeated evaluation of nested
                     instructions: <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-choose"><code>xsl:choose</code></a>, 
                     <a href="#element-switch"><code>xsl:switch</code></a>, <a href="#element-try"><code>xsl:try</code></a>,
                     <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-fork"><code>xsl:fork</code></a>, 
                     <a href="#element-iterate"><code>xsl:iterate</code></a>
                        and its subordinate instructions <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> and
                        <a href="#element-break"><code>xsl:break</code></a>;</p>
                  </li>
                  <li>
                     <p>instructions that generate output conditionally if elements are or are not
                     empty: <a href="#element-on-empty"><code>xsl:on-empty</code></a>, <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>,
                     <a href="#element-where-populated"><code>xsl:where-populated</code></a>;</p>
                  </li>
                  <li>
                     <p>instructions that invoke templates: <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                     <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>,
                     <a href="#element-next-match"><code>xsl:next-match</code></a>;</p>
                  </li>
                  <li>
                     <p>Instructions that declare variables: <a href="#element-variable"><code>xsl:variable</code></a>;</p>
                  </li>
                  <li>
                     <p>Instructions to assist debugging: <a href="#element-message"><code>xsl:message</code></a>,
                     <a href="#element-assert"><code>xsl:assert</code></a>;</p>
                  </li>
                  <li>
                     <p>other specialized instructions: <a href="#element-number"><code>xsl:number</code></a>,
                     <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, <a href="#element-fork"><code>xsl:fork</code></a>, 
                     <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
                        <a href="#element-merge"><code>xsl:merge</code></a>.</p>
                  </li>
               </ul>
            </div>
            <div class="div2">
               
               <h3><a id="rule-based-processing"></a>2.5 <a href="#rule-based-processing" style="text-decoration: none">Rule-Based Processing</a></h3>
               <p>The classic method of executing an XSLT transformation is to apply
               template rules to the root node of an input document (see <a href="#invoking-initial-mode"><i>2.3.3 Apply-Templates Invocation</i></a>).
               The operation of applying templates to a node searches the stylesheet for the best matching template
               rule for that node. This template rule is then evaluated. A common coding pattern, especially when XSLT
               is used to convert XML documents into display formats such as HTML, is to have one template rule 
               for each kind of element in the source document, and for that template rule to generate some 
               appropriate markup elements, and to apply templates recursively to its own children. The effect is to 
               perform a recursive traversal of the source tree, in which each node is processed using the best-fit 
               template rule for that node. The final result of the transformation is then the tree produced by this 
               recursive process. This result can then be optionally serialized (see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>). 
            </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="rule-based-processing-example"></a>Example: Example of Rule-Based Processing</div>
                  <p>This example uses rule-based processing to convert a simple XML input document into an HTML
               output document.</p>
                  <p>The input document takes the form:</p>
                  <div class="exampleInner">
                     <pre>

  &lt;PERSONAE PLAY="OTHELLO"&gt;
    &lt;TITLE&gt;Dramatis Personae&lt;/TITLE&gt;
    &lt;PERSONA&gt;DUKE OF VENICE&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BRABANTIO, a senator.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Other Senators.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;GRATIANO, brother to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;LODOVICO, kinsman to Brabantio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;OTHELLO, a noble Moor in the service of the Venetian state.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;CASSIO, his lieutenant.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;IAGO, his ancient.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;RODERIGO, a Venetian gentleman.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;MONTANO, Othello's predecessor in the government of Cyprus.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Clown, servant to Othello. &lt;/PERSONA&gt;
    &lt;PERSONA&gt;DESDEMONA, daughter to Brabantio and wife to Othello.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;EMILIA, wife to Iago.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;BIANCA, mistress to Cassio.&lt;/PERSONA&gt;
    &lt;PERSONA&gt;Sailor, Messenger, Herald, Officers, 
             Gentlemen, Musicians, and Attendants.&lt;/PERSONA&gt;
  &lt;/PERSONAE&gt;</pre>
                  </div>
                  <p>The stylesheet to render this as HTML can be written as a set of template rules:</p>
                  <div class="exampleInner">
                     <pre>
 &lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    version="3.0"
    expand-text="yes"&gt;
    
 &lt;xsl:strip-space elements="PERSONAE"/&gt;   
    
 &lt;xsl:template match="PERSONAE"&gt;
   &lt;html&gt;
     &lt;head&gt;
       &lt;title&gt;The Cast of {@PLAY}&lt;/title&gt;
     &lt;/head&gt;
     &lt;body&gt;
       &lt;xsl:apply-templates/&gt;
     &lt;/body&gt;
   &lt;/html&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="TITLE"&gt;
   &lt;h1&gt;{.}&lt;/h1&gt;
 &lt;/xsl:template&gt;
 
 &lt;xsl:template match="PERSONA[count(tokenize(., ',')) = 2]"&gt;
   &lt;p&gt;&lt;b&gt;{substring-before(., ',')}&lt;/b&gt;: {substring-after(., ',')}&lt;/p&gt;
 &lt;/xsl:template&gt; 

 &lt;xsl:template match="PERSONA"&gt;
   &lt;p&gt;&lt;b&gt;{.}&lt;/b&gt;&lt;/p&gt;
 &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                  </div>
                  <p>There are four template rules here:</p>
                  <ul>
                     <li>
                        <p>The first rule matches the outermost element, named <code>PERSONAE</code> (it could equally
                  have used <code>match="/"</code> to match the document node). The effect of this rule is to create
                  the skeleton of the output HTML page. Technically, the body of the template is a sequence constructor
                  comprising a single <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> (the <code>html</code> element); this
                  in turn contains a sequence constructor comprising two literal result elements (the <code>head</code>
                  and <code>body</code> elements). The <code>head</code> element is populated with a literal <code>title</code>
                     element whose content is computed as a mixture of fixed and variable text using a <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a>. 
                     The <code>body</code> element is populated by evaluating an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  instruction.</p>
                        <p>The effect of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is to process the children of
                     the <code>PERSONAE</code> element in the source tree: that is, the <code>TITLE</code> and
                     <code>PERSONA</code> elements. (It would also process any whitespace text node children, but these
                     have been stripped by virtue of the <a href="#element-strip-space"><code>xsl:strip-space</code></a> declaration.) Each of these
                     child elements is processed by the best matching template rule for that element, which will be one 
                     of the other three rules in the stylesheet.</p>
                     </li>
                     <li>
                        <p>The template rule for the <code>TITLE</code> element outputs an <code>h1</code> element
                  to the HTML result document, and populates this with the value of <code>.</code>, the context item. That is,
                  it copies the text content of the <code>TITLE</code> element to the output <code>h1</code> element.</p>
                     </li>
                     <li>
                        <p>The last two rules match <code>PERSONA</code> elements. The first rule matches <code>PERSONA</code>
                  elements whose text content contains exactly one comma; the second rule matches all <code>PERSONA</code> elements,
                     but it has lower priority than the first rule (see <a href="#default-priority"><i>6.3.3 Default Priority for Patterns</i></a>), so in practice it 
                     applies only to <code>PERSONA</code>
                  elements that contain no comma or multiple commas.</p>
                        <p>For both rules the body of the rule is a sequence constructor containing a single literal result element,
                  the <code>p</code> element. These literal result elements contain
                  further sequence constructors comprising literal result elements and text nodes. 
                  In each of these examples the text nodes are in the form of a <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a>:
                  in general this is a combination of fixed text together with XPath expressions enclosed in curly braces, which 
                  are evaluated to form the content of the containing literal result element. </p>
                     </li>
                  </ul>
               </div>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-template-rule" title="template rule"></a>A stylesheet contains a set of
                  <b>template rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A template rule has
                  three parts: a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that is matched against
                  selected items (often but not necessarily nodes), a (possibly empty) set of <a title="template parameter" class="termref" href="#dt-template-parameter">template
                     parameters</a>, and a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a> that is evaluated to produce a sequence of
                  items.<span class="definition">]</span> In many cases these items are newly constructed nodes, which are
               then written to a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="context"></a>2.6 <a href="#context" style="text-decoration: none">The Evaluation Context</a></h3>
               <p>The results of some expressions and instructions in a stylesheet may depend on
               information provided contextually. This context information is divided into two
               categories: the static context, which is known during static analysis of the
               stylesheet, and the dynamic context, which is not known until the stylesheet is
               evaluated. Although information in the static context is known at analysis time, it
               is sometimes used during stylesheet evaluation.</p>
               <p>Some context information can be set by means of declarations within the stylesheet
               itself. For example, the namespace bindings used for any XPath expression are
               determined by the namespace declarations present in containing elements in the
               stylesheet. Other information may be supplied externally or implicitly: an example is
               the current date and time.</p>
               <p>The context information used in processing an XSLT stylesheet includes as a subset
               all the context information required when evaluating XPath expressions. 
               The XPath 4.0 specification defines a static and dynamic
               context that the host language (in this case, XSLT) may initialize, which affects the
               results of XPath expressions used in that context. XSLT augments the context with
               additional information: this additional information is used firstly by XSLT
               constructs outside the scope of XPath (for example, the <a href="#element-sort"><code>xsl:sort</code></a>
               element), and secondly, by functions that are defined in the XSLT specification (such
               as <a href="#func-key"><code>key</code></a> and <a href="#func-current-group"><code>current-group</code></a>) that are
               available for use in XPath expressions appearing within a stylesheet.</p>
               <p>The static context for an expression or other construct in a stylesheet is determined
               by the place in which it appears lexically. The details vary for different components
               of the static context, but in general, elements within a stylesheet module affect the
               static context for their descendant elements within the same stylesheet module.</p>
               <p>The dynamic context is maintained as a stack. When an instruction or expression is
               evaluated, it may add dynamic context information to the stack; when evaluation is
               complete, the dynamic context reverts to its previous state. An expression that
               accesses information from the dynamic context always uses the value at the top of the
               stack.</p>
               <p>The most commonly used component of the dynamic context is the <a title="context item" class="termref" href="#dt-context-item">context item</a>. This is an implicit variable whose
               value is the item currently being processed (it may be a node, an atomic item,
                  or a function item). The value of the context
               item can be referenced within an XPath expression using the expression <code>.</code>
               (dot).</p>
               <p>XPath 4.0 generalizes the <a title="context item" class="termref" href="#dt-context-item">context item</a> so it can be any value (not necessarily a single item),
            and it is now known as the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup>. In certain XPath expressions, the
            value of the expression <code>.</code> can now be an arbitrary value, rather than a single item. However, there
            is currently no construct in XSLT 4.0 that takes advantage of this; in the context supplied by XSLT to XPath
            (except when using the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction),
            the context value is always either a single item, or absent. The XSLT specification therefore continues to refer
            to the <a title="context item" class="termref" href="#dt-context-item">context item</a> rather than the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup>.</p>
               <p>Full details of the static and dynamic context are provided in <a href="#static-and-dynamic-context"><i>5.3 The Static and Dynamic Context</i></a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="parsing-and-serialization"></a>2.7 <a href="#parsing-and-serialization" style="text-decoration: none">Parsing and Serialization</a></h3>
               <p>An XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
               describes a process that constructs a set of results from a set of inputs. The inputs
               are the data provided at stylesheet invocation, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. The results include the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a>
               (an arbitrary sequence), which is the result of the initial component invocation,
               together with any <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>
               produced using <a href="#element-result-document"><code>xsl:result-document</code></a> instructions. </p>
               <p>The <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> does not describe how a
                  <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> is constructed. Some possible
               ways of constructing source trees are described in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. Frequently an <a title="implementation" class="termref" href="#dt-implementation">implementation</a> will
               operate in conjunction with an XML parser (or more strictly, in the terminology of
                  <a href="#REC-xml">[XML 1.0]</a>, an <em>XML processor</em>), to build a source tree
               from an input XML document. An implementation <span class="verb">may</span> also provide an
               application programming interface allowing the tree to be constructed directly, or
               allowing it to be supplied in the form of a DOM Document object (see <a href="#DOM-Level-2-Core">[DOM Level 2]</a>). This is outside the scope of this specification. Users
               should be aware, however, that since the input to the transformation is a tree
               conforming to the XDM data model as described in <a href="#xpath-datamodel-40">[XDM 4.0]</a>,
               constructs that might exist in the original XML document, or in the DOM, but which
               are not within the scope of the data model, cannot be processed by the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> and cannot be guaranteed to remain
               unchanged in the transformation output. Such constructs include CDATA section
               boundaries, the use of entity references, and the DOCTYPE declaration and internal
               DTD subset.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-serialization" title="serialization"></a>A frequent requirement is to
                  output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as an XML
                  document (or in other formats such as HTML). This process is referred to as
                     <b>serialization</b>.<span class="definition">]</span>
            </p>
               <p>Like parsing, serialization is not part of the transformation process, and it is not
                  <span class="verb">required</span> that an XSLT processor <span class="verb">must</span> be able
               to perform serialization. However, for pragmatic reasons, this specification
               describes declarations (the <a href="#element-output"><code>xsl:output</code></a> element and the
                  <a href="#element-character-map"><code>xsl:character-map</code></a> declarations, see <a href="#serialization"><i>26 Serialization</i></a>), and attributes on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, that
               allow a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to specify the desired
               properties of a serialized output file. When serialization is not being performed,
               either because the implementation does not support the serialization option, or
               because the user is executing the transformation in a way that does not invoke
               serialization, then the content of the <a href="#element-output"><code>xsl:output</code></a> and
                  <a href="#element-character-map"><code>xsl:character-map</code></a> declarations has no effect. Under these
               circumstances the processor <span class="verb">may</span> raise any errors in an
                  <a href="#element-output"><code>xsl:output</code></a> or <a href="#element-character-map"><code>xsl:character-map</code></a> declaration, or
               in the serialization attributes of <a href="#element-result-document"><code>xsl:result-document</code></a>, but is not
                  <span class="verb">required</span> to do so.</p>
            </div>
            <div class="div2">
               
               <h3><a id="packages-and-modules"></a>2.8 <a href="#packages-and-modules" style="text-decoration: none">Packages and Modules</a></h3>
               <p>In XSLT 1.0 and 2.0 it was possible to structure a
               stylesheet as a collection of modules, using the <a href="#element-include"><code>xsl:include</code></a> and
                  <a href="#element-import"><code>xsl:import</code></a> declarations to express the dependency of one module on
               others.</p>
               <p>In XSLT 3.0 an additional layer of modularization of stylesheet code was enabled
               through the introduction of <a title="package" class="termref" href="#dt-package">packages</a>. A package
               is a collection of stylesheet modules with a controlled interface to the packages
               that use it: for example, it defines which functions and templates defined in the
               package are visible to callers, which are purely internal, and which are not only
               public but capable of being overridden by other functions and templates supplied by
               the using package.</p>
               <p>Packages are introduced with several motivations, which broadly divide into two
               categories:</p>
               <ol class="enumar">
                  <li>
                     <p>Software engineering benefits: greater re-use of code, greater robustness
                     through ease of testing, controlled evolution of code in response to new
                     requirements, ability to deliver code that users cannot see or modify.</p>
                  </li>
                  <li>
                     <p>Efficiency benefits: the ability to avoid compiling libraries repeatedly when
                     they are used in multiple stylesheets, and to avoid holding multiple copies of
                     the same library in memory simultaneously.</p>
                  </li>
               </ol>
               <p>Packages are designed to allow separate compilation: that is, a package can be
               compiled independently of the packages that use it. This specification does not
               define a process model for compilation, or expand on what it means to compile
               different packages independently. Nor does it mandate that implementations offer any
               feature along these lines. It merely defines language features that are designed to
               make separate compilation of packages possible.</p>
               <p>To achieve this, packages (unlike modules):</p>
               <ul>
                  <li>
                     <p>Must not contain unresolved references to functions, templates, or variables
                     declared in other packages;</p>
                  </li>
                  <li>
                     <p>Have strict rules governing the ability to override declarations in a <a title="library package" class="termref" href="#dt-library-package">library package</a> with declarations in a
                     package that uses the library;</p>
                  </li>
                  <li>
                     <p>Constrain the visibility of component names and of context declarations such as
                     the declarations of keys and decimal formats;</p>
                  </li>
                  <li>
                     <p>Can declare a mode (a collection of template rules) as final, which disallows
                     the addition of new overriding template rules in a using package;</p>
                  </li>
                  <li>
                     <p>Require explicit disambiguation where naming conflicts arise, for example when
                     a package uses two other packages that both export like-named components;</p>
                  </li>
                  <li>
                     <p>Allow multiple specializations of library components to coexist in the same
                     application.</p>
                  </li>
               </ul>
               <p>A package is defined in XSLT
               by means of an XML document whose
               outermost element is an <a href="#element-package"><code>xsl:package</code></a> element. This is referred to as
               the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>. The <a href="#element-package"><code>xsl:package</code></a> element
               has optional child elements <a href="#element-use-package"><code>xsl:use-package</code></a> and
                  <a href="#element-expose"><code>xsl:expose</code></a> describing properties of the package. The package
               manifest may refer to an external top-level stylesheet module using an
                  <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> declaration, or it may
               contain the body of a stylesheet module inline (the two approaches can also be
               mixed).</p>
               <p>Although this specification defines packages as constructs 
               written using a defined XSLT syntax, implementations <span class="verb">may</span> provide mechanisms that allow 
               packages to be written using other languages (for example, XQuery).</p>
               <p>When no packages are explicitly defined, the entire
               stylesheet is treated as a single package; the effect is as if the
                  <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element of the
                  <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet
                  module</a> were replaced by an <a href="#element-package"><code>xsl:package</code></a> element with no
               other information in the package manifest.</p>
            </div>
            <div class="div2">
               
               <h3><a id="extensibility"></a>2.9 <a href="#extensibility" style="text-decoration: none">Extensibility</a></h3>
               <p>XSLT defines a number of features that allow the language to be extended by
               implementers, or, if implementers choose to provide the capability, by users. These
               features have been designed, so far as possible, so that they can be used without
               sacrificing interoperability. Extensions other than those explicitly defined in this
               specification are not permitted.</p>
               <p>These features are all based on XML namespaces; namespaces are used to ensure that
               the extensions provided by one implementer do not clash with those of a different
               implementer.</p>
               <p>The most common way of extending the language is by providing additional functions,
               which can be invoked from XPath expressions. These are known as 
               <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>, and are described in
                  <a href="#extension-functions"><i>24.2 Extension Functions</i></a>.</p>
               <p>It is also permissible to extend the language by providing new <a title="instruction" class="termref" href="#dt-instruction">instructions</a>. 
               These are referred to as <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>, and are described
               in <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>. A stylesheet that uses extension
               instructions in a particular namespace must declare that it is doing so by using the
                  <code>[xsl:]extension-element-prefixes</code> attribute.</p>
               <p>Extension instructions and extension functions defined according to these rules
                  <span class="verb">may</span> be provided by the implementer of the XSLT processor, and
               the implementer <span class="verb">may</span> also provide facilities to allow users to
               create further extension instructions and extension functions.</p>
               <p>This specification defines how extension instructions and extension functions are
               invoked, but the facilities for creating new extension instructions and extension
               functions are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. 
               For further details, see <a href="#extension"><i>24 Extensibility and Fallback</i></a>.</p>
               <p>The XSLT language can also be extended by the use of <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a> (see <a href="#extension-attributes"><i>24.1 Extension Attributes</i></a>), and by means of <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>).</p>
            </div>
            <div class="div2">
               
               <h3><a id="stylesheets-and-schemas"></a>2.10 <a href="#stylesheets-and-schemas" style="text-decoration: none">Stylesheets and XML Schemas</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#standard-attributes">next</a> | <a href="#terminology">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  Different parts of a stylesheet may now use different imported schemas.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>An XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can make use of information
               from a schema. An XSLT transformation can take place in the absence of a schema (and,
               indeed, in the absence of a DTD), but where the source document has undergone schema
               validity assessment, the XSLT processor has access to the type information associated
               with individual nodes, not merely to the untyped text.</p>
               <p>Information from a schema can be used both statically (when the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is compiled), and dynamically (during
               evaluation of the stylesheet to transform a source document).</p>
               <p>There are places within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and
               within XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> and <a title="pattern" class="termref" href="#dt-pattern">patterns</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, where it is possible to refer to named type definitions in
               a schema, or to element and attribute declarations. For example, it is possible to
               declare the types expected for the parameters of a function. This is done using
               a <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-type" title="SequenceType"></a>A <b>SequenceType</b>
            constrains the type and number of items in a sequence. The term is used both to denote the
            concept, and to refer to the syntactic form in which sequence types are expressed in the
            XPath grammar: specifically <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup> in
                <a href="#xpath-40">[XPath 4.0]</a>.<span class="definition">]</span></p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-schema-component" title="schema component"></a>Type definitions and
                  element and attribute declarations are referred to collectively as <b>schema
                     components</b>.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-in-scope-schema-component" title="in-scope schema component"></a>The
                     <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> that may be
                  referenced by name in a <a title="package" class="termref" href="#dt-package">package</a> are referred to as the
                     <b>in-scope schema components</b>.<span class="definition">]</span></p>
               <p>The set of in-scope schema components may vary between
               one package and another, and between different parts of the same package,
               but as explained in <a href="#import-schema"><i>3.13 Importing Schema Components</i></a>, the
               schema components used in different parts of the stylesheet 
               must be consistent with each other.</p>
               <p>The conformance rules for XSLT 4.0, defined in
                  <a href="#conformance"><i>27 Conformance</i></a>, distinguish between a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a> and a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>. As the
               names suggest, a basic XSLT processor does not support the features of XSLT that
               require access to schema information, either statically or dynamically. A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that works with a basic XSLT processor
               will produce the same results with a schema-aware XSLT processor provided that the
               source documents are untyped (that is, they are not validated against a schema).
               However, if source documents are validated against a schema then the results may be
               different from the case where they are not validated. Some constructs that work on
               untyped data may fail with typed data (for example, an attribute of type
                  <code>xs:date</code> cannot be used as an argument of the
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-substring"><code>substring</code></a> function) and other constructs may produce
               different results depending on the datatype (for example, given the element
                  <code>&lt;product price="10.00" discount="2.00"/&gt;</code>, the expression
                  <code>@price gt @discount</code> will return <code>true</code> if the attributes have type
                  <code>xs:decimal</code>, but will return <code>false</code> if they are untyped).</p>
               <p>There is a standard set of type definitions that are always available as <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> in every
               stylesheet. These are defined in <a href="#built-in-types"><i>3.12 Built-in Types</i></a>. </p>
               <p>The remainder of this section describes facilities that are available only with a
                  <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
                  processor</a>.</p>
               <p>Additional <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> (type
               definitions, element declarations, and attribute declarations) may be added to the
                  <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>
               by means of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration in a stylesheet.</p>
               <p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration may reference an external schema
               document by means of a URI, or it may contain an inline <code>xs:schema</code>
               element.</p>
               <p>An <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration may include a <code>role</code>
            attribute, which indicates that the schema components are only to be present in the
            static context of a region of the stylesheet where they are explicitly invoked
            by means of an <code>[xsl:]schema-role</code> attribute.</p>
               <p>It is only necessary to import a schema explicitly if one or more of its <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> are referenced explicitly by
               name in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>; it is not necessary to
               import a schema merely because the stylesheet is used to process a source document
               that has been assessed against that schema. It is possible to make use of the
               information resulting from schema assessment (for example, the fact that a particular
               attribute holds a date) even if no schema has been imported by the stylesheet.</p>
               <p>Importing a schema does not of itself say anything about the type of the source
               document that the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is expected to
               process. The imported type definitions can be used for temporary nodes or for nodes
               on a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> just as much as for nodes in
               source documents. It is possible to make assertions about the type of an input
               document by means of tests within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example:</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e3121"></a>Example: Asserting the Required Type of the Source Document</div>
                  <div class="exampleInner">
                     <pre>&lt;xsl:mode typed="lax"/&gt;
&lt;xsl:global-context-item use="required"
            as="document-node(schema-element(my:invoice))"/&gt;</pre>
                  </div>
                  <p>This example will cause the transformation to fail with an error message, unless
                  the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is valid against the top-level element
                  declaration <code>my:invoice</code>, and has been annotated as such.</p>
                  <p>A <code>schema-role</code> attribute could be added to the declaration to indicate
                 which schema the element declaration <code>my:invoice</code> is to be taken from.</p>
                  <p>The setting <code>typed="lax"</code> further ensures that in any
                  match pattern for a template rule in this mode, an element name that corresponds
                  to the name of an element declaration in the schema is taken as referring to
                  elements validated against that declaration: for example,
                     <code>match="employee"</code> will only match a validated <code>employee</code>
                  element. Selecting this option enables the XSLT processor to do more compile-time
                  type-checking against the schema, for example it allows the processor to produce
                  warning or error messages when path expressions contain misspelt element names, or
                  confuse an element with an attribute.</p>
               </div>
               <p>It is also true that importing a schema does not of itself say
               anything about the structure of the result tree. It is possible to request validation
               of a result tree against the schema by using the <a href="#element-result-document"><code>xsl:result-document</code></a>
               instruction, for example:</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e3155"></a>Example: Requesting Validation of the Result Document</div>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xhtml:html&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xhtml:html&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>This example will cause the transformation to fail with an error message unless
                  the document element of the result document is valid against the top-level element
                  declaration <code>xhtml:html</code>.</p>
                  <p>A <code>schema-role</code> attribute could be added to the <a href="#element-result-document"><code>xsl:result-document</code></a>
                  instruction to indicate
                 which schema the document is to be validated against.</p>
               </div>
               <p>It is possible that a source document may contain nodes whose 
               <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> is not one of the types
               imported by the stylesheet. The data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>)
               requires that the processor has sufficient information about such types to 
               correctly implement the semantics of the language, even though the schema has
               not been imported; it also requires that all schemas used by the processor in a given
               processing episode (for example, an XSLT transformation) should be consistent. For 
               example, if a type annotation of a node is the simple type <code>my:percentage</code>,
               and a type named <code>my:percentage</code> appears in an imported schema, then they
               must be the same type.</p>
               <p>Where a stylesheet author chooses to make assertions about the types of nodes or of
                  <a title="variable" class="termref" href="#dt-variable">variables</a> and <a title="parameter" class="termref" href="#dt-parameter">parameters</a>, it is possible for an XSLT processor to perform static
               analysis of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (that is, analysis
               in the absence of any source document). Such analysis <span class="verb">may</span> reveal
               errors that would otherwise not be discovered until the transformation is actually
               executed. An XSLT processor is not <span class="verb">required</span> to perform such static
               type-checking. Under some circumstances (see <a href="#errors"><i>2.12 Error Handling</i></a>) type errors
               that are detected early <span class="verb">may</span> be raised as static errors. In
               addition an implementation <span class="verb">may</span> report any condition found during
               static analysis as a warning, provided that this does not prevent the stylesheet
               being evaluated as described by this specification.</p>
               <p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> can also control the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> of nodes that it constructs in
               a <a title="result tree" class="termref" href="#dt-result-tree">result
                     tree</a>. This can be done in a number of ways.</p>
               <ul>
                  <li>
                     <p>It is possible to request explicit validation of a complete document, that is,
                     a <a title="result tree" class="termref" href="#dt-result-tree">result
                           tree</a> rooted at a document node.  Validation
                     is either strict or lax, as described in <a href="#xmlschema-1">[XML Schema Part 1]</a>. If
                     validation of a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> fails
                     (strictly speaking, if the outcome of the validity assessment is
                        <code>invalid</code>), then the transformation fails, but in all other
                     cases, the element and attribute nodes of the tree will be annotated with the
                     names of the types to which these nodes conform. These <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> will be discarded if the
                     result tree is serialized as an XML document, but they remain available when
                     the result tree is passed to an application (perhaps another <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>) for further processing.</p>
                  </li>
                  <li>
                     <p>It is also possible to validate individual element and attribute nodes as they
                     are constructed. This is done using the <code>type</code> and
                        <code>validation</code> attributes of the <a href="#element-element"><code>xsl:element</code></a>,
                        <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, and
                        <a href="#element-copy-of"><code>xsl:copy-of</code></a> instructions, or the <code>xsl:type</code> and
                        <code>xsl:validation</code> attributes of a literal result element.</p>
                  </li>
                  <li>
                     <p>When elements, attributes, or document nodes are copied, either explicitly
                     using the <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a>
                     instructions, or implicitly when nodes in a sequence are attached to a new
                     parent node, the options <code>validation="strip"</code> and
                        <code>validation="preserve"</code> are available, to control whether
                     existing <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> are to be
                     retained or not.</p>
                  </li>
               </ul>
               <p>When nodes in a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> are
               validated, type information is available for use by operations carried out on the
               temporary tree, in the same way as for a source document that has undergone schema
               assessment.</p>
               <p>For details of how validation of element and attribute nodes works, see <a href="#validation"><i>25.4 Validation</i></a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="streaming-concepts"></a>2.11 <a href="#streaming-concepts" style="text-decoration: none">Streaming</a></h3>
               <p>Streaming is an optional feature of the XSLT 4.0 language.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-streaming" title="streaming"></a>The term <b>streaming</b> refers to
                  a manner of processing in which XML documents (such as source and result documents)
                  are not represented by a complete tree of nodes occupying memory proportional to
                  document size, but instead are processed “on the fly” as a sequence of events,
                  similar in concept to the stream of events notified by an XML parser to represent
                  markup in lexical XML.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-streamed-document" title="streamed document"></a>A <b>streamed
                     document</b> is a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> that
                  is processed using streaming, that is, without constructing a complete tree of
                  nodes in memory.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-streamed-node" title="streamed node"></a>A <b>streamed
                     node</b> is a node in a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed
                     document</a>.<span class="definition">]</span></p>
               <p>For full information about streaming, see <a href="#xslt40streaming">[XSLT 4.0 Streaming]</a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="errors"></a>2.12 <a href="#errors" style="text-decoration: none">Error Handling</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-static-error" title="static error"></a>An error that can be detected by
                  examining a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> before execution
                  starts (that is, before the source document and values of stylesheet parameters
                  are available) is referred to as a <b>static error</b>.<span class="definition">]</span>
            </p>
               <p>Generally, errors in the structure of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, or in the syntax of XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> contained in the stylesheet, are classified as <a title="static error" class="termref" href="#dt-static-error">static errors</a>. Where this specification states
               that an element in the stylesheet <span class="verb">must</span> or <span class="verb">must
                  not</span> appear in a certain position, or that it <span class="verb">must</span> or
                  <span class="verb">must not</span> have a particular attribute, or that an attribute
                  <span class="verb">must</span> or <span class="verb">must not</span> have a value satisfying
               specified conditions, then any contravention of this rule is a static error unless
               otherwise specified. </p>
               <p>A processor <span class="verb">must</span> provide a mode of operation 
               that takes a (possibly erroneous) stylesheet <a title="package" class="termref" href="#dt-package">package</a> as 
               input and enables the user to determine whether or not that package contains any
               <a title="static error" class="termref" href="#dt-static-error">static errors</a>.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The manner in which static errors are reported, and the behavior when there are multiple
               static errors, are left as design choices for the implementer. It is <span class="verb">recommended</span> 
               that the error codes defined in this specification should be made available in any diagnostics.
            </p>
               </div>
               <p>A processor <span class="verb">may</span> also provide a mode of operation in which 
               <a title="static error" class="termref" href="#dt-static-error">static errors</a> in parts of the stylesheet that 
               are not evaluated can go unreported.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>For example, when operating in this mode, a processor might report static errors 
               in a template rule only if the input document contains nodes that match that template rule. 
               Such a mode of operation can provide performance benefits when large and well-tested stylesheets 
               are used to process source documents that might only use a small part of the XML vocabulary 
               that the stylesheet is designed to handle.
            </p>
               </div>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-dynamic-error" title="dynamic error"></a>An error that is not 
                  capable of detection
                  until a source document is being transformed is referred to as a <b>dynamic
                     error</b>.<span class="definition">]</span>
            </p>
               <p>When a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs, and is not caught
               using <a href="#element-catch"><code>xsl:catch</code></a>, the <a title="processor" class="termref" href="#dt-processor">processor</a>
               <span class="verb">must</span> raise the error, and the transformation fails.</p>
               <p>Because different implementations may optimize execution of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> in different ways, the detection of
               dynamic errors is to some degree <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. In cases where an implementation is able to
               produce a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or
                     <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>
                without evaluating a particular construct, the
               implementation is never <span class="verb">required</span> to evaluate that construct solely
               in order to determine whether doing so causes a dynamic error. For example, if a
                  <a title="variable" class="termref" href="#dt-variable">variable</a> is declared but never referenced, an
               implementation <span class="verb">may</span> choose whether or not to evaluate the variable
               declaration, which means that if evaluating the variable declaration causes a dynamic
               error, some implementations will raise this error and others will not.</p>
               <p>There are some cases where this specification requires that a construct <span class="verb">must
                  not</span> be evaluated: for example, the content of an <a href="#element-if"><code>xsl:if</code></a>
               instruction <span class="verb">must not</span> be evaluated if the test condition is false.
               This means that an implementation <span class="verb">must not</span> raise any dynamic
               errors that would arise if the construct were evaluated.</p>
               <p>An implementation <span class="verb">may</span> raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> before any source document is available, but only if it
               can determine that the error would be raised for every possible source document and
               every possible set of parameter values. For example, some <a title="circularity" class="termref" href="#dt-circularity">circularity</a> errors fall into this category: see
                  <a href="#circularity"><i>9.11 Circular Definitions</i></a>.</p>
               <p>There are also some <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                  errors</a> where the specification gives a processor license to raise the
               error during the analysis phase even if the construct might never be executed; an
               example is the use of an invalid QName as a literal argument to a function such as
                  <a href="#func-key"><code>key</code></a>, or the use of an invalid regular expression in the
                  <code>regex</code> attribute of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>
               instruction.</p>
               <p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>
               is also raised during the static
               analysis phase if the error occurs during evaluation of a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>.</p>
               <p>The XPath specification states (see <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-kinds-of-errors">2.5.1 Kinds of Errors</a>)
               that if any expression (at any level) can be evaluated during the analysis phase
               (because all its explicit operands are known and it has no dependencies on the
               dynamic context), then any error in performing this evaluation <span class="verb">may</span>
               be raised as a static error. For XPath expressions used in an XSLT stylesheet,
               however, any such errors <span class="verb">must not</span> be raised as static errors in
               the stylesheet unless they would occur in every possible evaluation of that
               stylesheet; instead, they must be raised as dynamic errors, and raised only if
               the XPath expression is actually evaluated.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e3465"></a>Example: Errors in Constant Subexpressions</div>
                  <p>An XPath processor may report statically that the expression <code>1 div 0</code>
                  fails with a “divide by zero” error. But suppose this XPath expression occurs in
                  an XSLT construct such as:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:choose&gt;
  &lt;xsl:when test="system-property('xsl:version') = '1.0'"&gt;
    &lt;xsl:value-of select="1 div 0"/&gt;
  &lt;/xsl:when&gt;
  &lt;xsl:otherwise&gt;
    &lt;xsl:value-of select="xs:double('INF')"/&gt;
  &lt;/xsl:otherwise&gt;
&lt;/xsl:choose&gt;</pre>
                  </div>
                  <p>Then the XSLT processor must not report an error, because the relevant XPath
                  construct appears in a context where it will never be executed by an XSLT 
                  <span>4.0</span> processor. (An XSLT 1.0 processor
                  will execute this code successfully, returning positive infinity, because it uses
                  double arithmetic rather than decimal arithmetic.)</p>
               </div>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-type-error" title="type error"></a>Certain errors are classified as
                     <b>type errors</b>. A type error occurs when the value supplied as input
                  to an operation is of the wrong type for that operation, for example when an
                  integer is supplied to an operation that expects a node.<span class="definition">]</span> If a type error
               occurs in an instruction that is actually evaluated, then it <span class="verb">must</span>
               be raised in the same way as a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a>. Alternatively, an
               implementation <span class="verb">may</span> raise a type error during the analysis phase
               in the same way as a <a title="static error" class="termref" href="#dt-static-error">static error</a>, even if
               it occurs in part of the stylesheet that is never evaluated, provided it can
               establish that execution of a particular construct would never succeed.</p>
               <p>It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether type errors are raised
               statically.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e3504"></a>Example: A Type Error</div>
                  <p>The following construct contains a type error, because
                     <code>42</code> is not allowed as the value of the <code>select</code>
                  expression of the <a href="#element-number"><code>xsl:number</code></a> instruction (it must be a node). An
                  implementation <span class="verb">may</span> optionally raise this as a static error,
                  even though the offending instruction will never be evaluated, and the type error
                  would therefore never be raised as a dynamic error.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:if test="false()"&gt;
  &lt;xsl:number select="42"/&gt;
&lt;/xsl:if&gt;</pre>
                  </div>
                  <p>On the other hand, in the following example it is not possible to determine
                  statically whether the operand of <a href="#element-number"><code>xsl:number</code></a> will have a suitable dynamic type. An
                  implementation <span class="verb">may</span> produce a warning in such cases, but it
                     <span class="verb">must not</span> treat it as an error.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="para"&gt;
  &lt;xsl:param name="p" as="item()"/&gt;
  &lt;xsl:number select="$p"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>If more than one error arises, an implementation is not <span class="verb">required</span>
               to raise any errors other than the first one that it detects. It is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> which of the
               several errors is raised. This applies both to static errors and to dynamic errors.
               An implementation is allowed to raise more than one error, but if any errors have
               been raised, it <span class="verb">must not</span> finish as if the transformation were
               successful.</p>
               <p>When a transformation raises one or more dynamic errors, the final state of any
               persistent resources updated by the transformation is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.
               Implementations are not <span class="verb">required</span> to restore such resources to
               their initial state. In particular, where a transformation produces multiple result
               documents, it is possible that one or more serialized result documents
                  <span class="verb">may</span> be written successfully before the transformation
               terminates, but the application cannot rely on this behavior.</p>
               <p>Everything said above about error handling applies equally to errors in evaluating
               XSLT instructions, and errors in evaluating XPath <a title="expression" class="termref" href="#dt-expression">expressions</a>. Static errors and dynamic errors may occur in both
               cases.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-serialization-error" title="serialization error"></a>If a transformation
                  has successfully produced a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>, it is
                     still possible that errors may occur in serializing that result
                  . For example, it may be impossible to
                  serialize the result  using the
                  encoding selected by the user. Such an error is referred to as a
                     <b>serialization error</b>.<span class="definition">]</span> If the processor performs
               serialization, then it <span class="verb">must</span> do so as specified in <a href="#serialization"><i>26 Serialization</i></a>, and in particular it <span class="verb">must</span> raise any
               serialization errors that occur.</p>
               <p>Errors are identified by a QName. For errors defined in this specification, the
               namespace of the QName is always <code>http://www.w3.org/2005/xqt-errors</code> (and
               is therefore not given explicitly), while the local part is an 8-character code in
               the form <var>PPSSNNNN</var>. Here <var>PP</var> is always <code>XT</code> (meaning
               XSLT), and <var>SS</var> is one of <code>SE</code> (static error), <code>DE</code>
               (dynamic error),  or <code>TE</code>
               (type error). Note that the allocation of an error to one of these categories is
               purely for convenience and carries no normative implications about the way the error
               is handled. Many errors, for example, can be raised either dynamically or
               statically. These error codes are used to label error conditions in this
               specification, and are summarized in <a href="#error-summary"><i>D Summary of Error Conditions</i></a>. </p>
               <p>Errors defined in related specifications (<a href="#xpath-40">[XPath 4.0]</a>, <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>
               <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>) use QNames with a similar structure, in
               the same namespace. When errors occur in processing XPath expressions, an XSLT
               processor <span class="verb">should</span> use the original error code reported by the XPath
               processor, unless a more specific XSLT error code is available.</p>
               <p>Implementations <span class="verb">must</span> use the codes
               defined in these specifications when raising dynamic errors, to ensure that
                     <a href="#element-catch"><code>xsl:catch</code></a> behaves in an interoperable way across
                  implementations. Stylesheet authors should note, however, that there are many
                  examples of errors where more than one rule in this specification is violated, and
                  where the processor therefore has discretion in deciding which error code to
                  associate with the condition: there is therefore no guarantee that different
                  processors will always use the same error code for the same erroneous
                  input.</p>
               <p>Additional errors defined by an implementation (or by an application)
                  <span class="verb">may</span> use QNames in an implementation-defined (or user-defined)
               namespace without risk of collision.</p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="stylesheet-structure"></a>3 <a href="#stylesheet-structure" style="text-decoration: none">Stylesheet Structure</a></h2>
            <p>This section describes the overall structure of a stylesheet as a collection of XML
            documents.</p>
            <div class="div2">
               
               <h3><a id="namespaces"></a>3.1 <a href="#namespaces" style="text-decoration: none">Namespaces</a></h3>
               <p>A <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> is typically written
               as a namespace well-formed XML document: more formally, as described in 
               <a href="#stylesheet-modules"><i>3.5 Stylesheet Modules</i></a>, a stylesheet module 
               takes the form of an XDM tree rooted at an element node.</p>
               <p>The names of elements and attributes in source documents and
               result documents are namespace-qualified names. In addition, as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>,
               XSLT uses namespace-qualified names to identify variables, functions, templates, and other components.
               These names generally use namespace prefixes that are resolved to namespace URIs using a set
               of prefix-uri namespace bindings.</p>
               <p>There are two ways namespace bindings can be established in a
            stylesheet module:</p>
               <ul>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-native-namespace-bindings" title="native namespace bindings"></a>
                     The <b>native namespace bindings</b> for any element in an XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>
                     are the prefix-uri mappings defined by the namespace nodes of that element, according to the rules in
                     <a href="#xpath-datamodel-40">[XDM 4.0]</a>.<span class="definition">]</span></p>
                     <p>For example, a namespace declaration of the form 
                     <code>xmlns:math="http://www.w3.org/2005/xpath-functions/math</code> establishes a binding 
                     of the prefix <code>math</code> to the namespace URI <code>http://www.w3.org/2005/xpath-functions/math</code>,
                     thereby enabling functions in that namespace to be invoked using an expression such as
                     <code>math:sin($theta)</code>
                  </p>
                  </li>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-fixed-namespace-bindings" title="fixed namespace bindings"></a>
                     The <b>fixed namespace bindings</b> for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are
                     established using the <code>fixed-namespaces</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>,
                     <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element enclosing the stylesheet
                     module.<span class="definition">]</span></p>
                     <p>For example, the attribute <code>fixed-namespaces="math map array"</code>
                     establishes bindings for the prefixes <code>math</code>, <code>map</code>, and <code>array</code>
                     to the namespace URIs conventionally associated with these prefixes as described
                     in <a href="#reserved-namespaces"><i>5.1.3 Reserved Namespaces</i></a>.</p>
                  </li>
               </ul>
               <p>Prefixes used in element and attribute names in the stylesheet, because these are interpreted
            by the XML parser and not only by the XSLT processor, <span class="verb">must</span> be bound
            using <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>.
            In particular, the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> is used in the names of XSLT elements, so it must 
            be declared in every stylesheet module using a namespace declaration such as
            <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform</code>. (A different prefix can be used:
               some users prefer <code>xslt</code>, some favor the default namespace.) 
               But namespace prefixes that are only used within the content of
            attribute and text nodes in the stylesheet (for example, <code>select="math:sin($theta)"</code>)
            can be declared in <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-applicable-static-namespaces" title="applicable static namespaces"></a>
               The <b>applicable static namespaces</b> for an element in a stylesheet module are the
               <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> for the module if the root element
               of the module has a <code>fixed-namespaces</code> attribute, or the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>
               of the element otherwise.
            <span class="definition">]</span></p>
               <p>The effect of declaring fixed namespace bindings is described in more detail in
            <a href="#fixed-namespaces"><i>3.6.1 The fixed-namespaces Attribute</i></a>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>As a general rule:</p>
                  <ul>
                     <li>
                        <p>Prefixes used in the names of elements and attributes in the stylesheet
                  must be declared using <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>.</p>
                     </li>
                     <li>
                        <p>Prefixes used in QNames appearing in the content of attribute nodes
                     and text nodes in the stylesheet can usually be declared using
                     <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>. There are a small number
                  of exceptions, notably the standard attributes <code>[xsl:]exclude-result-prefixes</code>
                  and <code>[xsl:]extension-element-prefixes</code>, and the <code>stylesheet-prefix</code>
                  and <code>result-prefix</code> attributes of <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>.</p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="xslt-namespace"></a>3.1.1 <a href="#xslt-namespace" style="text-decoration: none">XSLT Namespace</a></h4>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-namespace" title="XSLT namespace"></a>The <b>XSLT namespace</b>
                     has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
                     identify elements, attributes, and other names that have a special meaning defined
                     in this specification.<span class="definition">]</span>
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <code>1999</code> in the URI indicates the year in which the URI was allocated
                     by the W3C. It does not indicate the version of XSLT being used, which is
                     specified by attributes (see <a href="#stylesheet-element"><i>3.6 Stylesheet Element</i></a> and <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>).</p>
                  </div>
                  <p>XSLT <a title="processor" class="termref" href="#dt-processor">processors</a>
                  <span class="verb">must</span> use the XML namespaces mechanism <a href="#xml-names">[Namespaces in XML]</a> to
                  recognize elements and attributes from this namespace. Elements from the XSLT
                  namespace are recognized only in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> and not in the source document. The complete list of
                  XSLT-defined elements is specified in <a href="#element-syntax-summary"><i>C Element Syntax Summary</i></a>.
                     <a title="implementation" class="termref" href="#dt-implementation">Implementations</a>
                  <span class="verb">must not</span> extend the XSLT namespace with additional elements or
                  attributes. Instead, any extension <span class="verb">must</span> be in a separate
                  namespace. Any namespace that is used for additional instruction elements
                     <span class="verb">must</span> be identified by means of the <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism specified
                  in <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>.</p>
                  <p>Except where the rules for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>
                     dictate otherwise, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a>
                     for any element in the stylesheet to be in the XSLT namespace unless it is an element defined in this
                     specification <span class="error">[see <a href="#err-XTSE0010">ERR XTSE0010</a>]</span>.</p>
                  <p>This specification uses a prefix of <code>xsl:</code> for referring to elements in
                  the XSLT namespace. However, XSLT stylesheets are free to use any prefix, provided
                  that there is a namespace declaration that binds the prefix to the URI of the XSLT
                  namespace.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Throughout this specification, an element or attribute that is in no namespace, or
                     an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> whose namespace part
                     is the empty sequence, is referred to as having a <b>null namespace
                     URI</b>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>By convention, the names of <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT
                        elements</a>, attributes and functions are all lower-case;
                     they use hyphens to separate words, and they use abbreviations only if these already appear
                     in the syntax of a related language such as XML or HTML. Names of types defined in
                     XML Schema are regarded as single words and are capitalized exactly as in XML
                     Schema. This sometimes leads to composite function names such as
                        <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>current-dateTime</code></a>.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="xslt-media-type"></a>3.2 <a href="#xslt-media-type" style="text-decoration: none">XSLT Media Type</a></h3>
               <p>The media type <code>application/xslt+xml</code>
               has been registered for XSLT stylesheet
               modules.</p>
               <p>The definition of the media type is at <a href="#XSLT-Mime-Type">[XSLT Media Type]</a>.</p>
               <p>This media type <span class="verb">should</span> be used for an XML document containing a
                  <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a>
               at its top level, and it <span class="verb">may</span> also be used for a <a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module">simplified stylesheet module</a>. It
                  <span class="verb">should not</span> be used for an XML document containing an 
               <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded stylesheet module</a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="standard-attributes"></a>3.3 <a href="#standard-attributes" style="text-decoration: none">Standard Attributes</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#package-locations">next</a> | <a href="#stylesheets-and-schemas">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The standard attribute <code>[xsl:]schema-role</code> is introduced, to allow 
                  different parts of a stylesheet to use different schemas.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-standard-attributes" title="standard attributes"></a>There are a number of
                     <b>standard attributes</b> that may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>: specifically
                     <code>default-collation</code>, 
                     <code>default-mode</code>,
                     <code>default-validation</code>,
                     <code>exclude-result-prefixes</code>, 
                     <code>expand-text</code>, 
                     <code>extension-element-prefixes</code>,
                     <code>schema-role</code>,
                     <code>use-when</code>, 
                     <code>version</code>, and
                     <code>xpath-default-namespace</code>.<span class="definition">]</span>
            </p>
               <p>These attributes may also appear on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, but in this case, to distinguish them from
               user-defined attributes, the names of the attributes are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. They are thus typically written
               as <code>xsl:default-collation</code>,
               <code>xsl:default-mode</code>, 
               <code>xsl:default-validation</code>,
                  <code>xsl:exclude-result-prefixes</code>, <code>xsl:expand-text</code>, 
               <code>xsl:extension-element-prefixes</code>, <code>xsl:use-when</code>,
                  <code>xsl:version</code>, or <code>xsl:xpath-default-namespace</code>.</p>
               <p>It is <span class="verb">recommended</span> that all these attributes should also be
               permitted on <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension
               instructions</a>, but this is at the discretion of the implementer of each
               extension instruction. They <span class="verb">may</span> also be permitted on <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>, though they will only
               have any useful effect in the case of data elements that are designed to behave like
               XSLT declarations or instructions.</p>
               <p>In the following descriptions, these attributes are referred to generically as
                  <code>[xsl:]version</code>, and so on.</p>
               <p>These attributes all affect the element they appear on, together with any elements
               and attributes that have that element as an ancestor. The two forms with and without
               the XSLT namespace have the same effect; the XSLT namespace is used for the attribute
               if and only if its parent element is <em>not</em> in the XSLT namespace.</p>
               <p>In the case of <code>[xsl:]default-collation</code>, 
               <code>[xsl:]expand-text</code>, <code>[xsl:]schema-role</code>,
               <code>[xsl:]version</code>, and <code>[xsl:]xpath-default-namespace</code>, the value
               can be overridden by a different value for the same attribute appearing on a
               descendant element. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute for a particular stylesheet
               element is determined by the innermost ancestor-or-self element on which the
               attribute appears.</p>
               <p>In an <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded stylesheet
                  module</a>, <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard
                  attributes</a> appearing on ancestors of the outermost element of the
               stylesheet module have no effect.</p>
               <p>In the case of <code>[xsl:]exclude-result-prefixes</code> and
                  <code>[xsl:]extension-element-prefixes</code> the values are cumulative. For these
               attributes, the value is given as a whitespace-separated list of namespace prefixes,
               and the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> for an element is the combined set of namespace URIs
               designated by the prefixes that appear in this attribute for that element and any of
               its ancestor elements. Again, the two forms with and without the XSLT namespace are
               equivalent.</p>
               <p>The effect of the <code>[xsl:]use-when</code> attribute is described in <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>.</p>
               <p>Because these attributes may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT
                  element</a>, they are not listed in the syntax summary of each individual
               element. Instead they are listed and described in the entry for the
                  <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, and <a href="#element-package"><code>xsl:package</code></a> elements only. This
               reflects the fact that these attributes are often used on the outermost element of the stylesheet, in which case they apply to
               the entire <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>
               or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>.</p>
               <p>Note that the effect of these attributes does <em>not</em> extend to <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> referenced by
                  <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a> declarations, nor to packages referenced using
                     <a href="#element-use-package"><code>xsl:use-package</code></a>.</p>
               <p>For the detailed effect of each attribute, see the following sections:</p>
               <dl>
                  <dt class="label">
                     <code>[xsl:]default-collation</code>
                     </dt>
                  <dd>
                     <p>see <a href="#default-collation-attribute"><i>3.6.2 The default-collation Attribute</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]default-mode</code>
                     </dt>
                  <dd>
                     <p>see <a href="#default-mode"><i>3.6.3 The default-mode Attribute</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]default-validation</code>
                     </dt>
                  <dd>
                     <p>see <a href="#validation"><i>25.4 Validation</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]exclude-result-prefixes</code>
                     </dt>
                  <dd>
                     <p>see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]expand-text</code>
                     </dt>
                  <dd>
                     <p>see <a href="#text-value-templates"><i>5.6.2 Text Value Templates</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]extension-element-prefixes</code>
                     </dt>
                  <dd>
                     <p>see <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]schema-role</code>
                     </dt>
                  <dd>
                     <p>see <a href="#multiple-schemas"><i>3.13.1 Multiple Schemas</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]use-when</code>
                     </dt>
                  <dd>
                     <p>see <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]version</code>
                     </dt>
                  <dd>
                     <p>see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a> and <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>
                     </p>
                  </dd>
                  <dt class="label">
                     <code>[xsl:]xpath-default-namespace</code>
                     </dt>
                  <dd>
                     <p>see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>
                     </p>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="packages"></a>3.4 <a href="#packages" style="text-decoration: none">Packages</a></h3>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-package" title="package"></a>An explicit <b>package</b> is
                  represented by an <a href="#element-package"><code>xsl:package</code></a> element, which will generally be
                  the outermost element of an XML document. When the
                        <a href="#element-package"><code>xsl:package</code></a> element is not used explicitly, the entire
                     stylesheet comprises a single implicit package.<span class="definition">]</span> (This
               specification does not preclude the <a href="#element-package"><code>xsl:package</code></a> being embedded in
               another XML document, but it will never have any other XSLT element as an
               ancestor).</p>
               <p class="element-syntax"><a id="element-package"></a><code>&lt;xsl:package<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;name? = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var>〔'1'〕<br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;declared-modes? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-expose">xsl:expose</a> | <var>declarations</var>)*) --&gt;<br>&lt;/xsl:package&gt;</code></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-package-manifest" title="package manifest"></a>The content of the
                     <a href="#element-package"><code>xsl:package</code></a> element is referred to as the <b>package
                     manifest</b><span class="definition">]</span>.</p>
               <p>The <code>version</code> attribute indicates the
               version of the XSLT language specification to which the package manifest conforms.
                  The value <span class="verb">should</span> normally be
                     <span><code>4.0</code></span>. 
               If the value is numerically less than <span><code>4.0</code></span>, the
                  content of the <a href="#element-package"><code>xsl:package</code></a> element is processed using the rules
                  for <a title="backwards compatible behavior" class="termref" href="#dt-backwards-compatible-behavior">backwards compatible
                     behavior</a> (see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>). If the value is
               numerically greater than <span><code>4.0</code></span>, it is processed using the rules for
                     <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>).</p>
               <p>A package typically has a name, given in its <code>name</code>
               attribute, which <span class="verb">must</span> be an absolute URI. Unnamed packages are
               allowed, but they can only be used as the “top level” of an application; they cannot
               be the target of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration in another
               package.</p>
               <p>A package may have a version identifier, given in
               its <code>package-version</code> attribute. This is used to distinguish different
               versions of a package. The value of the version
                  attribute, after trimming leading and trailing whitespace, <span class="verb">must</span>
                  conform to the syntax given in <a href="#package-versions"><i>3.4.1 Versions of a Package</i></a>. If no version
                  number is specified for a package, version <code>1</code> is assumed.</p>
               <p>The attributes <code>default-collation</code>, <code>default-mode</code>, <code>default-validation</code>,
                  <code>exclude-result-prefixes</code>, <code>expand-text</code>,
                  <code>extension-element-prefixes</code>, <code>use-when</code>,
                  <code>version</code>, and <code>xpath-default-namespace</code> are standard
               attributes that can appear on any XSLT element, and potentially affect all descendant
               elements. Their meaning is described in <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>.</p>
               <p>The package manifest contains the following
                  elements, arbitrarily ordered:</p>
               <ol class="enumar">
                  <li>
                     <p>Zero or more <a href="#element-expose"><code>xsl:expose</code></a> declarations that define the interface
                     offered by this package to the outside world. An <a href="#element-expose"><code>xsl:expose</code></a>
                  declaration may appear only as a child of <a href="#element-package"><code>xsl:package</code></a>.</p>
                  </li>
                  <li>
                     <p>Zero or more additional <a title="declaration" class="termref" href="#dt-declaration">declarations</a>.
                     These are the same as the declarations permitted as children of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                     or <a href="#element-transform"><code>xsl:transform</code></a>.</p>
                     <p>Some declarations of particular relevance to packages include:</p>
                     <ol class="enumla">
                        <li>
                           <p>The <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, which declares the names and
                     versions of the packages on which this package depends.</p>
                        </li>
                        <li>
                           <p>The optional <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element; if present this
                           element defines constraints on the existence and type of the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p>
                        </li>
                        <li>
                           <p>Zero or more <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a>
                     declarations, which define additional stylesheet modules to be incorporated into this package.</p>
                        </li>
                        <li>
                           <p>Zero or more ordinary <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, that is,
                        elements that are permitted as children of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or
                        <a href="#element-transform"><code>xsl:transform</code></a>. One possible coding style is to include in
                        the package manifest just a single <a href="#element-import"><code>xsl:import</code></a> or
                        <a href="#element-include"><code>xsl:include</code></a> declaration as a reference to the effective
                        top-level stylesheet module; this approach is particularly suitable when
                        writing code that is required to run under releases of XSLT 
                        <span>earlier than 3.0</span>. 
                        Another approach is to include the substance of the top-level
                        stylesheet module inline within the package manifest.</p>
                        </li>
                     </ol>
                  </li>
               </ol>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e4371"></a>Example: An example package</div>
                  <p>The following example shows a package that offers a number of functions for
                  manipulating complex numbers. A complex number is represented as a map with two
                  entries, the keys being 0 for the real part, and 1 for the imaginary part.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:package
  name="http://example.org/complex-arithmetic.xsl"
  package-version="1.0"
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:xs="http://www.w3.org/2001/XMLSchema"
  xmlns:f="http://example.org/complex-arithmetic.xsl"&gt;
  
  &lt;xsl:function name="f:complex-number" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="real" as="xs:double"/&gt;
    &lt;xsl:param name="imaginary" as="xs:double"/&gt;
    &lt;xsl:sequence select="{ 0: $real, 1: $imaginary }"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:real" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(0)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:imag" 
                as="xs:double" visibility="public"&gt;
    &lt;xsl:param name="complex" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="$complex(1)"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:add" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x) + f:real($y), 
           f:imag($x) + f:imag($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;xsl:function name="f:multiply" 
                as="map(xs:integer, xs:double)" visibility="public"&gt;
    &lt;xsl:param name="x" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:param name="y" as="map(xs:integer, xs:double)"/&gt;
    &lt;xsl:sequence select="
         f:complex-number(
           f:real($x)*f:real($y) - f:imag($x)*f:imag($y),
           f:real($x)*f:imag($y) + f:imag($x)*f:real($y))"/&gt;
  &lt;/xsl:function&gt;
  
  &lt;!-- etc. --&gt;
  
&lt;/xsl:package&gt;</pre>
                  </div>
                  <p>A more complex package might include private or abstract functions as well as
                  public functions; it might expose components other than functions (for example,
                  templates or global variables), and it might contain
                     <a href="#element-use-package"><code>xsl:use-package</code></a> elements to allow it to call on the services
                  of other packages.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In this example, the way in which complex numbers are represented is exposed to
                     users of the package. It would be possible to hide the representation by
                     declaring the types on public functions simply as <code>item()</code>; but this
                     would be at the cost of type safety.</p>
                  </div>
               </div>
               <p>A package that does not itself expose any components  may be written
               using a simplified syntax: the <a href="#element-package"><code>xsl:package</code></a> element is omitted, and
               the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element is now
               the outermost element of the stylesheet module. For compatibility reasons, all the
               named templates and modes declared in the package are made public. More formally, the
               principal stylesheet module of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level
                  package</a> may be expressed as an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or
                  <a href="#element-transform"><code>xsl:transform</code></a> element, which is equivalent to the package represented
               by the output of the following transformation, preserving the base URI of the
               source:</p>
               <div class="exampleInner">
                  <pre>
 &lt;xsl:transform version="3.0" 
    xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
    xmlns:t="http://www.w3.org/1999/XSL/TransformAlias"&gt;
 
    &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
    
    &lt;xsl:template match="xsl:stylesheet|xsl:transform"&gt;
      &lt;t:package declared-modes="no"&gt;
        &lt;xsl:copy-of select="@*"/&gt;
        &lt;t:expose component="mode" names="*" visibility="public"/&gt;
        &lt;t:expose component="template" names="*" visibility="public"/&gt;
        &lt;xsl:copy-of select="node()"/&gt;
      &lt;/t:package&gt;
    &lt;/xsl:template&gt;
 &lt;/xsl:transform&gt;</pre>
               </div>
               <p>The effect of the <code>input-type-annotations</code>
               attribute is defined in <a href="#stripping-annotations"><i>4.2.1 Stripping Type Annotations from a Source Tree</i></a>.</p>
               <p>A more extensive example of a package, illustrating how components
               in a package can be overridden in a client package, is given in <a href="#packages-csv-library-example"><i>3.4.8 Worked Example of a Library Package</i></a>.</p>
               <div class="div3">
                  
                  <h4><a id="package-versions"></a>3.4.1 <a href="#package-versions" style="text-decoration: none">Versions of a Package</a></h4>
                  <p>If a package has a version number, the version number must conform to the
                  grammar:</p>
                  <div class="exampleInner">
                     <pre>
        PackageVersion   ::= NumericPart ( "-" NamePart )?
        NumericPart      ::= IntegerLiteral ( "." IntegerLiteral )*
        NamePart         ::= NCName</pre>
                  </div>
                  <p>Here <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-IntegerLiteral">IntegerLiteral</a><sup><small>XP</small></sup> and <code>NCName</code> are as defined in
                  the XPath <span>4.0</span> grammar productions of the same name (including rules on
                     limits). Leading and trailing whitespace is ignored; no other
                  whitespace is allowed.</p>
                  <p>Examples of valid version numbers are <code>2.0.5</code> or
                     <code>3.10-alpha</code>.</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-portion" title="portion"></a>The integer literals and the optional
                        <code>NamePart</code> within the version number are referred to as the
                        <b>portions</b> of the version number.<span class="definition">]</span></p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This means that <code>1-alpha-2</code> is a valid version number, with two
                        <a title="portion" class="termref" href="#dt-portion">portions</a>: <code>1</code> and
                        <code>alpha-2</code>. The second hyphen is part of the <code>NCName</code>,
                     it does not act as a portion separator.</p>
                  </div>
                  <p>Versions are ordered. When comparing two versions:</p>
                  <ol class="enumar">
                     <li>
                        <p>Trailing zero <a title="portion" class="termref" href="#dt-portion">portions</a> (that is, any
                        zero-valued integer that is not followed by another integer) are
                        discarded.</p>
                     </li>
                     <li>
                        <p>Comparison proceeds by comparing <a title="portion" class="termref" href="#dt-portion">portions</a> pairwise from the left.</p>
                     </li>
                     <li>
                        <p>If both versions have the same number of <a title="portion" class="termref" href="#dt-portion">portions</a> and all <a title="portion" class="termref" href="#dt-portion">portions</a>
                        compare equal (under the rules of the
                           XPath <code>eq</code> operator using the Unicode codepoint
                           collation), then the versions compare equal.</p>
                     </li>
                     <li>
                        <p>If the number of <a title="portion" class="termref" href="#dt-portion">portions</a> in the two
                        versions <var>V<sub>1</sub></var> and <var>V<sub>2</sub></var> is <var>N<sub>1</sub></var> and <var>N<sub>2</sub></var>,
                        with <var>N<sub>1</sub></var>&lt;<var>N<sub>2</sub></var>, and if all <a title="portion" class="termref" href="#dt-portion">portions</a> in positions 1 to <var>N</var> compare equal, then
                           <var>V<sub>1</sub></var> is less than <var>V<sub>2</sub></var> if the <a title="portion" class="termref" href="#dt-portion">portion</a> of <var>V<sub>2</sub></var> in position <var>N<sub>1</sub></var> is an integer, and is
                        greater than <var>V<sub>2</sub></var> if this <a title="portion" class="termref" href="#dt-portion">portion</a> is an
                           <code>NCName</code>. For example, <code>1.2</code> is less than
                           <code>1.2.5</code>, while <code>2.0</code> is greater than
                           <code>2.0-rc1</code>.</p>
                     </li>
                     <li>
                        <p><a title="portion" class="termref" href="#dt-portion">Portions</a> are compared as follows:</p>
                        <ol class="enumla">
                           <li>
                              <p>If both <a title="portion" class="termref" href="#dt-portion">portions</a> are integers,
                              they are compared using the rules
                                 of XPath value comparisons.</p>
                           </li>
                           <li>
                              <p>If both <a title="portion" class="termref" href="#dt-portion">portions</a> are NCNames, they
                              are compared using the rules of
                                 XPath value comparisons, using the Unicode Codepoint
                              Collation.</p>
                           </li>
                           <li>
                              <p>If one <a title="portion" class="termref" href="#dt-portion">portion</a> is an integer and the other is an
                                 <code>NCName</code>, the <code>NCName</code> comes first.</p>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  <p>For example, the following shows a possible ordered sequence of version
                  numbers:</p>
                  <div class="exampleInner">
                     <pre>0-rc1 &lt; 0-rc2 &lt; 0 &lt; 1 = 1.0 &lt; 1.0.2 
   &lt; 1.0.3-rc1 &lt; 1.0.3 &lt; 1.0.3.2 &lt; 1.0.10</pre>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The version number format defined here is designed to be general enough to
                     accommodate a variety of conventions in common use, and to allow useful
                     semantics for matching of versions and ranges of versions, without being
                     over-prescriptive. It is influenced by <a href="#SemVer">[SemVer]</a>, but is not as
                     prescriptive, and it imposes no assumptions about backwards compatibility of
                     packages between successive versions.</p>
                  </div>
                  <p>Implementations <span class="verb">may</span> impose limits on the values
               used in a version number (or a version range: see below). Such limits are
               <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. As a minimum, 
               a processor <span class="verb">must</span> accept version numbers including:</p>
                  <ul>
                     <li>
                        <p>A numeric part containing four integers;</p>
                     </li>
                     <li>
                        <p>Each integer being in the range 0 to 999999;</p>
                     </li>
                     <li>
                        <p>An <code>NCName</code> of up to 100 characters</p>
                     </li>
                  </ul>
                  <p>Dependencies between packages may specify a version range (see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>). A version range represents a set of accepted
                  versions. The syntax of a version range is
                     shown below. Whitespace is permitted only where indicated, using the terminal
                     symbol <var>S</var>.</p>
                  <div class="exampleInner">
                     <pre>
        PackageVersionRange    ::=  AnyVersion | VersionRanges
        AnyVersion             ::=  "*"
        VersionRanges          ::=  VersionRange (S? "," S? VersionRange)*
        VersionRange           ::=  PackageVersion | VersionPrefix | 
                                      VersionFrom | VersionTo | VersionFromTo
        VersionPrefix          ::=  PackageVersion ".*"
        VersionFrom            ::=  PackageVersion "+"
        VersionTo              ::=  "to" S (PackageVersion | VersionPrefix)
        VersionFromTo          ::=  PackageVersion S 
                                      "to" S (PackageVersion | VersionPrefix)</pre>
                  </div>
                  <p>The meanings of the various forms of version range are
                  defined below:</p>
                  <ul>
                     <li>
                        <p>The range <code>AnyVersion</code> matches any version.</p>
                     </li>
                     <li>
                        <p>The range <code>VersionRanges</code> matches a version if any constituent
                           <code>VersionRange</code> matches that version.</p>
                        <p>For example, <code>9.5.0.8, 9.6.1.2</code>
                        matches those specific versions only, while <code>9.5.0.8, 9.6+</code>
                        matches either version 9.5.0.8 or any version from 9.6 onwards.</p>
                     </li>
                     <li>
                        <p>A range that is a <code>PackageVersion</code> matches that version only.</p>
                     </li>
                     <li>
                        <p>The range <code>VersionPrefix</code> matches any version whose leading
                           <a title="portion" class="termref" href="#dt-portion">portions</a> are the same as the 
                           <a title="portion" class="termref" href="#dt-portion">portions</a> in the <code>PackageVersion</code> part of the
                              <code>VersionPrefix</code>.</p>
                        <p>For example, <code>1.3.*</code> matches <code>1.3</code>,&nbsp;
                           <code>1.3.5</code>,&nbsp; <code>1.3.10.2</code>,&nbsp; and
                           <code>1.3-beta</code>
                        (but not <code>1</code> or
                              <code>1.4</code>).</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The <code>.*</code> indicates that additional 
                           <a title="portion" class="termref" href="#dt-portion">portions</a> may follow; 
                           it does not indicate a substring match
                           on the final <a title="portion" class="termref" href="#dt-portion">portion</a>. So
                              <code>1.3.*</code> does not match <code>1.35</code>, and
                              <code>3.3-beta.*</code> does not match <code>3.3-beta12</code>. Also,
                              <code>3.3-beta.*</code> does not match <code>3.3-beta.5</code>: this
                           is because the last dot is not a portion separator, but is part of the
                           final <code>NCName</code>. In fact, using <code>.*</code> after a version
                           number that includes an <code>NCName</code> portion is pointless, because
                           an <code>NCName</code> portion can never be followed by further
                           portions.</p>
                        </div>
                     </li>
                     <li>
                        <p>The range <code>VersionFrom</code> matches any version that is greater than
                        or equal to the version supplied.</p>
                        <p>For example <code>1.3+</code> matches
                           <code>1.3</code>,&nbsp; <code>1.3.2</code>,&nbsp; <code>1.4</code>,&nbsp;
                        and <code>2.1</code> (but not <code>1.3-beta</code> or <code>1.2</code>).
                        And <code>1.3-beta+</code> matches <code>1.3-beta</code>,&nbsp;
                           <code>1.3-gamma</code>,&nbsp; <code>1.3.0</code>,&nbsp; <code>1.4</code>,
                        and <code>8.0</code>, but not <code>1.3-alpha</code> or
                        <code>1.2</code>.</p>
                     </li>
                     <li>
                        <p>The range <code>VersionTo</code> matches any version that is less than or
                        equal to some version that matches the supplied 
                        <code>PackageVersion</code> or <code>VersionPrefix</code>.</p>
                        <p>For example, <code>to 4.0</code> matches <code>1.5</code>,&nbsp;
                           <code>2.3</code>,&nbsp; <code>3.8</code>,&nbsp; <code>4.0</code>,&nbsp;
                        and <code>4.0-beta</code> (but not <code>4.0.1</code>), while <code>to
                           3.3.*</code> matches <code>1.5</code> or <code>2.0.6</code> or
                           <code>3.3.4621</code>, but not <code>3.4.0</code> or
                           <code>3.4.0-beta</code>. </p>
                     </li>
                     <li>
                        <p>The range <code>VersionFromTo</code> matches any version that is greater
                        than or equal to the starting <code>PackageVersion</code>, and less than or
                        equal to some version that matches the ending 
                        <code>PackageVersion</code> or <code>VersionPrefix</code>.</p>
                        <p>For example, <code>1 to 5</code> matches <code>1.1</code>,&nbsp;
                           <code>2.1</code>,&nbsp; <code>3.1</code>,&nbsp; or <code>5.0</code> (but
                        not <code>5.1</code>), while <code>1 to 5.*</code> matches all of these,
                        plus versions such as <code>5.7.2</code> (but not <code>6.0</code> or
                           <code>6.0-beta</code>). Similarly,
                              <code>1.0-beta to 1.0</code> matches <code>1.0-beta</code>,
                              <code>1.0-beta.2</code>, <code>1.0-gamma</code>, and <code>1.0</code>,
                           but not <code>1.0-alpha</code> or <code>1.0.1</code>.</p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="package-dependencies"></a>3.4.2 <a href="#package-dependencies" style="text-decoration: none">Dependencies between Packages</a></h4>
                  <p>When <a title="component" class="termref" href="#dt-component">components</a> in one <a title="package" class="termref" href="#dt-package">package</a> reference components in another, the dependency of the first
                  package on the second must be represented by an <a href="#element-use-package"><code>xsl:use-package</code></a>
                  element. This may appear in the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a>
               of the first package (which may be a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>), or
               it may appear in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is referenced from
                  the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> via one or more
               <a href="#element-include"><code>xsl:include</code></a> declarations; however it must not be referenced
               via <a href="#element-import"><code>xsl:import</code></a> declarations (this is to avoid complications
                     caused by multiple <a href="#element-use-package"><code>xsl:use-package</code></a> declarations with
                     different <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>).</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-use" title="use"></a>If a package <var>Q</var> contains an
                        <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package
                        <var>P</var>, then package <var>Q</var> is said to <b>use</b> package
                        <var>P</var>. In this relationship package <var>Q</var> is referred to as
                     the <b>using</b> package, package <var>P</var> as the <b>used</b>
                     package.<span class="definition">]</span></p>
                  <p>The phrase <b>directly uses</b> is synonymous with <b>uses</b> as
                  defined above, while <b>directly or indirectly uses</b> refers to the
                  transitive closure of this relationship.</p>
                  <p class="element-syntax"><a id="element-use-package"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:use-package<br>&nbsp;&nbsp;<b>name</b> = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var>〔'*'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-package-location">xsl:package-location</a> | <a href="#element-accept">xsl:accept</a> | <a href="#element-override">xsl:override</a>)* --&gt;<br>&lt;/xsl:use-package&gt;</code></p>
                  <p>A <a title="package" class="termref" href="#dt-package">package</a> may be <a title="use" class="termref" href="#dt-use">used</a> by more than one other package, but the relationship
                     <span class="verb">must not</span> be cyclic. It is possible, but by no means
                  inevitable, that using the same package in more than one place within a stylesheet
                  will cause static errors due to the presence of conflicting components according
                  to the above rules. Where a package is successfully used by more than one other
                  package, its components may be overridden in different ways by different using
                  packages.</p>
                  <p>The <code>name</code> and <code>package-version</code> attributes together
                  identify the used package. The value of the
                        <code>package-version</code> attribute, if present, must conform to the
                     rules for a <code>PackageVersionRange</code> given in <a href="#package-versions"><i>3.4.1 Versions of a Package</i></a>; if omitted the value <code>*</code> is assumed,
                     which matches any version. The used package must have a name that is an exact
                     match for the name in the <code>name</code> attribute (using codepoint
                     comparison), and its explicit or implicit <code>package-version</code> must
                     match the version range given in the <code>package-version</code>
                     attribute.</p>
                  <p>Rules for determining the location of the package are described at 
                   <a href="#package-locations"><i>3.4.3 Locating Packages</i></a>.</p>
                  <p><a id="err-XTSE3005"><span class="error">[ERR XTSE3005] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package is dependent on
                        itself, where package <var>A</var> is defined as being dependent on package
                           <var>B</var> if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a>
                        declaration that references <var>B</var>, or if <var>A</var> contains an
                           <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references a package
                           <var>C</var> that is itself dependent on <var>B</var>.</p>
                  <p><a id="err-XTSE3008"><span class="error">[ERR XTSE3008] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-use-package"><code>xsl:use-package</code></a>
                  declaration appears in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is not in the
                  same <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> as the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a>
                  of the <a title="package" class="termref" href="#dt-package">package</a>.</p>
                  <p>The <a href="#element-accept"><code>xsl:accept</code></a> and <a href="#element-override"><code>xsl:override</code></a> elements are
                  used to modify the visibility or behavior of components acquired from the used
                  package; they are described in <a href="#accepting-components"><i>3.4.4.2 Accepting Components</i></a> below.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>It is not intrinsically an error to have two 
                  <a href="#element-use-package"><code>xsl:use-package</code></a> declarations that identify the same package
                  (or different versions of the same package). This has the same effect as
                  having two declarations that identify packages with different names but
                  identical content. In most cases it will result in an error (<span class="error">[see <a href="#err-XTSE3050">ERR XTSE3050</a>]</span>)
                  due to the presence of multiple components with the same name; but 
                  no error would occur, for example, if the used package is empty, or if the 
                  two <a href="#element-use-package"><code>xsl:use-package</code></a> declarations use <a href="#element-accept"><code>xsl:accept</code></a>
                  to accept non-overlapping subsets of the components in the used package.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="package-locations"></a>3.4.3 <a href="#package-locations" style="text-decoration: none">Locating Packages</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#stylesheet-element">next</a> | <a href="#standard-attributes">previous</a>)</p>
                     <ol>
                        <li>
                           <p>A new XSLT element, <code>xsl:package-location</code> is provide
                      to indicate to the processor where the required package is to be found.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/366">366</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1888">1888</a>&nbsp;17 June 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>A package may be located either explicitly, through one or more
                            <a href="#element-use-package"><code>xsl:use-package</code></a> elements, or implicitly, in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanism. Providing multiple package locations 
                       allows a developer to create fallback mechanisms or perform diagnostics.</p>
                  <p class="element-syntax"><a id="element-package-location"></a><code>&lt;xsl:package-location<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var><br>&nbsp;&nbsp;path-in-archive? = <var>string</var><br>&nbsp;&nbsp;archive-type? = <var>string</var><br>&nbsp;&nbsp;is-priority? = <var>boolean</var>〔true()〕<br>&nbsp;&nbsp;format? = <var>string</var>&nbsp;/&gt;</code></p>
                  <p>A <code>xsl:package-location</code> points to a resource that may or 
                    may not be an archive. If the target resource is an archive, then <code>xsl:package-location</code>:
                       </p>
                  <ul>
                     <li>
                        <p> <span class="verb">must</span> have an attribute <code>path-in-archive</code>, specifying the 
                                 location of the package manifest within the archive. The value of 
                                 <code>path-in-archive</code> is normalized such that it always begins with the string <code>!/</code>
                                 (the result of <code>replace(., "^(!/)?(.+)", "!/$2")</code>).
                             </p>
                     </li>
                     <li>
                        <p> <span class="verb">may</span> have an attribute <code>archive-type</code>,
                                specifying the type of archive. Implementations <span class="verb">must</span> 
                                support the ZIP file format, as defined by <a href="#ISO21320">[ISO 21320]</a>, the 
                                default archive format if the attribute is missing or the explicit format 
                                if the attribute has the value <code>zip</code>. All other values of this 
                                attribute are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
                     </li>
                  </ul>
                  <p>
                    </p>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the attribute <code>archive-type</code>
                      is present without the attribute <code>path-in-archive</code>, or if it does not have the
                      value <code>zip</code> or an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value.
                   </p>
                  <p>The attribute <code>href</code> takes an absolute or relative URI reference,
                        which is resolved as described in <a href="#uri-references"><i>5.8 URI References</i></a>, to 
                        locate the resource that is the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> 
                        or is the archive that contains the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>. </p>
                  <p>The URI scheme for archive resources is currently only provisionally defined (<a href="#rfc7595">[RFC 7595]</a>),
                       with the syntax <code>jar:&lt;url&gt;!/[&lt;entry&gt;]</code>, but variations on this syntax are known (such as using
                       <code>zip</code> instead of <code>jar</code>). The entry is already accommodated by the attribute 
                       <code>archive-type</code>, so the following adjustments must be made to the value of <code>href</code>
                       that points to an archive:
                        </p>
                  <ul>
                     <li>
                        <p>Remove "zip:" or "jar:" from the beginning of the value.</p>
                     </li>
                     <li>
                        <p>Remove <code>!/</code> and any string text that follows.</p>
                     </li>
                  </ul>
                  <p>
                    </p>
                  <p>The attribute <code>format</code> takes a string, default value
                            <code>xslt</code> if the attribute is absent, specifying the format of
                        the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>. The value 
                        <code>xslt</code> indicates that the package manifest is a standard XML
                        resource as described in these specifications. All other values are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, allowing implementers to support optimized
                        formats for a package manifest, be it a compiled binary resource or a different XML 
                        format.</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-high-priority-package-location" title="high priority package location"></a>A 
                         <code>xsl:package-location</code> without the attribute <code>is-priority</code>, 
                         or with <code>is-priority</code> set to <code>true</code> is a <b>high priority package 
                            location</b>.<span class="definition">]</span>
                      <span class="definition">[Definition:&nbsp;</span><a id="dt-low-priority-package-location" title="low priority package location"></a>A 
                         <code>xsl:package-location</code> with <code>is-priority</code> set to <code>false</code> is a 
                         <b>low priority package location</b>.<span class="definition">]</span></p>
                  <p>Each <a title="high priority package location" class="termref" href="#dt-high-priority-package-location">high priority package location</a> is processed in document order, followed by
                       <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> package locations, followed by each 
                       <a title="low priority package location" class="termref" href="#dt-low-priority-package-location">low priority package location</a> in document order. <span class="definition">[Definition:&nbsp;</span><a id="dt-optimal-package-location" title="priority package location"></a>The
                            first package location whose value of <code>href</code>, when resolved
                            as described in <a href="#uri-references"><i>5.8 URI References</i></a>, allows the system to
                            find the specified resource, and its entry if the resource is an archive, is
                            the <b>optimal package location</b>.<span class="definition">]</span> Once an optimal
                        package location is found, no other package locations are checked. </p>
                  <p>If the returned resource is an archive, the archive entry is to be treated as the
                     <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>, otherwise the resource itself is to be
                  treated as the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>. The <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> returned from the optimal package location is
                  checked against the implicit or explicit value of the attribute
                     <code>format</code>. If the resource does not conform to the rules for the
                  format type a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised.</p>
                  <p>The <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> is then checked against the the
                        package name and version specified in the <a href="#element-use-package"><code>xsl:use-package</code></a>
                        declaration. If the resource does not conform to the rules for the name and
                        version, a <a title="static error" class="termref" href="#dt-static-error">static error</a> is raised.</p>
                  <p><a id="err-XTSE3000"><span class="error">[ERR XTSE3000] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if after evaluating each
                                    <a href="#element-package-location"><code>xsl:package-location</code></a> declaration and <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> package location, no 
                               <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> is found.</p>
                  <p><a id="err-XTSE3002"><span class="error">[ERR XTSE3002] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> returned by the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> does not conform to the
                                rules of the implicit or explicit value of attribute
                                    <code>format</code>.</p>
                  <p><a id="err-XTSE3003"><span class="error">[ERR XTSE3003] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> returned by the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> does not conform to the
                                name and version specified in an <a href="#element-use-package"><code>xsl:use-package</code></a>
                                declaration.</p>
                  <p><a id="err-XTSE3004"><span class="error">[ERR XTSE3004] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the attribute <code>archive-type</code>
                               is present without the attribute <code>path-in-archive</code>, or if it does not have the
                               value <code>zip</code> or an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Use of the package name as a dereferenceable URI is <span class="verb">not
                                recommended</span>, because the intent of the packaging feature
                            is to allow a package to be distributed as reusable code and therefore
                            to exist in many different locations.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Depending on the implementation architecture, there may be a need to
                            locate used packages both during static analysis (for example, to get
                            information about the names and type signatures of the components
                            exposed by the used package), and also at evaluation time (to link to
                            the implementation of these components so they can be invoked). A
                            failure to locate a package may cause an error at either stage.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="example-of-package-locations"></a>Example: Example configuration of
                        <code>xsl:package-location</code>s.</div>
                     <p>Consider a using package <var>Q</var>, invoked as follows:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:use-package name="Q" version="3.0" xmlns:saxon="http://saxon.sf.net/"/&gt;
     &lt;package-location href="q-dev.xsl" use-when="$diagnostics-on"/&gt;
     &lt;package-location _href="file:/{$prod-path}/q.zip" path-in-archive="q.sef" 
           is-priority="true" format="saxon:sef"/&gt;
     &lt;package-location href="file:/D:/fallback/q.xsl" format="xslt" is-priority="false"/&gt;
&lt;/xsl:package&gt;</pre>
                     </div>
                     <p>The first <a href="#element-package-location"><code>xsl:package-location</code></a> will be the first to be evaluated
                           only if the static parameter <code>$diagnostics-on</code> is <code>true</code>, in which case
                           the local file <code>q-dev.xsl</code>, if it exists, will be the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a>. 
                            The next <a href="#element-package-location"><code>xsl:package-location</code></a> to be checked points to the archive resource located by 
                            the path <code>file:/{$prod-path}/q.zip</code> (which depends upon
                            the value of static parameter <code>$prod-path</code>), and the entry <code>q.sef</code>
                            at the root of the archive (assumed to be a ZIP file for lack of a 
                            <code>archive-type</code>). Next will be any <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> package locations. Last will be
                            the last <code>xsl:package-location</code>, a <a title="low priority package location" class="termref" href="#dt-low-priority-package-location">low priority package location</a>, which 
                           serves as a local fallback.</p>
                     <p>Each of these package locations will be evaluated in turn. If no 
                            <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> is found, an error is raised. 
                            Only the first resource to qualify as the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> 
                            will be checked, to ensure it conforms to the file format and the package name and version.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="named-components"></a>3.4.4 <a href="#named-components" style="text-decoration: none">Named Components in Packages</a></h4>
                  <p>This section discusses the use of named components in packages.</p>
                  <p>The components which can be declared in one package and
                  referenced in another are: <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">functions</a>, <a title="named template" class="termref" href="#dt-named-template">named
                     templates</a>, <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a>,
                     <a title="mode" class="termref" href="#dt-mode">modes</a>,  and <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">parameters</a>.</p>
                  <p>In addition, <a title="key" class="termref" href="#dt-key">keys</a> and <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a>
                  are classified as named components because they can contain references to
                  components in another package, even though they cannot themselves be referenced
                  from outside the package.</p>
                  <p>Named and unnamed <a title="mode" class="termref" href="#dt-mode">modes</a> come within the scope of this section, but there are
                  differences noted in <a href="#modes-and-packages"><i>3.4.5 Overriding Template Rules from a Used Package</i></a>.</p>
                  <p>Not all <a title="declaration" class="termref" href="#dt-declaration">declarations</a> result in <a title="component" class="termref" href="#dt-component">components</a>:</p>
                  <ul>
                     <li>
                        <p>Named <a title="declaration" class="termref" href="#dt-declaration">declarations</a> that can neither be referenced from outside their
                        containing package, nor can contain references to components in other
                        packages (examples are <a href="#element-output"><code>xsl:output</code></a>,
                           <a href="#element-character-map"><code>xsl:character-map</code></a>, and
                           <a href="#element-decimal-format"><code>xsl:decimal-format</code></a>) are not considered to be components
                        and are therefore outside the scope of this section.</p>
                     </li>
                     <li>
                        <p>Some declarations, such as <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> and
                           <a href="#element-strip-space"><code>xsl:strip-space</code></a>, declare aspects of the processing
                        context which are not considered to be components as defined here.</p>
                     </li>
                     <li>
                        <p><a title="template rule" class="termref" href="#dt-template-rule">Template rules</a>
                           (<a href="#element-template"><code>xsl:template</code></a> with a <code>match</code> attribute) are
                        also not considered to be components for the purposes of this section, which
                        is concerned only with components that are bound by name. However, when an
                           <a href="#element-template"><code>xsl:template</code></a> has both a <code>match</code> attribute and
                        a <code>name</code> attribute, then it establishes both a template rule and
                        a <a title="named template" class="termref" href="#dt-named-template">named template</a>, and in its role
                        as a named template it comes within the scope of this discussion.</p>
                     </li>
                     <li>
                        <p>A named declaration, for example a named template, a function, 
                         or a global
                        variable, may be overridden within the same package by another like-named
                        declaration having higher <a title="import precedence" class="termref" href="#dt-import-precedence">import
                           precedence</a>. When a declaration is overridden in this way it cannot
                        be referenced by name either from within its containing package or
                        from outside that package. </p>
                     </li>
                     <li>
                        <p>In the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
                        and <a href="#element-key"><code>xsl:key</code></a> declarations, several declarations combine to
                        form a single component.</p>
                     </li>
                  </ul>
                  <p>The section is largely concerned with details of the rules that affect references
                  from one component to another by name, whether the components are in the same
                  package or in different packages. The rules are designed to meet a number of
                  requirements:</p>
                  <ul>
                     <li>
                        <p>A component defined in one package can be overridden by a component in
                        another package, provided the signatures are type-compatible.</p>
                     </li>
                     <li>
                        <p>The author of a package can declare whether the components in the package
                        are public or private (that is, whether or not they can be used from outside
                        the package) and whether they are final, overridable, or abstract (that is
                        whether they can or must be overridden by the using package).</p>
                     </li>
                     <li>
                        <p>Within an application, two packages can make use of a common library and
                        override its components in different ways.</p>
                     </li>
                     <li>
                        <p>Visibility of components can be defined either as part of the declaration of
                        the component, or in the package manifest.</p>
                     </li>
                     <li>
                        <p>An application that wishes to make use of a <a title="library package" class="termref" href="#dt-library-package">library package</a> can be selective about
                        which components from the library it acquires, perhaps to avoid name clashes
                        between components acquired from different libraries.</p>
                     </li>
                  </ul>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-component" title="component"></a>The term <b>component</b> is
                     used to refer to any of the following: a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a <a title="named template" class="termref" href="#dt-named-template">named
                        template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="accumulator function" class="termref" href="#dt-accumulator-function">accumulator</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, or a <a title="mode" class="termref" href="#dt-mode">mode</a>.<span class="definition">]</span></p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-symbolic-identifier" title="symbolic identifier"></a>The <b>symbolic
                        identifier</b> of a <a title="component" class="termref" href="#dt-component">component</a> is a
                     composite name used to identify the component uniquely within a package. The
                     symbolic identifier comprises the kind of component (stylesheet function, named
                     template, accumulator, attribute set, global
                     variable, key, or mode), the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                        QName</a> of the component (namespace URI plus local name), and in the
                     case of stylesheet functions, <span>the upper
                     bound of the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a></span>.<span class="definition">]</span></p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In the case of the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>,
                     the expanded QName of the component may be considered to be some
                     system-allocated name different from any user-defined mode name.</p>
                  </div>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-homonymous" title="homonymous"></a>Two <a title="component" class="termref" href="#dt-component">components</a> are said to be <b>homonymous</b> if they have
                     the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic
                     identifier</a>.<span class="definition">]</span></p>
                  <p>Every <a title="component" class="termref" href="#dt-component">component</a> has a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> in some <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> and therefore within some <a title="package" class="termref" href="#dt-package">package</a>. In the
                     case of <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a> and <a title="key" class="termref" href="#dt-key">keys</a>, there may be several declarations. The
                  declaration is an element in an XDM tree representing the stylesheet module.
                  Declarations therefore have identity, based on XDM node identity.</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-declaring-package" title="declaring package"></a>The <b>declaring
                        package</b> of a <a title="component" class="termref" href="#dt-component">component</a> is the
                     package that contains the declaration (or,
                        in the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> and
                           <a href="#element-key"><code>xsl:key</code></a>, multiple declarations) of the
                     component.<span class="definition">]</span></p>
                  <p>When a <a title="component" class="termref" href="#dt-component">component</a> declared in one <a title="package" class="termref" href="#dt-package">package</a> is made available in another, the using
                  package will contain a separate component that can be regarded as a modified copy
                  of the original. The new component shares the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> as the original, and
                  it has the same <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, but it has
                  other properties such as its <a title="visibility" class="termref" href="#dt-visibility">visibility</a>
                  that may differ from the original.</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-containing-package" title="containing package"></a>A
                     component declaration results in multiple components, one in the package in
                     which the declaration appears, and potentially one in each package that uses
                     the declaring package, directly or indirectly, subject to the visibility of the
                     component. Each of these multiple components has the same <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, but each has a different <b>containing
                        package</b>. For the original component, the declaring package and the
                     containing package are the same; for a copy of a component made as a result of
                     an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, the declaring package will be
                     the original package, and the containing package will be the package in which
                     the <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears.<span class="definition">]</span></p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Within this specification, we generally use the
                     notation <var>C<sub>P</sub></var> for a component named C whose declaring package and
                     containing package are both <var>P</var>; and the notation <var>C<sub>PQ</sub></var> for
                     a component whose containing package is <var>P</var> and whose declaring
                     package is <var>Q</var> (that is, a component in <var>P</var> that is derived
                     from a component <var>C<sub>Q</sub></var> in the used package <var>Q</var>).</p>
                  </div>
                  <p>The properties of a <a title="component" class="termref" href="#dt-component">component</a> are as
                  follows:</p>
                  <ul>
                     <li>
                        <p>The original <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of the
                        component.</p>
                     </li>
                     <li>
                        <p>The <a title="package" class="termref" href="#dt-package">package</a> to which the component
                        belongs (called its <b>containing</b> package, not to be confused with
                        the <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>).</p>
                     </li>
                     <li>
                        <p>The <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> of
                        the component.</p>
                     </li>
                     <li>
                        <p>The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component,
                        which determines the way in which the component is seen by other components
                        within the same package and within using packages. This is one of
                           <code>public</code>, <code>private</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>. The visibility of components
                        is discussed further in <a href="#visibility"><i>3.4.4.1 Visibility of Components</i></a>.</p>
                     </li>
                     <li>
                        <p>A set of bindings for the <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic
                           references</a> in the component. The way in which these bindings
                        are established is discussed further in <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>.</p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>When a function <var>F</var> defined in a package <var>P</var> is acquired by
                     two using packages <var>Q</var> and <var>R</var>, we may think of <var>P</var>,
                     <var>Q</var>, and <var>R</var> as all providing access to the “same”
                     function. The detailed semantics, however, demand an understanding that there
                     is one function declaration, but three components. The three components
                     representing the function <var>F</var> within packages <var>P</var>,
                        <var>Q</var>, and <var>R</var> have some properties in common (the same
                     symbolic identifier, the same declaration), but other properties (the
                     visibility and the bindings of symbolic references) that may vary from one of
                     these components to another.</p>
                  </div>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-symbolic-reference" title="symbolic reference"></a>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a component includes
                     constructs that can be interpreted as references to other <a title="component" class="termref" href="#dt-component">components</a> by means of their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. These
                     constructs are generically referred to as <b>symbolic references</b>.
                     Examples of constructs that give rise to symbolic references are the
                        <code>name</code> attribute of <a href="#element-call-template"><code>xsl:call-template</code></a>; the
                        <code>[xsl:]use-attribute-sets</code> attribute of
                     <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>; the
                        explicit or implicit
                     <code>mode</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>; XPath
                     variable references referring to global variables; XPath static function calls (including partial function
                        applications) referring to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; and
                        named function references (example: <code>my:f#1</code>) referring to
                        stylesheet functions.
                     <span class="definition">]</span></p>
                  <p>Symbolic references exist as properties of the <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a <a title="component" class="termref" href="#dt-component">component</a>.
                  The <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> being
                  referred to can be determined straightforwardly from the syntactic form and
                  context of the reference: for example, the instruction <code>&lt;xsl:value-of
                     select="f:price($o)" xmlns:f="http://f.com/"/&gt;</code> contains a symbolic
                  reference to a function with expanded name <code>{http://f.com/}price</code> and
                  with arity=1. However, because there may be several (homonymous) function
                  components with this symbolic identifier, translating this symbolic reference into
                  a reference to a specific component (a process called “binding”) is less
                  straightforward, and is described in the text that follows. </p>
                  <p>The process of assembling a stylesheet from its constituent packages is primarily
                  a process of binding these symbolic references to actual components. Within any
                     <a title="component" class="termref" href="#dt-component">component</a> whose <a title="declaration" class="termref" href="#dt-declaration">declaration</a> is <var>D</var>, there is a set of
                  bindings; each binding is an association between a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> in <var>D</var> and a
                     <a title="component" class="termref" href="#dt-component">component</a> whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> matches the outward
                  reference. Outward references for which a component <var>C</var> contains a
                  binding are said to be <b>bound</b> in <var>C</var>; those for which
                     <var>C</var> contains no binding are said to be <b>unbound</b>.</p>
                  <p>For example, suppose that in some package <var>Q</var>, function <var>A</var>
                  calls <var>B</var>, which in turn calls <var>C</var>, and that <var>B</var> is
                     <code>private</code>. Now suppose that in some package <var>P</var> which uses
                     <var>Q</var>, <var>C</var> is overridden. The effect of the binding process is
                  that <var>P</var> will contain three components corresponding to <var>A</var>,
                     <var>B</var>, and <var>C</var>, which we might call <var>A<sub>P</sub></var>,
                     <var>B<sub>P</sub></var>, and <var>C<sub>P</sub></var>. The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> of <var>A<sub>P</sub></var> and <var>B<sub>P</sub></var> are in package
                     <var>Q</var>, but the declaration of <var>C<sub>P</sub></var> is in <var>P</var>. The
                  internal visibility of <var>B<sub>P</sub></var> will be <code>hidden</code> (meaning that it
                  cannot be referenced from within <var>P</var>), and <var>B<sub>P</sub></var> will contain a
                  binding for the component <var>C<sub>P</sub></var> that corresponds to the outward reference
                  from <var>B</var> to <var>C</var>. The effect is that when <var>A</var> calls
                     <var>B</var> and <var>B</var> calls <var>C</var>, it is the overriding version
                  of <var>C</var> that is executed.</p>
                  <p>In another package <var>R</var> that uses <var>Q</var> without overriding
                     <var>C</var>, there will be three different components <var>A<sub>R</sub></var>,
                     <var>B<sub>R</sub></var>, and <var>C<sub>R</sub></var>. This time the declaration of all three
                  components is in the original package <var>Q</var>. Component <var>B<sub>R</sub></var> will
                  contain a binding to <var>C<sub>R</sub></var>, so in this package, the original version of
                     <var>C</var> is executed. The fact that one package <var>P</var> overrides
                     <var>C</var> thus has no effect on <var>R</var>, which does not override
                  it.</p>
                  <p>The binding process outlined above is described in more detail in <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>.</p>
                  <p>Template rules are not components in their own right;
                  unlike named templates, they are never referenced by name. Component references
                  within a template rule (for example, references to functions, global variables, or
                  named templates) are treated as occurring within the component that represents the
                  containing mode. This includes component references within the match patterns of
                  template rules. If a template rule lists several modes, it is treated as if there
                  were multiple template rules one in each mode.</p>
                  <p>An <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction
                  with no <code>mode</code> attribute is treated as a reference to the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a>
                  defined for that <a title="instruction" class="termref" href="#dt-instruction">instruction</a> (see <a href="#default-mode"><i>3.6.3 The default-mode Attribute</i></a>), which in turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. An implicit
                  reference to the unnamed made is treated in the same way as any other <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a>. Note that there is an unnamed mode in every
                  package, and the unnamed mode always has private visibility.</p>
                  <p>Where an <a href="#element-template"><code>xsl:template</code></a> element has both
                  a <code>name</code> and a <code>match</code> attribute, it is treated as if there
                  were two separate <a href="#element-template"><code>xsl:template</code></a> elements, one with a
                     <code>name</code> attribute and one with a <code>match</code> attribute. </p>
                  <p><a title="key" class="termref" href="#dt-key">Keys</a>
                  and <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a> behave rather differently from other
                  components. Their visibility is always private, which means they can only be used
                  within their declaring package. In addition, the component binding is generally
                  made dynamically rather than statically, by
                     virtue of a string passed as an argument to the function
                        <a href="#func-key"><code>key</code></a>, <a href="#func-accumulator-before"><code>accumulator-before</code></a>, or
                        <a href="#func-accumulator-after"><code>accumulator-after</code></a>. (In the case of accumulators, there
                     can also be static references: see the <code>use-accumulators</code> attribute
                     of <a href="#element-source-document"><code>xsl:source-document</code></a>, 
                     <a href="#element-merge-source"><code>xsl:merge-source</code></a>, and <a href="#element-mode"><code>xsl:mode</code></a>.) 
                     However, outward references from key
                  definitions and <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a> to other components (such as global
                  variables and functions) behave in the same way as component references contained
                  in any other private component, in that they may be re-bound to an overriding
                  declaration of the target component.</p>
                  <div class="div4">
                     
                     <h5><a id="visibility"></a>3.4.4.1 <a href="#visibility" style="text-decoration: none">Visibility of Components</a></h5>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-visibility" title="visibility"></a>The <b>visibility</b> of a
                           <a title="component" class="termref" href="#dt-component">component</a> is one of:
                           <code>private</code>, <code>public</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>.<span class="definition">]</span></p>
                     <p>The meanings of these visibility values is as follows:</p>
                     <dl>
                        <dt class="label">public</dt>
                        <dd>
                           <p>The component can be referenced from other components in this package
                              or in any using package; it can be overridden by a different component
                              in any using package.</p>
                        </dd>
                        <dt class="label">private</dt>
                        <dd>
                           <p>The component can be referenced from other components in this
                              package; it cannot be referenced or overridden within a using
                              package.</p>
                        </dd>
                        <dt class="label">abstract</dt>
                        <dd>
                           <p>The component can be referenced from other components in this package
                              or in any using package; in a using package it can either remain
                              abstract or be overridden by a different component. </p>
                        </dd>
                        <dt class="label">final</dt>
                        <dd>
                           <p>The component can be referenced from other components in this package
                              or in any using package; it cannot be overridden by a different
                              component in any using package.</p>
                        </dd>
                        <dt class="label">hidden</dt>
                        <dd>
                           <p>The component cannot be referenced from other components in this
                              package; it cannot be referenced or overridden within a using
                              package.</p>
                        </dd>
                     </dl>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The visibility of a component in a package <var>P</var> primarily affects
                        how the component can be used in other packages, specifically, packages that
                        use <var>P</var>. There is one exception: if the visibility is
                           <code>hidden</code>, it also affects how the component can be used within
                           <var>P</var>.</p>
                     </div>
                     <p>When a component is declared within a particular
                     package, its <a title="visibility" class="termref" href="#dt-visibility">visibility</a>, which affects
                     how it can be used in other (using) packages, depends on two factors: the value
                     of the <code>visibility</code> declaration on the declaration itself (if
                     present), and the rules given in the <a href="#element-expose"><code>xsl:expose</code></a> declarations
                     of the package manifest.</p>
                     <p>The <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-template"><code>xsl:template</code></a>,
                        <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>, <a href="#element-variable"><code>xsl:variable</code></a>, 
                        <a href="#element-mode"><code>xsl:mode</code></a>, <a href="#element-item-type"><code>xsl:item-type</code></a>, and <a href="#element-record-type"><code>xsl:record-type</code></a>
                     <a title="declaration" class="termref" href="#dt-declaration">declarations</a> each have an optional
                        <code>visibility</code> attribute. The permitted value is some subset of <code>private</code>,
                        <code>public</code>, <code>abstract</code>, or <code>final</code> (never
                        <code>hidden</code>). In the case of
                           an <a href="#element-param"><code>xsl:param</code></a> element there is no explicit 
                           <code>visibility</code> attribute; rather the declaration has the
                           implicit attribute <code>visibility="public"</code>.</p>
                     <p>Any <a href="#element-expose"><code>xsl:expose</code></a> declarations that
                     appear as children of <a href="#element-package"><code>xsl:package</code></a> define the visibility of
                     components whose declaration has no explicit <code>visibility</code> attribute,
                     and can also be used to reduce the visibility of components where this
                     attribute is present.</p>
                     <p class="element-syntax"><a id="element-expose"></a><code>&lt;xsl:expose<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "item-type" | "record-type" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract"&nbsp;/&gt;</code></p>
                     <p>The <a href="#element-expose"><code>xsl:expose</code></a> element allows the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of selected components within a package to be defined.</p>
                     <p>The components in question are identified using their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. The
                        <code>component</code> attribute defines the kind of component that is
                        selected.
                     The value <code>*</code> means “all component kinds”;
                        in this case the value of the <code>names</code> attribute must be a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Wildcard">Wildcard</a><sup><small>XP</small></sup>.</p>
                     <p>An <a href="#element-expose"><code>xsl:expose</code></a> declaration has no effect on the 
                     <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, which is always private to a package.</p>
                     <p>The <code>names</code> attribute selects a subset of these components by name
                     (and in the case of functions, arity); its value is a whitespace-separated
                     sequence of tokens each of which is either a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> or a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NamedFunctionRef">NamedFunctionRef</a><sup><small>XP</small></sup>. (Examples are
                        <code>*</code>, <code>p:*</code>, <code>*:local</code>,
                     <code>p:local</code>, and <code>p:local#2</code>.)</p>
                     <p>The value may be a <code>NamedFunctionRef</code> only in the case of stylesheet
                     functions, and distinguishes functions with the same name and different
                     arity. <span>A <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup>
                     on its own (that is, with no arity) cannot be used to identify a function.</span></p>
                     <p>The visibility of a 
                     named template, function, variable, attribute set, mode,
                     named item type, or named record type
                     declared within a package is the first of the following that applies, subject to consistency
                     constraints which are defined below:</p>
                     <ol class="enumar">
                        <li>
                           <p>The visibility of a variable declared using
                           an <a href="#element-param"><code>xsl:param</code></a> element is
                           always <code>public</code>. No <a href="#element-expose"><code>xsl:expose</code></a> element
                        ever matches an <a href="#element-param"><code>xsl:param</code></a> component.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Attempting to match an <a href="#element-param"><code>xsl:param</code></a> with
                        an explicit <code>EQName</code> will therefore always give an error, while
                        using a wildcard has no effect.</p>
                           </div>
                        </li>
                        <li>
                           <p>If the package manifest contains an <a href="#element-expose"><code>xsl:expose</code></a> element
                           that matches this component by virtue of an explicit <code>EQName</code>
                           or <code>NamedFunctionRef</code> (that is, not by virtue of a wildcard
                           match), then the value of the <code>visibility</code> attribute of the
                           last such <a href="#element-expose"><code>xsl:expose</code></a> element in document order (call
                           this the <b>explicit exposed visibility</b>).</p>
                        </li>
                        <li>
                           <p>If the declaration of the component has a <code>visibility</code>
                           attribute, then the value of this attribute (call this the <b>declared
                              visibility</b>).</p>
                        </li>
                        <li>
                           <p>If the package manifest contains an <a href="#element-expose"><code>xsl:expose</code></a> element
                           that matches this component by virtue of a wildcard match that specifies
                           either the namespace part of the component name or the local part of the
                           name (for example, <code>prefix:*</code> or <code>*:local</code> or
                              <code>Q{uri}*</code>), then the value of the <code>visibility</code>
                           attribute of the last such <a href="#element-expose"><code>xsl:expose</code></a> element in
                           document order.</p>
                        </li>
                        <li>
                           <p>If the package manifest contains an <a href="#element-expose"><code>xsl:expose</code></a> element
                           that matches this component by virtue of a wildcard match that matches
                           all names (that is, <code>*</code>), then the value of the
                              <code>visibility</code> attribute of the last such
                              <a href="#element-expose"><code>xsl:expose</code></a> element in document order.</p>
                        </li>
                        <li>
                           <p>Otherwise, <code>private</code>.</p>
                        </li>
                     </ol>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>In the above rules, no distinction is made between declarations that specify
                  a specific component kind, and those that specify <code>component="*"</code>. If both match,
                  the value of the <code>component</code> attribute plays no role in deciding which 
                  declaration wins.</p>
                     </div>
                     <p>If both a declared visibility and an explicit
                     exposed visibility exist for the same component, then as mentioned above, they
                     must be consistent. This is determined by reference to the following table,
                     where the entry N/P means “not permitted”. (In cases where the combination is
                     permitted, the actual visibility is always the same as the visibility
                     determined by <a href="#element-expose"><code>xsl:expose</code></a>.)</p>
                     <table class="data">
                        <caption>Relationship of Exposed Visibility to Potential Visibility</caption>
                        <thead>
                           <tr>
                              <th style="text-align:left; vertical-align:top" rowspan="2">Explicit exposed visibility</th>
                              <th style="text-align:left; vertical-align:top" colspan="4">Declared visibility</th>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">public</th>
                              <th style="text-align:left; vertical-align:top">private</th>
                              <th style="text-align:left; vertical-align:top">final</th>
                              <th style="text-align:left; vertical-align:top">abstract</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <th style="text-align:left; vertical-align:top">public</th>
                              <td style="text-align:left; vertical-align:top">public</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">private</th>
                              <td style="text-align:left; vertical-align:top">private</td>
                              <td style="text-align:left; vertical-align:top">private</td>
                              <td style="text-align:left; vertical-align:top">private</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">final</th>
                              <td style="text-align:left; vertical-align:top">final</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">final</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">abstract</th>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">abstract</td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                     <a id="err-XTSE3010"><span class="error">[ERR XTSE3010] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           explicit exposed visibility of a component is inconsistent with its
                           declared visibility, as defined in the above table. (This error occurs
                           only when the component declaration has an explicit
                              <code>visibility</code> attribute, and the component is also listed
                           explicitly by name in an <a href="#element-expose"><code>xsl:expose</code></a> declaration.)
                  </p>
                     <p>
                     <a id="err-XTSE3020"><span class="error">[ERR XTSE3020] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token
                           in the <code>names</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a>, other
                           than a wildcard, matches no component in the containing package.
                  </p>
                     <p>
                     <a id="err-XTSE3022"><span class="error">[ERR XTSE3022] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the 
                           <code>component</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.
                  </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>There is no ambiguity, and no error, if several tokens within the same
                           <a href="#element-expose"><code>xsl:expose</code></a> element match the same component.</p>
                     </div>
                     <p>If the visibility of a component as established by the above rules
                  is <code>abstract</code>, then the component must have a declared visibility of <code>abstract</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>In other words, the <a href="#element-expose"><code>xsl:expose</code></a> declaration cannot be used to make a component
                  abstract unless it was declared as abstract to start with.</p>
                     </div>
                     <p>
                     <a id="err-XTSE3025"><span class="error">[ERR XTSE3025] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           effect of an <a href="#element-expose"><code>xsl:expose</code></a> declaration would be to make a component
                           <code>abstract</code>, unless the component is already <code>abstract</code>
                           in the absence of the <a href="#element-expose"><code>xsl:expose</code></a> declaration.
                        
                  </p>
                     <p>For a component accepted into a package <var>P</var>
                     from another package <var>Q</var>, the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in <var>P</var> (which primarily
                     affects how it can be used in a package <var>R</var> that uses <var>P</var>)
                     depends on the visibility declared in the relevant <a href="#element-accept"><code>xsl:accept</code></a>
                     or <a href="#element-override"><code>xsl:override</code></a> element in <var>P</var> (see <a href="#accepting-components"><i>3.4.4.2 Accepting Components</i></a>); this in turn has a default that depends on
                     the visibility of the corresponding component in <var>Q</var>. In this case the
                     visibility is unaffected by any <a href="#element-expose"><code>xsl:expose</code></a> declaration in
                        <var>P</var>.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="accepting-components"></a>3.4.4.2 <a href="#accepting-components" style="text-decoration: none">Accepting Components</a></h5>
                     <p>When a package <var>P</var> uses a package <var>Q</var>, by virtue of an
                        <a href="#element-use-package"><code>xsl:use-package</code></a> element in the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> of <var>P</var>, then
                        <var>P</var> will contain a <a title="component" class="termref" href="#dt-component">component</a>
                     corresponding to every component in <var>Q</var>. The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component within
                        <var>P</var> depends on the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in <var>Q</var>, optionally modified
                     by two elements that may appear as children of the
                        <a href="#element-use-package"><code>xsl:use-package</code></a> element, namely <a href="#element-accept"><code>xsl:accept</code></a>
                     and <a href="#element-override"><code>xsl:override</code></a>.</p>
                     <p>For every component <var>C<sub>Q</sub></var> in package <var>Q</var> that is not matched
                     by any <a href="#element-override"><code>xsl:override</code></a> or <a href="#element-accept"><code>xsl:accept</code></a> element in
                     the package manifest of <var>P</var>, there will be a corresponding component
                        <var>C<sub>P</sub></var> in package <var>P</var> that has the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> and <a title="declaration" class="termref" href="#dt-declaration">declaration</a> as <var>C<sub>Q</sub></var>.</p>
                     <p>If <var>C<sub>Q</sub></var> is an <a href="#element-param"><code>xsl:param</code></a>
                        component, then the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of <var>C<sub>P</sub></var> is
                        <code>public</code>.</p>
                     <p>In other cases, the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of <var>C<sub>P</sub></var> 
                        depends on the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of <var>C<sub>Q</sub></var>, as defined by the following table:</p>
                     <table class="data">
                        <caption>Visibility of Components in Used and Using Packages</caption>
                        <thead>
                           <tr>
                              <th style="text-align:left; vertical-align:top">Visibility in used package <var>C<sub>Q</sub></var></th>
                              <th style="text-align:left; vertical-align:top">Visibility in using package <var>C<sub>P</sub></var></th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td style="text-align:left; vertical-align:top">public</td>
                              <td style="text-align:left; vertical-align:top">private</td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top">final</td>
                              <td style="text-align:left; vertical-align:top">private</td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top">private</td>
                              <td style="text-align:left; vertical-align:top">hidden</td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top">hidden</td>
                              <td style="text-align:left; vertical-align:top">hidden</td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top">abstract</td>
                              <td style="text-align:left; vertical-align:top">hidden</td>
                           </tr>
                        </tbody>
                     </table>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The effect of these rules is as follows:</p>
                        <ul>
                           <li>
                              <p>Components that are public or final in the used package <var>Q</var> become
                        private in the using package <var>P</var>. This means that they can be referenced
                        within <var>P</var> but are not (by default) visible within a package <var>R</var>
                        that uses <var>P</var>.</p>
                           </li>
                           <li>
                              <p>Components that are private or hidden in the used package <var>Q</var> become
                           hidden in the using package <var>P</var>. This means that they cannot be referenced
                           within <var>P</var>; but if they contain references to components that are overridden
                           in <var>P</var>, the hidden component’s references are bound to the overriding components
                        in <var>P</var>.</p>
                           </li>
                           <li>
                              <p>Components that are abstract in the used package <var>Q</var> become
                           hidden in the using package <var>P</var>. The hidden component in this case raises a dynamic
                           error if it is invoked. Such an invocation cannot originate within <var>P</var>,
                           because the component is not visible within <var>P</var>; but it can occur
                        if a public component in <var>Q</var> is invoked, which in turn invokes the abstract
                        component.</p>
                           </li>
                        </ul>
                     </div>
                     <p class="element-syntax"><a id="element-accept"></a><code>&lt;xsl:accept<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "item-type" | "record-type" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract" | "hidden"&nbsp;/&gt;</code></p>
                     <p>The <a href="#element-accept"><code>xsl:accept</code></a> element has very similar syntax and semantics
                     to <a href="#element-expose"><code>xsl:expose</code></a>. Whereas <a href="#element-expose"><code>xsl:expose</code></a> allows a
                     package to restrict the visibility of its own components to other (using)
                     packages, <a href="#element-accept"><code>xsl:accept</code></a> allows a package to restrict the
                     visibility of components exposed by a package that it uses. This may be
                     necessary if, for example, it uses two different packages whose component names
                     conflict. It may also simply be good practice if the package author knows that
                     only a small subset of the functionality of a used package is required.</p>
                     <p>The rules for determining whether an <a href="#element-accept"><code>xsl:accept</code></a> element
                     matches a particular component, and for which element to use if there are
                     several matches, are the same as the rules for the <a href="#element-expose"><code>xsl:expose</code></a>
                     element.</p>
                     <p>No <a href="#element-accept"><code>xsl:accept</code></a> element
                     ever matches a variable declared using <a href="#element-param"><code>xsl:param</code></a>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Attempting to match an <a href="#element-param"><code>xsl:param</code></a> with
                     an explicit <code>EQName</code> will therefore always give an error, while
                     using a wildcard has no effect.</p>
                     </div>
                     <p>
                     <a id="err-XTSE3030"><span class="error">[ERR XTSE3030] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token
                           in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other
                           than a wildcard, matches no component in the used package.
                  </p>
                     <p>
                     <a id="err-XTSE3032"><span class="error">[ERR XTSE3032] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the 
                           <code>component</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.
                  </p>
                     <p>In the absence of a matching <a href="#element-override"><code>xsl:override</code></a> element (see
                        <a href="#package-overriding-components"><i>3.4.4.3 Overriding Components from a Used Package</i></a>), the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of a component that matches an
                        <a href="#element-accept"><code>xsl:accept</code></a> element depends both on the
                        <code>visibility</code> attribute of the best-matching
                        <a href="#element-accept"><code>xsl:accept</code></a> element and on the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the corresponding component in the used package,
                     according to the following table. In this table the entry “N/P” means “not
                     permitted”.</p>
                     <table class="data">
                        <caption>Relationship of the Visibility given in xsl:accept to Visibility in the Used Package</caption>
                        <thead>
                           <tr>
                              <th style="text-align:left; vertical-align:top" rowspan="2">Visibility in <a href="#element-accept"><code>xsl:accept</code></a> element</th>
                              <th style="text-align:left; vertical-align:top" colspan="4">Visibility in used package</th>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">public</th>
                              <th style="text-align:left; vertical-align:top">private</th>
                              <th style="text-align:left; vertical-align:top">final</th>
                              <th style="text-align:left; vertical-align:top">abstract</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <th style="text-align:left; vertical-align:top">public</th>
                              <td style="text-align:left; vertical-align:top">public</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">private</th>
                              <td style="text-align:left; vertical-align:top">private</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">private</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">final</th>
                              <td style="text-align:left; vertical-align:top">final</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">final</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">abstract</th>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">abstract</td>
                           </tr>
                           <tr>
                              <th style="text-align:left; vertical-align:top">hidden</th>
                              <td style="text-align:left; vertical-align:top">hidden</td>
                              <td style="text-align:left; vertical-align:top">N/P</td>
                              <td style="text-align:left; vertical-align:top">hidden</td>
                              <td style="text-align:left; vertical-align:top">hidden</td>
                           </tr>
                        </tbody>
                     </table>
                     <p>
                     <a id="err-XTSE3040"><span class="error">[ERR XTSE3040] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           visibility assigned to a component by an <a href="#element-accept"><code>xsl:accept</code></a>
                           element is incompatible with the visibility of the corresponding
                           component in the used package, as defined by the above table, unless the
                           token that matches the component name is a wildcard, in which case the
                              <a href="#element-accept"><code>xsl:accept</code></a> element is treated as not matching that
                           component.
                  </p>
                     <p>
                     <a id="err-XTSE3050"><span class="error">[ERR XTSE3050] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                              <a href="#element-use-package"><code>xsl:use-package</code></a> elements in a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> cause two or more
                              <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> components to be
                           accepted with a visibility other than <code>hidden</code>.
                  </p>
                     <p>Conflicts between the components accepted from used packages and those declared
                     within the package itself are handled as follows:</p>
                     <ol class="enumar">
                        <li>
                           <p>If the conflict is between two components both declared within the
                           package itself, then it is resolved by the rules relating to <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> defined for
                           each kind of component.</p>
                        </li>
                        <li>
                           <p>If the conflict is between two components both accepted from used
                           packages, or between a component declared within the package and an
                           accepted component, then a static error occurs.</p>
                        </li>
                        <li>
                           <p>If a component is explicitly accepted from a used package (by name, rather
                           than by a matching wildcard), and if the same component is the subject
                           of an <a href="#element-override"><code>xsl:override</code></a> declaration, then a static error
                        occurs (see below). There is no conflict, however, if a component declared
                        within <a href="#element-override"><code>xsl:override</code></a> also matches a wildcard in an <a href="#element-accept"><code>xsl:accept</code></a>
                        element.</p>
                           <p>
                           <a id="err-XTSE3051"><span class="error">[ERR XTSE3051] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if
                                 a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>,
                                 other than a wildcard, matches the symbolic name of a component declared
                                 within an <a href="#element-override"><code>xsl:override</code></a> child of the same
                                 <a href="#element-use-package"><code>xsl:use-package</code></a> element.
                        </p>
                        </li>
                     </ol>
                     <p>Where the used package <var>Q</var> contains a component whose
                     visibility is <code>abstract</code>, the using package <var>P</var> has three options:</p>
                     <ol class="enumar">
                        <li>
                           <p><var>P</var> can accept the component with <code>visibility="abstract"</code>.
                        In this case <var>P</var> can contain references to the component, but invocation via
                     these references will fail unless a non-abstract overriding component has
                     been supplied in some package <var>R</var> that (directly or indirectly) uses <var>P</var>.</p>
                        </li>
                        <li>
                           <p><var>P</var> can accept the component with <code>visibility="hidden"</code>.
                        In this case <var>P</var> cannot contain references to the component, and invocation via
                        references in <var>Q</var> will always fail with a dynamic error. This is the default
                     if <var>P</var> does not explicitly accept or override the component.</p>
                        </li>
                        <li>
                           <p><var>P</var> can provide a concrete implementation of the component
                     within an <a href="#element-override"><code>xsl:override</code></a> element.</p>
                        </li>
                     </ol>
                     <p>Any invocation of the absent component (typically from within its
                           declaring package) causes a dynamic error, as if the component were
                           overridden by a component that unconditionally raises a dynamic
                           error.</p>
                     <p>
                           <a id="err-XTDE3052"><span class="error">[ERR XTDE3052] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if
                                 an invocation of an abstract component is evaluated.
                                                        
                        </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This can occur when a public component in the used package invokes
                           an abstract component in the used package, and the using package provides
                           no concrete implementation for the component in an <a href="#element-override"><code>xsl:override</code></a>
                           element.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>To override a component accepted from a used package, the overriding
                        declaration must appear as a child of the <a href="#element-override"><code>xsl:override</code></a>
                        element.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>There is no rule that prevents a function (say) being declared in the using
                        package with the same name as a <code>private</code> function in the used
                        package. This does not create a conflict, since all references in the used
                        package are bound to one function and all those in the using package are
                        bound to another.</p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="package-overriding-components"></a>3.4.4.3 <a href="#package-overriding-components" style="text-decoration: none">Overriding Components from a Used Package</a></h5>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-override" title="override"></a>A component in a using package may
                           <b>override</b> a component in a used package, provided that the
                           <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in the
                        used package is either <code>abstract</code> or <code>public</code>. The
                        overriding declaration is written as a child of the
                           <a href="#element-override"><code>xsl:override</code></a> element, which in turn appears as a child
                        of <a href="#element-use-package"><code>xsl:use-package</code></a>.<span class="definition">]</span></p>
                     <p class="element-syntax"><a id="element-override"></a><code>&lt;xsl:override&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a> | <a href="#element-function">xsl:function</a> | <a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a> | <a href="#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br>&lt;/xsl:override&gt;</code></p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This mechanism is distinct from the mechanism for overriding declarations
                        within the same package by relying on <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. It imposes stricter rules: the overriding
                        component is required to be type-compatible with the component that it
                        overrides.</p>
                     </div>
                     <p>If the used package <var>Q</var> contains a <a title="component" class="termref" href="#dt-component">component</a>
                     <var>C<sub>Q</sub></var> and the <a href="#element-use-package"><code>xsl:use-package</code></a> element contains an
                        <a href="#element-override"><code>xsl:override</code></a> element which contains a declaration
                        <var>D</var> whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic
                        identifier</a> matches the symbolic identifier of <var>C<sub>Q</sub></var>, then
                     the using package <var>P</var> will contain a component <var>C<sub>P</sub></var> whose
                     declaration is D, whose symbolic identifier is that of D, and whose <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is equal to the value of the <code>visibility</code>
                     attribute of <var>D</var>, or <code>private</code> if this is absent, 
                     except in the case
                           of <a href="#element-param"><code>xsl:param</code></a>, which is implicitly
                           <code>public</code>.</p>
                     <p>The using package <var>P</var> will also contain a component <var>C<sub>PQ</sub></var>
                     whose body is the same as the body of <var>C<sub>Q</sub></var> and whose <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is <code>hidden</code>. This
                     component is used as the target of a binding for the symbolic reference
                        <code>xsl:original</code> described below.</p>
                     <p>Other than its appearance as a child of <a href="#element-override"><code>xsl:override</code></a>, the
                     overriding declaration is a normal <a href="#element-function"><code>xsl:function</code></a>,
                        <a href="#element-template"><code>xsl:template</code></a>,
                     <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, or
                        <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element. In the case of
                        <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a>, the variable
                     that is declared is a <a title="global variable" class="termref" href="#dt-global-variable">global
                        variable</a>.</p>
                     <p>The rules in the remainder of this section apply to
                     components having a <code>name</code> attribute (<b>named
                     components</b>). The only element with no <code>name</code> attribute that
                     can appear as a child of <a href="#element-override"><code>xsl:override</code></a> is an
                        <a href="#element-template"><code>xsl:template</code></a> declaration having a <code>match</code>
                     attribute (that is, a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>). The rules for
                     overriding of template rules appear in <a href="#modes-and-packages"><i>3.4.5 Overriding Template Rules from a Used Package</i></a>. If
                     an <a href="#element-template"><code>xsl:template</code></a> element has both a <code>name</code> attribute
                     and a <code>match</code> attribute, then it defines both a named component and
                     a template rule, and both sections apply.</p>
                     <p>
                     <a id="err-XTSE3055"><span class="error">[ERR XTSE3055] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                           component declaration appearing as a child of
                              <a href="#element-override"><code>xsl:override</code></a> is <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with any other declaration in the using package,
                           regardless of <a title="import precedence" class="termref" href="#dt-import-precedence">import
                              precedence</a>, including any other overriding declaration in
                           the package manifest of the using package.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>When an attribute set is overridden, the
                        overriding attribute set must be defined using a single
                           <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element. Attribute sets defined in
                        different packages are never merged by virtue of having the same name,
                        though they may be merged explicitly by using the
                           <code>use-attribute-sets</code> attribute.</p>
                     </div>
                     <p>
                     <a id="err-XTSE3058"><span class="error">[ERR XTSE3058] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                           component declaration appearing as a child of
                              <a href="#element-override"><code>xsl:override</code></a> does not match (is not <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with) some component in the
                           used package.</p>
                     <p>
                     <a id="err-XTSE3060"><span class="error">[ERR XTSE3060] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           component referenced by an <a href="#element-override"><code>xsl:override</code></a> declaration has
                              <a title="visibility" class="termref" href="#dt-visibility">visibility</a> other than
                              <code>public</code> or <code>abstract</code>
                  </p>
                     <p>A package is executable if and only if it contains no <a title="component" class="termref" href="#dt-component">component</a> whose <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is <code>abstract</code>. A package that is not
                     executable is not a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and
                     therefore cannot be nominated as the stylesheet to be used when initiating a
                     transformation.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>In other words, if a component is declared as abstract, then some package
                        that uses the declaring package of that component directly or indirectly
                        must override that component with one that is not abstract. It is not
                        necessary for the override to happen in the immediately using package.</p>
                     </div>
                     <p>
                     <a id="err-XTSE3070"><span class="error">[ERR XTSE3070] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           signature of an overriding component is not <a title="compatible" class="termref" href="#dt-compatible">compatible</a> with the signature of the component that it is
                           overriding.
                  </p>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-compatible" title="compatible"></a>The signatures of two <a title="component" class="termref" href="#dt-component">components</a> are <b>compatible</b> if
                        they present the same interface to the user of the component. The additional
                        rules depend on the kind of component.<span class="definition">]</span></p>
                     <p>Compatibility is only relevant when comparing two components that have the same
                        <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>. The compatibility rules for each
                     kind of component are as follows:</p>
                     <ul>
                        <li>
                           <p>Two attribute sets with the same name are compatible if
                           and only if they satisfy the following rule:</p>
                           <ol class="enumar">
                              <li>
                                 <p>If the overridden attribute set specifies
                                    <code>streamable="yes"</code> then the overriding attribute set
                                 also specifies <code>streamable="yes"</code>.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>Two functions with the same symbolic identifier are compatible if and only if
                           they satisfy all the following rules:</p>
                           <ol class="enumar">
                              <li>
                                 <p>They have the same <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                              (which implies they have the same number of required and optional parameters)</p>
                              </li>
                              <li>
                                 <p>The declared types of the parameters 
                                 (defaulting to <code>item()*</code>) are pairwise <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>.</p>
                              </li>
                              <li>
                                 <p>The declared return types 
                                 (defaulting to <code>item()*</code>) are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>.</p>
                              </li>
                              <li>
                                 <p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the 
                                 <code>new-each-time</code> 
                                 attribute on the overriding function is the same as its value on the overridden function.</p>
                              </li>
                              <li>
                                 <p>If the overridden function has a <code>streamability</code> attribute with a value
                              other than <code>unspecified</code>, then the overriding function has a
                                 <code>streamability</code> attribute with the same value. </p>
                              </li>
                           </ol>
                           <p>It is <span class="verb">recommended</span>
                        that the parameter names on the overriding function should be the same as on the overridden function.
                        (However, in order to maintain backwards compatibility with XSLT 3.0, 
                        this is not <span class="verb">required</span>.) If the parameter names are not the same,
                        then the parameter names on the overriding function are effectively replaced with the names declared
                        on the overridden function, so that any static function calls using keyword arguments to set the values
                        of arguments must use the names defined on the overridden function.</p>
                        </li>
                        <li>
                           <p>Two named templates with the same name are compatible if and only if they
                           satisfy all the following rules:</p>
                           <ol class="enumar">
                              <li>
                                 <p>Their return types are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>.</p>
                              </li>
                              <li>
                                 <p>For every non-tunnel parameter on the overridden template, there is a
                                 non-tunnel parameter on the overriding template that has the same name, an
                                    <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a> required
                                 type, and the same <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> for the <code>required</code> attributes.</p>
                              </li>
                              <li>
                                 <p>For every tunnel parameter <var>P</var> on the overridden template, if there is a
                                 parameter <var>Q</var> on the overriding template that has the same name 
                                 as <var>P</var> then <var>Q</var> is also a tunnel parameter, and <var>P</var> and <var>Q</var> have
                                 <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a> required
                                 types.</p>
                              </li>
                              <li>
                                 <p>Any parameter on the overriding template for which there is no
                                 corresponding parameter on the overridden template specifies
                                    <code>required="no"</code>.</p>
                              </li>
                              <li>
                                 <p>The two templates have equivalent
                                    <a href="#element-context-item"><code>xsl:context-item</code></a> children, where equivalence
                                 means that the <code>use</code> attributes are the same and the
                                 required types are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>; an absent
                                    <a href="#element-context-item"><code>xsl:context-item</code></a> is equivalent to one that
                                 specifies <code>use="optional"</code> and
                                 <code>as="item()"</code>.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>Two variables (including parameters) with the same name are compatible if
                           and only if they satisfy all the following rules:</p>
                           <ol class="enumar">
                              <li>
                                 <p>Their declared types are <a title="identical (types)" class="termref" href="#dt-identical-types">identical</a>.
                              <span>For this purpose, the declared type is the first
                              of the following that applies:</span></p>
                                 <ul>
                                    <li>
                                       <p>If there is an <code>as</code> attribute, then the type defined by that attribute.</p>
                                    </li>
                                    <li>
                                       <p>If there is a <code>select</code> attribute, then <code>item()*</code>.</p>
                                    </li>
                                    <li>
                                       <p>If there is a non-empty sequence constructor, then <code>document-node()</code>.</p>
                                    </li>
                                    <li>
                                       <p>Otherwise, <code>xs:string</code>. </p>
                                    </li>
                                 </ul>
                              </li>
                           </ol>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>A variable may override a parameter or vice-versa, and the initial
                              value may differ.</p>
                              <p>Because static variables and parameters are
                              constrained to have visibility <code>private</code>
                              ,
                              they cannot be overridden in another package. The compatibility rules
                              therefore do not arise. The reason that such variables cannot be
                              overridden is that they are typically used during stylesheet
                              compilation (for example, in <code>[xsl:]use-when</code> expressions
                              and shadow attributes) and it is a design goal that packages should be
                              capable of independent compilation.</p>
                           </div>
                        </li>
                     </ul>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-identical-types" title="identical (types)"></a>Types <var>S</var> 
                     and <var>T</var> are considered <b>identical</b> for the purpose of
                        these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T,
                           S)</code> both hold, where the subtype relation is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.<span class="definition">]</span></p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <ol class="enumar">
                           <li>
                              <p>One consequence of this rule is that two plain union types are
                              considered identical if they have the same set of member types, even
                              if the union types have different names or the ordering of the member
                              types is different.</p>
                              <p>Consider a function that accepts an argument
                           whose declared type is a union type with member types <code>xs:double</code>
                           and <code>xs:decimal</code>, in that order (we might write this as <code>(xs:double | xs:decimal)</code>).
                           Using the same notation, this can be overridden by a function that declares the argument
                           type as <code>(xs:decimal | xs:double)</code>. This does not affect type checking:
                              a function call that passes the type checking rules with one signature will also pass the
                              type checking rules with the other. It does however affect the way that the function
                           conversion rules work: a call that passes the <code>xs:untypedAtomic</code> item
                           <code>"93.7"</code> (or an untyped node with this as its string value) will be converted to 
                              an <code>xs:decimal</code> in one case and an <code>xs:double</code> in the other.</p>
                           </li>
                           <li>
                              <p>While this rule may appear formal, it is not as straightforward as
                              might be supposed, because the subtype relation in XPath has a
                              dependency on the “Type derivation OK (Simple)” relation in XML
                              Schema, which itself appeals to a judgement as to whether the two type
                              definitions being compared “are the same type definition”. Both XSD
                              1.0 and XSD 1.1 add the note “The wording of [this rule] appeals to a
                              notion of component identity which is only incompletely defined by
                              this version of this specification.” However, they go on to say that
                              component identity is well defined if the components are named simple
                              type definitions, which will always apply in this case. For named
                              atomic types, the final result of these rules is that two atomic types
                              are identical if and only if they have the same name.</p>
                           </li>
                           <li>
                              <p>A named item type
                           (declared in an <a href="#element-item-type"><code>xsl:item-type</code></a> declaration) is considered
                           identical to its expansion.</p>
                           </li>
                           <li>
                              <p>Two named record types are compared by name, not by content. This is
                              because named record types may potentially be recursive, so the name
                              cannot always be expanded to an expressible record type designator.
                              By implication, the named record type must itself be declared or exposed
                              with <code>visibility="public"</code>.</p>
                           </li>
                        </ol>
                     </div>
                     <p>Modes, named item types, and named record type are not overridable, 
                     so <a href="#element-mode"><code>xsl:mode</code></a>, <a href="#element-item-type"><code>xsl:item-type</code></a>, and
                     <a href="#element-record-type"><code>xsl:record-type</code></a> declarations cannot
                     appear as children of <a href="#element-override"><code>xsl:override</code></a>. However,
                     the constructor function implicitly created from an 
                     <a href="#element-record-type"><code>xsl:record-type</code></a> declaration may be overridden
                     in an <a href="#element-function"><code>xsl:function</code></a> declaration.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="refer-to-overridden"></a>3.4.4.4 <a href="#refer-to-overridden" style="text-decoration: none">Referring to Overridden Components</a></h5>
                     <p>Within the declaration of an overriding named <a title="component" class="termref" href="#dt-component">component</a>
                     (that is, a component whose declaration is a child of
                        <a href="#element-override"><code>xsl:override</code></a>, and has a <code>name</code> attribute), where
                     the overridden component has public <a title="visibility" class="termref" href="#dt-visibility">visibility</a>, it is
                     possible to use the name <code>xsl:original</code> as a symbolic reference to
                     the overridden component. More specifically: </p>
                     <ul>
                        <li>
                           <p>Within a <a title="named template" class="termref" href="#dt-named-template">named template</a> appearing as a child of
                              <a href="#element-override"><code>xsl:override</code></a>, the name <code>xsl:original</code>
                           may appear as the value of the <code>name</code> attribute of
                              <a href="#element-call-template"><code>xsl:call-template</code></a>: for example,
                              <code>&lt;xsl:call-template name="xsl:original"/&gt;</code>. </p>
                        </li>
                        <li>
                           <p>Within a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> appearing as a child of
                              <a href="#element-override"><code>xsl:override</code></a>, the static context for contained XPath
                           expressions (other than <a title="static expression" class="termref" href="#dt-static-expression">static
                              expressions</a>) is augmented as follows: the <b>statically
                              known function signatures</b> includes a mapping from the name
                              <code>xsl:original</code> to the signature of the overridden
                           function (which is the same as the signature of the overriding function).
                           This means that the name <code>xsl:original</code> can be used in static
                           function calls, including calls that use partial function application
                           (where one of the arguments is given as <code>"?"</code>), and also in named function
                           references. For example: <code>xsl:original($x)</code>,
                              <code>xsl:original($x, ?)</code>, <code>xsl:original#2</code>.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The result of calling <code>function-name(xsl:original#2)</code> is
                              the name of the overridden function, not
                              <code>xsl:original</code>.</p>
                           </div>
                           <p>If the function <code>xsl:original</code> is
                        called with keyword arguments, the keywords used are those of the overridden
                        function.</p>
                           <p>Neither <code>xsl:original</code>, nor the overridden function, is added
                           to the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamically-known-function-definitions">dynamically known function definitions</a><sup><small>XP</small></sup> component of the dynamic context for
                           XPath expressions within the overriding function. This means that any
                           attempt to bind the function name <code>xsl:original</code> dynamically
                           (for example using <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>, or
                              <a href="#func-function-available"><code>function-available</code></a>, or
                              <a href="#element-evaluate"><code>xsl:evaluate</code></a>) will fail, and any attempt to bind
                           the name of the overriding/overridden function dynamically will return
                           the overriding function. </p>
                        </li>
                        <li>
                           <p>Within a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or parameter appearing as a
                           child of <a href="#element-override"><code>xsl:override</code></a>, the static context for contained
                           XPath expressions (other than <a title="static expression" class="termref" href="#dt-static-expression">static
                              expressions</a>) is augmented as follows: the <b>in-scope
                              variables</b> includes a mapping from the name
                              <code>xsl:original</code> to the declared type of the overridden
                           variable or parameter (which is the same as the type of the overriding
                           global variable or parameter). </p>
                        </li>
                        <li>
                           <p>Within an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> appearing as a child of
                              <a href="#element-override"><code>xsl:override</code></a>, any
                              <code>[xsl:]use-attribute-sets</code> attribute (whether on the
                              <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element itself, or on any
                           descendant element) may include the name <code>xsl:original</code> as a
                           reference to the overridden attribute set. </p>
                        </li>
                     </ul>
                     <p>Within the overriding component <var>C<sub>P</sub></var>, the <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a>
                     <code>xsl:original</code> is bound to the hidden component <var>C<sub>PQ</sub></var>
                     described earlier, whose body is that of the component <var>C<sub>Q</sub></var> in the
                     used package. </p>
                     <p>
                     <a id="err-XTSE3075"><span class="error">[ERR XTSE3075] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use the
                           component reference <code>xsl:original</code> when the overridden
                           component has <code>visibility="abstract"</code>.
                  </p>
                     <p>Modes are not overridable, so the name
                        <code>xsl:original</code> cannot be used to refer to a <a title="mode" class="termref" href="#dt-mode">mode</a> (for example in the <code>mode</code> attribute of
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>). </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>In the case of variables, templates, and attribute sets, the invocation of
                        the overridden component can occur only within the lexical scope of the
                        overriding component. With functions, however, there is greater flexibility.
                        The overriding component can obtain a reference to the overridden component
                        in the form of a function item, and can export this value by passing it to
                        other functions or returning it in its result. A dynamic invocation of this
                        function item (and hence, of the overridden function) can thus occur
                        anywhere. </p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="component-references"></a>3.4.4.5 <a href="#component-references" style="text-decoration: none">Binding References to Components</a></h5>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-reference-binding" title="reference binding"></a>The process of
                        identifying the <a title="component" class="termref" href="#dt-component">component</a> to which a
                           <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> applies
                        (possibly chosen from several <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> alternatives) is called <b>reference
                           binding</b>.<span class="definition">]</span>
                  </p>
                     <p>The process of <a title="reference binding" class="termref" href="#dt-reference-binding">reference binding</a> in the presence of
                     overriding declarations is best illustrated by an example. The formal rules
                     follow later in the section.</p>
                     <div class="example">
                        
                        <div class="exampleHeader"><a id="example-of-component-binding"></a>Example: Binding References to Named Components</div>
                        <p>Consider a package <var>Q</var> defined as follows:</p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:package name="Q"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:variable name="A" visibility="final" select="$B + 1"/&gt;
  &lt;xsl:variable name="B" visibility="private" select="$C * 2"/&gt;
  &lt;xsl:variable name="C" visibility="public" select="22"/&gt;
&lt;/xsl:package&gt;</pre>
                        </div>
                        <p>(The process is illustrated here using variables as the components, but the
                        logic would be the same if the example used functions, named templates, or
                        attribute sets.)</p>
                        <p>There are three components in this package, and their properties are
                        illustrated in the following table. (The ID column is an arbitrary component
                        identifier used only for the purposes of this exposition.)</p>
                        <table class="data">
                           <caption>Components in the above Package and their Properties</caption>
                           <thead>
                              <tr>
                                 <th style="text-align:left; vertical-align:top">ID</th>
                                 <th style="text-align:left; vertical-align:top">Symbolic Name</th>
                                 <th style="text-align:left; vertical-align:top">Declaring Package</th>
                                 <th style="text-align:left; vertical-align:top">Containing Package</th>
                                 <th style="text-align:left; vertical-align:top">Visibility</th>
                                 <th style="text-align:left; vertical-align:top">Body</th>
                                 <th style="text-align:left; vertical-align:top">Bindings</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>A<sub>Q</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">variable <var>A</var></td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">final</td>
                                 <td style="text-align:left; vertical-align:top"><code>$B + 1</code></td>
                                 <td style="text-align:left; vertical-align:top">$B → <var>B<sub>Q</sub></var></td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>B<sub>Q</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">variable <var>B</var></td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">private</td>
                                 <td style="text-align:left; vertical-align:top"><code>$C * 2</code></td>
                                 <td style="text-align:left; vertical-align:top">$C → <var>C<sub>Q</sub></var></td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>C<sub>Q</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">variable <var>C</var></td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">public</td>
                                 <td style="text-align:left; vertical-align:top"><code>22</code></td>
                                 <td style="text-align:left; vertical-align:top">none</td>
                              </tr>
                           </tbody>
                        </table>
                        <p>Now consider a package <var>P</var> that uses <var>Q</var>, and that
                        overrides one of the variables declared in <var>Q</var>:</p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:package name="P"
        version="3.0"                
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:use-package name="Q"&gt;
    &lt;xsl:override&gt;
      &lt;xsl:variable name="C" visibility="private" select="$xsl:original + 3"/&gt;
    &lt;/xsl:override&gt;
  &lt;/xsl:use-package&gt;
  
  &lt;xsl:template name="T" visibility="public"&gt;
    &lt;xsl:value-of select="$A"/&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:package&gt;</pre>
                        </div>
                        <p>Package <var>P</var> has five components, whose properties are shown in the
                        following table:</p>
                        <table class="data">
                           <caption>Components in the above Package and their Properties</caption>
                           <thead>
                              <tr>
                                 <th style="text-align:left; vertical-align:top">ID</th>
                                 <th style="text-align:left; vertical-align:top">Symbolic Name</th>
                                 <th style="text-align:left; vertical-align:top">Declaring Package</th>
                                 <th style="text-align:left; vertical-align:top">Containing Package</th>
                                 <th style="text-align:left; vertical-align:top">Visibility</th>
                                 <th style="text-align:left; vertical-align:top">Body</th>
                                 <th style="text-align:left; vertical-align:top">Bindings</th>
                              </tr>
                           </thead>
                           <tbody>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>A<sub>PQ</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">variable <var>A</var></td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">P</td>
                                 <td style="text-align:left; vertical-align:top">final</td>
                                 <td style="text-align:left; vertical-align:top"><code>$B + 1</code></td>
                                 <td style="text-align:left; vertical-align:top">$B → <var>B<sub>PQ</sub></var></td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>B<sub>PQ</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">variable <var>B</var></td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">P</td>
                                 <td style="text-align:left; vertical-align:top">hidden</td>
                                 <td style="text-align:left; vertical-align:top"><code>$C * 2</code></td>
                                 <td style="text-align:left; vertical-align:top">$C → <var>C<sub>P</sub></var></td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>C<sub>PQ</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">variable <var>C</var></td>
                                 <td style="text-align:left; vertical-align:top">Q</td>
                                 <td style="text-align:left; vertical-align:top">P</td>
                                 <td style="text-align:left; vertical-align:top">hidden</td>
                                 <td style="text-align:left; vertical-align:top"><code>22</code></td>
                                 <td style="text-align:left; vertical-align:top">none</td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>C<sub>P</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">variable <var>C</var></td>
                                 <td style="text-align:left; vertical-align:top">P</td>
                                 <td style="text-align:left; vertical-align:top">P</td>
                                 <td style="text-align:left; vertical-align:top">private</td>
                                 <td style="text-align:left; vertical-align:top"><code>$xsl:original + 3</code></td>
                                 <td style="text-align:left; vertical-align:top">$xsl:original → <var>C<sub>PQ</sub></var></td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top"><var>T<sub>P</sub></var></td>
                                 <td style="text-align:left; vertical-align:top">template <var>T</var></td>
                                 <td style="text-align:left; vertical-align:top">P</td>
                                 <td style="text-align:left; vertical-align:top">P</td>
                                 <td style="text-align:left; vertical-align:top">public</td>
                                 <td style="text-align:left; vertical-align:top"><code>value-of select="$A</code></td>
                                 <td style="text-align:left; vertical-align:top">$A → <var>A<sub>PQ</sub></var></td>
                              </tr>
                           </tbody>
                        </table>
                        <p>The effect of these bindings is that when template <var>T</var> is called,
                        the result is <code>51</code>. This is why:</p>
                        <ol class="enumar">
                           <li>
                              <p>The result of <var>T</var> is the value of <var>A<sub>PQ</sub></var>.</p>
                           </li>
                           <li>
                              <p>The value of <var>A<sub>PQ</sub></var> is the value of <var>B<sub>PQ</sub></var> plus
                              1.</p>
                           </li>
                           <li>
                              <p>The value of <var>B<sub>PQ</sub></var> is the value of <var>C<sub>P</sub></var> times
                              2.</p>
                           </li>
                           <li>
                              <p>The value of <var>C<sub>P</sub></var> is the value of <var>C<sub>PQ</sub></var> plus
                              3.</p>
                           </li>
                           <li>
                              <p>The value of <var>C<sub>PQ</sub></var> is 22.</p>
                           </li>
                           <li>
                              <p>So the final result is ((22 + 3) * 2) + 1</p>
                           </li>
                        </ol>
                        <p>In this example, the components of <var>P</var> are established in three
                        different ways:</p>
                        <ol class="enumar">
                           <li>
                              <p>Components <var>A<sub>PQ</sub></var>, <var>B<sub>PQ</sub></var>, and <var>C<sub>PQ</sub></var> are
                              modified copies of the corresponding component <var>A<sub>Q</sub></var>,
                                 <var>B<sub>Q</sub></var>, and <var>C<sub>Q</sub></var> in the used package
                              <var>Q</var>. The properties of these components are modified as
                              follows:</p>
                              <ol class="enumla">
                                 <li>
                                    <p>The <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a>, <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, and body are unchanged.</p>
                                 </li>
                                 <li>
                                    <p>The <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> is changed to
                                       <var>P</var>.</p>
                                 </li>
                                 <li>
                                    <p>The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is changed according to the
                                    rules in <a href="#accepting-components"><i>3.4.4.2 Accepting Components</i></a>: in particular,
                                       <code>visibility="private"</code> changes to
                                       <code>visibility="hidden"</code>.</p>
                                 </li>
                                 <li>
                                    <p>The references to other components are rebound as described in
                                    this section.</p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>Component <var>C<sub>P</sub></var> is the overriding component. Its properties
                              are exactly as if it were declared as a top-level component in
                                 <var>P</var> (outside the <a href="#element-use-package"><code>xsl:use-package</code></a>
                              element), except that (a) it must adhere to the constraints on
                              overriding components (see <a href="#package-overriding-components"><i>3.4.4.3 Overriding Components from a Used Package</i></a>), (b) it is allowed to use
                              the variable reference <code>$xsl:original</code>, and (c) the fact
                              that it overrides <var>C<sub>Q</sub></var> affects the way that references from
                              other components are rebound.</p>
                           </li>
                           <li>
                              <p>Component <var>T<sub>P</sub></var> is a new component declared locally in
                                 <var>P</var>.</p>
                           </li>
                        </ol>
                     </div>
                     <p>The general rules for <a title="reference binding" class="termref" href="#dt-reference-binding">reference binding</a> can now be
                     stated:</p>
                     <ol class="enumar">
                        <li>
                           <p>If the <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> of a component
                              <var>C<sub>P</sub></var> is <var>P</var>, then all <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic references</a> in
                              <var>C<sub>P</sub></var> are bound to components whose <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> is <var>P</var>.</p>
                        </li>
                        <li>
                           <p>When a package <var>P</var> uses a package <var>Q</var>, then for every
                           component <var>C<sub>Q</sub></var> in <var>Q</var>, there is a <b>corresponding
                              component</b>
                           <var>C<sub>P</sub></var> in <var>P</var>, as described in <a href="#accepting-components"><i>3.4.4.2 Accepting Components</i></a>.</p>
                        </li>
                        <li>
                           <p>Given a component <var>C<sub>P</sub></var> whose <a title="containing package" class="termref" href="#dt-containing-package">containing package</a> and <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a> are the same package <var>P</var>, then (as a consequence of rules
                           elsewhere in this specification) for every <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a>
                           <var>D</var> within <var>C<sub>P</sub></var>, other than a reference using the name
                              <code>xsl:original</code>, there will always be exactly one non-hidden
                           component <var>D<sub>P</sub></var> whose containing package is <var>P</var> and
                           whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifier</a> matches <var>D</var>
                           (otherwise a static error will have been raised). The reference is then
                           bound to <var>D<sub>P</sub></var>.</p>
                        </li>
                        <li>
                           <p>In the case of a component reference using the name
                              <code>xsl:original</code>, this will in general appear within a
                           component <var>C<sub>P</sub></var> that overrides a component <var>C<sub>Q</sub></var> whose
                           corresponding component in <var>P</var> is <var>C<sub>PQ</sub></var>, and the
                              <code>xsl:original</code> reference is bound to <var>C<sub>PQ</sub></var>.</p>
                        </li>
                        <li>
                           <p>Given a component <var>C<sub>P</sub></var> whose <a title="containing package" class="termref" href="#dt-containing-package">containing package</a>
                           <var>P</var> is a different package from its <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>
                           <var>R</var> (that is, <var>C<sub>P</sub></var> is present in <var>P</var> by
                           virtue of an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration referencing
                           package <var>Q</var>, which may or may not be the same as <var>R</var>),
                           then the component bindings in <var>C<sub>P</sub></var> are derived from the
                           component bindings in the corresponding component <var>C<sub>Q</sub></var> as
                           follows: if the component binding within <var>C<sub>Q</sub></var> is to a component
                              <var>D<sub>Q</sub></var>, then:</p>
                           <ol class="enumla">
                              <li>
                                 <p>If <var>D<sub>Q</sub></var> is overridden within <var>P</var> by a component
                                    <var>D<sub>P</sub></var>, then the reference is bound to
                                 <var>D<sub>P</sub></var>;</p>
                              </li>
                              <li>
                                 <p>Otherwise, the reference is bound to the component <var>D<sub>PQ</sub></var>
                                 in <var>P</var> whose corresponding component in <var>Q</var> is
                                    <var>D<sub>Q</sub></var>.</p>
                              </li>
                           </ol>
                        </li>
                     </ol>
                     <p>When reference resolution is performed on a package that is intended to be used
                     as a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (that is, for the
                        <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>), there must
                     be no symbolic references referring to components whose visibility is
                        <code>abstract</code> (that is, an implementation must be provided for every
                     abstract component). </p>
                     <p>
                     <a id="err-XTSE3080"><span class="error">[ERR XTSE3080] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                              <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> (as
                           distinct from a <a title="library package" class="termref" href="#dt-library-package">library
                              package</a>) contains 
                           components whose visibility is <code>abstract</code>.
                  </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Abstract components in a used package by default become hidden in the using package, 
                        which means that a reference to the component in the top-level package will fail 
                        to resolve (resulting in a different static error). This particular error occurs 
                        only if the abstract component is declared within the top-level package.
                     </p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Unresolved references are allowed at the module level but not at the package
                        level. A stylesheet module can contain references to components that are
                        satisfied only when the module is imported into another module that declares
                        the missing component.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The process of resolving references (or linking) is critical to an
                        implementation that uses separate compilation. One of the aims of these
                        rules is to ensure that when compiling a package, it is always possible to
                        determine the signature of called functions, templates, and other
                        components. A further aim is to establish unambiguously in what
                        circumstances components can be overridden, so that compilers know when it
                        is possible to perform optimizations such as inlining of function and
                        variable references.</p>
                        <p>Suppose a public template <var>T</var> calls a private function
                        <var>F</var>. When the package containing these two components is referenced
                        by a using package, the template remains public, while the function becomes
                        hidden. Because the function becomes hidden, it can no longer conflict with
                        any other function of the same name, or be overridden by any other function;
                        at this stage the compiler knows exactly which function <var>T</var> will be
                        calling, and can perform optimizations based on this knowledge.</p>
                     </div>
                     <p>The mechanism for resolving component references described in
                     this section is consistent with the mechanism used for binding function and
                     variable references described in the XPath specification. XPath requires these
                     variable and function names to be present in the static context for an XPath
                     expression. XSLT ensures that all the non-hidden functions, global variables,
                     and global parameters in a package are present in the static context for every
                     XPath expression that appears in that package, along with required information
                     such as the type of a variable and the signature of a function.</p>
                     <div class="example">
                        
                        <div class="exampleHeader"><a id="d5e8232"></a>Example: Named Component References in Inline Functions</div>
                        <p>Named component references within inline functions follow the standard rules, but the rules need
                        to be interpreted with care. Suppose that in package <var>P</var> we find the declarations:</p>
                        <div class="exampleInner">
                           <pre>
&lt;xsl:variable name="v" as="xs:integer" visibility="public" select="3"/&gt;

&lt;xsl:function name="f:factory" as="fn(*)" visibility="final"&gt;
  &lt;xsl:sequence select="fn() { $v }"/&gt;
&lt;/xsl:function&gt;</pre>
                        </div>
                        <p>and that in a using package Q we find:</p>
                        <div class="exampleInner">
                           <pre>
      
&lt;xsl:use-package name="P"&gt;
  &lt;xsl:override&gt;
    &lt;xsl:variable name="v" as="xs:integer" select="4"/&gt;
  &lt;/xsl:override&gt;
&lt;/xsl:use-package&gt;

&lt;xsl:template name="xsl:initial-template"&gt;
  &lt;v value="{f:factory()()}"/&gt;
&lt;/xsl:template&gt;</pre>
                        </div>
                        <p>The correct output here is <code>&lt;v value="4"/&gt;</code>.</p>
                        <p>The explanation for this is as follows. Package <var>Q</var> contains a function <var>f:factory<sub>QP</sub></var>
                        whose declaring package is <var>P</var> and whose containing package is <var>Q</var>. The symbolic reference
                        <code>$v</code> within the body of this function is resolved in the normal way; since the containing package
                        is <var>Q</var>, it is resolved to the global variable <var>v<sub>Q</sub></var>: that is, the overriding declaration
                        of <code>$v</code> that appears within the <a href="#element-override"><code>xsl:override</code></a> element within package <var>Q</var>,
                        whose value is 4.</p>
                        <p>In terms of internal implementation, one way of looking at this is that the anonymous function returned
                        by <code>f:factory</code> contains within its closure bindings for the global variables and functions that
                        the anonymous function references; these bindings are inherited from the component bindings of the
                        component that lexically contains these symbolic references, which in this case is <code>f:factory</code>,
                        and more specifically the version of the <code>f:factory</code> component in package <var>Q</var>.</p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="dynamic-component-references"></a>3.4.4.6 <a href="#dynamic-component-references" style="text-decoration: none">Dynamic References to Components</a></h5>
                     <p>There are several functions in which a dynamically evaluated QName is used to
                     identify a component: these include <a href="#func-key"><code>key</code></a>,
                        <a href="#func-accumulator-before"><code>accumulator-before</code></a>,
                        <a href="#func-accumulator-after"><code>accumulator-after</code></a>,
                     <a href="#func-apply-templates"><code>apply-templates</code></a>,
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>, and
                        <a href="#func-function-available"><code>function-available</code></a>. Dynamic references can also occur
                     in the XPath expression supplied to the <a href="#element-evaluate"><code>xsl:evaluate</code></a>
                     instruction. </p>
                     <p>In all these cases, the set of components that are available to be referenced
                     are those that are declared in the package where this function call appears,
                     including components declared within an <a href="#element-override"><code>xsl:override</code></a>
                     declaration in that package, but excluding components declared with
                        <code>visibility="abstract"</code>. If the relevant component has been
                     overridden in a different package, the overriding declarations are not
                     considered. </p>
                     <p>If one of these functions (for example <a href="#func-key"><code>key</code></a> or
                        <a href="#func-accumulator-before"><code>accumulator-before</code></a>) is invoked via a dynamic function
                     invocation, then the relevant package is the one in which the function item is
                     created (using a construct such as <code>key#2</code>, <code>key('my-key',
                        ?)</code>, or <code>function-lookup($KEYFN, 2)</code>). Function items
                     referring to context-dependent functions bind the context at the point where
                     the function item is created, not the context at the point where the function
                     item is invoked.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This means that if a package wishes to make a key available for use by a
                        calling package, it can do so by creating a public global variable whose
                        value is a partial application of the <a href="#func-key"><code>key</code></a> function:</p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:variable name="get-order" select="key('orders-key', ?, ?)"/&gt;</pre>
                        </div>
                        <p>which the calling code can invoke as <code>$get-order('123-456', /)</code>.</p>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="modes-and-packages"></a>3.4.5 <a href="#modes-and-packages" style="text-decoration: none">Overriding Template Rules from a Used Package</a></h4>
                  <p>The rules in the previous section apply to named components including functions,
                  named templates, global variables, and named attribute sets. The rules for
                     <a title="mode" class="termref" href="#dt-mode">modes</a>, and the <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> appearing within a mode, are slightly different.</p>
                  <p>The unnamed mode is local to a package: in effect, each package has its own
                  private unnamed mode, and the unnamed mode of one package does not interact with
                  the unnamed mode of any other package. An
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>mode</code>
                     attribute is treated as a <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> to the default
                     mode defined for that instruction (see <a href="#default-mode"><i>3.6.3 The default-mode Attribute</i></a>), which in
                     turn defaults to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. Because the unnamed mode
                     always has private visibility, it cannot be overridden in another 
                     package.</p>
                  <p>A named mode may be declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration as being
                  either <code>public</code>, <code>private</code>, or <code>final</code>. The
                  values of the <code>visibility</code> attribute are interpreted as follows:</p>
                  <table class="def">
                     <caption>Visibility Values for Named Modes, and their Meaning</caption>
                     <thead>
                        <tr>
                           <th style="text-align:left; vertical-align:top">Value</th>
                           <th style="text-align:left; vertical-align:top">Meaning</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align:left; vertical-align:top">public</td>
                           <td style="text-align:left; vertical-align:top">A <b>using</b> package may use
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> to invoke templates in this mode;
                              it may also declare additional template rules in this mode, which are
                              selected in preference to template rules in the used package. These may
                              appear only as children of the <a href="#element-override"><code>xsl:override</code></a> element
                              within the <a href="#element-use-package"><code>xsl:use-package</code></a> element.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">private</td>
                           <td style="text-align:left; vertical-align:top">A <b>using</b> package may neither reference the mode nor provide
                              additional templates in this mode; the name of the mode is not even
                              visible in the using package, so no such attempt is possible. The using
                              package can use the same name for its own modes without risk of conflict.
                              </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">final</td>
                           <td style="text-align:left; vertical-align:top">A <b>using</b> package may use
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> to invoke templates in this mode,
                              but it must not provide additional template rules in this mode. </td>
                        </tr>
                     </tbody>
                  </table>
                  <p>As with other named components, an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration
                  may contain an <a href="#element-accept"><code>xsl:accept</code></a> element to control the visibility of a
                  mode acquired from the <b>used</b> package. The allowed values of its
                     <code>visibility</code> attribute are <code>public</code>,
                  <code>private</code>, and <code>final</code>.</p>
                  <p>The <a href="#element-mode"><code>xsl:mode</code></a> declaration itself must not be overridden. A using
                  package must not contain an <a href="#element-mode"><code>xsl:mode</code></a> declaration whose name
                  matches that of a <code>public</code> or <code>final</code>
                  <a href="#element-mode"><code>xsl:mode</code></a> component accepted from a used package.</p>
                  <p>The <a href="#element-expose"><code>xsl:expose</code></a> and <a href="#element-accept"><code>xsl:accept</code></a> elements may be
                  used to reduce the visibility of a mode in a using package; the same rules apply
                  in general, though some of the rules are not applicable because, for example,
                  modes cannot be <code>abstract</code>.</p>
                  <p>It is not possible for a package to combine the template rules from two other
                  packages into a single mode. When <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used
                  without specifying a mode, the chosen template rules will always come from the
                  same package; when it is used with a named mode, then they will come from the
                  package where the mode is defined, or any package that uses that package and adds
                  template rules to the mode. If two template rules defined in different packages
                  match the same node, then the rule in the using package wins over any rule in the
                  used package; this decision is made before taking other factors such as import
                  precedence and priority into account.</p>
                  <p>A static error occurs if two modes with the same name are visible within a
                  package, either because they are both declared within the package, or because one
                  is declared within the package and the other is acquired from a used package, or
                  because both are accepted from different used packages.</p>
                  <p>The rules for matching template rules by <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a> operate as
                  normal, with the addition that template rules declared within an
                     <a href="#element-use-package"><code>xsl:use-package</code></a> element have higher precedence than any
                  template rule declared in the used package. More specifically, given an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction
                     in package <var>P</var>, naming a mode <var>M</var> that is declared in a used
                     package <var>Q</var> and is overridden in <var>P</var>, the search order for
                     template rules is:</p>
                  <ol class="enumar">
                     <li>
                        <p>Rules declared within <var>P</var> (specifically,
                           <a href="#element-template"><code>xsl:template</code></a> rules declared as children of an
                           <a href="#element-override"><code>xsl:override</code></a> element within the
                           <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package
                           <var>Q</var>). If there are multiple rules declared within <var>P</var>
                        that match a selected node, they are resolved on the basis of their explicit
                        or implicit <a title="priority" class="termref" href="#dt-priority">priority</a>, and if the priorities are equal, the last one in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> wins.</p>
                     </li>
                     <li>
                        <p>Rules declared within <var>Q</var>, taking <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, <a title="priority" class="termref" href="#dt-priority">priority</a>, and <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> into account in the usual way (see <a href="#conflict"><i>6.6 Conflict Resolution for Template Rules</i></a>).</p>
                     </li>
                     <li>
                        <p>Built-in template rules (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>) selected
                        according to the <code>on-no-match</code> attribute of the
                           <a href="#element-mode"><code>xsl:mode</code></a> declaration (in <var>Q</var>), or its
                        default.</p>
                     </li>
                  </ol>
                  <p>If the mode is overridden again in a package
                     <var>R</var> that uses <var>P</var>, then this search order is extended by
                  adding <var>R</var> at the start of the search list, and so on recursively.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If existing XSLT code has been written to use template rules in the unnamed
                     mode, a convenient way to incorporate this code into a <a title="library package" class="termref" href="#dt-library-package">library package</a> is to add a stub module
                     that defines a new named <code>public</code> or <code>final</code> mode, in
                     which there is a single template rule whose content is the single instruction
                        <code>&lt;xsl:apply-templates select="."/&gt;</code>. This in effect redirects
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions using the named mode to
                     the rules defined in the unnamed mode.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="requiring-explicit-modes"></a>3.4.5.1 <a href="#requiring-explicit-modes" style="text-decoration: none">Requiring Explicit Mode Declarations</a></h5>
                     <p>In previous versions of XSLT, modes were implicitly declared by simply using a
                     mode name in the <code>mode</code> attribute of <a href="#element-template"><code>xsl:template</code></a>
                     or <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>. XSLT 3.0 introduced the ability to
                     declare a mode explicitly using an <a href="#element-mode"><code>xsl:mode</code></a> declaration (see
                        <a href="#declaring-modes"><i>6.7.1 Declaring Modes</i></a>).</p>
                     <p>By default, within a package that is defined using an explicit
                        <a href="#element-package"><code>xsl:package</code></a> element, all modes must be explicitly declared.
                     In an implicit package, however (that is, one rooted at an
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element),
                     modes can be implicitly declared as in previous XSLT versions.</p>
                     <p>The <code>declared-modes</code>
                     attribute of <a href="#element-package"><code>xsl:package</code></a> determines whether or not modes that
                     are referenced within the package must be explicitly declared. 
                     
                     If the value is <code>yes</code> (the default),
                     then it is an error to use a mode name 
                        unless the package either contains
                     an explicit <a href="#element-mode"><code>xsl:mode</code></a> declaration for that mode, or accepts the mode
                     from a used package. If the value is <code>no</code>, then this is not an error.
                     
                     
                  
                  </p>
                     <p>This attribute affects all modules making up the package, it is not confined to
                     declarations appearing as children of the <a href="#element-package"><code>xsl:package</code></a>
                     element.</p>
                     <p>
                     <a id="err-XTSE3085"><span class="error">[ERR XTSE3085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, 
                           when the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of 
                           an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the 
                           package contains an explicit reference to an undeclared mode, or if 
                           it implicitly uses the unnamed mode and the unnamed mode is undeclared.</p>
                     <p>For the purposes of the above rule:</p>
                     <ol class="enumar">
                        <li>
                           <p>A mode is <b>declared</b> if either of the following conditions is true:</p>
                           <ol class="enumla">
                              <li>
                                 <p>The package contains an <a href="#element-mode"><code>xsl:mode</code></a> 
                                 declaration for that mode.</p>
                              </li>
                              <li>
                                 <p>The mode is a public or final mode accepted 
                                 from a used package. </p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>The offending reference may be either an explicit mode name, or the token <code>#unnamed</code> 
                           treated as a reference to the unnamed mode, or a defaulted mode attribute, and it may occur in any of the following:</p>
                           <ol class="enumla">
                              <li>
                                 <p>The <code>mode</code> 
                                 attribute of an <a href="#element-template"><code>xsl:template</code></a> declaration</p>
                              </li>
                              <li>
                                 <p>The <code>mode</code> 
                                 attribute of an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction</p>
                              </li>
                              <li>
                                 <p>An <code>[xsl:]default-mode</code> attribute.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>A package <b>implicitly uses the unnamed mode</b>
                           if either of the following conditions is true:</p>
                           <ol class="enumla">
                              <li>
                                 <p>There is an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> 
                                 element with no <code>mode</code> attribute, and with no ancestor-or-self having 
                                 an <code>[xsl:]default-mode</code> attribute.</p>
                              </li>
                              <li>
                                 <p>There is an <a href="#element-template"><code>xsl:template</code></a> 
                                 element with a <code>match</code> attribute and no <code>mode</code> attribute, and with no ancestor-or-self having 
                                 an <code>[xsl:]default-mode</code> attribute.</p>
                              </li>
                           </ol>
                        </li>
                     </ol>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="package-local-declarations"></a>3.4.6 <a href="#package-local-declarations" style="text-decoration: none">Declarations Local to a Package</a></h4>
                  <p>The <a href="#element-import"><code>xsl:import</code></a> and
                     <a href="#element-include"><code>xsl:include</code></a> declarations are local to a package.</p>
                  <p>Declarations of <a title="key" class="termref" href="#dt-key">keys</a>, <a title="accumulator" class="termref" href="#dt-accumulator">accumulators</a>, 
                  <a title="decimal format" class="termref" href="#dt-decimal-format">decimal formats</a>, namespace aliases (see
                     <a href="#namespace-aliasing"><i>11.1.4 Namespace Aliasing</i></a>), <a title="output definition" class="termref" href="#dt-output-definition">output definitions</a>, and <a title="character map" class="termref" href="#dt-character-map">character
                     maps</a> within a package have local scope within that package —
                  they are all effectively private. The elements that declare these constructs do
                  not have a <code>visibility</code> attribute. The unnamed decimal format and the
                  unnamed output format are also local to a package.</p>
                  <p>If <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
                  declarations appear within a <a title="library package" class="termref" href="#dt-library-package">library
                     package</a>, they only affect calls to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or
                     <a href="#func-document"><code>document</code></a> functions appearing within that package. Such a declaration within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> additionally affects stripping of whitespace in
                     the document that contains the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>.</p>
                  <p>An <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration within a package applies only
                  to calls on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> appearing within that
                  package.</p>
                  <p>An <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration within a package applies only
                  to literal result elements within the same package.</p>
                  <p>An <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration within a package adds the names
                  of the imported schema components to the static context for that package only;
                  these names are effectively private, in the sense that they do not become
                  available for use in any other packages. However, the names of schema components
                  must be consistent across the stylesheet as a whole: it is not possible for two
                  different packages within a stylesheet to use a type-name such as <code>part-number</code> to
                  refer to different schema-defined simple or complex types.</p>
                  <p>Type names used in the interface of public components in a package (for example,
                  in the arguments of a function) must be respected by callers of those components,
                  in the sense that the caller must supply values of the correct type. Often this
                  will mean that the using component, if it contains calls on such interfaces, must
                  itself import the necessary schema components. However, the requirement for an
                  explicit schema import applies only where the package contains explicit use of the
                  names of schema components required to call such interfaces.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>For example, suppose a <a title="library package" class="termref" href="#dt-library-package">library
                        package</a> contains a function which requires an argument of type
                        <code>mfg:part-number</code>. The caller of this function must supply an
                     argument of the correct type, but does not need to import the schema unless it
                     explicitly uses the schema type name <code>mfg:part-number</code>. If it
                     obtains an instance of this type from outside the package, for example as the
                     result of another function call, then it can supply this instance to the
                     acquired function even though it has not imported a schema that defines this
                     type.</p>
                  </div>
                  <p>At execution time, the schema available for validating instance documents contains
                  (at least) the union of the schema components imported into all constituent
                  packages of the stylesheet.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="declaring-global-context-item"></a>3.4.7 <a href="#declaring-global-context-item" style="text-decoration: none">Declaring the Global Context Item</a></h4>
                  <p>The <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element is used to declare whether a
                     <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> is required, and if so, what its
                     <a title="required type" class="termref" href="#dt-required-type">required type</a> is.</p>
                  <p>The element is a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> that
                  can appear at most once in any stylesheet module; and if more than one
                     <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a <a title="package" class="termref" href="#dt-package">package</a>, then the declarations must be consistent. Specifically, all
                  the attributes <span class="verb">must</span> have semantically equivalent values.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This means that omitting an attribute is equivalent to specifying its default
                     value explicitly; and purely lexical variations, such as the presence of whitespace
                     in an attribute value, are not considered significant.</p>
                  </div>
                  <p>
                  <a id="err-XTSE3087"><span class="error">[ERR XTSE3087] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if more than
                        one <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a
                           <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, or if several modules within a
                        single <a title="package" class="termref" href="#dt-package">package</a> contain inconsistent
                           <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declarations</p>
                  <p>If there is no <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration for a package,
                  this is equivalent to specifying the empty element
                     <code>&lt;xsl:global-context-item/&gt;</code>, which imposes no constraints.</p>
                  <p class="element-syntax"><a id="element-global-context-item"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:global-context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"〔'optional'〕&nbsp;/&gt;</code></p>
                  <p>The <code>use</code> attribute takes the value <code>required</code>,
                     <code>optional</code>, or <code>absent</code>. The
                  default is <code>optional</code>.</p>
                  <ul>
                     <li>
                        <p>If the value <code>required</code> is specified, then there must be a
                           global context item. </p>
                     </li>
                     <li>
                        <p>If the value <code>optional</code> is specified, or if the attribute is
                           omitted, or if the <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> element is
                           omitted, then there may or may not be a global context item.</p>
                     </li>
                     <li>
                        <p>If the value <code>absent</code> is specified, then the global focus
                           (context item, position, and size) will be <a title="absent" class="termref" href="#dt-absent">absent</a></p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This specification does not define whether supplying a global context
                              item in this situation results in an error or warning, or whether the
                              supplied context item is simply ignored.</p>
                        </div>
                     </li>
                  </ul>
                  <p>If the <code>as</code> attribute is present then its value must be an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>. If the attribute is
                  omitted this is equivalent to specifying <code>as="item()"</code>.</p>
                  <p>The <code>as</code> attribute defines the required type of the global context
                  item. The default value is <code>as="item()"</code>. If a global context item is
                  supplied then it must conform to the required type, after conversion (if
                  necessary) using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                  <p><a id="err-XTSE3089"><span class="error">[ERR XTSE3089] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is
                        present  when <code>use="absent"</code> is specified.</p>
                  <p>The global context item is available only within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>. If a valid <a href="#element-global-context-item"><code>xsl:global-context-item</code></a>
                  declaration appears within a <a title="library package" class="termref" href="#dt-library-package">library package</a>, then it is
                  ignored, unless it specifies <code>use="required"</code>, in which case an error
                  is raised: <span class="error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In earlier releases of this specification, the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> and
                  the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> were essentially the same thing, often referred
                  to as the <em>principal source document</em>. In XSLT 3.0, they were separated:
                  the global context item is a single item accessible to the initializers of global variables
                  as the value of the expression <code>.</code> (dot), while the initial match selection
                  is a sequence of nodes or other items supplied to an initial implicit <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  invocation.</p>
                     <p>APIs that were originally designed for use with earlier versions of XSLT
                  are likely to bundle the two concepts together.</p>
                  </div>
                  <p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised if 
                  <span>the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> contains</span>
                  an <a href="#element-global-context-item"><code>xsl:global-context-item</code></a>
                  declaration specifying a required type that does not match the supplied <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>. The error code is the same as for
                     <a href="#element-param"><code>xsl:param</code></a>: <span class="error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If the <code>ItemType</code> is one that can only be satisfied by a
                     schema-validated input document, for example
                        <code>as="schema-element(invoice)"</code>, the <a title="processor" class="termref" href="#dt-processor">processor</a> may interpret this as a request to apply schema
                     validation to the input. Similarly, if the <code>KindTest</code> indicates that
                     an element node is required, the processor may interpret this as a request to
                     supply the document element rather than the document node of a supplied input
                     document.</p>
                  </div>
                  <p>
                  <a id="err-XTDE3086"><span class="error">[ERR XTDE3086] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an
                        <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration specifies
                     <code>use="required"</code>, and no global context item is supplied.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="packages-csv-library-example"></a>3.4.8 <a href="#packages-csv-library-example" style="text-decoration: none">Worked Example of a Library Package</a></h4>
                  <p>The example in this section illustrates the use of overrides to customize or
                  extend a (fictional) library package named
                     <code>http://example.com/csv-parser</code>, which provides a parsing function
                  for data formatted as lines containing comma-separated values. For simplicity of
                  exposition, the example shows a simple, naive implementation; a realistic CSV
                  parser would be more complicated and make the example harder to follow.</p>
                  <div class="div4">
                     
                     <h5><a id="csv-example-default-functionality"></a>3.4.8.1 <a href="#csv-example-default-functionality" style="text-decoration: none">Default Functionality of the CSV Package</a></h5>
                     <p>The basic functionality of the package is provided by the function
                        <code>csv:parse</code>, which expects a string parameter named
                        <code>input</code>. By default, the function parses the input into lines,
                     and breaks lines on commas, returning as result an element named
                        <code>csv</code> containing one <code>row</code> element per line, each
                        <code>row</code> containing a sequence of <code>field</code> elements.</p>
                     <p>A simple stylesheet which uses this library and applies it to a string might
                     look like the following. The initial template applies <code>csv:parse</code> to
                     a suitable string and returns a copy of the result:</p>
                     <div class="exampleInner">
                        <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*" /&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name,id,postal code
       "Abel Braaksma",34291,1210 KA
       "Anders Berglund",473892,9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                     <p>The result returned by this stylesheet would be:</p>
                     <div class="exampleInner">
                        <pre>&lt;csv&gt;
  &lt;row&gt;
    &lt;field quoted="no"&gt;name&lt;/field&gt;
    &lt;field quoted="no"&gt;id&lt;/field&gt;
    &lt;field quoted="no"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Abel Braaksma&lt;/field&gt;
    &lt;field quoted="no"&gt;34291&lt;/field&gt;
    &lt;field quoted="no"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes"&gt;Anders Berglund&lt;/field&gt;
    &lt;field quoted="no"&gt;473892&lt;/field&gt;
    &lt;field quoted="no"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/csv&gt;</pre>
                     </div>
                     <p>Variations on this default behavior are achieved by overriding selected
                     declarations in the package, as described below.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-package-structure"></a>3.4.8.2 <a href="#csv-example-package-structure" style="text-decoration: none">Package Structure</a></h5>
                     <p>The package module itself is version 1.0.0 of a package called
                        <code>http://example.com/csv-parser</code>; it has the following
                     structure:</p>
                     <div class="exampleInner">
                        <pre>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xsl:package
   name="http://example.com/csv-parser"
   package-version="1.0.0"
   xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   declared-modes="yes"
   version="3.0"&gt;

   &lt;!--* Mode declarations ... *--&gt;
   &lt;!--* Variable declarations ... *--&gt;
   &lt;!--* Attribute-set declaration ... *--&gt;
   &lt;!--* Function declarations ... *--&gt;
   &lt;!--* Templates ... *--&gt;

&lt;/xsl:package&gt;</pre>
                     </div>
                     <p>The contents of the package (represented here by comments) are described more
                     fully below.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-customizing-parse"></a>3.4.8.3 <a href="#csv-example-customizing-parse" style="text-decoration: none">The <code>csv:parse</code> Function and its User-customization Hooks</a></h5>
                     <p>The <code>csv:parse</code> function is final and cannot be overridden. As can be
                     seen from the code below, it (1) parses its <code>input</code> parameter into
                     lines, (2) calls function <code>csv:preprocess-line</code> on each line, then
                     (3) applies the templates of mode <code>csv:parse-line</code> to the
                     pre-processed value. The result is then (4) processed again by mode
                        <code>csv:post-process</code>.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="csv:parse" visibility="final"&gt;
    &lt;xsl:param name="input" as="xs:string" /&gt;   
    &lt;xsl:variable name="result" as="element()"&gt;
        &lt;csv&gt;
            &lt;xsl:apply-templates 
                select="(tokenize($input, $csv:line-separator) 
                        ! csv:preprocess-line(.))" 
                mode="csv:parse-line" /&gt;
        &lt;/csv&gt;
    &lt;/xsl:variable&gt;
    &lt;xsl:apply-templates select="$result" 
                         mode="csv:post-process" /&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>The default code for this processing is given below. Each part of the
                     processing except the first (the tokenization into lines) can be overridden by
                     the user of the package.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-line-breaking"></a>3.4.8.4 <a href="#csv-example-line-breaking" style="text-decoration: none">Breaking the Input into Lines</a></h5>
                     <p>The first user-customization hook is given by the global variable
                        <code>csv:line-separator</code>, which specifies the line separator used to
                     break the input string into lines. It can be overridden by the user if need be.
                     The default declaration attempts to handle the line-separator sequences used by
                     most common operating systems in text files:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="csv:line-separator" 
              as="xs:string" 
              select="'\r\n?|\n\r?'" 
              visibility="public"/&gt;</pre>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-preprocessing-lines"></a>3.4.8.5 <a href="#csv-example-preprocessing-lines" style="text-decoration: none">Pre-processing the Lines</a></h5>
                     <p>The function <code>csv:preprocess-line</code> calls
                        <code>normalize-space()</code> on its argument:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="csv:preprocess-line" 
                 as="xs:string?" 
                 visibility="public"&gt;
    &lt;xsl:param name="line" as="xs:string" /&gt;
    &lt;xsl:sequence select="normalize-space($line)" /&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>Because the function is declared <code>public</code>, it can be overridden by a
                     user. (This might be necessary, for example, if whitespace within quoted
                     strings needs to be preserved.)</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="example-csv-mode-parse-line"></a>3.4.8.6 <a href="#example-csv-mode-parse-line" style="text-decoration: none">The Mode <code>csv:parse-line</code></a></h5>
                     <p>By default, the mode <code>csv:parse-line</code> parses the current item (this
                     will be one line of the input data) into fields, using mode
                        <code>csv:parse-field</code> on the individual fields and (by default)
                     wrapping the result in a <code>row</code> element.</p>
                     <p>The mode is declared with <code>visibility="public"</code> to allow it to be
                     called from elsewhere and overridden:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:mode name="csv:parse-line" visibility="public"/&gt;</pre>
                     </div>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template match="." mode="csv:parse-line"&gt;
    &lt;row&gt;
        &lt;xsl:apply-templates 
            select="tokenize(., $csv:field-separator)" 
            mode="csv:parse-field" /&gt;
    &lt;/row&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>This relies on the variable <code>csv:field-separator</code>, which is a comma
                     by default but which can be overridden by the user to parse tab-separated data
                     or data with other delimiters.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="csv:field-separator" 
              as="xs:string" 
              select="','" 
              visibility="public"/&gt;</pre>
                     </div>
                     <p>The default implementation of <code>csv:parse-line</code> does not handle
                     occurrences of the field separator occurring within quoted strings. The user
                     can add templates to the mode to provide that functionality. </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-mode"></a>3.4.8.7 <a href="#csv-example-mode" style="text-decoration: none">Mode <code>csv:parse-field</code></a></h5>
                     <p>Mode <code>csv:parse-field</code> processes the current item as a field; by
                     default it strips quotation marks from the value, calls the function
                        <code>csv:preprocess-field()</code> on it, and wraps the result in a
                        <code>field</code> element, which carries the attributes declared in the
                     attribute set <code>csv:field-attributes</code>.</p>
                     <div class="exampleInner">
                        <pre>
&lt;xsl:template match="." 
              mode="csv:parse-field" 
              expand-text="yes"&gt;
    &lt;xsl:variable name="string-body-pattern"
                  as="xs:string"
                  select="'([^' || $csv:validated-quote || ']*)'"/&gt;
    &lt;xsl:variable name="quoted-value"
                  as="xs:string"
                  select="$csv:validated-quote 
                          || $string-body-pattern 
                          || $csv:validated-quote"/&gt;
    &lt;xsl:variable name="unquoted-value"
                  as="xs:string"
                  select="'(.+)'"/&gt;

    &lt;field xsl:use-attribute-sets="csv:field-attributes"&gt;{
        csv:preprocess-field(
          replace(., 
                  $quoted-value || '|' || $unquoted-value, 
                  '$1$2'))
    }&lt;/field&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>The attribute set <code>csv:field-attributes</code> includes, by default, a
                        <code>quoted</code> attribute which has the values <code>yes</code> or
                        <code>no</code> to show whether the input value was quoted or not.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:attribute-set name="csv:field-attributes" 
                   visibility="public"&gt;
    &lt;xsl:attribute name="quoted" 
                   select="if (starts-with(., $csv:validated-quote)) 
                           then 'yes' 
                           else 'no'" /&gt;
&lt;/xsl:attribute-set&gt;</pre>
                     </div>
                     <p>The mode <code>csv:parse-field</code> is declared with
                        <code>visibility="public"</code> to allow it to be called from elsewhere and
                     overridden; it specifies <code>on-no-match="shallow-copy"</code> so that any
                     string not matching a template will simply be copied:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:mode name="csv:parse-field"
          on-no-match="shallow-copy" 
          visibility="public"/&gt;</pre>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-variable"></a>3.4.8.8 <a href="#csv-example-variable" style="text-decoration: none">The <code>csv:quote</code> Variable</a></h5>
                     <p>The variable <code>csv:quote</code> can be used to specify the character used
                     in a particular input stream to quote values.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="csv:quote" 
              as="xs:string" 
              select="'&amp;quot;'" 
              visibility="public"/&gt;</pre>
                     </div>
                     <p>The template given above assumes that the variable is one character long. To
                     ensure that any overriding value of the variable is properly checked, references to the value use a
                     second variable <code>csv:validated-quote</code>, which
                     is declared <code>private</code> to ensure that the checking cannot be
                     disabled.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="csv:validated-quote" visibility="private"
   as="xs:string" select="
       if (string-length($csv:quote) ne 1) 
       then error( #csv:ERR001, 
                  'Incorrect length for $csv:quote, should be 1') 
       else $csv:quote" /&gt;</pre>
                     </div>
                     <p>When the value of <code>csv:quote</code> is not
                     exactly one character long, the reference to
                        <code>csv:validated-quote</code> will cause an error (csv:ERR001)
                     to be raised.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-preprocess-field"></a>3.4.8.9 <a href="#csv-example-preprocess-field" style="text-decoration: none">The <code>csv:preprocess-field</code> Function</a></h5>
                     <p>The function <code>csv:preprocess-field</code> is called on each field after
                     any quotation marks are stripped and before it is written out as the value of a
                        <code>field</code> element:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="csv:preprocess-field" 
              as="xs:string"&gt;
    &lt;xsl:param name="field" 
               as="xs:string" /&gt;
    &lt;xsl:sequence select="$field" /&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>As can be seen, the function does nothing but return its input; its only
                     purpose is to provide the opportunity for the user to supply a suitable
                     function to be invoked at this point in the processing of each field.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-postprocess"></a>3.4.8.10 <a href="#csv-example-postprocess" style="text-decoration: none">The Mode <code>csv:post-process</code></a></h5>
                     <p>The mode <code>csv:post-process</code> is intended solely as a hook for user
                     code. By default, it does nothing.</p>
                     <p>The package defines no templates for this mode; the mode definition makes it
                     return a copy of its input:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:mode name="csv:post-process" 
          on-no-match="shallow-copy" 
          visibility="public"/&gt;</pre>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="csv-example-overriding"></a>3.4.8.11 <a href="#csv-example-overriding" style="text-decoration: none">Overriding the Default Behavior</a></h5>
                     <p>As can be seen from the code shown above, the package provides several
                     opportunities for users to override the default behavior:</p>
                     <ul>
                        <li>
                           <p>The global variables <code>csv:line-separator</code>,
                              <code>csv:field-separator</code>, and <code>csv:quote</code> can be
                           overridden to specify the character strings used to separate lines and
                           fields and to quote individual field values.</p>
                        </li>
                        <li>
                           <p>The function <code>csv:preprocess-line</code> can be overridden to do
                           more (or less) than stripping white space; the function
                              <code>csv:preprocess-field</code> can be overridden to process
                           individual field values.</p>
                        </li>
                        <li>
                           <p>Templates can be added to the modes <code>csv:parse-line</code>,
                              <code>csv:parse-field</code>, and <code>csv:post-process</code> to
                           change their behavior.</p>
                        </li>
                        <li>
                           <p>The attribute set <code>csv:field-attributes</code> can be overridden to
                           specify a different set of attributes (or none) for <code>field</code>
                           elements.</p>
                        </li>
                     </ul>
                     <p>The following using stylesheet illustrates the use of the
                        <a href="#element-override"><code>xsl:override</code></a> element to take advantage of several of these
                     opportunities:</p>
                     <div class="exampleInner">
                        <pre>
&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
   xmlns:xs="http://www.w3.org/2001/XMLSchema"
   xmlns:csv="http://example.com/csv"
   exclude-result-prefixes="xs csv"
   version="3.0"&gt;

   &lt;xsl:output indent="yes" /&gt;

   &lt;xsl:use-package name="http://example.com/csv-parser" 
                    package-version="*"&gt;
       &lt;xsl:override&gt;
           &lt;!-- Change the root element from 'csv' to 'root' --&gt;
           &lt;xsl:template match="csv" mode="csv:post-process"&gt;
               &lt;root&gt;
                   &lt;xsl:apply-templates mode="csv:post-process" /&gt;
               &lt;/root&gt;
           &lt;/xsl:template&gt;

           &lt;!-- add an extra attribute that uses the context item --&gt;
           &lt;xsl:attribute-set name="csv:field-attributes" 
                              use-attribute-sets="xsl:original"&gt;
               &lt;xsl:attribute name="type" 
                              select="if (. castable as xs:decimal) 
                                      then 'numeric' 
                                      else 'string'" /&gt;
           &lt;/xsl:attribute-set&gt;          

           &lt;!-- use semicolon not comma between fields --&gt;
           &lt;xsl:variable name="csv:field-separator" 
                         as="xs:string" select="';'" 
                         visibility="public"/&gt;

           &lt;!-- prevent empty rows from appearing with empty lines --&gt;
           &lt;xsl:function name="csv:preprocess-line" 
                         as="xs:string?" 
                         visibility="public"&gt;
               &lt;xsl:param name="line" as="xs:string" /&gt;
               &lt;xsl:variable name="norm-line" 
                             select="normalize-space(xsl:original($line))" /&gt;
               &lt;xsl:sequence select="if (string-length($norm-line) &gt; 0) 
                                     then $norm-line 
                                     else ()" /&gt;
           &lt;/xsl:function&gt;
       &lt;/xsl:override&gt;
   &lt;/xsl:use-package&gt;

   &lt;!-- example input "file"  --&gt;
   &lt;xsl:variable name="input" as="xs:string"&gt;
       name;id;postal code
       "Braaksma Abel";34291;1210 KA
       "Berglund Anders";473892;9843 ZD
   &lt;/xsl:variable&gt;

   &lt;!-- entry point --&gt;
   &lt;xsl:template name="xsl:initial-template"&gt;
       &lt;xsl:copy-of select="csv:parse($input)" /&gt;
   &lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <ul>
                           <li>
                              <p>As it does elsewhere, the visibility of components declared within
                                 <a href="#element-override"><code>xsl:override</code></a> defaults to <code>private</code>; to keep
                              the component public, it is necessary to specify visibility
                              explicitly.</p>
                           </li>
                           <li>
                              <p>The types and optionality of all function parameters must match those
                              of the function being overridden; for function overriding to be
                              feasible, packages must document the function signature
                              thoroughly.</p>
                           </li>
                           <li>
                              <p>The names, types, and optionality of all named-template parameters
                              must match those of the template being overridden; for overriding to
                              be feasible, packages must document the template signature
                              thoroughly.</p>
                           </li>
                           <li>
                              <p>The values for the attributes in the attribute set
                                 <code>csv:field-attributes</code> are calculated once for each
                              element for which the attribute set is supplied; the
                                 <code>select</code> attributes which determine the values can thus
                              refer to the context item. Here, the value specification for the
                                 <code>type</code> attribute checks to see whether the string value
                              of the context item is numeric by inquiring whether it can be cast to
                              decimal, and sets the value for the <code>type</code> attribute
                              accordingly.</p>
                           </li>
                        </ul>
                     </div>
                     <p>The result returned by this stylesheet would be:</p>
                     <div class="exampleInner">
                        <pre>&lt;root&gt;
  &lt;row&gt;
    &lt;field quoted="no" type="string"&gt;name&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;id&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;postal code&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Braaksma Abel&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;34291&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;1210 KA&lt;/field&gt;
  &lt;/row&gt;
  &lt;row&gt;
    &lt;field quoted="yes" type="string"&gt;Berglund Anders&lt;/field&gt;
    &lt;field quoted="no" type="numeric"&gt;473892&lt;/field&gt;
    &lt;field quoted="no" type="string"&gt;9843 ZD&lt;/field&gt;
  &lt;/row&gt;
&lt;/root&gt;</pre>
                     </div>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="stylesheet-modules"></a>3.5 <a href="#stylesheet-modules" style="text-decoration: none">Stylesheet Modules</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-module" title="stylesheet module"></a>A <a title="package" class="termref" href="#dt-package">package</a> consists of one or
                  more <b>stylesheet modules</b>, each one forming all or part of an XML
                  document.<span class="definition">]</span>
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>A stylesheet module is represented by an XDM element node (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>). In the case of a standard stylesheet module, this
                  will be an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a>
                  element. In the case of a simplified stylesheet module, it can be any element (not
                  in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) that has an
                     <code>xsl:version</code> attribute.</p>
                  <p>Although stylesheet modules will commonly be maintained in the form of documents
                  conforming to XML 1.0 or XML 1.1, this specification does not mandate such a
                  representation. As with <a title="source tree" class="termref" href="#dt-source-tree">source trees</a>, the
                  way in which stylesheet modules are constructed, from textual XML or otherwise, is
                  outside the scope of this specification.</p>
               </div>
               <p>The principal stylesheet module of a package may take one
               of three forms:</p>
               <ul>
                  <li>
                     <p>A package manifest, as described in <a href="#packages"><i>3.4 Packages</i></a>, which is a
                     subtree rooted at an <a href="#element-package"><code>xsl:package</code></a> element</p>
                  </li>
                  <li>
                     <p>An implicit package, which is a subtree rooted at an
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element.
                     This is transformed automatically to a package as described in <a href="#packages"><i>3.4 Packages</i></a>. </p>
                  </li>
                  <li>
                     <p>A simplified stylesheet, which is a subtree rooted at a literal result element,
                     as described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>. This is first converted
                     to an implicit package by wrapping it in an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                     element using the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>, and then to an explicit package (rooted at an
                        <a href="#element-package"><code>xsl:package</code></a> element) using the transformation described in
                        <a href="#packages"><i>3.4 Packages</i></a>. </p>
                  </li>
               </ul>
               <p>A stylesheet module other than the principal stylesheet
               module of a package may take either of two forms:</p>
               <ul>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-stylesheet-module" title="standard stylesheet module"></a>A
                           <b>standard stylesheet module</b>, which is a subtree rooted at an
                           <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a>
                        element.<span class="definition">]</span></p>
                  </li>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-simplified-stylesheet-module" title="simplified stylesheet"></a>A
                           <b>simplified stylesheet</b>, which is a subtree rooted at a
                           <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result
                        element</a>, as described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>.
                        This is first converted to a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> by wrapping it in an xsl:stylesheet
                        element using the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>.<span class="definition">]</span>
                  </p>
                  </li>
               </ul>
               <p>Whichever of the above forms a module takes, the outermost
               element (<a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>) <span class="verb">may</span> either be the outermost
               element of an XML document, or it <span class="verb">may</span> be a child of some
               (non-XSLT) element in a host document. </p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-embedded-stylesheet-module" title="embedded stylesheet module"></a>A stylesheet module whose outermost element is
                  the child of a non-XSLT element in a host document is referred to as an
                     <b>embedded stylesheet module</b>.<span class="definition">]</span>
            </p>
            </div>
            <div class="div2">
               
               <h3><a id="stylesheet-element"></a>3.6 <a href="#stylesheet-element" style="text-decoration: none">Stylesheet Element</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#fixed-namespaces">next</a> | <a href="#package-locations">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  A new attribute, <code>main-module</code>, is added to the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                  element. The attribute is provided for the benefit of development tools such as syntax-directed
                  editors to provide information about all the components (variables, functions, etc) visible
                  within a stylesheet module.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/87">87</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/353">353</a>&nbsp;19 April 2023]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-stylesheet"></a><code>&lt;xsl:stylesheet<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:stylesheet&gt;</code></p>
               <p class="element-syntax"><a id="element-transform"></a><code>&lt;xsl:transform<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:transform&gt;</code></p>
               <p>A stylesheet module is represented by an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element in
               an XML document. <a href="#element-transform"><code>xsl:transform</code></a> is allowed as a synonym for
                  <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>; everything this specification says about the
                  <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element applies equally to
                  <a href="#element-transform"><code>xsl:transform</code></a>.</p>
               <p>The <code>version</code> attribute indicates the version
               of XSLT that the stylesheet module requires. The attribute is
                  <span class="verb">required</span>.</p>
               <p>
               <a id="err-XTSE0110"><span class="error">[ERR XTSE0110] </span></a>The value of the <code>version</code> attribute <span class="verb">must</span> be a number:
                     specifically, it <span class="verb">must</span> be a valid instance of the type
                        <code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.
            </p>
               <p>The <code>version</code> attribute is intended to indicate the
               version of the XSLT specification against which the stylesheet is written. In a
               stylesheet written to use XSLT 4.0, the value <span class="verb">should</span> normally be
               set to <code>4.0</code>. If the value is numerically less than 4.0, the
               stylesheet is processed using the rules for <a title="backwards compatible behavior" class="termref" href="#dt-backwards-compatible-behavior">backwards compatible behavior</a>
               (see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>). If the value is numerically greater than
               <span>4.0</span>, the stylesheet is processed using the rules for 
               <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>).</p>
               <p>The effect of the <code>input-type-annotations</code> attribute is described in
                  <a href="#stripping-annotations"><i>4.2.1 Stripping Type Annotations from a Source Tree</i></a>.</p>
               <p>The <code>[xsl:]default-validation</code> attribute defines the default value of the
                  <code>validation</code> attribute of all relevant instructions appearing within
               its scope. For details of the effect of this attribute, see <a href="#validation"><i>25.4 Validation</i></a>.</p>
               <p>The optional <code>main-module</code> attribute is purely documentary.
            By including this attribute in every <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> of a <a title="package" class="termref" href="#dt-package">package</a>,
            an XSLT editing tool may be enabled to locate the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the relevant package,
            and thus to gather information about all the global variables, templates, and functions available
            within the module being edited.
            This information can be used (for example) to enable auto-completion and error highlighting of the code as it is
            entered. Note that it may be inconvenient or misleading to use this attribute when the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>
            module is used as a shared component within multiple <a title="package" class="termref" href="#dt-package">packages</a>.
          </p>
               <p>
               <a id="err-XTSE0120"><span class="error">[ERR XTSE0120] </span></a>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>,
                  or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any
                     text node children. (This rule applies after stripping of <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> as described in <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>.)</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-top-level" title="top-level"></a>An element occurring as a child of an
                     <a href="#element-package"><code>xsl:package</code></a>,
                     <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>,
                        <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a>
                  element is called a <b>top-level</b> element.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-declaration" title="declaration"></a>Top-level elements fall into two
                  categories: declarations, and user-defined data elements. Top-level elements whose
                  names are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> are
                     <b>declarations</b>. Top-level elements in any other namespace are
                     <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see
                     <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)<span class="definition">]</span>.</p>
               <p>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> elements permitted in the
                  <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element are:</p>
               <blockquote>
                  <p>
                  <a href="#element-accumulator"><code>xsl:accumulator</code></a>
               <br>
                  <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
               <br>
                  <a href="#element-character-map"><code>xsl:character-map</code></a>
               <br>
                  <a href="#element-decimal-format"><code>xsl:decimal-format</code></a>
               <br>
                  <a href="#element-function"><code>xsl:function</code></a>
               <br>
                  <a href="#element-global-context-item"><code>xsl:global-context-item</code></a>
               <br>
                  <a href="#element-import"><code>xsl:import</code></a>
               <br>
                  <a href="#element-import-schema"><code>xsl:import-schema</code></a>
               <br>
                  <a href="#element-include"><code>xsl:include</code></a>
               <br>
                  <a href="#element-item-type"><code>xsl:item-type</code></a>
               <br>
                  <a href="#element-key"><code>xsl:key</code></a>
               <br>                 
                  <a href="#element-mode"><code>xsl:mode</code></a>                 
               <br>
                  <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>
               <br>
                  <a href="#element-output"><code>xsl:output</code></a>
               <br>
                  <a href="#element-param"><code>xsl:param</code></a>
               <br>
                  <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
               <br>
                  <a href="#element-record-type"><code>xsl:record-type</code></a>
               <br>
                  <a href="#element-strip-space"><code>xsl:strip-space</code></a>
               <br>
                  <a href="#element-template"><code>xsl:template</code></a>
               <br>
                  <a href="#element-use-package"><code>xsl:use-package</code></a>
               <br>
                  <a href="#element-variable"><code>xsl:variable</code></a>
               </p>
               </blockquote>
               <p>Note that the <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> elements
               can act either as <a title="declaration" class="termref" href="#dt-declaration">declarations</a> or as <a title="instruction" class="termref" href="#dt-instruction">instructions</a>. A global variable or parameter is
               defined using a declaration; a local variable or parameter using an instruction.</p>
               <p>The child elements of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
               element may appear in any order. In most cases, the ordering of these elements does
               not affect the results of the transformation; however:</p>
               <ul>
                  <li>
                     <p>As described in <a href="#conflict"><i>6.6 Conflict Resolution for Template Rules</i></a>, when two template rules with the
                     same <a title="priority" class="termref" href="#dt-priority">priority</a> match the same nodes, there
                     are situations where the order of the template rules will affect which is
                     chosen.</p>
                  </li>
                  <li>
                     <p>Forwards references to <a title="static variable" class="termref" href="#dt-static-variable">static variables</a> are not allowed in <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>.</p>
                  </li>
               </ul>
               <div class="div3">
                  
                  <h4><a id="fixed-namespaces"></a>3.6.1 <a href="#fixed-namespaces" style="text-decoration: none">The <code>fixed-namespaces</code> Attribute</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#simplified-stylesheet">next</a> | <a href="#stylesheet-element">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     The <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a>
                     element may have a <code>fixed-namespaces</code> attribute making it easier to have the same
                     namespace declarations in force throughout a stylesheet.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/369">369</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/470">470</a>&nbsp;29 November 2023]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>The <code>fixed-namespaces</code> attribute, if present, defines the 
                  <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>
               for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. The attribute may appear only on the
               outermost element of a stylesheet module (<a href="#element-stylesheet"><code>xsl:stylesheet</code></a>,
               <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a>). It is
               not available with <a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module">simplified stylesheet modules</a>.</p>
                  <p>If the <code>fixed-namespaces</code> attribute is present, then it defines the entire
               set of namespace bindings present in the static context of XPath expressions and 
               <a title="pattern" class="termref" href="#dt-pattern">patterns</a> within the stylesheet,
               as well as other constructs where namespace prefixes are used in attribute and text nodes,
               such as the <code>name</code> attribute of declarations like <a href="#element-function"><code>xsl:function</code></a>
               and <a href="#element-variable"><code>xsl:variable</code></a>, and <code>as</code> and <code>type</code> attributes
               referring to item types and schema types.</p>
                  <p>The value of the attribute is a whitespace-separated list of tokens, where each token
                  contributes one or more namespace bindings to the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>
                  of the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. Each token must be one of the following. If
                  a token falls into more than one of these categories, then the first one that applies
                  takes precedence.</p>
                  <ul>
                     <li>
                        <p>The string <code>#standard</code>, which is equivalent to specifying
                  <code>xsl xml xs xsi fn math map array err</code>. This has the effect of binding
                     each of these namespace prefixes to the <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> with which 
                     it is conventionally associated.</p>
                     </li>
                     <li>
                        <p>An <code>NCName</code> corresponding to one of the namespace prefixes present
                    in the in-scope namespaces of the containing element node. This has the effect of adding
                    the corresponding namespace binding to the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>.</p>
                     </li>
                     <li>
                        <p>Any one of the strings <code>xsl</code>, <code>xml</code>,
                     <code>xs</code>, <code>xsi</code>, <code>fn</code>, <code>math</code>,
                     <code>map</code>, <code>array</code>, <code>err</code>. This has the effect of binding
                     that particular namespace prefix to the <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> with which 
                     it is conventionally associated, whether or not the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>
                     contain a binding for this prefix.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>Including <code>xml</code> in the list has no effect, since the XML namespace
                     will always be in scope anyway.</p>
                        </div>
                        <p>If the namespace prefix is explicitly bound to a different namespace, for example
                     <code>xmlns:math="java:java.util.Math"</code>, then that binding takes precedence.</p>
                     </li>
                     <li>
                        <p>A string in the form <code>prefix=uri</code>, where <code>prefix</code> is an <code>NCName</code>
                     and <code>uri</code> is a (non-empty) namespace URI: for example,
                     <code>xalan=http://xml.apache.org/xalan</code>. This has the effect of binding the specified
                     prefix to the specified URI.</p>
                     </li>
                     <li>
                        <p>A <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a> identifying the location of an
                     XML document whose namespace bindings are to be used. For example, <code>./package.xsl</code>.
                     A token is interpreted as a URI if it does not match any of the other possibilities listed above
                     (which will be the case if it contains a <code>"/"</code> as in this example).</p>
                        <p>The <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a> is used to locate an XML document, in the same way
                     as described for <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> in
                     <a href="#locating-modules"><i>3.10.1 Locating Stylesheet Modules</i></a>. The resource that is retrieved may be any namespace well-formed 
                     XML document. The in-scope namespace bindings of the outermost element of this document are
                     added to the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> of the stylesheet module.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>Such URIs cannot contain whitespace.</p>
                        </div>
                     </li>
                  </ul>
                  <p>If different tokens in the <code>fixed-namespaces</code> attribute result in multiple bindings
               for the same namespace prefix, the last one wins.</p>
                  <p>
                  <a id="err-XTSE0122"><span class="error">[ERR XTSE0122] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token
                        appearing in the <code>fixed-namespaces</code> attribute takes a form
                        that is not one of the permitted forms, or if it is interpreted as a URI
                     but cannot be dereferenced to locate a namespace well-formed XML document.
                     It is not permitted to bind the prefix <code>xmlns</code>. It is not permitted to bind the
                        prefix <code>xml</code> or the XML namespace URI <code>http://www.w3.org/XML/1998/namespace</code>, other than
                     to each other.
               </p>
                  <p>The following observations apply when a <code>fixed-namespaces</code> attribute is present:</p>
                  <ul>
                     <li>
                        <p>All expressions in the stylesheet module will have the same 
                     <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-namespaces">statically known
                        namespaces</a><sup><small>XP</small></sup> in their static context. This means that all 
                     prefixes used in XPath expressions, patterns,
                  and similar constructs must be declared at the top level.</p>
                     </li>
                     <li>
                        <p>Namespace prefixes used in element and attribute names in the stylesheet
                  cannot be declared using this mechanism. Such prefixes must be bound using
                  <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>. This also applies to namespace
                  prefixes used in the <code>[xsl:]exclude-result-prefixes</code> 
                     and <code>[xsl:]extension-element-prefixes</code> attributes, and the
                  <code>stylesheet-prefix</code> and <code>result-prefix</code> attributes
                  of <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>.</p>
                     </li>
                     <li>
                        <p>It is not an error for an element within a stylesheet module
                     to rebind a prefix listed in the <code>fixed-namespaces</code> attribute 
                     to a different URI; however this rebinding has no effect on the static
                  context of XPath expressions and other similar constructs within its scope.</p>
                     </li>
                     <li>
                        <p>The <code>fixed-namespaces</code> attribute has no effect on the interpretation
                  of unprefixed names.</p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>It is possible to use
                     the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> in other attributes of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                  element, such as <code>default-mode</code>. It is also possible to use them in
                  shadow attributes (see <a href="#shadow-attributes"><i>3.11.4 Shadow Attributes</i></a>).</p>
                     <p>It is possible for the <code>fixed-namespaces</code> attribute itself to be supplied as
                  a shadow attribute (written with an underscore, <code>_fixed-namespaces</code>). 
                  It can then refer to <a title="static variable" class="termref" href="#dt-static-variable">static variables</a>
                  declared in an importing or including <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. This provides an
                  alternative way of sharing common namespace bindings throughout a <a title="package" class="termref" href="#dt-package">package</a>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The ability to fetch namespace bindings using a URI can be exploited in various ways:</p>
                     <ul>
                        <li>
                           <p>Generally, the benefit is that it avoids repeating the same information
                     in every stylesheet module, thereby reducing the amount of boilerplate code and keeping
                     common information in a common place. This satisfies the <b>DRY</b> principle in software
                     engineering: <em>Don't Repeat Yourself</em>.</p>
                        </li>
                        <li>
                           <p>The document identified by the URI may be a stylesheet module.
                     One way to use the feature is to use the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>
                     as the primary source for namespace bindings.</p>
                        </li>
                        <li>
                           <p>It is also possible to adopt the namespace bindings from a sample source
                     document. For example, if it is known that the stylesheet is designed primarily to process
                     documents whose first start tag takes the form:</p>
                           <div class="exampleInner">
                              <pre>&lt;w:document
  xmlns:wps="http://schemas.microsoft.com/office/word/2010/wordprocessingShape"
  xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
  xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main"&gt;</pre>
                           </div>
                           <p>then these three namespace bindings may conveniently be copied to the stylesheet
                     by referencing a sample document of this form.</p>
                           <p>Note however, that only the namespace bindings from the outermost element of
                     the document will be copied.</p>
                        </li>
                        <li>
                           <p>It is possible to supply multiple URIs to assemble namespace bindings
                     from more than one source.</p>
                        </li>
                        <li>
                           <p>Namespace bindings taken from an external document may be overridden
                        using a local declaration for the prefix. This must appear after the URI
                     in the content of the <code>fixed-namespaces</code> attribute.</p>
                        </li>
                     </ul>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Using the <code>fixed-namespaces</code> attribute rather 
                     than <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>
                  to bind namespaces has a number of potential benefits:</p>
                     <ul>
                        <li>
                           <p>It reduces repetitive coding across stylesheet module boundaries,
                     and thus eliminates a source of potential errors.</p>
                        </li>
                        <li>
                           <p>It ensures that all expressions in a stylesheet module have the same
                     namespace bindings in their static context. This can reduce implementation overheads
                     because it reduces the need to maintain the namespace context at the level of individual
                     expressions through rewrites such as function inlining. With processors that compile
                     stylesheets to a persistent executable form, it can contribute to a reduction in 
                     the size of compiled code.</p>
                        </li>
                        <li>
                           <p>Namespaces bound in this way will never accidentally leak into a result tree;
                     there is no need to exclude them using <code>[xsl:]exclude-result-prefixes</code>.</p>
                        </li>
                        <li>
                           <p>Namespaces declared on literal result elements are used purely to define the
                     namespace of elements and attributes within the result tree; they no longer leak into
                     the static context used when evaluating XPath expressions.</p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="default-collation-attribute"></a>3.6.2 <a href="#default-collation-attribute" style="text-decoration: none">The <code>default-collation</code> Attribute</a></h4>
                  <p>The <code>default-collation</code> attribute is a <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attribute</a> that may appear on
                  any element in the XSLT namespace, or (as <code>xsl:default-collation</code>) on a
                     <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p>
                  <p>The attribute, when it appears on an element
                        <var>E</var>, is used to specify the default collation used by all XPath
                     expressions appearing in attributes or <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a> that have <var>E</var> as an
                     ancestor, unless overridden by another <code>default-collation</code>
                  attribute on an inner element. It also determines the collation used by certain
                  XSLT constructs (such as <a href="#element-key"><code>xsl:key</code></a> and
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>) within its scope.</p>
                  <p>The value of the attribute is a whitespace-separated list of collation URIs. If
                  any of these URIs is a relative URI reference,
                  then it is resolved <span>as described in 
                     <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#collations">5.3.1 Collations</a>.</span>. If the implementation recognizes one or more of the resulting absolute
                  collation URIs, then it uses the first one that it recognizes as the default
                  collation.</p>
                  <p>
                  <a id="err-XTSE0125"><span class="error">[ERR XTSE0125] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value
                        of an <code>[xsl:]default-collation</code> attribute, after resolving
                        against the base URI, contains no URI that the implementation recognizes as
                        a collation URI.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The reason the attribute allows a list of collation URIs is that collation URIs
                     will often be meaningful only to one particular XSLT implementation.
                     Stylesheets designed to run with several different implementations can
                     therefore specify several different collation URIs, one for use with each. To
                     avoid the above error condition, it is possible to include as the last
                     collation URI in the list either the Unicode Codepoint Collation or a collation in the UCA family (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#uca-collations">5.3.4 The Unicode Collation Algorithm</a>) with the parameter
                        <code>fallback=yes</code>.</p>
                  </div>
                  <p>The <code>[xsl:]default-collation</code> attribute does not affect the collation
                  used by <a href="#element-sort"><code>xsl:sort</code></a> or by <a href="#element-merge"><code>xsl:merge</code></a>.</p>
                  <p>In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <span class="verb">may</span> be set by the calling application in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. The recommended default, unless the user
                  chooses otherwise, is to use the Unicode codepoint collation.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="default-mode"></a>3.6.3 <a href="#default-mode" style="text-decoration: none">The <code>default-mode</code> Attribute</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-default-mode" title="default mode"></a>The 
                  <code>[xsl:]default-mode</code> attribute defines the <b>default mode</b>,
                  which is used as the default value for the
                     <a title="mode" class="termref" href="#dt-mode">mode</a> attribute of all
                     <a href="#element-template"><code>xsl:template</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements
                     within its scope.<span class="definition">]</span></p>
                  <p>More specifically, when an element <var>E</var> matches
                  the pattern <code>(xsl:template[@match] | xsl:apply-templates)[not(@mode) or
                     normalize-space(@mode) eq "#default"]</code> (using the Unicode codepoint
                  collation), then the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>mode</code> attribute is taken
                  from the value of the <code>[xsl:]default-mode</code> attribute of the innermost
                  ancestor-or-self element of <var>E</var> that has such an attribute. If there is
                  no such element, then the default is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
                     mode</a>. This is equivalent to specifying <code>#unnamed</code>.</p>
                  <p>In addition, when the attribute appears on the <a href="#element-package"><code>xsl:package</code></a>,
                  <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or <a href="#element-transform"><code>xsl:transform</code></a> element of the 
                  <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a> of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>,
                     it provides a default value for the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> used on stylesheet
                     invocation.</p>
                  <p>The value of the <code>[xsl:]default-mode</code> attribute <span class="verb">must</span>
                  either be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or the token <code>#unnamed</code> which refers to
                  the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This attribute is provided to support an approach to stylesheet modularity in
                     which all the template rules for one <a title="mode" class="termref" href="#dt-mode">mode</a> are
                     collected together into a single <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet
                        module</a>. Using this attribute reduces the risk of forgetting to
                     specify the mode in one or more places where it is needed, and it also makes it
                     easier to reuse an existing stylesheet module that does not use modes in an
                     application where modes are needed to avoid conflicts with existing template
                     rules.</p>
                     <p>It is not necessary for the referenced mode to be
                     explicitly declared in an <a href="#element-mode"><code>xsl:mode</code></a> declaration, unless this is
                     mandated by the <code>declared-modes</code> attribute (which defaults to
                        <code>yes</code> on an <a href="#element-package"><code>xsl:package</code></a> element).</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="user-defined-top-level"></a>3.6.4 <a href="#user-defined-top-level" style="text-decoration: none">User-defined Data Elements</a></h4>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-data-element" title="user-defined data element"></a>In addition to
                        <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, the
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain among its children any
                     element not from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>,
                     provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of
                     the element has a non-null namespace URI. Such elements are referred to as
                        <b>user-defined data elements</b>.<span class="definition">]</span>
               </p>
                  <p>
                  <a id="err-XTSE0130"><span class="error">[ERR XTSE0130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>,
                           or <a href="#element-package"><code>xsl:package</code></a> element has a child element whose name
                        has a null namespace URI.
               </p>
                  <p>An implementation <span class="verb">may</span> attach an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> meaning to user-defined data elements that
                  appear in particular namespaces. The set of namespaces that are recognized for
                  such data elements is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The presence of a user-defined data element
                     <span class="verb">must not</span> change the behavior of <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a> and functions defined in this
                  document; for example, it is not permitted for a user-defined data element to
                  specify that <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> should use different rules to
                  resolve conflicts. The constraints on what user-defined data elements can and
                  cannot do are exactly the same as the constraints on <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>, described in
                     <a href="#extension-attributes"><i>24.1 Extension Attributes</i></a>. Thus, an implementation is always free
                  to ignore user-defined data elements, and <span class="verb">must</span> ignore such data
                  elements without giving an error if it does not recognize the namespace URI. </p>
                  <p>User-defined data elements can provide, for example,</p>
                  <ul>
                     <li>
                        <p>information used by <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension
                           instructions</a> or <a title="extension function" class="termref" href="#dt-extension-function">extension
                           functions</a> (see <a href="#extension"><i>24 Extensibility and Fallback</i></a>),</p>
                     </li>
                     <li>
                        <p>information about what to do with any <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>,</p>
                     </li>
                     <li>
                        <p>information about how to construct <a title="source tree" class="termref" href="#dt-source-tree">source
                           trees</a>,</p>
                     </li>
                     <li>
                        <p>optimization hints for the <a title="processor" class="termref" href="#dt-processor">processor</a>,</p>
                     </li>
                     <li>
                        <p>metadata about the stylesheet,</p>
                     </li>
                     <li>
                        <p>structured documentation for the stylesheet.</p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="simplified-stylesheet"></a>3.7 <a href="#simplified-stylesheet" style="text-decoration: none">Simplified Stylesheet Modules</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#include">next</a> | <a href="#fixed-namespaces">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  Simplified stylesheets no longer require an <code>xsl:version</code> attribute
                  (which means they might not need a declaration of the XSLT namespace). Unless otherwise
                  specified, a 4.0 simplified stylesheet defaults <code>expand-text</code> to <code>true</code>.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/90">90</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/599">599</a>&nbsp;12 September 2023]</i></p>
                     </li>
                     <li>
                        <p>
                  The outermost element of a simplified stylesheet need no longer be a literal result element,
                  it can now be any instruction (including <a href="#element-result-document"><code>xsl:result-document</code></a>). This allows a
                  simplified stylesheet to produce JSON output as well as XML or HTML.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2322">2322</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2323">2323</a>&nbsp;30 November 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>A simplified syntax is allowed for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet
               module</a> that defines only a single template rule.
               A simplified stylesheet module consist of a single <a title="instruction" class="termref" href="#dt-instruction">instruction</a> or
               <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>
               together with its contents. Such a stylesheet module is equivalent to a standard stylesheet module
               whose <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element contains a 
               <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> containing the instruction or literal result
               element; the template rule has a match <a title="pattern" class="termref" href="#dt-pattern">pattern</a> of <code>match="."</code>,
               which matches any item.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e10437"></a>Example: A Simplified Stylesheet</div>
                  <p>The following example shows a stylesheet that simply evaluates one XPath expression:</p>
                  <div class="exampleInner">
                     <pre>&lt;out&gt;{count(//*)}&lt;/out&gt;</pre>
                  </div>
                  <p>The output of the stylesheet will be an XML document such as <code>&lt;out&gt;17&lt;/out&gt;</code>
                  showing the number of elements found in the supplied source document.</p>
                  <p>This simplified stylesheet is defined to be equivalent to the following expanded stylesheet:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:stylesheet xmlns="http://www.w3.org/1999/XSL/Transform"
                  version="4.0" expand-text="yes"&gt;
    &lt;xsl:template match="."&gt;
        &lt;out&gt;{count(//*)}&lt;/out&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
                  </div>
                  <p>Because the stylesheet contains no elements or attributes in the XSLT namespace, it does
               not need to contain any namespace declarations.</p>
               </div>
               <p>A simplified stylesheet can contain XSLT instructions, in which case the XSLT namespace needs
               to be declared. This is illustrated in the next example.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e10452"></a>Example: A Simplified Stylesheet Containing XSLT Instructions</div>
                  <p>This stylesheet outputs an HTML document containing a table that summarizes the value
                  of transactions according to their rate of tax:</p>
                  <div class="exampleInner">
                     <pre>&lt;html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
      xsl:version="4.0"&gt;
  &lt;head&gt;
    &lt;title&gt;Expenditure by Tax Rate&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;table&gt;
      &lt;thead&gt;
        &lt;tr&gt;
           &lt;th&gt;Gross Amount&lt;/th&gt;
           &lt;th&gt;Tax Rate&lt;/th&gt;
        &lt;/tr&gt;
      &lt;/thead&gt;
      &lt;tbody&gt;
        &lt;xsl:for-each-group select="//transaction" group-by="vat-rate"&gt;
          &lt;tr&gt;
            &lt;td&gt;{sum(current-group()/value)}&lt;/td&gt;
            &lt;td&gt;{current-grouping-key()}&lt;/td&gt;
          &lt;/tr&gt;
        &lt;/xsl:for-each-group&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e10457"></a>Example: A Simplified Stylesheet to Transform JSON</div>
                  <p>This example expects as input a parsed JSON document containing an array of records. It outputs a serialized
               JSON document containing a selection of fields from these records.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:result-document method="json" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:array&gt;
    &lt;xsl:for-each select="?*"&gt;
      &lt;xsl:record first="?firstName" 
                  last="?surname"
                  phone="?mobile"/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:array&gt;
&lt;/xsl:result-document&gt;</pre>
                  </div>
               </div>
               <p>More formally, a simplified stylesheet module is equivalent to the standard
               stylesheet module that would be generated by applying the following transformation to
               the simplified stylesheet module, invoking the transformation by calling the <a title="named template" class="termref" href="#dt-named-template">named template</a>
               <code>expand</code>, with the outermost element as the <a title="context node" class="termref" href="#dt-context-node">context node</a>: </p>
               <div class="exampleInner">
                  <pre>&lt;xsl:stylesheet version="4.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&amp;gt;

&lt;xsl:template name="expand"&gt;
  &lt;xsl:element name="xsl:stylesheet"&gt;
    &lt;xsl:variable name="version"
        select="(if (self::xsl:*) then @version else @xsl:version)
                   otherwise '4.0'"/&gt;
    &lt;xsl:attribute name="version" select="$version"/&gt;
    &lt;xsl:attribute name="expand-text" 
                   select="not(number($version) le 3.0)"/&gt;
    &lt;xsl:element name="xsl:template"&gt;
      &lt;xsl:attribute name="match" select="'.'"/&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:element&gt;
  &lt;/xsl:element&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
               </div>
               <p>The allowed content of an instruction or literal result element when used as a simplified stylesheet
               is the same as when it occurs within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. Thus, 
               a simplified stylesheet cannot contain <a title="declaration" class="termref" href="#dt-declaration">declarations</a>. In particular, simplified stylesheets therefore
               cannot use <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>, 
               <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, 
               <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, 
               <a title="key" class="termref" href="#dt-key">keys</a>, <a title="attribute set" class="termref" href="#dt-attribute-set">attribute-sets</a>, or
               <a title="output definition" class="termref" href="#dt-output-definition">output definitions</a>. Furthermore, they
               cannot contain <a href="#element-include"><code>xsl:include</code></a>, <a href="#element-import"><code>xsl:import</code></a>, or <a href="#element-use-package"><code>xsl:use-package</code></a>
               declarations.</p>
               <p>The only useful way to initiate the transformation is to supply an item
               as the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, to be matched by the implicit
               <code>match="."</code> template rule using the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>There are several significant changes to simplified stylesheets in XSLT 4.0.</p>
                  <ol class="enumar">
                     <li>
                        <p>It is no longer required to include an <code>xsl:version</code> attribute; this
                     in turn means it is often no longer necessary to declare the <code>xsl</code> namespace.
                     The <code>xsl:version</code> attribute defaults to the version of the XSLT processor,
                     that is, "4.0" for an XSLT 4.0 processor.</p>
                     </li>
                     <li>
                        <p>If the <code>xsl:version</code> attribute is omitted, or is set to "4.0" or a larger
                     value, then the <code>expand-text</code> attribute defaults to <code>true</code>, meaning that 
                     <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a> are recognized.</p>
                     </li>
                     <li>
                        <p>The outermost element of a simplified stylesheet can be any instruction (for example,
                  <code>xsl:array</code>, <code>xsl:map</code>, or <code>xsl:result-document</code>), allowing the
                  stylesheet to deliver arrays, maps, or serialized JSON.</p>
                     </li>
                     <li>
                        <p>The match pattern of the implicit template rule uses <code>match="."</code> rather
                  than <code>match="/"</code>, allowing the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> to be
                  any item, not only a document node.</p>
                        <p>There may be edge cases where this causes a backwards incompatibility. For example,
                     if a transformation using a simplified stylesheet is invoked supplying an element node
                     (rather than a document node) as the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>,
                     then under 4.0 this will match the implicitly-defined template rule (<code>match="."</code>
                     matches an element node), whereas in 3.0 it would have been processed using the built-in
                     template rules for the unnamed mode. A similar situation arises if a simplified stylesheet
                     module is imported into a larger stylesheet package, and the implicitly-defined template
                     rule is invoked using <a href="#element-next-match"><code>xsl:next-match</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>.</p>
                     </li>
                  </ol>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>It is technically valid for the outermost element to be <a href="#element-variable"><code>xsl:variable</code></a> or
               <a href="#element-param"><code>xsl:param</code></a>, because these are defined as <a title="" class="termref" href="#">instructions</a>;
               however, this achieves no useful purpose because the result of these instructions is the empty sequence.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="backwards"></a>3.8 <a href="#backwards" style="text-decoration: none">Backwards Compatible Processing</a></h3>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-effective-version" title="effective version"></a>The <b>effective
                     version</b> of an element in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> is the decimal value of the <code>[xsl:]version</code> attribute
                  (see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>) on that element or on the innermost
                  ancestor element that has such an attribute, <span>subject
                  to special rules for the <a href="#element-output"><code>xsl:output</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a>
                     elements.</span><span class="definition">]</span></p>
               <p>These rules do not apply to the <a href="#element-output"><code>xsl:output</code></a> element, whose
               <code>version</code> attribute has an entirely different purpose: it is used to
               define the version of the output method to be used for serialization.
               The <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of an <a href="#element-output"><code>xsl:output</code></a> element
            is the effective version of its parent element.</p>
               <p>There are additional rules for an <a href="#element-fallback"><code>xsl:fallback</code></a> element: see
            <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-backwards-compatible-behavior" title="backwards compatible behavior"></a>An element is 
                  processed with <b>backwards compatible behavior</b> if its
                     <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is less than
                  <span>4.0</span>.<span class="definition">]</span>
            </p>
               <p>Specifically:</p>
               <ul>
                  <li>
                     <p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal
                     to 1.0, then the element is processed with XSLT 1.0 behavior as described in
                        <a href="#backwards-1.0"><i>3.8.1 XSLT 1.0 Compatibility Mode</i></a>.</p>
                  </li>
                  <li>
                     <p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal
                     to 2.0, then the element is processed with XSLT 2.0 behavior as described in
                        <a href="#backwards-2.0"><i>3.8.2 XSLT 2.0 Compatibility Mode</i></a>.</p>
                  </li>
                  <li>
                     <p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal
                     to 3.0, then the element is processed with XSLT 3.0 behavior as described in
                     <a href="#backwards-3.0"><i>3.8.3 XSLT 3.0 Compatibility Mode</i></a>.</p>
                  </li>
                  <li>
                     <p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is any
                     other value less than <span>4.0</span>, 
                     the <span class="verb">recommended</span> action is to
                     raise a static error; however, processors <span class="verb">may</span> recognize
                     such values and process the element in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>XSLT 1.0 allowed the <code>version</code> attribute to take any decimal
                        value, and invoked forwards compatible processing for any value other than
                        1.0. XSLT 2.0 allowed the attribute to take any decimal value, and invoked
                        backwards compatible (i.e. 1.0-compatible) processing for any value less
                        than 2.0. Some stylesheets may therefore be encountered that use values
                        other than 1.0 or 2.0. In particular, the value 1.1 is sometimes
                        encountered, as it was used at one stage in a draft language proposal.</p>
                     </div>
                  </li>
               </ul>
               <p>It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether a particular XSLT 4.0
               implementation supports backwards compatible behavior for any XSLT version earlier
               than XSLT 4.0.</p>
               <p>
               <a id="err-XTDE0160"><span class="error">[ERR XTDE0160] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if an element has
                     an <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of
                     <var>V</var> (with <var>V</var> &lt; <span>4.0</span>) when the implementation does not
                     support backwards compatible behavior for XSLT version <var>V</var>.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>By making use of backwards compatible behavior, it is possible to write the
                  stylesheet in a way that ensures that its results when processed with an XSLT 4.0
                  processor are identical to the effects of processing the same stylesheet using
                     a processor for an earlier version of XSLT.
                  To assist with transition, some parts of a stylesheet may be processed with
                  backwards compatible behavior enabled, and other parts with this behavior
                  disabled.</p>
                  <p>All data values manipulated by an XSLT 4.0
                  processor are defined by the XDM data model, whether or not the relevant
                  expressions use backwards compatible behavior. Because the same data model is used
                  in both cases, expressions are fully composable. The result of evaluating
                  instructions or expressions with backwards compatible behavior is fully defined in
                  the XSLT 4.0 and XPath 4.0 specifications, it is not defined by reference to earlier versions of the XSLT and XPath
                     specifications. </p>
                  <p>To write a stylesheet that makes use of features that
                     are new in version <var>N</var>, while also working with a processor that only
                     supports XSLT version <var>M</var> (<var>M</var> &lt; <var>N</var>),
                  it is necessary to understand both the rules for backwards compatible behavior in
                     XSLT version <var>N</var>, and the rules for
                  forwards compatible behavior in XSLT version
                        <var>M</var>. If the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element
                  specifies <span>a <code>version</code> attribute with a value greater than 1.0</span>, then an XSLT 1.0
                  processor will ignore 
                  <a title="declaration" class="termref" href="#dt-declaration">declarations</a> that were not defined in XSLT
                  1.0, for example <a href="#element-function"><code>xsl:function</code></a>,
                     <a href="#element-import-schema"><code>xsl:import-schema</code></a><span>, 
                        and <a href="#element-mode"><code>xsl:mode</code></a></span>. If any new XSLT
                  <span>4.0 instructions are used (for example <a href="#element-switch"><code>xsl:switch</code></a>
                     or <a href="#element-array"><code>xsl:array</code></a>)</span>, or if new XPath
                  <span>4.0 features are used (for example, keyword arguments in function calls)</span>, 
                     then the stylesheet must provide
                  fallback behavior that relies only on facilities available in the earliest XSLT version supported. The fallback
                  behavior can be invoked by using the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction, or
                  by testing the results of the <a href="#func-function-available"><code>function-available</code></a> or
                     <a href="#func-element-available"><code>element-available</code></a> functions, or by testing the value of
                  the <code>xsl:version</code> property returned by the
                     <a href="#func-system-property"><code>system-property</code></a> function.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="backwards-1.0"></a>3.8.1 <a href="#backwards-1.0" style="text-decoration: none">XSLT 1.0 Compatibility Mode</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-10-behavior" title="XSLT 1.0 behavior"></a>An element in the
                     stylesheet is processed with <b>XSLT 1.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to
                     1.0.<span class="definition">]</span></p>
                  <p>In this mode, if any attribute contains an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>, then the expression is evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
                     <code>true</code>. For details of this mode, see <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. Expressions contained in
                        <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a> are
                     always evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0
                        compatibility mode</a> set to <code>false</code>, since this construct
                     was not available in XSLT 1.0.</p>
                  <p>Furthermore, in such an expression any function call for which no implementation
                  is available (unless it uses the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>) is bound to a fallback error function
                  whose effect when evaluated is to raise a dynamic error <span class="error">[see <a href="#err-XTDE1425">ERR XTDE1425</a>]</span> . The effect is that with backwards compatible
                  behavior enabled, calls on <a title="extension function" class="termref" href="#dt-extension-function">extension
                     functions</a> that are not available in a particular implementation do
                  not cause an error unless the function call is actually evaluated. For further
                  details, see <a href="#extension-functions"><i>24.2 Extension Functions</i></a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This might appear to contradict the specification of XPath 3.0, which states that a static error [XPST0017] is raised
                     when an expression contains a call to a function that is not present (with
                     matching name and arity) in the static context. This apparent contradiction is
                     resolved by specifying that the XSLT processor constructs a static context for
                     the expression in which every possible function name and arity (other than
                     names in the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function
                        namespace</a>) is present; when no other implementation of the
                     function is available, the function call is bound to a fallback error function
                     whose run-time effect is to raise a dynamic error.</p>
                  </div>
                  <p>Certain XSLT constructs also produce different results when XSLT 1.0 compatibility
                  mode is enabled. This is described separately for each such construct.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="backwards-2.0"></a>3.8.2 <a href="#backwards-2.0" style="text-decoration: none">XSLT 2.0 Compatibility Mode</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-20-behavior" title="XSLT 2.0 behavior"></a>An element is processed
                     with <b>XSLT 2.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 2.0.<span class="definition">]</span></p>
                  <p>In this specification, no differences are defined for XSLT 2.0 behavior. An XSLT
                  <span>4.0</span> processor will therefore 
                  produce the same results whether the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of an element is set to
                  2.0 or <span>4.0</span>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>An XSLT 2.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                        <a href="#element-switch"><code>xsl:switch</code></a> instruction with an
                     <a href="#element-fallback"><code>xsl:fallback</code></a> child, an XSLT <span>4.0</span> processor will process the
                        <a href="#element-switch"><code>xsl:switch</code></a> instruction regardless whether the effective
                     version is 2.0, 3.0, <span>or 4.0</span>, while an 
                     XSLT 2.0 processor will raise a static error
                     if the effective version is 2.0, and will take the fallback action if the
                     effective version is 3.0 or 4.0.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="backwards-3.0"></a>3.8.3 <a href="#backwards-3.0" style="text-decoration: none">XSLT 3.0 Compatibility Mode</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-xslt-30-behavior" title="XSLT 3.0 behavior"></a>An element is processed
                  with <b>XSLT 3.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> 
                  is equal to 3.0.<span class="definition">]</span></p>
                  <p>In this specification, no differences are defined for XSLT 3.0 behavior. An XSLT
                  <span>4.0</span> processor will therefore 
                  produce the same results whether the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of an element is set to
                  3.0 or <span>4.0</span>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>An XSLT 3.0 processor, by contrast, will in some cases produce different
                     results in the two cases. For example, if the stylesheet contains an
                     <a href="#element-switch"><code>xsl:switch</code></a> instruction with an
                     <a href="#element-fallback"><code>xsl:fallback</code></a> child, an XSLT <span>4.0</span> processor will process the
                     <a href="#element-switch"><code>xsl:switch</code></a> instruction regardless whether the effective
                     version is 2.0, 3.0, <span>or 4.0</span>, while an 
                     XSLT 3.0 processor will raise a static error
                     if the effective version is 2.0 or 3.0, and will take the fallback action if the
                     effective version is 4.0.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="forwards"></a>3.9 <a href="#forwards" style="text-decoration: none">Forwards Compatible Processing</a></h3>
               <p>The intent of forwards compatible behavior is to make it possible to write a
               stylesheet that takes advantage of features introduced in some version of XSLT
               subsequent to XSLT 4.0, while retaining the
               ability to execute the stylesheet with an XSLT 4.0
               processor using appropriate fallback behavior.</p>
               <p>It is always possible to write conditional code to run under different XSLT versions
               by using the <code>use-when</code> feature described in <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>. 
               The rules for forwards compatible behavior
               supplement this mechanism in two ways:</p>
               <ul>
                  <li>
                     <p>Certain constructs in the stylesheet that mean nothing to an XSLT 4.0 processor are ignored, 
                     rather than being treated as errors.</p>
                  </li>
                  <li>
                     <p>Explicit fallback behavior can be defined for instructions defined in a future
                     XSLT release, using the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction.</p>
                  </li>
               </ul>
               <p>The detailed rules follow.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-forwards-compatible-behavior" title="forwards compatible behavior"></a>An
                  element is processed with <b>forwards compatible behavior</b> if its
                     <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is greater than
                     <span>4.0</span>.<span class="definition">]</span>
            </p>
               <p>These rules do not apply to the <code>version</code> attribute of the
                  <a href="#element-output"><code>xsl:output</code></a> element, which has an entirely different purpose: it
               is used to define the version of the output method to be used for serialization.</p>
               <p>When an element is processed with forwards compatible behavior:</p>
               <ul>
                  <li>
                     <p>If the element is in the XSLT namespace and appears as a child of the
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, and XSLT 4.0 does not allow the element 
                        to appear as a child of the
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, then the element and its content
                        <span class="verb">must</span> be ignored.</p>
                  </li>
                  <li>
                     <p>If the element has an attribute that XSLT 4.0 does not allow the element to have, then the attribute
                        <span class="verb">must</span> be ignored.</p>
                  </li>
                  <li>
                     <p>If the element is in the XSLT namespace and appears as a child of an element 
                     whose content model requires a
                     <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and XSLT
                     <span>4.0</span> does not allow such elements to
                     appear as part of a sequence constructor, then:</p>
                     <ol class="enumar">
                        <li>
                           <p>If the element has one or more <a href="#element-fallback"><code>xsl:fallback</code></a> children,
                           then no error is raised either statically or dynamically, and the
                           result of evaluating the instruction is the concatenation of the
                           sequences formed by evaluating the sequence constructors within its
                              <a href="#element-fallback"><code>xsl:fallback</code></a> children, in document order. Siblings of
                           the <a href="#element-fallback"><code>xsl:fallback</code></a> elements are ignored, even if they are
                           valid XSLT 4.0 instructions.</p>
                        </li>
                        <li>
                           <p>If the element has no <a href="#element-fallback"><code>xsl:fallback</code></a> children, then a
                           static error is raised in the same way as if forwards compatible
                           behavior were not enabled.</p>
                        </li>
                     </ol>
                  </li>
               </ul>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e11005"></a>Example: Forwards Compatible Behavior</div>
                  <p>For example, an XSLT 4.0
                  <a title="processor" class="termref" href="#dt-processor">processor</a> will process the following
                  stylesheet without error, although the stylesheet includes elements from the
                     <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> that are not defined
                  in this specification:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:stylesheet version="17.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:template match="/"&gt;
    &lt;xsl:exciting-new-17.0-feature&gt;
      &lt;xsl:fly-to-the-moon/&gt;
      &lt;xsl:fallback&gt;
        &lt;html&gt;
          &lt;head&gt;
            &lt;title&gt;XSLT 17.0 required&lt;/title&gt;
          &lt;/head&gt;
          &lt;body&gt;
            &lt;p&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/p&gt;
          &lt;/body&gt;
        &lt;/html&gt;
      &lt;/xsl:fallback&gt;
    &lt;/xsl:exciting-new-17.0-feature&gt;
  &lt;/xsl:template&gt;
&lt;/xsl:stylesheet&gt;</pre>
                  </div>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>If a stylesheet depends crucially on a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> 
                  introduced by a version of XSLT after <span>4.0</span>, then the stylesheet can use an
                     <a href="#element-message"><code>xsl:message</code></a> element with <code>terminate="yes"</code> (see
                     <a href="#message"><i>23.1 Messages</i></a>) to ensure that implementations that conform to an
                  earlier version of XSLT will not silently ignore the <a title="declaration" class="termref" href="#dt-declaration">declaration</a>.</p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e11038"></a>Example: Testing the XSLT Version</div>
                  <p>For example,</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:stylesheet version="18.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

  &lt;xsl:important-new-17.0-declaration/&gt;

  &lt;xsl:template match="/"&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="number(system-property('xsl:version')) lt 17.0"&gt;
        &lt;xsl:message terminate="yes"&gt;
          &lt;xsl:text&gt;Sorry, this stylesheet requires XSLT 17.0.&lt;/xsl:text&gt;
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        ...
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:template&gt;
  ...
&lt;/xsl:stylesheet&gt;</pre>
                  </div>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The XSLT 1.0 and XSLT 2.0 specifications did not anticipate the
                  introduction of the <a href="#element-package"><code>xsl:package</code></a> element. An XSLT 1.0 or 2.0
                  processor encountering this element will raise a static error, regardless of the
                     <code>version</code> setting.</p>
                  <p>This problem can be circumvented by using the simplified package
                  syntax (whereby an
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is implicitly treated as
                        <a href="#element-package"><code>xsl:package</code></a>), or by writing the stylesheet code in
                  a separate module from the package manifest, and using the separate module as the
                  version of the stylesheet that is presented to a 2.0 processor.</p>
               </div>
               <p>For an XSLT 4.0 processor, the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of an 
               <a href="#element-fallback"><code>xsl:fallback</code></a> element that has no explicit <code>version</code> attribute 
               is 4.0: more generally, it is the version of XSLT supported by the processor.
               This rule is designed to ensure that the <a href="#element-fallback"><code>xsl:fallback</code></a> element
               itself is not processed with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>,
            which would be pointless since the whole purpose of the instruction is to provide
            code that can be evaluated with an earlier version of XSLT.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This rule was not present in earlier versions of this specification.
               On a strict reading of the XSLT 3.0 specification, for example, an <a href="#element-fallback"><code>xsl:fallback</code></a>
               instruction with no <code>version</code> attribute is evaluated with forwards compatible
               behavior. This means, for example, that if the stylesheet author writes
               <code>&lt;xsl:fallback select="42"/&gt;</code> (which is incorrect, because
               the instruction does not define a <code>select</code> attribute) then the <code>select</code>
               attribute will simply be ignored.</p>
                  <p>Stylesheet authors can prevent this problem by adding an explicit
               <code>version</code> attribute to <code>xsl:fallback</code> indicating the version
               of XSLT that is needed to evaluate the fallback code.</p>
                  <p>This specification cannot retrospectively dictate what XSLT 3.0 (or earlier)
               processors should do; however, developers of such processors are encouraged to adopt
               this rule, so that in an XSLT 4.0 stylesheet, an <a href="#element-fallback"><code>xsl:fallback</code></a> instruction 
               that cannot be properly evaluated by an XSLT 3.0 processor is rejected rather than 
               being silently ignored.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="combining-modules"></a>3.10 <a href="#combining-modules" style="text-decoration: none">Combining Stylesheet Modules</a></h3>
               <p>XSLT provides two mechanisms to construct a <a title="package" class="termref" href="#dt-package">package</a> from multiple <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a>:</p>
               <ul>
                  <li>
                     <p>an inclusion mechanism that allows stylesheet modules to be combined without
                     changing the semantics of the modules being combined, and</p>
                  </li>
                  <li>
                     <p>an import mechanism that allows stylesheet modules to override each other.</p>
                  </li>
               </ul>
               <div class="div3">
                  
                  <h4><a id="locating-modules"></a>3.10.1 <a href="#locating-modules" style="text-decoration: none">Locating Stylesheet Modules</a></h4>
                  <p>The include and import mechanisms use two declarations,
                     <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a>, which are defined
                  in the sections that follow.</p>
                  <p>These declarations use an <code>href</code> attribute, whose value is a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI reference</a>, to identify the <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> to be included or
                  imported. If the value of this attribute is a relative URI reference, it is resolved as described in <a href="#uri-references"><i>5.8 URI References</i></a>.</p>
                  <p>After resolving against the base URI, the way in which the URI reference is used
                  to locate a representation of a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet
                     module</a>, and the way in which the stylesheet module is constructed
                  from that representation, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. In particular, it is implementation-defined
                  which URI schemes are supported, whether fragment identifiers are supported, and
                  what media types are supported. Conventionally, the URI is a reference to a
                  resource containing the stylesheet module as a source XML document, or it may
                  include a fragment identifier that selects an embedded stylesheet module within a
                  source XML document; but the implementation is free to use other mechanisms to
                  locate the stylesheet module identified by the URI reference.</p>
                  <p>The referenced <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>
                  <span class="verb">must</span> be either a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a>
                  or a <a title="simplified stylesheet" class="termref" href="#dt-simplified-stylesheet-module">simplified stylesheet</a>. It <span class="verb">must
                     not</span> be a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a>. If it is a simplified
                  stylesheet module then it is transformed into the equivalent standard stylesheet
                  module by applying the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>. </p>
                  <p>Implementations <span class="verb">may</span> choose to accept URI references containing
                  a fragment identifier defined by reference to the XPointer specification (see
                     <a href="#xptr-framework">[XPointer Framework]</a>). Note that if the implementation does not
                  support the use of fragment identifiers in the URI reference, then it will not be
                  possible to include an <a title="embedded stylesheet module" class="termref" href="#dt-embedded-stylesheet-module">embedded
                     stylesheet module</a>.</p>
                  <p>
                  <a id="err-XTSE0165"><span class="error">[ERR XTSE0165] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        processor is not able to retrieve the resource identified by the URI
                           reference, or if the resource that is retrieved does not contain a
                        stylesheet module.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p> It is appropriate to use this error code when
                     the resource cannot be retrieved, or when the retrieved resource is not well
                     formed XML. If the resource contains XML that can be parsed but that violates
                     the rules for stylesheet modules, then a more specific error code may be more
                     appropriate.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="include"></a>3.10.2 <a href="#include" style="text-decoration: none">Stylesheet Inclusion</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#xsl-note-elements">next</a> | <a href="#simplified-stylesheet">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     Duplicate <a href="#element-include"><code>xsl:include</code></a> declarations within a stylesheet level are
                     now ignored, preventing spurious errors caused by the presence of duplicate named components.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1449">1449</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1454">1454</a>&nbsp;17 September 2024]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-include"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:include<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p>
                  <p>A stylesheet module may include another stylesheet module using an
                     <a href="#element-include"><code>xsl:include</code></a> declaration.</p>
                  <p>The <a href="#element-include"><code>xsl:include</code></a> declaration has a <span class="verb">required</span>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <a href="#locating-modules"><i>3.10.1 Locating Stylesheet Modules</i></a>.</p>
                  <p>
                  <a id="err-XTSE0170"><span class="error">[ERR XTSE0170] </span></a>An <a href="#element-include"><code>xsl:include</code></a> element <span class="verb">must</span> be a
                           <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.
               </p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-level" title="stylesheet level"></a>A <b>stylesheet
                        level</b> is a collection of <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> connected using <a href="#element-include"><code>xsl:include</code></a>
                     declarations: specifically, two stylesheet modules <var>A</var> and
                        <var>B</var> are part of the same stylesheet level if one of them includes
                     the other by means of an <a href="#element-include"><code>xsl:include</code></a> declaration, or if there
                     is a third stylesheet module <var>C</var> that is in the same stylesheet level
                     as both <var>A</var> and <var>B</var>.<span class="definition">]</span>
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>A stylesheet level thus groups the <a title="declaration" class="termref" href="#dt-declaration">declarations</a> 
                     in a <a title="package" class="termref" href="#dt-package">package</a> by <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>:
                  two declarations within a package are in the same stylesheet level if and only if they
                  have the same import precedence.</p>
                  </div>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-declaration-order" title="declaration order"></a>The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> within a <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering
                     known as <b>declaration order</b>. The order of declarations within a
                     stylesheet level is the same as the document order that would result if each
                     stylesheet module were inserted textually in place of the
                        <a href="#element-include"><code>xsl:include</code></a> element that references it.<span class="definition">]</span> In other
                  respects, however, the effect of <a href="#element-include"><code>xsl:include</code></a> is not equivalent to
                  the effect that would be obtained by textual inclusion.</p>
                  <p>If two or more <a href="#element-include"><code>xsl:include</code></a> declarations within the same <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a>
               reference the same absolute URI, or reference different absolute URIs that are known to refer
               to the same resource, then the duplicate <a href="#element-include"><code>xsl:include</code></a> declarations, other than the
               first in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>, are ignored. Similarly, an <a href="#element-include"><code>xsl:include</code></a>
               declaration that references the top-level stylesheet module within its stylesheet level is ignored.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The above rule is new in XSLT 4.0. It can prevent the unwanted errors that can
                  occur when assembling a stylesheet from multiple modules, where each module declares its
                  dependencies using potentially redundant, and potentially circular <a href="#element-include"><code>xsl:include</code></a> 
                  declarations.</p>
                     <p>In XSLT 3.0 and earlier versions, including the same module more than once would usually
                  lead to errors caused by duplicate definitions of components such as global variables, named
                  templates, or functions. In the rare case where the included module only contains template rules, the
                  new rule could potentially cause a backwards incompatibility. However, it is very unlikely
                  that a stylesheet author would do this intentionally.</p>
                     <p>The new rule does not apply when multiple <a href="#element-include"><code>xsl:include</code></a> declarations for the
                  same module appear in different <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a>,
                  that is, at different <a title="import precedence" class="termref" href="#dt-import-precedence">import precedences</a>.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="import"></a>3.10.3 <a href="#import" style="text-decoration: none">Stylesheet Import</a></h4>
                  <p class="element-syntax"><a id="element-import"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:import<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p>
                  <p>A stylesheet module may import another <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> using an <a href="#element-import"><code>xsl:import</code></a>
                  <a title="declaration" class="termref" href="#dt-declaration">declaration</a>. Importing a stylesheet module
                  is the same as including it (see <a href="#include"><i>3.10.2 Stylesheet Inclusion</i></a>) except that <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> and other <a title="declaration" class="termref" href="#dt-declaration">declarations</a> in the importing module take
                  precedence over template rules and declarations in the imported module; this is
                  described in more detail below.</p>
                  <p>The <a href="#element-import"><code>xsl:import</code></a> declaration has a <span class="verb">required</span>
                  <code>href</code> attribute whose value is a URI reference identifying the
                  stylesheet module to be included. This attribute is used as described in <a href="#locating-modules"><i>3.10.1 Locating Stylesheet Modules</i></a>.</p>
                  <p>
                  <a id="err-XTSE0190"><span class="error">[ERR XTSE0190] </span></a>An <a href="#element-import"><code>xsl:import</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.
               </p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e11382"></a>Example: Using <code>xsl:import</code>
                        </div>
                     <p>For example,</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:stylesheet version="3.0"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;xsl:import href="article.xsl"/&gt;
  &lt;xsl:import href="bigfont.xsl"/&gt;
  &lt;xsl:attribute-set name="note-style"&gt;
    &lt;xsl:attribute name="font-style"&gt;italic&lt;/xsl:attribute&gt;
  &lt;/xsl:attribute-set&gt;
&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                  </div>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-import-tree" title="import tree"></a>The <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a> making up a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> are treated as forming an
                        <b>import tree</b>. In the import tree, each stylesheet level has one
                     child for each <a href="#element-import"><code>xsl:import</code></a> declaration that it
                     contains.<span class="definition">]</span> The ordering of the children is the <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> of the
                     <a href="#element-import"><code>xsl:import</code></a> declarations within their stylesheet level.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-import-precedence" title="import precedence"></a>A <a title="declaration" class="termref" href="#dt-declaration">declaration</a>
                     <var>D</var> in the stylesheet is defined to have lower <b>import
                        precedence</b> than another declaration <var>E</var> if the stylesheet
                     level containing <var>D</var> would be visited before the stylesheet level
                     containing <var>E</var> in a post-order traversal of the import tree (that is,
                     a traversal of the import tree in which a stylesheet level is visited after its
                     children). Two declarations within the same stylesheet level have the same
                     import precedence.<span class="definition">]</span>
               </p>
                  <p>For example, suppose</p>
                  <ul>
                     <li>
                        <p>stylesheet module <var>A</var> imports stylesheet modules <var>B</var> and
                           <var>C</var> in that order;</p>
                     </li>
                     <li>
                        <p>stylesheet module <var>B</var> imports stylesheet module <var>D</var>;</p>
                     </li>
                     <li>
                        <p>stylesheet module <var>C</var> imports stylesheet module <var>E</var>.</p>
                     </li>
                  </ul>
                  <p>Then the import tree has the following structure:</p>
                  <ul class="type-hierarchy type-colors">
                     <li class="primitive special root">
                        <p id="th_anyAtomicType" class="root">
                        <span>A</span>
                     </p>
                        <ul>
                           <li class="primitive">
                              <p class="first">
                              <span>B</span>
                           </p>
                              <ul>
                                 <li class="atomic">
                                    <p class="first">
                                    <span>D</span>
                                 </p>
                                 </li>
                              </ul>
                           </li>
                           <li class="primitive">
                              <p class="item">
                              <span>C</span>
                           </p>
                              <ul>
                                 <li class="atomic">
                                    <p class="first">
                                    <span>E</span>
                                 </p>
                                 </li>
                              </ul>
                           </li>
                        </ul>
                     </li>
                  </ul>
                  <p>The order of import precedence (lowest first) is <var>D</var>, <var>B</var>,
                     <var>E</var>, <var>C</var>, <var>A</var>.</p>
                  <p>In general, a <a title="declaration" class="termref" href="#dt-declaration">declaration</a> with higher
                  import precedence takes precedence over a declaration with lower import
                  precedence. This is defined in detail for each kind of declaration.</p>
                  <p>
                  <a id="err-XTSE0210"><span class="error">[ERR XTSE0210] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                        stylesheet module directly or indirectly references itself via a chain
                        of <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a>
                        declarations that contains at least one <a href="#element-import"><code>xsl:import</code></a>.                 
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Under the new XSLT 4.0 rules, a cyclic reference that involves
                     <a href="#element-include"><code>xsl:include</code></a> only is ignored. A cycle involving
                     <a href="#element-import"><code>xsl:import</code></a> cannot be ignored, because it makes it
                     impossible to determine which declarations have the highest
                     <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The case where a stylesheet module with a particular URI is imported several
                     times is not treated specially. The effect is exactly the same as if several
                     stylesheet modules with different URIs but identical content were imported.
                     This might or might not cause an error, depending on the content of the
                     stylesheet module.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="preprocessing"></a>3.11 <a href="#preprocessing" style="text-decoration: none">Stylesheet Preprocessing</a></h3>
               <p>This specification provides several features that cause the
               raw stylesheet to be preprocessed as the first stage of static processing:
               </p>
               <ul>
                  <li>
                     <p>Whitespace and commentary are stripped (see <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>).</p>
                  </li>
                  <li>
                     <p>Any <a href="#element-note"><code>xsl:note</code></a> elements are removed: see <a href="#xsl-note-elements"><i>3.11.2 The xsl:note element</i></a>.</p>
                  </li>
                  <li>
                     <p>Elements
                     may be conditionally included or excluded by means of an <code>[xsl:]use-when</code>
                     attribute as described in <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>.</p>
                  </li>
                  <li>
                     <p>Attributes may
                     be conditionally computed as described in <a href="#shadow-attributes"><i>3.11.4 Shadow Attributes</i></a>.</p>
                  </li>
               </ul>
               <p>
            </p>
               <p>Note that many of the rules affecting the validity of
               stylesheet documents apply to a stylesheet after this preprocessing phase has been
               carried out.</p>
               <div class="div3">
                  
                  <h4><a id="stylesheet-stripping"></a>3.11.1 <a href="#stylesheet-stripping" style="text-decoration: none">Stripping Whitespace and Commentary from the Stylesheet</a></h4>
                  <p>The tree representing the stylesheet is preprocessed as follows:</p>
                  <ol class="enumar">
                     <li>
                        <p>All comments and processing instructions are removed.</p>
                     </li>
                     <li>
                        <p>All <a href="#element-note"><code>xsl:note</code></a> elements are removed, together with their content
                     (see <a href="#xsl-note-elements"><i>3.11.2 The xsl:note element</i></a>).</p>
                     </li>
                     <li>
                        <p>Any text nodes that are now adjacent to each other are merged.</p>
                     </li>
                     <li>
                        <p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> that
                        satisfies both the following conditions is removed from the tree:</p>
                        <ul>
                           <li>
                              <p>The parent of the text node is not an <a href="#element-text"><code>xsl:text</code></a>
                              element</p>
                           </li>
                           <li>
                              <p>The text node does not have an ancestor element that has an
                              <code>xml:space</code> attribute with a value of
                              <code>preserve</code>, unless there is a closer ancestor element having
                              an <code>xml:space</code> attribute with a value of
                              <code>default</code>.</p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose
                        parent is one of the following elements is removed from the tree, regardless of
                        any <code>xml:space</code> attributes:</p>
                        <blockquote>
                           <p>
                           
                           <a href="#element-accumulator"><code>xsl:accumulator</code></a>
                           
                        <br>
                           <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>
                        <br>
                           <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
                        <br>
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                        <br>
                           <a href="#element-attribute-set"><code>xsl:attribute-set</code></a>
                        <br>
                           <a href="#element-call-template"><code>xsl:call-template</code></a>
                        <br>
                           <a href="#element-character-map"><code>xsl:character-map</code></a>
                        <br>
                           <a href="#element-choose"><code>xsl:choose</code></a>
                        <br>
                           
                           <a href="#element-evaluate"><code>xsl:evaluate</code></a>
                           
                        <br>
                           
                           <a href="#element-fork"><code>xsl:fork</code></a>
                           
                        <br>
                           
                           <a href="#element-merge"><code>xsl:merge</code></a>
                           
                        <br>
                           
                           <a href="#element-merge-source"><code>xsl:merge-source</code></a>
                           
                        <br>
                           
                           <a href="#element-mode"><code>xsl:mode</code></a>
                           
                        <br>
                           
                           <a href="#element-next-iteration"><code>xsl:next-iteration</code></a>
                           
                        <br>
                           <a href="#element-next-match"><code>xsl:next-match</code></a>
                        <br>
                           
                           <a href="#element-override"><code>xsl:override</code></a>
                           
                        <br>
                           
                           <a href="#element-package"><code>xsl:package</code></a>
                           
                        <br>
                           <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                        <br>
                           <a href="#element-switch"><code>xsl:switch</code></a>
                        <br>
                           <a href="#element-transform"><code>xsl:transform</code></a>
                        <br>
                           
                           <a href="#element-use-package"><code>xsl:use-package</code></a>
                           
                        </p>
                        </blockquote>
                     </li>
                     <li>
                        <p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> whose
                        immediate following-sibling node is an <a href="#element-param"><code>xsl:param</code></a> or
                        <a href="#element-sort"><code>xsl:sort</code></a>
                        or <a href="#element-context-item"><code>xsl:context-item</code></a> or
                        <a href="#element-on-completion"><code>xsl:on-completion</code></a> element is removed from the
                        tree, regardless of any <code>xml:space</code> attributes.</p>
                     </li>
                     <li>
                        <p>Any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text
                        node</a> whose immediate preceding-sibling node is an
                        <a href="#element-catch"><code>xsl:catch</code></a>
                        element is removed from the
                        tree, regardless of any <code>xml:space</code> attributes.</p>
                     </li>
                  </ol>
                  <p>
                  <a id="err-XTSE0260"><span class="error">[ERR XTSE0260] </span></a>Within an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> that is
                        <span class="verb">required</span> to be empty, any content other than comments or
                        processing instructions, including any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> preserved using the
                        <code>xml:space="preserve"</code> attribute, is a <a title="static error" class="termref" href="#dt-static-error">static error</a>.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Using <code>xml:space="preserve"</code> in parts of the stylesheet that contain
                     <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a> will
                     cause whitespace text nodes in that part of the
                     stylesheet to be copied to the result of the sequence constructor.
                     When the result of the sequence constructor is used to form the content of an
                     element, this can cause errors if such text nodes are followed by attribute nodes
                     generated using <a href="#element-attribute"><code>xsl:attribute</code></a>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If an <code>xml:space</code> attribute is specified on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, it will be
                     copied to the result tree in the same way as any other attribute.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="xsl-note-elements"></a>3.11.2 <a href="#xsl-note-elements" style="text-decoration: none">The <code>xsl:note</code> element</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#import-schema">next</a> | <a href="#include">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     A new element <a href="#element-note"><code>xsl:note</code></a> is available for documentation and similar purposes:
                     it can appear anywhere in the stylesheet and is ignored by the XSLT processor.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/109">109</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/353">353</a>&nbsp;19 April 2023]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>An <a href="#element-note"><code>xsl:note</code></a> element may appear anywhere in the stylesheet, except as the outermost element.</p>
                  <p class="element-syntax"><a id="element-note"></a><code>&lt;xsl:note<br>&nbsp;&nbsp;#any#? = <var>string</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>any</var> --&gt;<br>&lt;/xsl:note&gt;</code></p>
                  <p>The element may have any attributes and any children, subject only to rules imposed by
                  other specifications such as the XML specification. The XSLT processor discards <a href="#element-note"><code>xsl:note</code></a>
                  elements at an early stage of processing, without performing any validation, as described
               in <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>.</p>
                  <p>An <a href="#element-note"><code>xsl:note</code></a> element is typically used for documentation. The format of this documentation
               is not prescribed here: it might be free text, or XHTML, or some custom vocabulary understood by a free-standing
               documentation generator.</p>
                  <p>An <a href="#element-note"><code>xsl:note</code></a> element might also be used for “commenting out” XSLT declarations or instructions.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>A number of documentation processors have been produced for use with XSLT, and the general convention has
                     been to use <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> for this purpose. This
                     approach has its drawbacks:</p>
                     <ul>
                        <li>
                           <p>Annotations can only appear at the top level of the stylesheet (between declarations, but not
                     within declarations). <a title="extension instruction" class="termref" href="#dt-extension-instruction">Extension instructions</a>
                     can also potentially be used as annotations, but this abuses their intended purpose and may create an unwanted 
                     dependency on a specific processor.</p>
                        </li>
                        <li>
                           <p>Annotations require a custom namespace to be declared, typically on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                     element, and this namespace becomes part of the static context for all expressions within the stylesheet,
                     thus changing (if only very slightly) the semantics of the stylesheet code. This is true even
                     if the namespace is excluded from the result tree by means of an <code>[xsl:]exclude-result-prefixes</code>
                        attribute.</p>
                        </li>
                     </ul>
                  </div>
                  <p>Implementations <span class="verb">must not</span> interpret the contents of an <a href="#element-note"><code>xsl:note</code></a> element
               to modify the behavior of the stylesheet in any way, whether or not the resulting behavior remains conformant
               with this specification.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>For example, <a href="#element-note"><code>xsl:note</code></a> elements must not be used to provide processor-specific performance
                     hints. There are better mechanisms for this, such as <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>
                  and <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="conditional-inclusion"></a>3.11.3 <a href="#conditional-inclusion" style="text-decoration: none">Conditional Element Inclusion</a></h4>
                  <p>Any element in the XSLT namespace may have a <code>use-when</code> attribute whose
                  value is an XPath expression that can be evaluated statically. 
                  A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or
                  any other element within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet
                     module</a> that is not in the XSLT namespace, may similarly carry an
                  <code>xsl:use-when</code> attribute.      
                  If the attribute is
                  present and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean
                     value</a><sup><small>XP</small></sup> of the expression is <code>false</code>, then the element, together with
                  all the nodes having that element as an ancestor, is effectively excluded from the
                     <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>. When a node is
                  effectively excluded from a stylesheet module the stylesheet module has the same
                  effect as if the node were not there. Among other things this means that no static
                  or dynamic errors will be raised in respect of the element and its contents,
                  other than errors in the <code>use-when</code> attribute itself.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This does not apply to XML parsing or validation errors, which will be raised
                     in the usual way. It also does not apply to attributes that are necessarily
                     processed before <code>[xsl:]use-when</code>, examples being
                        <code>xml:space</code> and <code>[xsl:]xpath-default-namespace</code>.</p>
                  </div>
                  <p>If the <a href="#element-package"><code>xsl:package</code></a>, 
               <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element
                  itself is effectively excluded, the effect is to exclude all the children of the
                     <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element, but
                  not the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a> element
                  or its attributes.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This allows all the declarations that depend on the same condition to be
                     included in one stylesheet module, and for their inclusion or exclusion to be
                     controlled by a single <code>use-when</code> attribute at the level of the
                     module.</p>
                  </div>
                  <p>Conditional element exclusion happens after stripping of whitespace text nodes
                  from the stylesheet, as described in <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>.</p>
                  <p>The XPath expression used as the value of the
                     <code>xsl:use-when</code> attribute follows the rules for <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>, including the rules for handling errors.</p>
                  <p>The use of <code>[xsl:]use-when</code> is illustrated in the following
                  examples.</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e11918"></a>Example: Using Conditional Exclusion to Achieve Portability</div>
                     <p>This example demonstrates the use of the <code>use-when</code> attribute to
                     achieve portability of a stylesheet across schema-aware and non-schema-aware
                     processors.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:import-schema schema-location="http://example.com/schema"
              use-when="system-property('xsl:is-schema-aware')='yes'"/&gt;

&lt;xsl:template match="/" 
              use-when="system-property('xsl:is-schema-aware')='yes'" 
              priority="2"&gt;
  &lt;xsl:result-document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:result-document&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>The effect of these declarations is that a non-schema-aware processor ignores
                     the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration and the first template rule,
                     and therefore raises no errors in respect of the schema-related constructs
                     in these declarations.</p>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e11931"></a>Example: Including Variant Stylesheet Modules</div>
                     <p>This example includes different stylesheet modules depending on which XSLT
                     processor is in use.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:include href="module-A.xsl" 
     use-when="system-property('xsl:vendor')='vendor-A'"/&gt;
&lt;xsl:include href="module-B.xsl" 
     use-when="system-property('xsl:vendor')='vendor-B'"/&gt;</pre>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="shadow-attributes"></a>3.11.4 <a href="#shadow-attributes" style="text-decoration: none">Shadow Attributes</a></h4>
                  <p>When a no-namespace attribute name <var>N</var> is permitted to appear on an element
                  in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> (provided that <var>N</var> does not start with an underscore), 
                  then a value <var>V</var> can be supplied for <var>N</var> in one of two ways:
               </p>
                  <ul>
                     <li>
                        <p>The conventional way is for an attribute node with name <var>N</var> and value <var>V</var> to appear 
                     in the XDM representation of the element node in the stylesheet tree.
                  </p>
                     </li>
                     <li>
                        <p>As an alternative, a shadow attribute may be supplied allowing the value <var>V</var> 
                     to be statically computed during the preprocessing phase. The shadow attribute has a name 
                     that is the same as the name <var>N</var> prefixed with an underscore, and the value of 
                     the shadow attribute is a <a title="value template" class="termref" href="#dt-value-template">value template</a> in which all expressions enclosed between 
                     curly braces must be <a title="static expression" class="termref" href="#dt-static-expression">static
                        expressions</a>. The value <var>V</var> is the result of 
                     evaluating the value template. If a shadow attribute is present, then any attribute node with name
                     <var>N</var> (sharing the same parent element) is ignored.
                  </p>
                     </li>
                  </ul>
                  <p>For example, an <a href="#element-include"><code>xsl:include</code></a> element might be written:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:include _href="common{ $VERSION }.xsl"/&gt;</pre>
                  </div>
                  <p>allowing the stylesheet to include a specific version of a library module based on
                  the value of a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a>.</p>
                  <p>Similarly, a <a title="mode" class="termref" href="#dt-mode">mode</a> might be declared like this:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:param name="streamable" as="xs:boolean" 
                  required="yes" static="yes"/&gt;
&lt;xsl:mode _streamable="{ $streamable }" on-no-match="shallow-skip"/&gt;</pre>
                  </div>
                  <p>this allowing the streamability of the mode to be controlled using a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a>
                  (Note: this example relies on the fact that the
                        <code>streamable</code> attribute accepts a boolean value, which means that
                     the values <code>true</code> and <code>false</code> are accepted as synonyms of
                        <code>yes</code> and <code>no</code>).</p>
                  <p>This mechanism applies to all attributes in the stylesheet where the attribute
                  name is in no namespace and the name of the parent element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. This includes attributes that have static
                  significance such as the <code>use-when</code> attribute, the <code>version</code>
                  attribute, and the <code>static</code> attribute on <a href="#element-variable"><code>xsl:variable</code></a>.
                  The mechanism does not apply to shadow attributes (that is, it is not possible to
                  invoke two stages of preprocessing by using two leading underscores). It does not
                  apply to attributes of literal result elements, nor to attributes in a namespace
                  such as the XML or XSLT namespace, nor to namespace declarations.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If a shadow attribute and its corresponding target attribute are both present in
                     the stylesheet, the non-shadow attribute is ignored.
                     This may be useful to make stylesheet code compatible across XSLT versions; an
                     XSLT 2.0 processor operating in forwards compatible mode will ignore shadow
                     attributes, and will require the target attribute to be valid.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The statement that the non-shadow attribute is
                     ignored extends to error detection: it is not an error if the non-shadow
                     attribute has an invalid value. However, this is not reflected in the schema
                     for XSLT stylesheets, so validation using this schema may raise errors in such
                     cases.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>An attribute whose name begins with an underscore is
                  treated specially only when it appears on an element in the XSLT namespace. On a 
                  <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, it is treated in the same way as any other attribute (that is,
                     its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is copied to the result tree). On an
                     <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> or
                  <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data element</a>, as with other attributes
                  on these elements, its meaning is entirely <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e12044"></a>Example: Using Shadow Attributes to Parameterize XPath Default Namespace</div>
                     <p>Although it is not usually considered good practice, it sometimes happens that
                     variants or versions of an XML vocabulary exist in which the same local names
                     are used, but in different namespaces. There is then a requirement to write
                     code that will process source documents in a variety of different
                     namespaces.</p>
                     <p>It is possible to define a static stylesheet parameter containing the target
                     namespace, for example:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:param name="NS" as="xs:string" static="yes" 
                          select="'http://example.com/ns/one'"/&gt;</pre>
                     </div>
                     <p>And this can then be used to set the default namespace for XPath
                     expressions:</p>
                     <div class="exampleInner">
                        <pre>_xpath-default-namespace="{ $NS }"</pre>
                     </div>
                     <p>However, it is not possible to put this shadow attribute on the
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-package"><code>xsl:package</code></a> element of
                     the principal stylesheet module, because at that point the variable
                        <code>$NS</code> is not in scope. A workaround is to create a stub
                     stylesheet module which contains nothing but the static parameter declaration
                     and an <a href="#element-include"><code>xsl:include</code></a> of the stylesheet module containing the
                     real logic. The static stylesheet parameter will then be in scope on the
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element of the included stylesheet module,
                     and the shadow attribute <code>_xpath-default-namespace="{ $NS }"</code> can
                     therefore appear on this <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e12072"></a>Example: Using Shadow Attributes to Parameterize Selection of Elements</div>
                     <p>The following stylesheet produces a report giving information about selected
                     employees. The predicate defining which employees are to be included in the
                     report is supplied (as a string containing an XPath expression) in a static
                     stylesheet parameter:</p>
                     <div class="exampleInner">
                        <pre>
&lt;xsl:param name="filter" static="yes"
           as="xs:string" select="'true()'"/&gt;
&lt;xsl:function name="local:filter" as="xs:boolean"&gt;
   &lt;xsl:param name="e" as="element(employee)"/&gt;
   &lt;xsl:sequence _select="$e/({ $filter })"/&gt;
&lt;/xsl:function&gt;
&lt;xsl:template match="/"&gt;
   &lt;report&gt;
      &lt;xsl:apply-templates mode="report" select="//employee[local:filter(.)]"/&gt;
   &lt;/report&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>If the supplied value of the filter parameter is, say <code>location =
                        "UK"</code>, then the report will cover employees based in the UK.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The stylesheet function <code>local:filter</code> is used here in preference
                        to direct use of the supplied predicate within the <code>select</code>
                        attribute of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction because it
                        reduces exposure to code injection attacks. It does not necessarily
                        eliminate all such risks, however. For example, it would be possible for a
                        caller to supply an expression that never terminates, thus creating a
                        denial-of-service risk.</p>
                     </div>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="built-in-types"></a>3.12 <a href="#built-in-types" style="text-decoration: none">Built-in Types</a></h3>
               <p>Every XSLT 4.0 processor includes the following
               named type definitions in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope
                  schema components</a>:</p>
               <ul>
                  <li>
                     <p>
                     All built-in types defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>, including <code>xs:anyType</code> and
                           <code>xs:anySimpleType</code>.</p>
                  </li>
                  <li>
                     <p>The following types defined in <a href="#xpath-40">[XPath 4.0]</a>:
                        <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>,
                        <code>xs:anyAtomicType</code>, <code>xs:untyped</code>, and
                        <code>xs:untypedAtomic</code>.</p>
                  </li>
               </ul>
               <p>XSLT 4.0 processors <span class="verb">may</span> optionally include types
               defined in XSD 1.1 (see <a href="#xmlschema11-1">[XML Schema 1.1 Part 1]</a>). XSD 1.1 adopts the types
                  <code>xs:yearMonthDuration</code>, <code>xs:dayTimeDuration</code>, and
                  <code>xs:anyAtomicType</code> previously defined in XPath 2.0, and adds one new
               type: <code>xs:dateTimeStamp</code>. XSD 1.1 also allows implementers to define
               additional primitive types, and XSLT 4.0 permits such types to be supported by an
               XSLT processor.</p>
               <p>A <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>
               additionally supports:</p>
               <ul>
                  <li>
                     <p>User-defined types, and element and attribute declarations, that are imported
                     using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration as described in
                        <a href="#import-schema"><i>3.13 Importing Schema Components</i></a>. These may include both simple and complex
                     types.</p>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The names that are imported from the XML Schema namespace do not include all the
                  names of top-level types defined in either the Schema for Schema Documents or the
                  Schema for Schema Documents (Datatypes). The Schema for Schema Documents, as well
                  as defining built-in types such as <code>xs:integer</code> and
                     <code>xs:double</code>, also defines types that are intended for use only
                  within that schema, such as <code>xs:derivationControl</code>. A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that is designed to process XML Schema
                  documents as its input or output may import the Schema for Schema Documents.</p>
               </div>
               <p>An implementation may define mechanisms that allow additional <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> to be added to the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> for the
               stylesheet. For example, the mechanisms used to define <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> (see <a href="#extension-functions"><i>24.2 Extension Functions</i></a>) may also be used to import the types used in the
               interface to such functions.</p>
               <p>These <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> are the only
               ones that may be referenced in XPath expressions within the stylesheet, or in the
                  <code>[xsl:]type</code> and <code>as</code> attributes of those elements that
               permit these attributes.</p>
            </div>
            <div class="div2">
               
               <h3><a id="import-schema"></a>3.13 <a href="#import-schema" style="text-decoration: none">Importing Schema Components</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#multiple-schemas">next</a> | <a href="#xsl-note-elements">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The rules concerning the compatibility of schemas imported by different packages have 
                  been clarified. It is now explicitly stated that instructions that trigger validation 
                  must use the imported schema of the package in which validation is invoked. 
                  This differs from the current practice of some XSLT 3.0 processors, which may 
                  use (for example) a schema formed from the union of the imported schemas in all 
                  packages.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635</a>&nbsp;24 October 2023]</i></p>
                     </li>
                     <li>
                        <p>
                  Different parts of a stylesheet may now use different imported schemas.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The facilities described in this section are not available with a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a>. They require a
                     <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</a>, as described in <a href="#conformance"><i>27 Conformance</i></a>.</p>
               </div>
               <p class="element-syntax"><a id="element-import-schema"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:import-schema<br>&nbsp;&nbsp;role? = <var>ncname</var><br>&nbsp;&nbsp;namespace? = <var>uri</var><br>&nbsp;&nbsp;schema-location? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: xs:schema? --&gt;<br>&lt;/xsl:import-schema&gt;</code></p>
               <p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration is used to identify <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> (that is, top-level type
               definitions and top-level element and attribute declarations) that need to be
               available statically, that is, before any source document is available. Names of such
               components used statically within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> must refer to an <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema component</a>, which means they must either be built-in
               types as defined in <a href="#built-in-types"><i>3.12 Built-in Types</i></a>, or they must be imported using
               an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p>
               <p>The <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration identifies a namespace containing
               the names of the components to be imported (or indicates that components whose names
               are in no namespace are to be imported). The effect is that the names of top-level
               element and attribute declarations and type definitions from this namespace (or
               non-namespace) become available for use within XPath expressions in the <a title="package" class="termref" href="#dt-package">package</a>, and within
               other stylesheet constructs such as the <code>type</code> and <code>as</code>
               attributes of various <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>.</p>
               <p>If the <code>role</code> attribute is absent,
               the relevant schema components are available in all stylesheet modules
                  within the <a title="declaring package" class="termref" href="#dt-declaring-package">declaring
                     package</a>, except within subtrees of a stylesheet module
               where a different schema is selected using an <code>[xsl:]schema-role</code>
               attribute. Importing components in one stylesheet module makes
               them available throughout the <a title="package" class="termref" href="#dt-package">package</a>, subject
               to the constraints imposed by the <code>[xsl:]schema-role</code> attribute.
            </p>
               <p>The schema components imported into different 
               <a title="package" class="termref" href="#dt-package">packages</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
               (regardless of the schema role)
               must be <span><a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible">compatible</a><sup><small>DM</small></sup></span>. 
               Specifically, it is not permitted to use
               the same name in the same XSD symbol space to refer to different schema components
               within different packages; and the union of the schema components imported into the
               packages of a stylesheet must constitute a valid schema (as well as the set of schema
               components imported into each package forming a valid schema in its own right).</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The fact that the schemas used in different packages
            must be compatible does not mean they must be identical. There are circumstances
            where validating an element using one schema might produce a different outcome from
            validation with a different schema, despite these consistency rules: an example
            is where the two schemas define different membership for a substitution group.</p>
                  <p>Nevertheless, the consistency rules are strong enough to ensure that an element
            node validated using one schema can safely be passed to a function declared in another
            package, where the function declares the required
            type of an argument as (say) <code>element(*, T)</code>.</p>
               </div>
               <p>The <code>namespace</code> and <code>schema-location</code> attributes are both
               optional.</p>
               <p>If the <a href="#element-import-schema"><code>xsl:import-schema</code></a> element contains an <code>xs:schema</code>
               element, then the <code>schema-location</code> attribute <span class="verb">must</span> be
               absent, and one of the following <span class="verb">must</span> be true:</p>
               <ul>
                  <li>
                     <p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both absent (indicating a no-namespace
                     schema), or</p>
                  </li>
                  <li>
                     <p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a>
                     element and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element are both present and both have the same
                     value, or</p>
                  </li>
                  <li>
                     <p>the <code>namespace</code> attribute of the <a href="#element-import-schema"><code>xsl:import-schema</code></a>
                     element is absent and the <code>targetNamespace</code> attribute of the
                        <code>xs:schema</code> element is present, in which case the target
                     namespace is as given on the <code>xs:schema</code> element.</p>
                  </li>
               </ul>
               <p>
               <a id="err-XTSE0215"><span class="error">[ERR XTSE0215] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-import-schema"><code>xsl:import-schema</code></a> element that contains an
                        <code>xs:schema</code> element has a <code>schema-location</code> attribute,
                     or if it has a <code>namespace</code> attribute that conflicts with the target
                     namespace of the contained schema.
            </p>
               <p>If two <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations with the same effective <code>role</code>
               name specify the same namespace, or
               if both specify no namespace, then only the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used. If this leaves
               more than one, then all the declarations at the highest import precedence are used
               (which may cause conflicts, as described below).</p>
               <p>After discarding any <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations under the above
               rule, the effect of the remaining <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations 
               for each distinct schema role is
               defined in terms of a hypothetical document called the synthetic schema document,
               which is constructed as follows. The synthetic schema document defines an arbitrary
               target namespace that is different from any namespace actually used by the
               application, and it contains <code>xs:import</code> elements corresponding
               one-for-one with the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations 
               with that effective schema role
               in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, with the following correspondence:</p>
               <ul>
                  <li>
                     <p>The <code>namespace</code> attribute of the <code>xs:import</code> element is
                     copied from the <code>namespace</code> attribute of the
                        <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration if it is explicitly present,
                     or is implied by the <code>targetNamespace</code> attribute of a contained
                        <code>xs:schema</code> element, and is absent if it is absent.</p>
                  </li>
                  <li>
                     <p>The <code>schemaLocation</code> attribute of the <code>xs:import</code> element
                     is copied from the <code>schema-location</code> attribute of the
                        <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration if present, and is absent if
                     it is absent. If there is a contained <code>xs:schema</code> element, the
                     effective value of the <code>schemaLocation</code> attribute is a URI
                     referencing a document containing a copy of the <code>xs:schema</code>
                     element.</p>
                  </li>
                  <li>
                     <p>The base URI of the <code>xs:import</code> element is the same as the base URI
                     of the <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p>
                  </li>
               </ul>
               <p>The schema components included in the 
               <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a> 
               of an XPath expression or other construct within a stylesheet (that is, the components whose names are
               available for use within that construct) depend on the effective schema role for that
               construct, which is determined by the value of the <code>[xsl:]schema-role</code> attribute
               of the innermost ancestor element having such an attribute; in the absence of such an attribute,
               the unnamed schema role applies. The schema components whose names are available
               are the top-level element and attribute
               declarations and type definitions that are available for reference within the
               synthetic schema document for that schema role. See <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 4.2.3,
                  <em>References to schema components across namespaces</em>).</p>
               <p>
               <a id="err-XTSE0220"><span class="error">[ERR XTSE0220] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the synthetic
                     schema document does not satisfy the constraints described in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in Schema Construction and
                        Structure</em>). This includes, without loss of generality, conflicts such
                     as multiple definitions of the same name.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The synthetic schema document does not need to be constructed by a real
                  implementation. It is purely a mechanism for defining the semantics of
                     <a href="#element-import-schema"><code>xsl:import-schema</code></a> in terms of rules that already exist within
                  the XML Schema specification. In particular, it implicitly defines the rules that
                  determine whether the set of <a href="#element-import-schema"><code>xsl:import-schema</code></a> declarations are
                  mutually consistent.</p>
                  <p>These rules do not cause names to be imported transitively. The fact that a name
                  is available for reference within a schema document <var>A</var> does not of itself make the
                  name available for reference in a stylesheet that imports the target namespace of
                  schema document <var>A</var>. (See <a href="#xmlschema-1">[XML Schema Part 1]</a> section 3.15.3, Constraints on
                  XML Representations of Schemas.) The stylesheet must import all the namespaces
                  containing names that it actually references.</p>
                  <p>The <code>namespace</code> attribute indicates that a schema for the given
                  namespace is required by the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.
                  This information may be enough on its own to enable an implementation to locate
                  the required schema components. The <code>namespace</code> attribute may be
                  omitted to indicate that a schema for names in no namespace is being imported. The
                  zero-length string is not a valid namespace URI, and is therefore not a valid
                  value for the <code>namespace</code> attribute.</p>
                  <p>The <code>schema-location</code> attribute is a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI Reference</a> that gives a hint indicating where a schema document
                  or other resource containing the required definitions may be found. It is likely
                  that a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT
                     processor</a> will be able to process a schema document found at this
                  location.</p>
                  <p>The XML Schema specification gives implementations flexibility in how to handle
                  multiple imports for the same namespace. Multiple imports do not cause errors if
                  the definitions do not conflict.</p>
                  <p>A consequence of these rules is that it is not intrinsically an error if no schema
                  document can be located for a namespace identified in an
                     <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration. This will cause an error only
                  if it results in the stylesheet containing references to names that have not been
                  imported.</p>
                  <p>An inline schema document (using an <code>xs:schema</code> element as a child of
                  the <code>xsl:import-schema</code> element) has the same status as an external
                  schema document, in the sense that it acts as a hint for a source of schema
                  components in the relevant namespace. To ensure that the inline schema document is
                  always used, it is advisable to use a target namespace that is unique to this
                  schema document.</p>
               </div>
               <p>The use of a namespace in an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration does not
               by itself associate any namespace prefix with the namespace. If names from the
               namespace are used within the stylesheet module then a namespace declaration must be
               included in the stylesheet module, in the usual way.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e12562"></a>Example: An Inline Schema Document</div>
                  <p>The following example shows an inline schema document. This declares a simple type
                     <code>local:yes-no</code>, which the stylesheet then uses in the declaration of
                  a variable.</p>
                  <p>The example assumes the namespace declaration
                     <code>xmlns:local="http://example.com/ns/yes-no"</code>
               </p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:import-schema&gt;
  &lt;xs:schema targetNamespace="http://example.com/ns/yes-no"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"
             xmlns:local="http://example.com/ns/yes-no"&gt;
    &lt;xs:simpleType name="yes-no"&gt;
      &lt;xs:restriction base="xs:string"&gt;
        &lt;xs:enumeration value="yes"/&gt;
        &lt;xs:enumeration value="no"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:simpleType&gt;
  &lt;/xs:schema&gt;
&lt;/xsl:import-schema&gt;

&lt;xsl:variable name="condition" select="local:yes-no('yes')" 
                               as="local:yes-no"/&gt;</pre>
                  </div>
               </div>
               <p>There are two built-in functions
                  (<a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-json-to-xml"><code>json-to-xml</code></a>) whose
               result is an XML structure for which a schema is defined. The namespace for these
               schema definitions is (in both cases) <code>http://www.w3.org/2005/xpath-functions</code>. Schema
               components for these namespaces are available for reference within the stylesheet if
               and only if an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration is present referencing
               this namespace. If such a declaration is present, then the schema that is
               imported is the schema defined in the specification of these functions: the <code>schemaLocation</code>
               attribute has no effect.</p>
               <div class="div3">
                  
                  <h4><a id="multiple-schemas"></a>3.13.1 <a href="#multiple-schemas" style="text-decoration: none">Multiple Schemas</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#unprefixed-qnames">next</a> | <a href="#import-schema">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     A stylesheet can import multiple schemas with different schema role names.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819</a>&nbsp;18 February 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>A stylesheet might perform a transformation from an input document conforming to
               one schema, to an output document conforming to a different schema. To facilitate this,
               a schema can be imported with a specific role name, and it is then used only in parts
               of the stylesheet within the scope of an <code>[xsl:]schema-role</code> attribute specifying
               this role name.
               </p>
                  <p>More specifically, within the subtree rooted at an element having an 
               <code>[xsl:]schema-role</code> attribute, the static context uses in-scope schema
                  definitions taken from the named schema role.</p>
                  <p><a id="err-XTSE4045"><span class="error">[ERR XTSE4045] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value
                  of any <code>[xsl:]schema-role</code> in a stylesheet package does
                  not match the value of the <code>role</code> attribute on some
                  <a href="#element-import-schema"><code>xsl:import-schema</code></a> element in the same package.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The introduction of multiple schema roles in XSLT 4.0 enables
                  different input and output documents to be validated against different
                  schemas. For example, a stylesheet might contain the instruction:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:result-document validation="strict" schema-role="output"&gt;
   ...
&lt;/xsl:result-document&gt;</pre>
                     </div>
                     <p>to control which schema is used to validate the result document.
                  Any instructions used to create validated element nodes
                  in this result document should normally also be within the scope of
                  the same <code>[xsl:]schema-role</code>.</p>
                     <p>The fact that multiple schemas can be imported does not relax 
                     the requirement that all
                  schemas used in a transformation must be 
                     <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible">compatible</a><sup><small>DM</small></sup>. This may mean,
                  for example, that a transformation designed to convert documents
                  from one version of a defined schema to a later version of the
                  same schema may be unable to import both.</p>
                     <p>The reason for this restriction is to ensure that stylesheet components
                  (such as functions) using schema components in their type signatures
                  are compatible across the stylesheet as a whole, and that instance
                  documents whose nodes have type annotations resulting from validation
                  against a schema can be checked for conformance with types declared
                  anywhere in the stylesheet.</p>
                     <p>It is possible to validate different parts of a constructed document
                  against different schemas. However, validating an element in a document
                  validates the entire subtree rooted at that element, so requesting 
                  validation at more than one level may be redundant.</p>
                  </div>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="data-model"></a>4 <a href="#data-model" style="text-decoration: none">Data Model</a></h2>
            <p>The data model used by XSLT is the XPath 4.0 and XQuery
               4.0 data model (XDM), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. XSLT
            operates on source, result and stylesheet documents using the same data model.</p>
            <p>This section elaborates on some particular features of XDM as it is used by XSLT:</p>
            <p>The rules in <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a> and <a href="#strip"><i>4.2.2 Stripping Whitespace from a Source Tree</i></a> make use
            of the concept of a whitespace text node.</p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-whitespace-text-node" title="whitespace text node"></a>A <b>whitespace
                  text node</b> is a text node whose content consists entirely of whitespace
               characters (that is, <span class="unicode-codepoint">U+0009</span> (<span class="unicode-name">TAB</span>) , <span class="unicode-codepoint">U+000A</span> (<span class="unicode-name">NEWLINE</span>) ,
               <span class="unicode-codepoint">U+000D</span> (<span class="unicode-name">CARRIAGE RETURN</span>) , or <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>) ).<span class="definition">]</span>
         </p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>Features of a source XML document that are not represented in the XDM tree will have
               no effect on the operation of an XSLT stylesheet. Examples of such features are
               entity references, CDATA sections, character references, whitespace within element
               tags, and the choice of single or double quotes around attribute values.</p>
            </div>
            <div class="div2">
               
               <h3><a id="xml-versions"></a>4.1 <a href="#xml-versions" style="text-decoration: none">XML Versions</a></h3>
               <p>The XDM data model defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> is capable of
               representing either an XML 1.0 document (conforming to <a href="#REC-xml">[XML 1.0]</a> and
                  <a href="#xml-names">[Namespaces in XML]</a>) or an XML 1.1 document (conforming to <a href="#xml11">[XML 1.1]</a> and <a href="#xml-names11">[Namespaces in XML 1.1]</a>), and it makes no distinction
               between the two. In principle, therefore, XSLT 4.0
               can be used with either of these XML versions.</p>
               <p>Construction of the XDM tree is outside the scope of this specification, so XSLT
                  4.0 places no formal requirements on an XSLT
               processor to accept input from either XML 1.0 documents or XML 1.1 documents or both.
               This specification does define a serialization capability (see <a href="#serialization"><i>26 Serialization</i></a>), though from a conformance point of view it is an optional
               feature. Although facilities are described for serializing the XDM tree as either XML
               1.0 or XML 1.1 (and controlling the choice), there is again no formal requirement on
               an XSLT processor to support either or both of these XML versions as serialization
               targets.</p>
               <p>Because the XDM tree is the same whether the original document was XML 1.0 or XML
               1.1, the semantics of XSLT processing do not depend on the version of XML used by the
               original document. There is no reason in principle why all the input and output
               documents used in a single transformation must conform to the same version of
               XML.</p>
               <p>Some of the syntactic constructs in XSLT 4.0 and
                  XPath 3.0, for example the productions <a href="https://www.w3.org/TR/REC-xml/#NT-Char">Char</a><sup><small>XML</small></sup> and <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, are defined by reference to the XML and XML Namespaces
               specifications. There are slight variations between the XML 1.0 and XML 1.1 versions
               of these productions (and, indeed, between different
                  editions of XML 1.0). Implementations <span class="verb">may</span> support
                  any version; it is
                  <span class="verb">recommended</span> that an XSLT 4.0
               processor that implements the 1.1 versions <span class="verb">should</span> also provide a
               mode that supports the 1.0 versions. It is thus <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> which versions
               and editions of XML and XML Namespaces are supported by the implementation.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The specification referenced as <a href="#xml-names">[Namespaces in XML]</a> was actually published
                  without a version number.</p>
               </div>
               <p>The current version of <a href="#xmlschema11-2">[XML Schema 1.1 Part 2]</a> references the XML 1.1 specifications, but the previous version (<a href="#xmlschema-2">[XML Schema Part 2]</a>) (that is, XSD 1.0) remains in widespread use, and only
                  references XML 1.0. With processors lacking support for XSD 1.1,
               therefore, datatypes such as <code>xs:NCName</code> and <code>xs:ID</code> may be
               constrained by the XML 1.0 rules, and not allow the full range of values permitted by
               XML 1.1. It is <span class="verb">recommended</span> that implementers wishing to support
               XML 1.1 should consult <a href="#SCHEMA-AND-XML-1.1">[XML Schema 1.0 and XML 1.1]</a> for guidance.</p>
            </div>
            <div class="div2">
               
               <h3><a id="preprocessing-source-docs"></a>4.2 <a href="#preprocessing-source-docs" style="text-decoration: none">Preprocessing Source Documents</a></h3>
               <p>Source documents supplied as input to a transformation may be subject to preprocessing. 
               Two kinds of preprocessing are defined: stripping of type annotations (see <a href="#stripping-annotations"><i>4.2.1 Stripping Type Annotations from a Source Tree</i></a>), 
               and stripping of whitespace text nodes (see <a href="#strip"><i>4.2.2 Stripping Whitespace from a Source Tree</i></a>).
            </p>
               <p>Stripping of type annotations happens before stripping of whitespace text nodes.
            </p>
               <p>The source documents to which this applies are as follows:
            </p>
               <ul>
                  <li>
                     <p>The document containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if it is a node;</p>
                  </li>
                  <li>
                     <p>Any documents containing a node present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>;</p>
                  </li>
                  <li>
                     <p>Any document containing a node that is returned by the functions <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>,
                  or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a>;</p>
                  </li>
                  <li>
                     <p>Any document read using <code>xsl:source-document</code>.</p>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This list excludes documents passed as the values of 
               <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a> or parameters 
               of the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a> or <a title="initial function" class="termref" href="#dt-initial-function">initial function</a>, 
               trees created by functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-xml"><code>parse-xml</code></a>, <code>parse-xml-fragment</code>,
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a>, or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-json-to-xml"><code>json-to-xml</code></a>,
               and values returned from <a title="extension function" class="termref" href="#dt-extension-function">extension
                  functions</a>.
            </p>
               </div>
               <p>If a node other than a document node is supplied (for example as the global context item), 
               then the preprocessing is applied to the entire document containing that node. If several nodes within the same 
               document are supplied (for example as nodes in the initial match selection, or as nodes returned by the 
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> function), then the preprocessing is only applied to that document once.
               If a whitespace text node is supplied (for example as the global context item) and the rules cause this node
               to be stripped from its containing tree, then the behavior is as if this node had not been supplied 
               (which may cause an error, for example if a global context item is required.)
            </p>
               <p>The rules determining whether or not stripping of annotations and/or whitespace 
               happens are defined at the level of a <a title="package" class="termref" href="#dt-package">package</a>. Declarations within a <a title="library package" class="termref" href="#dt-library-package">library package</a> 
               only affect the handling of documents loaded using a call on the <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>,
               or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions or an evaluation of an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction 
               appearing lexically within the same package. Declarations within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> also affect the processing 
               of the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> and the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>.
            </p>
               <p>The semantics of the <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>,
               and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions are formally defined in terms of mappings from URIs to document nodes 
               maintained within the dynamic context (see <a href="#xpath-dynamic-context"><i>5.3.3 Initializing the Dynamic Context</i></a>). The effect of the 
               declarations that control stripping of type annotations 
               and whitespace is therefore to modify this mapping (so it now maps the URI to a stripped document). The modification 
               applies to the dynamic context for calls to these function appearing within a particular package; each package therefore 
               has a different set of mappings. This means that when two calls to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function appear in 
               different packages, specifying the same absolute URI, then in general different documents are returned. An implementation 
               <span class="verb">may</span> return the same document for two such calls if it is able to determine that the effect of the annotation 
               and whitespace stripping rules in both packages is the same.
            </p>
               <p>The effect of dynamic calls to the <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>,
               and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions is defined in the same way as for other functions with dependencies on 
               the dynamic context. As described in <a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a>, named function references 
               (such as <code>doc#1</code>) and calls on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> (for example, <code>function-lookup("doc", 1)</code>) 
               are defined to retain the XPath static and dynamic context at the point of invocation as part of the closure of the 
               resulting function item, and to use this preserved context when a dynamic function call is subsequently made using the function item.
            </p>
               <div class="div3">
                  
                  <h4><a id="stripping-annotations"></a>4.2.1 <a href="#stripping-annotations" style="text-decoration: none">Stripping Type Annotations from a Source Tree</a></h4>
                  <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-type-annotation" title="type annotation"></a>The term <b>type
                     annotation</b> is used in this specification to refer to the value returned
                  by the <code>dm:type-name</code> accessor of a node: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-type-name">7.6.13 type-name Accessor</a>.<span class="definition">]</span>
            </p>
                  <p>There is sometimes a requirement to write stylesheets that produce the same results
               whether or not the source documents have been validated against a schema. To achieve
               this, an option is provided to remove any <a title="type annotation" class="termref" href="#dt-type-annotation">type
                  annotations</a> on element and attribute nodes in a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>, replacing them with an annotation of
                  <code>xs:untyped</code> in the case of element nodes, and
                  <code>xs:untypedAtomic</code> in the case of attribute nodes.</p>
                  <p>Such stripping of <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> can be
               requested by specifying <code>input-type-annotations="strip"</code> on the <a href="#element-package"><code>xsl:package</code></a> element. This
               attribute has three permitted values: <code>strip</code>, <code>preserve</code>, and
                  <code>unspecified</code>. The default value is <code>unspecified</code>. 
            <span>Specifying <code>unspecified</code> has the same effect
            as omitting the attribute.</span></p>
                  <p>The <code>input-type-annotations</code> attribute may also
               be specified on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element; if it is specified at
               this level then it must be consistent for all stylesheet modules within the same
               package.</p>
                  <p>
               <a id="err-XTSE0265"><span class="error">[ERR XTSE0265] </span></a> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is a
                        <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> in a
                        <a title="package" class="termref" href="#dt-package">package</a> that specifies
                        <code>input-type-annotations="strip"</code> and another <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that specifies
                        <code>input-type-annotations="preserve"</code>, or if a stylesheet module specifies the value
                           <code>strip</code> or <code>preserve</code> and the same value is not
                        specified on the <a href="#element-package"><code>xsl:package</code></a> element of the containing
                        package.
            </p>
                  <p>Type annotations are stripped from relevant source documents if 
               at least one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
               specifies <code>input-type-annotations="strip"</code> on the <a href="#element-package"><code>xsl:package</code></a>, 
               <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, or <a href="#element-transform"><code>xsl:transform</code></a> element.</p>
                  <p>When type annotations are stripped, the following changes are made to the source
               tree:</p>
                  <ul>
                     <li>
                        <p>The type annotation of every element node is changed to <code>xs:untyped</code>
                  </p>
                     </li>
                     <li>
                        <p>The type annotation of every attribute node is changed to
                        <code>xs:untypedAtomic</code>
                  </p>
                     </li>
                     <li>
                        <p>The typed value of every element and attribute node is set to be the same as
                     its string value, as an instance of <code>xs:untypedAtomic</code>.</p>
                     </li>
                     <li>
                        <p>The <code>is-nilled</code> property of every element node is set to
                        <code>false</code>.</p>
                     </li>
                  </ul>
                  <p>The values of the <code>is-id</code> and <code>is-idrefs</code> properties are not
               changed.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Stripping <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> does not
                  necessarily return the document to the state it would be in had validation not
                  taken place. In particular, any defaulted elements and attributes that were added
                  to the tree by the validation process will still be present, and elements and
                  attributes validated as IDs will still be accessible using the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>id</code></a> function.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="strip"></a>4.2.2 <a href="#strip" style="text-decoration: none">Stripping Whitespace from a Source Tree</a></h4>
                  <p>A <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> supplied as input to the
               transformation process may contain <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace
                  text nodes</a> that are of no interest, and that do not need to be retained
               by the transformation. Conceptually, an XSLT <a title="processor" class="termref" href="#dt-processor">processor</a> makes a copy of the source tree from which unwanted <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> have been removed.
               This process is referred to as whitespace stripping. </p>
                  <p>The stripping process takes as input a set of element names whose child <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> are to be preserved.
               The way in which this set of element names is established using the
                  <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
               declarations is described later in this section.</p>
                  <p>The stripping process that applies for a particular
               <a title="package" class="termref" href="#dt-package">package</a> is determined by the <a href="#element-strip-space"><code>xsl:strip-space</code></a>
               and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations within that package.</p>
                  <p>A <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> is preserved
               if either of the following apply:</p>
                  <ul>
                     <li>
                        <p>The element name of the parent of the text node is in the set of
                     whitespace-preserving element names.</p>
                     </li>
                     <li>
                        <p>An ancestor element of the text node has an <code>xml:space</code> attribute
                     with a value of <code>preserve</code>, and no closer ancestor element has
                        <code>xml:space</code> with a value of <code>default</code>.</p>
                     </li>
                  </ul>
                  <p>Otherwise, the <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a>
               is stripped.</p>
                  <p>The <code>xml:space</code> attributes are not removed from the tree.</p>
                  <p class="element-syntax"><a id="element-strip-space"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:strip-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p>
                  <p class="element-syntax"><a id="element-preserve-space"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:preserve-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p>
                  <p>The set of whitespace-preserving element names is specified by
                  <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
               <a title="declaration" class="termref" href="#dt-declaration">declarations</a>. Whether an element name is
               included in the set of whitespace-preserving names is determined by the best match
               among all the <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
               declarations: it is included if and only if there is no match or the best match is an
                  <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element. The <a href="#element-strip-space"><code>xsl:strip-space</code></a>
               and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> elements each have an <code>elements</code>
               attribute whose value is a whitespace-separated list of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTests</a><sup><small>XP</small></sup>; an element name matches an
                  <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element if
               it matches one of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTests</a><sup><small>XP</small></sup>.
               An element matches a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> if
               and only if the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> would be
               true for the element as an XPath node test.</p>
                  <p><a id="err-XTSE0270"><span class="error">[ERR XTSE0270] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within any <a title="package" class="termref" href="#dt-package">package</a> the same <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> appears in both an
                        <a href="#element-strip-space"><code>xsl:strip-space</code></a> and an <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
                     declaration if both have the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                        precedence</a>. Two NameTests are considered the same if they match
                     the same set of names (which can be determined by comparing them after
                     expanding namespace prefixes to URIs).</p>
                  <p>Otherwise, when more than one
                  <a href="#element-strip-space"><code>xsl:strip-space</code></a> and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> element
                  within the relevant <a title="package" class="termref" href="#dt-package">package</a> matches, the best matching element is determined by
               the best matching <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup>.
                  
               The rules are similar to those for
               <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>:</p>
                  <ul>
                     <li>
                        <p>First, any match with lower <a title="import precedence" class="termref" href="#dt-import-precedence">import
                        precedence</a> than another match is ignored.</p>
                     </li>
                     <li>
                        <p>Next, any match that has a lower <a title="default priority" class="termref" href="#dt-default-priority">default
                        priority</a> than the <a title="default priority" class="termref" href="#dt-default-priority">default
                        priority</a> of another match is ignored.</p>
                     </li>
                     <li>
                        <p>If several matches have the same <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> (which can only happen
                     if one of the NameTests takes the form <code>*:local</code> and the other takes
                     the form <code>prefix:*</code>), then the declaration that appears last in
                        <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> is used.</p>
                     </li>
                  </ul>
                  <p>If an element in a source document has a <a title="type annotation" class="termref" href="#dt-type-annotation">type
                  annotation</a> that is a simple type or a complex type with simple content,
               then any whitespace text nodes among its children are preserved, regardless of any
                  <a href="#element-strip-space"><code>xsl:strip-space</code></a> declarations. The reason for this is that
               stripping a whitespace text node from an element with simple content could make the
               element invalid: for example, it could cause the <code>minLength</code> facet to be
               violated.</p>
                  <p>Stripping of <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a> happens
               before stripping of whitespace text nodes, so this situation will not occur if
                  <code>input-type-annotations="strip"</code> is specified.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In <a href="#xpath-datamodel-40">[XDM 4.0]</a>, processes are described for constructing an
                  XDM tree from an Infoset or from a PSVI. Those processes deal with whitespace
                  according to their own rules, and the provisions in this section apply to the
                  resulting tree. In practice this means that elements that are defined in a DTD or
                  a Schema to contain element-only content will have <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> stripped,
                  regardless of the <a href="#element-strip-space"><code>xsl:strip-space</code></a> and
                     <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations in the stylesheet.</p>
                     <p>However, source trees are not necessarily constructed using those processes;
                  indeed, they are not necessarily constructed by parsing XML documents. Nothing in
                  the XSLT specification constrains how the source tree is constructed, or what
                  happens to <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a>
                  during its construction. The provisions in this section relate only to whitespace
                  text nodes that are present in the tree supplied as input to the XSLT processor.
                  The XSLT processor cannot preserve whitespace text nodes unless they were actually
                  present in the supplied tree.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-in-data-model"></a>4.3 <a href="#id-in-data-model" style="text-decoration: none">Attribute Types and DTD Validation</a></h3>
               <p>The mapping from the Infoset to the XDM data model, described in <a href="#xpath-datamodel-40">[XDM 4.0]</a>, does not retain attribute types. This means, for
               example, that an attribute described in the DTD as having attribute type
                  <code>NMTOKENS</code> will be annotated in the XDM tree as
                  <code>xs:untypedAtomic</code> rather than <code>xs:NMTOKENS</code>, and its typed
               value will consist of a single <code>xs:untypedAtomic</code> item rather than a
               sequence of <code>xs:NMTOKEN</code> items.</p>
               <p>Attributes with a DTD-derived type of ID, IDREF, or IDREFS will be marked in the XDM
               tree as having the <code>is-id</code> or <code>is-idrefs</code> properties. It is
               these properties, rather than any <a title="type annotation" class="termref" href="#dt-type-annotation">type
                  annotation</a>, that are examined by the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>id</code></a>
               and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-idref"><code>idref</code></a> described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="limits"></a>4.4 <a href="#limits" style="text-decoration: none">Limits</a></h3>
               <p>The XDM data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>) leaves it to the host
               language to define limits. This section describes the limits that apply to XSLT.</p>
               <p>Limits on some primitive datatypes are defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>. Other
               limits, listed below, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Note that this does not necessarily mean that
               each limit must be a simple constant: it may vary depending on environmental factors
               such as available resources.</p>
               <p>The following limits are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>:</p>
               <ol class="enumar">
                  <li>
                     <p>For the <code>xs:decimal</code> type, the maximum number of decimal digits (the
                        <code>totalDigits</code> facet). This must be at least 18 digits. (Note,
                     however, that support for the full value range of <code>xs:unsignedLong</code>
                     requires 20 digits.) </p>
                  </li>
                  <li>
                     <p>For the types <code>xs:date</code>, <code>xs:time</code>,
                        <code>xs:dateTime</code>, <code>xs:gYear</code>, and
                        <code>xs:gYearMonth</code>: the range of values of the year component, which
                     must be at least +0001 to +9999; and the maximum number of fractional second
                     digits, which must be at least 3.</p>
                  </li>
                  <li>
                     <p>For the <code>xs:duration</code> type: the maximum absolute values of the
                     years, months, days, hours, minutes, and seconds components. </p>
                  </li>
                  <li>
                     <p>For the <code>xs:yearMonthDuration</code> type: the maximum absolute value,
                     expressed as an integer number of months.</p>
                  </li>
                  <li>
                     <p>For the <code>xs:dayTimeDuration</code> type: the maximum absolute value,
                     expressed as a decimal number of seconds.</p>
                  </li>
                  <li>
                     <p>For the types <code>xs:string</code>, <code>xs:hexBinary</code>,
                        <code>xs:base64Binary</code>, <code>xs:QName</code>, <code>xs:anyURI</code>,
                        <code>xs:NOTATION</code>, and types derived from them: the maximum length of
                     the value. </p>
                  </li>
                  <li>
                     <p>For sequences, the maximum number of items in a sequence.</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="d-o-e-in-data-model"></a>4.5 <a href="#d-o-e-in-data-model" style="text-decoration: none">Disable Output Escaping</a></h3>
               <p>For backwards compatibility reasons, XSLT 4.0
               continues to support the <code>disable-output-escaping</code> feature introduced in
               XSLT 1.0. This is an optional feature and implementations are not
                  <span class="verb">required</span> to support it. A new facility, that of named <a title="character map" class="termref" href="#dt-character-map">character maps</a> (see <a href="#character-maps"><i>26.3 Character Maps</i></a>) was introduced in XSLT 2.0. It provides
               similar capabilities to <code>disable-output-escaping</code>, but without distorting
               the data model.</p>
               <p>If an <a title="implementation" class="termref" href="#dt-implementation">implementation</a> supports the
                  <code>disable-output-escaping</code> attribute of <a href="#element-text"><code>xsl:text</code></a> and
                  <a href="#element-value-of"><code>xsl:value-of</code></a>, (see <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a>),
               then the data model for trees constructed by the <a title="processor" class="termref" href="#dt-processor">processor</a> is augmented with a boolean value representing the value of
               this property. This boolean value, however, can be set only within a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> that is being passed to the
               serializer.</p>
               <p>Conceptually, each character in a text node on such a result tree has a boolean
               property indicating whether the serializer is to disable the normal rules for
               escaping of special characters (for example, outputting of <code>&amp;</code> as
                  <code>&amp;amp;</code>) in respect of this character.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In practice, the nodes in a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                     tree</a> will often be streamed directly from the XSLT processor to the
                  serializer. In such an implementation, <code>disable-output-escaping</code> can be
                  viewed not so much a property stored with nodes in the tree, but rather as
                  additional information passed across the interface between the XSLT processor and
                  the serializer.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="constructs"></a>5 <a href="#constructs" style="text-decoration: none">Features of the XSLT Language</a></h2>
            <div class="div2">
               
               <h3><a id="names"></a>5.1 <a href="#names" style="text-decoration: none">Names</a></h3>
               <div class="div3">
                  
                  <h4><a id="qname"></a>5.1.1 <a href="#qname" style="text-decoration: none">Qualified Names</a></h4>
                  <p>Many constructs appearing in a stylesheet, for example <a title="named template" class="termref" href="#dt-named-template">named templates</a>, <a title="mode" class="termref" href="#dt-mode">modes</a>, and <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a>,
                  are named using a qualified name: this consists of a local name and an optional
                  namespace URI.</p>
                  <p>In most cases where such names are written in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, 
                  the syntax for expressing the name is given by the
                  production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup> in the XPath
                  specification. In practice, this means that three forms are permitted:</p>
                  <ul>
                     <li>
                        <p>A simple <code>NCName</code> appearing on its own (without any prefix). This
                        represents the local name of the object. The interpretation of unprefixed
                        names is described below.</p>
                     </li>
                     <li>
                        <p>A <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> written in the
                        form <code>NCName ":" NCName</code> where the first part is a namespace
                        prefix and the second part is the local name. The namespace part of the
                        object’s name is then derived from the prefix by examining the
                        <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> 
                        for the element node in the stylesheet where the
                        name appears.</p>
                     </li>
                     <li>
                        <p>A <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-URIQualifiedName">URIQualifiedName</a><sup><small>XP</small></sup> in the form <code>"Q{" URI? "}" NCName</code>
                        where the two parts of the name, that is the namespace part and the local
                        part, both appear explicitly. If the URI part is omitted (for example
                           <code>Q{}local</code>), the resulting expanded QName is a QName whose
                        namespace part is absent.</p>
                     </li>
                  </ul>
                  <p>The rules for the use of these constructs generally permit
               leading and trailing whitespace, which is ignored.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>There are a few places where the third form, a URIQualifiedName, is not
                     permitted. These include the <code>name</code> attribute of
                        <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-attribute"><code>xsl:attribute</code></a> (which have
                     a separate <code>namespace</code> attribute for the purpose), and constructs
                     defined by other specifications. For example, names appearing within an
                     embedded <code>xs:schema</code> element must follow the XSD rules.</p>
                  </div>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-expanded-qname" title="expanded QName"></a>An <b>expanded
                        QName</b> is a value in the value space of the <code>xs:QName</code>
                     datatype as defined in the XDM data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>): that is, a triple containing namespace prefix (optional), namespace URI
                     (optional), and local name. Two expanded QNames are equal if the namespace URIs
                     are the same (or both absent) and the local names are the same. The prefix
                     plays no part in the comparison, but is used only if the expanded QName needs
                     to be converted back to a string.<span class="definition">]</span>
               </p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-eqname" title="EQName"></a>An <b>EQName</b> is a string
                     representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where
                     the string, after removing leading and trailing whitespace, is in the form
                     defined by the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>
                     production in the XPath specification.<span class="definition">]</span></p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-lexical-qname" title="lexical QName"></a>A <b>lexical QName</b>
                     is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                        QName</a> where the string, after removing leading and trailing
                     whitespace, is within the lexical space of the <code>xs:QName</code> datatype
                     as defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local
                     name optionally preceded by a namespace prefix and a colon.<span class="definition">]</span>
               </p>
                  <p>Note that every <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is an
                     <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, but the converse is not true.</p>
                  <p>The following rules are used when interpreting a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>:</p>
                  <ol class="enumar">
                     <li>
                        <p>
                        <span class="definition">[Definition:&nbsp;</span><a id="dt-defining-element" title="defining element"></a>A string in the
                           form of a lexical QName may occur as the value of an attribute node in a
                           stylesheet module, or within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in an attribute or text node within a stylesheet module, or as the
                           result of evaluating an XPath expression contained in such a node. The
                           element containing this attribute or
                              text node is referred to as the <b>defining element</b>
                           of the lexical QName.<span class="definition">]</span>
                     </p>
                     </li>
                     <li>
                        <p>If the lexical QName has a prefix, then the prefix is expanded into a URI
                        reference using the namespace declarations in effect on its <a title="defining element" class="termref" href="#dt-defining-element">defining element</a>. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> consisting of the local
                        part of the name and the possibly null URI reference is used as the name of
                        the object. The default namespace of the defining element (see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#ElementNode">7.5.2 Element nodes</a>) is <em>not</em> used for unprefixed
                        names.</p>
                        <p>
                        <a id="err-XTSE0280"><span class="error">[ERR XTSE0280] </span></a>In the case of a prefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                                 QName</a> used as the value (or as
                                 part of the value) of an attribute in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, or appearing within an
                              XPath <a title="expression" class="termref" href="#dt-expression">expression</a> in the
                              stylesheet, it is a <a title="static error" class="termref" href="#dt-static-error">static
                                 error</a> if the <a title="defining element" class="termref" href="#dt-defining-element">defining
                                 element</a> has no namespace node whose name matches the
                              prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                              QName</a>.
                     </p>
                        <p>
                        <a id="err-XTDE0290"><span class="error">[ERR XTDE0290] </span></a>Where the result of evaluating an XPath expression (or an attribute
                              value template) is required to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, or if it is permitted to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> and the actual value
                              takes the form of a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                                 QName</a>, then unless otherwise specified it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value
                              has a prefix and the <a title="defining element" class="termref" href="#dt-defining-element">defining
                                 element</a> has no namespace node whose name matches that
                              prefix. This error <span class="verb">may</span> be raised as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the
                              expression can be determined statically.
                     </p>
                     </li>
                     <li>
                        <p>If the lexical QName has no prefix, then:</p>
                        <ol class="enumla">
                           <li>
                              <p>In the case of an unprefixed QName used as a <code>NameTest</code>
                              within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> (see
                                 <a href="#expressions"><i>5.2 Expressions</i></a>), and in certain other contexts, the
                              namespace to be used in expanding the QName may be specified by means
                              of the <code>[xsl:]xpath-default-namespace</code> attribute, as
                              specified in <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>.</p>
                           </li>
                           <li>
                              <p>If the name is in one of the following categories, then the default
                              namespace of the <a title="defining element" class="termref" href="#dt-defining-element">defining
                                 element</a> is used:</p>
                              <ol class="enumlr">
                                 <li>
                                    <p>Where a QName is used to define the name of an element being
                                    constructed. This applies both to cases where the name is known
                                    statically (that is, the name of a literal result element) and
                                    to cases where it is computed dynamically (the value of the
                                       <code>name</code> attribute of the
                                       <a href="#element-element"><code>xsl:element</code></a> instruction).</p>
                                 </li>
                                 <li>
                                    <p>The default namespace is used when expanding the first argument
                                    of the function <a href="#func-element-available"><code>element-available</code></a>.</p>
                                 </li>
                                 <li>
                                    <p>The default namespace applies to any unqualified element names
                                    appearing in the <code>cdata-section-elements</code>
                                    or
                                          <code>suppress-indentation</code> attributes of
                                       <a href="#element-output"><code>xsl:output</code></a> or
                                       <a href="#element-result-document"><code>xsl:result-document</code></a>
                                 </p>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>In all other cases, a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                                 QName</a> with no prefix represents an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> in no namespace
                              (that is, an <code>xs:QName</code> value in which both the prefix and
                              the namespace URI are absent).</p>
                           </li>
                        </ol>
                     </li>
                  </ol>
               </div>
               <div class="div3">
                  
                  <h4><a id="unprefixed-qnames"></a>5.1.2 <a href="#unprefixed-qnames" style="text-decoration: none">Unprefixed Lexical QNames in Expressions and Patterns</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#additional-dynamic-context">next</a> | <a href="#multiple-schemas">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     The <code>[xsl:]xpath-default-namespace</code> attribute can be set to the value
                     <code>##any</code>, which causes unprefixed element names to match in any namespace
                     or none.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/296">296</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1181">1181</a>&nbsp;30 April 2024]</i></p>
                        </li>
                     </ol>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="unprefixed-element-names"></a>5.1.2.1 <a href="#unprefixed-element-names" style="text-decoration: none">Unprefixed Element Names</a></h5>
                     <p>The attribute <code>[xsl:]xpath-default-namespace</code> (see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>) 
                  may be used on an element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to define the 
                  namespace that will be used for an unprefixed element or type name within an XPath expression, and
                  in certain other contexts listed below.</p>
                     <p>The value of the attribute is either the namespace URI to be used, or a zero-length string,
                  or the value <code>##any</code>.</p>
                     <p>For any element in the stylesheet, this attribute has an effective value, which is the value of 
                     the <code>[xsl:]xpath-default-namespace</code> on that element or on the innermost containing 
                     element that specifies such an attribute, or the zero-length string if no containing 
                     element specifies such an attribute.</p>
                     <p>For any element in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, the
                     effective value of the attribute determines the value of the 
                     <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-namespace-elements-and-types">default namespace for elements and types</a><sup><small>XP</small></sup>
                     in the static context of any XPath
                     expression contained in an attribute or text
                     node of that element (including XPath expressions in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>
                     and <a title="text value template" class="termref" href="#dt-text-value-template">text value
                        templates</a>). The effect of this is specified in <a href="#xpath-40">[XPath 4.0]</a>; in summary, 
                     it determines the namespace used for any
                     unprefixed type name or element name.</p>
                     <p>The special value <code>##any</code> only affects:</p>
                     <ul>
                        <li>
                           <p>An unprefixed element name used in a 
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup>, 
                        either within an XPath expression or a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.
                        Its effect is that an unprefixed name matches any element having the required local name,
                        irrespective of the namespace URI (or lack of it). A pattern such as <code>match="title"</code>
                        is therefore interpreted as a wildcard match <code>match="*:title</code>. The default priority
                        of such a pattern changes accordingly.</p>
                        </li>
                        <li>
                           <p>An unprefixed type name; the effect is to treat the name as
                     referring to a type whose namespace is <code>http://www.w3.org/2001/XMLSchema</code>.</p>
                        </li>
                     </ul>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>To take an example, older versions of the internet index of RFCs (requests for comments)
                     use the namespace URI <code>http://www.rfc-editor.org/rfc-index</code>, while newer
                     versions use <code>https://www.rfc-editor.org/rfc-index</code> (note the change of URI scheme).
                     XSLT code that needs to work with either version can be simplified by setting the
                     default namespace to <code>##any</code>: but be aware that this might lead to spurious matching
                     of names in an unrelated namespace.</p>
                     </div>
                     <p>Any other value of this attribute sets the default namespace for any of the following
                     constructs appearing within its scope:</p>
                     <ul>
                        <li>
                           <p>any unprefixed element name used in a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>
                        </p>
                        </li>
                        <li>
                           <p>any unprefixed element name used in the <code>elements</code> attribute of
                           the <a href="#element-strip-space"><code>xsl:strip-space</code></a> or <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
                           instructions</p>
                        </li>
                        <li>
                           <p>any unprefixed element name used in the <code>as</code>
                           attribute of an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>
                        </p>
                        </li>
                        <li>
                           <p>any unprefixed type name used in the <code>type</code> attribute of an 
                           <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>
                        </p>
                        </li>
                        <li>
                           <p>any unprefixed type name used in the <code>xsl:type</code> attribute of a 
                           literal result element.
                        </p>
                        </li>
                     </ul>
                     <p>The <code>[xsl:]xpath-default-namespace</code> attribute <span class="verb">must</span>
                  be in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> if and only if
                  its parent element is <em>not</em> in the XSLT namespace.</p>
                     <p>If the effective value of the attribute is a zero-length string, which will be the
                  case if it is explicitly set to a zero-length string or if it is not specified at
                  all, then an unprefixed element name or type name refers to a name that is in no
                  namespace. The default namespace of the parent element (see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#ElementNode">7.5.2 Element nodes</a>) 
                  is <em>not</em> used.</p>
                     <p>The attribute does not affect other names, for example function names, 
                     variable names, or template names, or strings that are interpreted 
                     as lexical QNames during stylesheet evaluation, such as the effective value 
                     of the name attribute of <a href="#element-element"><code>xsl:element</code></a> or the string supplied as the first 
                     argument to the <code>key</code> function.
                  </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="unprefixed-function-names"></a>5.1.2.2 <a href="#unprefixed-function-names" style="text-decoration: none">Unprefixed Function Names</a></h5>
                     <p>Unprefixed function names are treated as names in the 
                     <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="other-unprefixed-names"></a>5.1.2.3 <a href="#other-unprefixed-names" style="text-decoration: none">Other Unprefixed Names</a></h5>
                     <p>For other unprefixed names, for example variable
                     names, template names, mode names, or strings that are interpreted as <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QNames</a> during stylesheet evaluation,
                     such as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                     <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a> or the string
                     supplied as the first argument to the <a href="#func-key"><code>key</code></a> function, any unprefixed
                  lexical QName is taken as being a no-namespace name.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="reserved-namespaces"></a>5.1.3 <a href="#reserved-namespaces" style="text-decoration: none">Reserved Namespaces</a></h4>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-reserved-namespace" title="reserved namespace"></a>The XSLT namespace,
                     together with certain other namespaces recognized by an XSLT processor, are
                     classified as <b>reserved namespaces</b> and <span class="verb">must</span> be
                     used only as specified in this and related specifications.<span class="definition">]</span> The
                  reserved namespaces are those listed below.</p>
                  <p>Each of the reserved namespaces has a conventional
               prefix. As described in <a href="#fixed-namespaces"><i>3.6.1 The fixed-namespaces Attribute</i></a>, the <code>fixed-namespaces</code>
               attribute may bind one of the reserved namespaces simply by referring to its conventional
               prefix. For example, <code>fixed-namespaces="xs"</code> has the effect of binding the prefix
               <code>xs</code> to the namespace <code>http://www.w3.org/2001/XMLSchema</code>.</p>
                  <ul>
                     <li>
                        <p>The <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> described in
                        <a href="#xslt-namespace"><i>3.1.1 XSLT Namespace</i></a>, is reserved, 
                        <span>with conventional prefix <code>xsl</code></span>.</p>
                     </li>
                     <li>
                        <p>
                        <span class="definition">[Definition:&nbsp;</span><a id="dt-standard-function-namespace" title="standard function namespace"></a>The <b>standard function
                              namespace</b>
                           <code>http://www.w3.org/2005/xpath-functions</code>,
                           <span>with conventional prefix <code>fn</code></span>,
                           is used for functions
                           in the function library defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> and
                           for standard functions defined in this specification.<span class="definition">]</span>
                     </p>
                     </li>
                     <li>
                        <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/math</code>,
                        <span>with conventional prefix <code>math</code></span>,
                        is used for
                        mathematical functions in the function library defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. </p>
                     </li>
                     <li>
                        <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/map</code>,
                        <span>with conventional prefix <code>map</code></span>,
                        is used for
                        functions defined in this specification relating to the manipulation of
                           maps. </p>
                     </li>
                     <li>
                        <p> The namespace
                           <code>http://www.w3.org/2005/xpath-functions/array</code>,
                        <span>with conventional prefix <code>array</code></span>,
                        is reserved for
                        use as described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p>
                     </li>
                     <li>
                        <p>
                        <span class="definition">[Definition:&nbsp;</span><a id="xml-namespace" title="XML namespace"></a>The <b>XML
                              namespace</b>, defined in <a href="#xml-names">[Namespaces in XML]</a> as
                              <code>http://www.w3.org/XML/1998/namespace</code>, is used for
                           attributes such as <code>xml:lang</code>, <code>xml:space</code>, and
                              <code>xml:id</code>.<span class="definition">]</span> 
                        <span>This namespace is always bound to the prefix <code>xml</code>.</span>
                     </p>
                     </li>
                     <li>
                        <p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-namespace" title="schema namespace"></a>The <b>schema
                              namespace</b>
                           <code>http://www.w3.org/2001/XMLSchema</code>,
                        <span>with conventional prefix <code>xs</code></span>,
                        is used as defined in
                              <a href="#xmlschema-1">[XML Schema Part 1]</a><span class="definition">]</span>. In a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> this namespace may be used to
                        refer to built-in schema datatypes and to the constructor functions
                        associated with those datatypes.</p>
                     </li>
                     <li>
                        <p><span class="definition">[Definition:&nbsp;</span><a id="dt-schema-instance-namespace" title="schema instance namespace"></a>The <b>schema instance namespace</b>
                           <code>http://www.w3.org/2001/XMLSchema-instance</code>,
                        <span>with conventional prefix <code>xsi</code></span>,
                        is used as defined
                           in <a href="#xmlschema-1">[XML Schema Part 1]</a><span class="definition">]</span>. Attributes in this namespace,
                        if they appear in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, are
                        treated by the XSLT processor in the same way as any other attributes.</p>
                     </li>
                     <li>
                        <p><span class="definition">[Definition:&nbsp;</span><a id="dt-standard-error-namespace" title="standard error namespace"></a>The <b>standard error namespace</b>
                           <code>http://www.w3.org/2005/xqt-errors</code>,
                        <span>with conventional prefix <code>err</code></span>,
                        is used for error codes
                           defined in this specification and related specifications. It is also used
                           for the names of certain predefined variables accessible within the scope
                           of an <a href="#element-catch"><code>xsl:catch</code></a> element.<span class="definition">]</span></p>
                     </li>
                     <li>
                        <p>The namespace <code>http://www.w3.org/2000/xmlns/</code> is reserved for use
                        as described in <a href="#xml-names">[Namespaces in XML]</a>. No element or attribute node can
                        have a name in this namespace, and although the prefix <code>xmlns</code> is
                        implicitly bound to this namespace, no namespace node will ever define this
                        binding.</p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>With the exception of the XML namespace, any of the above namespaces that are
                     used in a stylesheet must be explicitly declared with a namespace declaration.
                     Although conventional prefixes are used for these namespaces in this
                     specification, any prefix may be used in a user stylesheet.</p>
                  </div>
                  <p>Reserved namespaces may be used without restriction to refer to the names of
                  elements and attributes in source documents and result documents. As far as the
                  XSLT processor is concerned, reserved namespaces other than the XSLT namespace may
                  be used without restriction in the names of <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a> and <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a>, and in the names of
                  attributes of literal result elements or of <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT
                     elements</a>: but other processors <span class="verb">may</span> impose
                  restrictions or attach special meaning to them. Reserved namespaces <span class="verb">must
                     not</span> be used, however, in the names of stylesheet-defined objects such
                  as <a title="variable" class="termref" href="#dt-variable">variables</a> and <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>,
                     nor in the names of <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>
                     or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>.</p>
                  <p>It is not an error to use a reserved namespace in the name of an 
                  <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attribute</a>: 
                  attributes such as <code>xml:space</code> and <code>xsi:type</code> 
                  fall into this category. XSLT processors <span class="verb">must not</span> reject such attributes, 
                  and <span class="verb">must not</span> attach any meaning to them other than any meaning 
                  defined by the relevant specification.</p>
                  <p>
                  <a id="err-XTSE0080"><span class="error">[ERR XTSE0080] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a
                           <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the
                        name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a
                           <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, a
                           <a title="decimal format" class="termref" href="#dt-decimal-format">decimal-format</a>, a <a title="variable" class="termref" href="#dt-variable">variable</a> or <a title="parameter" class="termref" href="#dt-parameter">parameter</a>, a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                           function</a>, a named <a title="output definition" class="termref" href="#dt-output-definition">output
                           definition</a>, an <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>, or a <a title="character map" class="termref" href="#dt-character-map">character map</a><span>; except that the name
                              <code>xsl:initial-template</code> is permitted as a template
                           name.</span>
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The name <code>xsl:original</code> is used within <a href="#element-override"><code>xsl:override</code></a>
                     to refer to a <a title="component" class="termref" href="#dt-component">component</a> that is being overridden. Although
                     the name <code>xsl:original</code> is used to refer to the component, the
                     component has its own name, and no component ever has the name
                        <code>xsl:original</code>. </p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="expressions"></a>5.2 <a href="#expressions" style="text-decoration: none">Expressions</a></h3>
               <p>XSLT uses the expression language defined by XPath 4.0
               <a href="#xpath-40">[XPath 4.0]</a>. Expressions are used in XSLT for a variety of purposes
               including:</p>
               <ul>
                  <li>
                     <p>selecting nodes for processing;</p>
                  </li>
                  <li>
                     <p>specifying conditions for different ways of processing a node;</p>
                  </li>
                  <li>
                     <p>generating text to be inserted in a <a title="result tree" class="termref" href="#dt-result-tree">result
                        tree</a>.</p>
                  </li>
               </ul>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-expression" title="expression"></a>Within this specification, the term
                     <b>XPath expression</b>, or simply <b>expression</b>, means a
                  string that matches the production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup> 
                  defined in <a href="#xpath-40">[XPath 4.0]</a>.<span class="definition">]</span>
            </p>
               <p>XPath expressions may occur:</p>
               <ul>
                  <li>
                     <p>As the value of certain attributes on XSLT-defined instructions (for example,
            the <code>select</code> attribute of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction)</p>
                  </li>
                  <li>
                     <p>Within curly brackets in <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>
               and <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>.</p>
                  </li>
                  <li>
                     <p>As the content of a text node within an <a href="#element-select"><code>xsl:select</code></a> instruction.</p>
                  </li>
               </ul>
               <p>In the above cases, the static processing (compilation) of XPath expressions takes place at the same time
               as the static processing of the stylesheet itself, while evaluation of the XPath expressions takes
               place dynamically during stylesheet evaluation. There are also, however:</p>
               <ul>
                  <li>
                     <p>XPath expressions where both the static processing and dynamic evaluation of the XPath expression
               takes place during static processing of the stylesheet. These are referred to as 
                  <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>,
               and they perform the same function as preprocessing directives in other languages.</p>
                  </li>
                  <li>
                     <p>XPath expressions that are dynamically constructed (as character strings):
               both the static processing and dynamic evaluation of these expressions occurs during stylesheet
               evaluation. See <a href="#dynamic-xpath"><i>10.5 Dynamic XPath Evaluation</i></a>.</p>
                  </li>
               </ul>
               <p>In general:</p>
               <ul>
                  <li>
                     <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> does not match 
                  the XPath production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>, or if it fails to satisfy other
               static constraints defined in the XPath specification, for example that all variable
               references <span class="verb">must</span> refer to <a title="variable" class="termref" href="#dt-variable">variables</a> 
                  that are in scope. Error codes are defined in <a href="#xpath-40">[XPath 4.0]</a>.</p>
                  </li>
                  <li>
                     <p>The transformation fails with a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> 
                  if any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> is evaluated and raises a dynamic error.
               Error codes are defined in <a href="#xpath-40">[XPath 4.0]</a>.</p>
                  </li>
                  <li>
                     <p>The transformation fails with a <a title="type error" class="termref" href="#dt-type-error">type error</a> if
               an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> raises a type error, or if
               the result of evaluating the XPath <a title="expression" class="termref" href="#dt-expression">expression</a>
               is evaluated and raises a type error, or if the XPath processor raises a type error
               during static analysis of an <a title="expression" class="termref" href="#dt-expression">expression</a>. Error
               codes are defined in <a href="#xpath-40">[XPath 4.0]</a>.</p>
                  </li>
               </ul>
               <p>There are some exceptions to these rules, for example:</p>
               <ul>
                  <li>
                     <p>Static errors may be suppressed where <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is enabled (see
                  <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>).</p>
                  </li>
                  <li>
                     <p>Dynamic errors may be caught using <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a>.</p>
                  </li>
                  <li>
                     <p>Dynamic errors evaluating a predicate within a pattern do not cause the transformation to fail,
               they merely cause the pattern not to match.</p>
                  </li>
               </ul>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-required-type" title="required type"></a>The context within a 
                  <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath 
                  <a title="expression" class="termref" href="#dt-expression">expression</a> appears may specify the <b>required
                     type</b> of the expression. The required type indicates the type of the
                  value that the expression is expected to return.<span class="definition">]</span> If no required type is
               specified, the expression may return any value: in effect, the required type is then
                  <code>item()*</code>. </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-coercion-rules" title="coercion rules"></a> The term <b>coercion rules</b> 
                  means the coercion rules defined in <a href="#xpath-40">[XPath 4.0]</a>, applied 
                  unless otherwise specified with XPath 1.0 
                  compatibility mode set to <code>false</code>.<span class="definition">]</span>
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In earlier versions of this specification, the coercion rules were referred to as the
               <b>function conversion rules.</b></p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p> These are the rules defined in <a href="#xpath-40">[XPath 4.0]</a> for converting the
                  supplied argument of a function call to the required type of that argument, as
                  defined in the function signature. The same rules are used in XSLT for converting
                  the value of a variable to the declared type of the variable, or the result of
                  evaluating a function or template body to the declared type of the function or
                  template. They are also used when parameters are supplied to a template using
                     <a href="#element-with-param"><code>xsl:with-param</code></a>. In all such cases, the rules that apply are
                  the XPath 4.0 rules without XPath 1.0 compatibility mode. The rules with XPath 1.0
                  compatibility mode set to <code>true</code> are used only for XPath function calls, and for the
                  operands of certain XPath operators. </p>
               </div>
               <p>This specification also invokes the XPath
               <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to
               convert the result of evaluating an XSLT <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> to a required type (for example, the sequence
               constructor enclosed in an <a href="#element-variable"><code>xsl:variable</code></a>,
                  <a href="#element-template"><code>xsl:template</code></a>, or <a href="#element-function"><code>xsl:function</code></a> element).</p>
               <p>Any <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> or <a title="type error" class="termref" href="#dt-type-error">type error</a> 
               that occurs when applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert
               a value to a required type results in the transformation failing, in the same way as
               if the error had occurred while evaluating an expression.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Note the distinction between the two kinds of error that may occur. Attempting to
                  convert an integer to a date is a type error, because such a conversion is never
                  possible. Type errors can be raised statically if they can be detected
                  statically, whether or not the construct in question is ever evaluated. Attempting
                  to convert the <span><code>xs:untypedAtomic</code></span> item 
                  <code>2003-02-29</code> to a date is a dynamic error rather
                  than a type error, because the problem is with this particular value, not with its
                  type. Dynamic errors are raised only if the instructions or expressions that
                  cause them are actually evaluated. </p>
               </div>
               <p>The XPath specification states (see <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-eol-handling">A.3.3 End-of-Line Handling</a>)
               that the host language must
               specify whether the XPath processor normalizes all line breaks on input, before
               parsing, and if it does so, whether it uses the rules of [XML 1.0] or [XML 1.1]. In
               the case of XSLT, all handling of line breaks is the responsibility of the XML parser
               (which may support either XML 1.0 or XML 1.1); the XSLT and XPath processors perform
               no further changes.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Most XPath expressions in a stylesheet appear within
                  XML attributes. They are therefore subject to XML line-ending normalization (for
                  example, a CRLF sequence is normalized to LF) and also to XML attribute-value
                  normalization, which replaces tabs and newlines by spaces. Normalization of whitespace can be
                  prevented by using character references such as <code>&amp;#x9;</code>.</p>
                  <p>XPath expressions appearing in text nodes, (specifically, in text value templates
                  — see <a href="#text-value-templates"><i>5.6.2 Text Value Templates</i></a>,  
                  or in the <a href="#element-select"><code>xsl:select</code></a> instruction) 
                  are subject to line-ending normalization but not
                  attribute-value normalization.</p>
                  <p>In both cases it is unwise to include the characters <span class="unicode-codepoint">U+0009</span> (<span class="unicode-name">TAB</span>) ,
               <span class="unicode-codepoint">U+000A</span> (<span class="unicode-name">NEWLINE</span>) , and <span class="unicode-codepoint">U+000D</span> (<span class="unicode-name">CARRIAGE RETURN</span>) , as literal characters within string literals.
               Instead they should be escaped as <code>&amp;#x9;</code>, <code>&amp;#xA;</code>,
               and <code>&amp;#xD;</code> respectively, or constructed dynamically by a call on 
               the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-char"><code>char</code></a> function. This can be conveniently embedded
               within a string template delimited by backticks: for example <code>`Width:{char(9)}8mm`</code>.
               (The advantage of using this form in preference to XML character references is that
               they are more likely to survive when the stylesheet is processed using tools such as XML editors.)</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="static-and-dynamic-context"></a>5.3 <a href="#static-and-dynamic-context" style="text-decoration: none">The Static and Dynamic Context</a></h3>
               <p>XPath defines the concept of an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-expression-context">expression context</a><sup><small>XP</small></sup> which contains all the information that can affect
               the result of evaluating an <a title="expression" class="termref" href="#dt-expression">expression</a>. The
               expression context has two parts, the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup>, and the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-context">dynamic context</a><sup><small>XP</small></sup>. The components that make up the expression context
               are defined in the XPath specification (see <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#context">2.2 Expression Context</a>).
               This section describes the way in which these components are initialized when an
               XPath expression is contained within an XSLT stylesheet.</p>
               <p>
               This section does not apply to <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a> 
               (whose context is defined in <a href="#static-expression"><i>9.7 Static Expressions</i></a>), nor to XPath expressions 
               evaluated using <a href="#element-evaluate"><code>xsl:evaluate</code></a> (whose context is defined in 
               <a href="#evaluate-dynamic-context"><i>10.5.2 Dynamic context for the target expression</i></a>).
            </p>
               <p>As well as providing values for the static and dynamic context components defined in
               the XPath specification, XSLT defines additional context components of its own. These
               context components are used by XSLT instructions (for example,
                  <a href="#element-next-match"><code>xsl:next-match</code></a> and <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>), and also
               by the functions in the extended function library described in this
               specification.</p>
               <p>The following four sections describe:</p>
               <blockquote>
                  <p>
                  <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a>
               <br>
                  <a href="#additional-static-context"><i>5.3.2 Additional Static Context Components used by XSLT</i></a>
               <br>
                  <a href="#xpath-dynamic-context"><i>5.3.3 Initializing the Dynamic Context</i></a>
               <br>
                  <a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a>
               </p>
               </blockquote>
               <div class="div3">
                  
                  <h4><a id="static-context"></a>5.3.1 <a href="#static-context" style="text-decoration: none">Initializing the Static Context</a></h4>
                  <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup> of an
                  XPath expression appearing in an XSLT stylesheet is initialized as follows. In
                  these rules, the term <b>containing element</b> means the element within the
                  stylesheet that is the parent of the attribute or text
                     node whose value contains the XPath expression in question, and the
                  term <b>enclosing element</b> means the containing element or any of its
                  ancestors.</p>
                  <ul>
                     <li>
                        <p>
                        <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a>
                        is set to <code>true</code> if and only if the containing element is processed with
                           <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a> (see
                           <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>).</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-namespaces">statically known
                           namespaces</a><sup><small>XP</small></sup> are the 
                        <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span>
                        for the containing element.</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-namespace-elements-and-types">default namespace
                           for elements and types</a><sup><small>XP</small></sup> is determined as described in
                        <a href="#unprefixed-element-names"><i>5.1.2.1 Unprefixed Element Names</i></a>.</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-function-namespace">default function namespace</a><sup><small>XP</small></sup> is
                        <code>http://www.w3.org/2005/xpath-functions</code> (and cannot be changed).</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema
                           definitions</a><sup><small>XP</small></sup> for the XPath expression are the same as the
                           <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema
                           components</a> for the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, and are as specified in <a href="#built-in-types"><i>3.12 Built-in Types</i></a>.</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-variables">in-scope
                           variables</a><sup><small>XP</small></sup> are defined by the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding elements</a>
                        that are in scope for the containing element (see <a href="#variables-and-parameters"><i>9 Variables and Parameters</i></a>).</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known
                           function definitions</a><sup><small>XP</small></sup> are:</p>
                        <ul>
                           <li>
                              <p>The functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in
                              namespaces <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/math</code>;</p>
                           </li>
                           <li>
                              <p>The functions defined in this specification in namespaces
                                 <code>http://www.w3.org/2005/xpath-functions</code> and
                                 <code>http://www.w3.org/2005/xpath-functions/map</code>;</p>
                           </li>
                           <li>
                              <p>Constructor functions for all the simple types in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup>, including both built-in
                              types and user-defined types;</p>
                           </li>
                           <li>
                              <p>The <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                                 functions</a> defined in the containing <a title="package" class="termref" href="#dt-package">package</a>;</p>
                           </li>
                           <li>
                              <p>Stylesheet functions defined in used packages, subject to visibility:
                              see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>;</p>
                           </li>
                           <li>
                              <p>any <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>
                              bound using <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanisms (see <a href="#extension"><i>24 Extensibility and Fallback</i></a>).</p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>The term <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> includes both
                                 vendor-supplied and user-written extension functions.</p>
                              </div>
                           </li>
                        </ul>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>It follows from the above that a conformant XSLT processor must implement
                           the entire library of functions defined in
                                 <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> as well as those defined
                           in this specification.</p>
                        </div>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-collations">statically known
                           collations</a><sup><small>XP</small></sup> are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, except that they <span class="verb">must</span> always include (a) the Unicode
                           codepoint collation, defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#string-compare">5.3 Comparison of strings</a>, and (b) the family of UCA collations described
                           in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#uca-collations">5.3.4 The Unicode Collation Algorithm</a>.</p>
                     </li>
                     <li>
                        <p><b>Static base URI</b>: In a conventional interpreted 
                        environment, the static base URI of an expression in the stylesheet is the base URI 
                        of the containing element in the stylesheet. The concept of the base URI of a node 
                        is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-base-uri">7.6.2 base-uri Accessor</a>.</p>
                        <p>When stylesheets are executed in an environment where no source code is present
                        (for example, because the code of the stylesheet has been compiled and is distributed 
                        as executable object code), it is <span class="verb">recommended</span> (subject to operational
                        constraints such as security) that the static base URI used during stylesheet evaluation
                        should be the location from which the stylesheet was loaded for execution 
                        (its “deployed location”). This means, for example, that when the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>
                        or <a href="#func-document"><code>document</code></a> functions are called with a relative URI, the required document
                        is by default located relative to the deployed location of the stylesheet.
                     </p>
                        <p>Whether or not the stylesheet is executed directly from source code,
                     it is possible that no static base URI is available, for example because the code was supplied
                     as an anonymous input stream, or because security policies are set to prevent executable code discovering
                     the location from which it was loaded. If the static base URI is not known, the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-static-base-uri"><code>static-base-uri</code></a>
                     function returns the empty sequence, and other operations that depend on the static base URI may fail with
                     a dynamic error.</p>
                     </li>
                     <li>
                        <p>The set of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically
                           known decimal formats</a><sup><small>XP</small></sup> is the set of decimal formats defined by
                           <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in the stylesheet. </p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="additional-static-context"></a>5.3.2 <a href="#additional-static-context" style="text-decoration: none">Additional Static Context Components used by XSLT</a></h4>
                  <p>Some of the components of the XPath static context are used also by <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>. For example, the
                     <a href="#element-sort"><code>xsl:sort</code></a> element makes use of the collations defined in the
                  static context, and attributes such as <code>type</code> and <code>as</code> may
                  reference types defined in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>.</p>
                  <p>Many top-level declarations in a stylesheet, and attributes on the
                     <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, affect the behavior of instructions
                  within the stylesheet. Each of these constructs is described in its appropriate
                  place in this specification.</p>
                  <p>A number of these constructs are of particular significance because they are used
                  by functions defined in XSLT, which are added to the library of functions
                  available for use in XPath expressions within the stylesheet. These are:</p>
                  <ul>
                     <li>
                        <p>The set of named keys, used by the <a href="#func-key"><code>key</code></a> function</p>
                     </li>
                     <li>
                        <p>The set of named character maps, used by the <a href="#func-character-map"><code>character-map</code></a> function</p>
                     </li>
                     <li>
                        <p>The values of system properties, used by the
                           <a href="#func-system-property"><code>system-property</code></a> function</p>
                     </li>
                     <li>
                        <p>The set of available instructions, used by the
                           <a href="#func-element-available"><code>element-available</code></a> function</p>
                     </li>
                     <li>
                        <p>The <a title="default mode" class="termref" href="#dt-default-mode">default mode</a>, used by the
                     <a href="#func-apply-templates"><code>apply-templates</code></a> function</p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If these functions are called within a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>, the results will reflect the capabilities and
                     configuration of the processor used to perform static analysis, while if they
                     are called elsewhere, the results should reflect the capabilities and
                     configuration of the processor used to perform dynamic evaluation, which might
                     give a different result. These calls should not be pre-evaluated at compile
                     time unless it is known that this will give the same result.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="xpath-dynamic-context"></a>5.3.3 <a href="#xpath-dynamic-context" style="text-decoration: none">Initializing the Dynamic Context</a></h4>
                  <p>For convenience, the dynamic context is described in two parts: the <a title="focus" class="termref" href="#dt-focus">focus</a>, which represents the place in the source
                  document that is currently being processed, and a collection of additional context
                  variables.</p>
                  <p>A number of functions specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> are defined
                  to be <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>,
                  meaning that if they are called twice during the same <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO</small></sup>, with the same arguments, then
                  they return the same results (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#terminology">1.9 Terminology</a>). In
                  XSLT, the execution of a stylesheet defines the execution scope. This means, for
                  example, that if the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>current-dateTime</code></a> is called
                  repeatedly during a transformation, it produces the same result each time. By
                  implication, the components of the dynamic context on which these functions depend
                  are also stable for the duration of the transformation. Specifically, the
                  following components defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#eval_context">2.2.2 Dynamic Context</a> must be
                  stable: <em>function implementations</em>, <em>current dateTime</em>,
                     <em>implicit timezone</em>, <em>available documents</em>,
                     <em>available collections</em>, and <em>default collection</em>. The
                  values of global variables and stylesheet parameters are also stable for the
                  duration of a transformation. The focus is <em>not</em> stable; the additional
                  dynamic context components defined in <a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a>
                  are also <em>not</em> stable.</p>
                  <p>As specified in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>, implementations may provide
                  user options that relax the requirement for the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> and
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions (and therefore, by implication, the
                     <a href="#func-document"><code>document</code></a> function) to return stable results. By default,
                  however, the functions must be stable. The manner in which such user options are
                  provided, if at all, is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
                  <p>XPath expressions contained in <code>[xsl:]use-when</code> attributes are not
                  considered to be evaluated “during the transformation” as defined above. For
                  details see <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>.</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-absent" title="absent"></a>A component of the context
                     that has no value is said to be <b>absent</b>.<span class="definition">]</span> This is a
                  distinguishable state, and is not the same as having the empty sequence as its
                  value.</p>
                  <div class="div4">
                     
                     <h5><a id="focus"></a>5.3.3.1 <a href="#focus" style="text-decoration: none">Maintaining Position: the Focus</a></h5>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-focus" title="focus"></a>When a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is
                        evaluated, the <a title="processor" class="termref" href="#dt-processor">processor</a> keeps track
                        of which items are being processed by means of a set of implicit variables
                        referred to collectively as the <b>focus</b>.<span class="definition">]</span> More
                     specifically, the focus consists of the following three values:</p>
                     <ul>
                        <li>
                           <p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-item" title="context item"></a>The <b>context
                                 item</b> is the item currently being processed. An item (see
                                 <a href="#xpath-datamodel-40">[XDM 4.0]</a>) is either an atomic item (such
                              as an integer, date, or string), a node, or
                                 a function item. It changes whenever instructions such as
                                 <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and
                                 <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of
                              items; each item in such a sequence becomes the context item while
                              that item is being processed.<span class="definition">]</span> The context item is returned
                           by the XPath <a title="expression" class="termref" href="#dt-expression">expression</a>
                           <code>.</code> (dot).</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Although XPath 4.0 allows the context value to be an arbitrary sequence,
                           at the interface between XSLT 4.0 and XPath 4.0 it is always either a single item,
                           or absent. XSLT 4.0 therefore continues to use the term <a title="context item" class="termref" href="#dt-context-item">context item</a>
                        rather than <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup>.</p>
                           </div>
                        </li>
                        <li>
                           <p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-position" title="context position"></a>The
                                 <b>context position</b> is the position of the context item
                              within the sequence of items currently being processed. It changes
                              whenever the context item changes. When an instruction such as
                                 <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or
                                 <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process a sequence of
                              items, the first item in the sequence is processed with a context
                              position of 1, the second item with a context position of 2, and so
                              on.<span class="definition">]</span> The context position is returned by the XPath <a title="expression" class="termref" href="#dt-expression">expression</a>
                           <code>position()</code>.</p>
                        </li>
                        <li>
                           <p><span class="definition">[Definition:&nbsp;</span><a id="dt-context-size" title="context size"></a>The <b>context
                                 size</b> is the number of items in the sequence of items
                              currently being processed. It changes whenever instructions such as
                                 <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and
                                 <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of
                              items; during the processing of each one of those items, the context
                              size is set to the count of the number of items in the sequence (or
                              equivalently, the position of the last item in the
                              sequence).<span class="definition">]</span> The context size is returned by the XPath
                              <a title="expression" class="termref" href="#dt-expression">expression</a>
                           <code>last()</code>.</p>
                        </li>
                     </ul>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-context-node" title="context node"></a>If the <a title="context item" class="termref" href="#dt-context-item">context item</a> is a node (as distinct from
                        an atomic item such as an integer), then it is also referred to as the
                           <b>context node</b>. The context node is not an independent
                        variable, it changes whenever the context item changes. When the context
                        item is an atomic item or a function
                           item, there is no context node.<span class="definition">]</span> The context node is
                     returned by the XPath <a title="expression" class="termref" href="#dt-expression">expression</a>
                     <code>self::node()</code>, and it is used as the starting node for all relative
                     path expressions.</p>
                     <p>Where the containing element of an XPath expression is an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> or a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, the
                     initial context item, context position, and context size for the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> are the same as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, <a title="context position" class="termref" href="#dt-context-position">context position</a>, and <a title="context size" class="termref" href="#dt-context-size">context size</a> for the evaluation of the
                     containing instruction or literal result element.</p>
                     <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup> for evaluating global
                        variables <span>declared</span>
                     in the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> is set to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>
                        supplied when the transformation is invoked (see <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>).
                     <span>For global variables declared in a </span> <a title="library package" class="termref" href="#dt-library-package">library
                           package</a>, the context value  is
                     <a title="absent" class="termref" href="#dt-absent">absent</a>. </p>
                     <p>For an XPath expression contained in a <a title="value template" class="termref" href="#dt-value-template">value template</a>, the initial context item, context position, and
                     context size for the XPath <a title="expression" class="termref" href="#dt-expression">expression</a>
                     are the same as the <a title="context item" class="termref" href="#dt-context-item">context item</a>,
                        <a title="context position" class="termref" href="#dt-context-position">context position</a>, and <a title="context size" class="termref" href="#dt-context-size">context size</a> for the evaluation of the
                     containing <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p>
                     <p>In other cases (for example, where the containing element is
                        <a href="#element-sort"><code>xsl:sort</code></a>, <a href="#element-with-param"><code>xsl:with-param</code></a>, or
                        <a href="#element-key"><code>xsl:key</code></a>), the rules are given in the specification of the
                     containing element.</p>
                     <p>The <a href="#func-current"><code>current</code></a> function can be used within any XPath <a title="expression" class="termref" href="#dt-expression">expression</a> to select the item that was
                     supplied as the context item to the XPath expression by the XSLT processor.
                     Unlike <code>.</code> (dot) this is unaffected by changes to the context item
                     that occur within the XPath expression. The <a href="#func-current"><code>current</code></a>
                     function is described in <a href="#func-current"><i>20.5.1 fn:current</i></a>.</p>
                     <p>On completion of an instruction that changes the <a title="focus" class="termref" href="#dt-focus">focus</a> (such as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or
                        <a href="#element-for-each"><code>xsl:for-each</code></a>), the focus reverts to its previous value.</p>
                     <p>When a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> is
                     called, the focus within the body of the function is initially <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
                     <p>When the focus is <a title="absent" class="termref" href="#dt-absent">absent</a>, evaluation of any
                        <a title="expression" class="termref" href="#dt-expression">expression</a> that references the
                     context item, context position, or context size results in a <a title="type error" class="termref" href="#dt-type-error">type error</a>
                     <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup></p>
                     <p>The description above gives an outline of the way the <a title="focus" class="termref" href="#dt-focus">focus</a> works. Detailed rules for the effect of each instruction
                     are given separately with the description of that instruction. In the absence
                     of specific rules, an instruction uses the same focus as its parent
                     instruction. </p>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-singleton-focus" title="singleton focus"></a>A <b>singleton
                           focus</b> based on an item <var>J</var> has the <a title="context item" class="termref" href="#dt-context-item">context item</a> (and
                           therefore the <a title="context node" class="termref" href="#dt-context-node">context node</a>, if
                              <var>J</var> is a node) set to <var>J</var>, and the <a title="context position" class="termref" href="#dt-context-position">context position</a> and <a title="context size" class="termref" href="#dt-context-size">context size</a> both set to 1
                        (one).<span class="definition">]</span>
                  </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="evaluation-context"></a>5.3.3.2 <a href="#evaluation-context" style="text-decoration: none">Other Components of the XPath Dynamic Context</a></h5>
                     <p>The previous section explained how the <a title="focus" class="termref" href="#dt-focus">focus</a>
                     for an XPath expression appearing in an XSLT stylesheet is initialized. This
                     section explains how the other components of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-context">dynamic context</a><sup><small>XP</small></sup> of an XPath expression
                     are initialized.</p>
                     <ul>
                        <li>
                           <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-variable-values">dynamic
                              variables</a><sup><small>XP</small></sup> are the current values of the in-scope <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding
                           elements</a>.</p>
                        </li>
                        <li>
                           <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamically-known-function-definitions">dynamically known function definitions</a><sup><small>XP</small></sup>
                        (representing the functions accessible using <a href="#func-function-available"><code>function-available</code></a> or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>)
                           include all the functions available in the static context, and may also include an additional 
                           <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of functions that are available dynamically but not statically.
                        </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>This set therefore includes some functions that are not available for
                        dynamic calling using <a href="#element-evaluate"><code>xsl:evaluate</code></a>, for example <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>
                        whose visibility is private, and XSLT-defined functions such as <a href="#func-current"><code>current</code></a> and <a href="#func-key"><code>key</code></a>.</p>
                           </div>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The rule that all functions present in the static context must always be present in 
                           the dynamic context is a consistency constraint. The effect of violating a consistency constraint is 
                           <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>: it does not necessarily lead to an error. 
                           For example, if the version of a used package that is available
                           at evaluation time does not include all public user-defined functions that were available in the version that was
                           used at analysis time, then a processor <span class="verb">may</span> recover by raising an error only if the function
                           is actually called. Conversely, if the evaluation-time version of the package includes additional public functions, these <span class="verb">may</span>
                        be included in the dynamic context even though they were absent from the static context. 
                        Dynamic calling of functions using <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>
                        may therefore be an effective strategy for coping with variations between versions of a library package on which a stylesheet
                        depends.</p>
                           </div>
                        </li>
                        <li>
                           <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-def-collation">default
                           collation</a><sup><small>XP</small></sup> is defined by the value of the
                           <code>[xsl:]default-collation</code> attribute on the innermost enclosing
                           element that has such an attribute. For details, see <a href="#default-collation-attribute"><i>3.6.2 The default-collation Attribute</i></a>.</p>
                           <p>
                           <span class="definition">[Definition:&nbsp;</span><a id="dt-default-collation" title="default collation"></a>In this
                              specification the term <b>default collation</b> means the collation
                              that is used by XPath operators such as <code>eq</code> and
                              <code>lt</code> appearing in XPath expressions within the
                              stylesheet.<span class="definition">]</span>
                        </p>
                           <p>This collation is also used by default when comparing strings in the
                           evaluation of the <a href="#element-key"><code>xsl:key</code></a> and
                           <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> elements. This <span class="verb">may</span>
                           also (but need not necessarily) be the same as the default collation used
                           for <a href="#element-sort"><code>xsl:sort</code></a> elements within the stylesheet. Collations
                           used by <a href="#element-sort"><code>xsl:sort</code></a> are described in <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The default collation is usually known
                        statically. One notable exception is when the function call <code>default-collation()</code>
                        appears in the initializing expression of an optional <a href="#element-function"><code>xsl:function</code></a> parameter,
                           for example:</p>
                              <div class="exampleInner">
                                 <pre>&lt;xsl:function name="f:myfunc"&gt;
  &lt;xsl:param name="collation" required="no" select="default-collation()"/&gt;
&lt;/xsl:function&gt;</pre>
                              </div>
                              <p>In this situation the call on <code>default-collation()</code> returns the default
                              collation from the context of the function call, which may differ from the default
                              collation of the function declaration.
                        </p>
                           </div>
                        </li>
                        <li>
                           <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-available-docs">available
                              documents</a><sup><small>XP</small></sup> are defined as part of the XPath 3.0 dynamic context to support the
                              <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function, but this component is also
                           referenced by the similar XSLT <a href="#func-document"><code>document</code></a> function:
                           see <a href="#func-document"><i>20.1 fn:document</i></a>. This variable defines a mapping
                           between URIs passed to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or
                              <a href="#func-document"><code>document</code></a> function and the document nodes that are
                           returned.</p>
                           <p>The mapping from URIs to document nodes is
                           affected by <a href="#element-strip-space"><code>xsl:strip-space</code></a> declarations and by the
                              <code>input-type-annotations</code> attribute, and may therefore vary
                           from one package to another.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Defining this as part of the evaluation context is a formal way of
                              specifying that the way in which URIs get turned into document nodes
                              is outside the control of the language specification, and depends
                              entirely on the run-time environment in which the transformation takes
                              place.</p>
                           </div>
                           <p>The XSLT-defined <a href="#func-document"><code>document</code></a> function allows the use of
                           URI references containing fragment identifiers. The interpretation of a
                           fragment identifier depends on the media type of the resource
                           representation. Therefore, the information supplied in 
                           <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-available-docs">available documents</a><sup><small>XP</small></sup> for
                           XSLT processing must provide not only a mapping from URIs to document
                           nodes as required by XPath, but also a mapping from URIs to media
                           types.</p>
                        </li>
                        <li>
                           <p>All other aspects of the dynamic context (for example,
                           the current date and time, the implicit timezone, the default language, calendar, and place,
                           the available documents, text resources, and collections, and the default collection) are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>,
                        and do not change in the course of a single transformation, except to the extent that they
                        <span class="verb">may</span> be different from one <a title="package" class="termref" href="#dt-package">package</a> to another.</p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="additional-dynamic-context"></a>5.3.4 <a href="#additional-dynamic-context" style="text-decoration: none">Additional Dynamic Context Components used by XSLT</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#named-item-types">next</a> | <a href="#unprefixed-qnames">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     <p>XSLT-specific components of the dynamic context can now be retained in the captured
                     context of a function item, in the same way as XPath-defined components of the dynamic context.</p>
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>In addition to the values that make up the <a title="focus" class="termref" href="#dt-focus">focus</a>, an XSLT processor maintains a number of other dynamic context
                  components that reflect aspects of the evaluation context. These components are
                  fully described in the sections of the specification that maintain and use them.
                  They are:</p>
                  <ul>
                     <li>
                        <p>The <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>,
                        which is the <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> most
                        recently invoked by an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                           <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>
                        instruction: see <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>; </p>
                     </li>
                     <li>
                        <p>The <a title="current mode" class="termref" href="#dt-current-mode">current mode</a>, which is the
                           <a title="mode" class="termref" href="#dt-mode">mode</a> set by the most recent call of
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> (for a full definition see <a href="#modes"><i>6.7 Modes</i></a>);</p>
                     </li>
                     <li>
                        <p>The <a title="current group" class="termref" href="#dt-current-group">current group</a> and <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a>, which
                        provide information about the collection of items currently being processed
                        by an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
                        
                        instruction: see <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a> and <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a>;</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>In XSLT 3.0 the initial value of these two properties is “absent”, which
                           means that any reference to their values causes a dynamic error.
                           Previously, the initial value was the empty sequence. </p>
                        </div>
                     </li>
                     <li>
                        <p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>, which provide information about the
                        collection of items currently being processed by an
                           <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p>
                     </li>
                     <li>
                        <p>The <a title="current captured groups" class="termref" href="#dt-current-captured-groups">current captured groups</a>: this is maintained
                        when a string is matched against a regular expression using the
                           <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction. It is a map
                        from integer group numbers (reflecting the ordering of capturing
                        parentheses with the regular expression) to string segments: a string segment
                        is a contiguous substring of the input string being matched, characterized
                        by the position of the first and last characters of the substring within the input. 
                        The current captured groups are accessible to applications using 
                        the <a href="#func-regex-groups"><code>regex-groups</code></a> and <a href="#func-regex-group"><code>regex-group</code></a> 
                        functions: see <a href="#func-regex-group"><i>17.2.2 fn:regex-group</i></a>.</p>
                     </li>
                     <li>
                        <p>The <a title="output state" class="termref" href="#dt-output-state">output state</a>: this is a flag
                        whose two possible values are <a title="final output state" class="termref" href="#dt-final-output-state">final
                           output state</a> and <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.  The initial setting when the stylesheet is invoked by executing a
                           template is <a title="final output state" class="termref" href="#dt-final-output-state">final output
                           state</a>, and it is switched to <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a> by
                        instructions such as <a href="#element-variable"><code>xsl:variable</code></a>. For more details, see
                           <a href="#result-document-restrictions"><i>25.2 Restrictions on the use of xsl:result-document</i></a>.</p>
                     </li>
                     <li>
                        <p>The <a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a>: this
                        is the URI associated with the result tree to which instructions are
                        currently writing. The current output URI is initially the same as the
                           <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>. During the evaluation of an
                           <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, the current output URI
                        is set to the absolute URI identified by the <code>href</code> attribute of
                        that instruction.</p>
                     </li>
                  </ul>
                  <p>The following non-normative table summarizes the initial state of each of the
                  components in the evaluation context, and the instructions which cause the state
                  of the component to change.</p>
                  <table class="data">
                     <caption>Components of the Dynamic Evaluation Context</caption>
                     <thead>
                        <tr>
                           <th style="text-align:left; vertical-align:top">Component</th>
                           <th style="text-align:left; vertical-align:top">Initial Setting</th>
                           <th style="text-align:left; vertical-align:top">Set by</th>
                           <th style="text-align:left; vertical-align:top">Cleared by</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="focus" class="termref" href="#dt-focus">focus</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">See <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.</td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>,
                              <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>,
                              <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, evaluation of <a title="pattern" class="termref" href="#dt-pattern">patterns</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                                 functions</a>
                              </td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">If apply-templates invocation is used
                              (see <a href="#invoking-initial-mode"><i>2.3.3 Apply-Templates Invocation</i></a>), then for each item in the 
                              <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>
                              is initially set to the template rule chosen for processing that item. Otherwise,
                              <a title="absent" class="termref" href="#dt-absent">absent</a>.
                              </td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>,
                              <a href="#element-next-match"><code>xsl:next-match</code></a>
                              </td>
                           <td style="vertical-align:top; text-align:left">See <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>.
                              </td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current mode" class="termref" href="#dt-current-mode">current mode</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">the initial <a title="mode" class="termref" href="#dt-mode">mode</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                              </td>
                           <td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                                 functions</a>. Also cleared while evaluating global
                              variables and stylesheet parameters, <a title="pattern" class="termref" href="#dt-pattern">patterns</a>, and the sequence
                              constructor contained in <a href="#element-key"><code>xsl:key</code></a> or
                              <a href="#element-sort"><code>xsl:sort</code></a>. Clearing the current mode causes the
                              current mode to be set to the default (unnamed) mode.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current group" class="termref" href="#dt-current-group">current group</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">absent</td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
                              </td>
                           <td style="vertical-align:top; text-align:left">See <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">absent</td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
                              </td>
                           <td style="vertical-align:top; text-align:left">See <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">absent</td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-merge"><code>xsl:merge</code></a>
                              </td>
                           <td style="vertical-align:top; text-align:left">See <a href="#func-current-merge-group"><i>15.5.1 fn:current-merge-group</i></a>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>
                              </td>
                           <td style="vertical-align:top; text-align:left"><span>absent</span></td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-merge"><code>xsl:merge</code></a>
                              </td>
                           <td style="vertical-align:top; text-align:left">See <a href="#func-current-merge-key"><i>15.5.3 fn:current-merge-key</i></a> and
                              <a href="#func-current-merge-key-array"><i>15.5.2 fn:current-merge-key-array</i></a>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current captured groups" class="termref" href="#dt-current-captured-groups">current captured
                                 substrings</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">empty sequence</td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>
                              </td>
                           <td style="vertical-align:top; text-align:left">
                              <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>; Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, dynamic function calls,
                              evaluation of global variables, stylesheet
                              parameters, and <a title="pattern" class="termref" href="#dt-pattern">patterns</a>
                              </td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="output state" class="termref" href="#dt-output-state">output state</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">
                              <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">Set to <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary
                                 output state</a> by instructions such as
                              <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>, etc.,
                              and by calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                                 functions</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">None</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">
                              <a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">
                              <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>
                              </td>
                           <td style="vertical-align:top; text-align:left"><a href="#element-result-document"><code>xsl:result-document</code></a></td>
                           <td style="vertical-align:top; text-align:left">Calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                                 functions</a>, dynamic function calls, evaluation of <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>, <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and
                              <a title="pattern" class="termref" href="#dt-pattern">patterns</a>.</td>
                        </tr>
                     </tbody>
                  </table>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-initial-setting" title="initial setting"></a>The <b>initial setting</b> of a component of the dynamic context is used
                     when evaluating <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>
                     and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>,
                     when evaluating the <code>use</code> and <code>match</code> attributes of
                        <a href="#element-key"><code>xsl:key</code></a>, and when evaluating the <code>initial-value</code> of
                        <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> expressions or
                     contained sequence constructors of
                     <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a><span class="definition">]</span>.</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-non-contextual-function-call" title="non-contextual function call"></a>The term <b>non-contextual function
                        call</b> is used to refer to function calls that do not pass the dynamic
                     context to the called function. This includes all calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> and all
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-function-call">dynamic function
                        calls</a><sup><small>XP</small></sup>, (that is calls to function items). It excludes calls to some
                        functions in the namespace
                           <code>http://www.w3.org/2005/xpath-functions</code>, in
                     particular those that explicitly depend on the context, such as the
                        <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-regex-group"><code>regex-group</code></a>
                     functions. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances,
                     calls to <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are
                     non-contextual.<span class="definition">]</span></p>
                  <p>Named function references (such as <code>position#0</code>) and
                  calls on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> (for example,
                     <code>function-lookup("position", 0)</code>) are defined to retain the XPath
                  static and dynamic context at the point of invocation as part of the closure of
                  the resulting function item, and to use this preserved context when a dynamic
                  function call is subsequently made using the function item. In XSLT 4.0 this rule 
                  extends to the XSLT extensions to the dynamic context defined in this section. 
                  For example the call <code>regex-group#1</code>) delivers a function item that holds a snapshot
                  of the <a title="" class="termref" href="#"></a> in its closure, and subsequent
                  evaluation of that function item will return the relevant value from that snapshot.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="named-types"></a>5.4 <a href="#named-types" style="text-decoration: none">Named Types</a></h3>
               <p>XSLT 4.0 introduces two new and closely-related constructs allowing item
            types to be given names, and to be referred to by name anywhere that item types
            are used, for example in function declarations and variable declarations.</p>
               <p>The <a href="#element-item-type"><code>xsl:item-type</code></a> declaration allows any item type to be given
            a name. It is particularly useful to avoid repetitive use of the same choice types,
            enumeration types, or function types, and means that if the definition changes, the change only
            needs to be made in one place.</p>
               <p>The <a href="#element-record-type"><code>xsl:record-type</code></a> declaration takes this a step further.
            Like <a href="#element-item-type"><code>xsl:item-type</code></a>, it allows a name to be given to any
            record type. In addition, though, it offers two further capabilities:</p>
               <ul>
                  <li>
                     <p>Named record types can be recursive, allowing definitions of
               recursive data structures such as lists and trees.</p>
                  </li>
                  <li>
                     <p>Declaring a named record type automatically establishes
               a constructor function for records of that type; the constructor
               function has the same name as the record type itself.</p>
                  </li>
               </ul>
               <div class="div3">
                  
                  <h4><a id="named-item-types"></a>5.4.1 <a href="#named-item-types" style="text-decoration: none">Named Item Types</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#named-record-types">next</a> | <a href="#additional-dynamic-context">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     Named item types can be declared using the new <a href="#element-item-type"><code>xsl:item-type</code></a>
                     element. This is designed to avoid repeating lengthy type definitions (for example
                     function types) every time they are used.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1606">1606</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1617">1617</a>&nbsp;1 January 2022]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-item-type"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:item-type<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>item-type</var>〔'item()*'〕<br>&nbsp;&nbsp;visibility? = "private" | "public"〔'private'〕&nbsp;/&gt;</code></p>
                  <p>An <a href="#element-item-type"><code>xsl:item-type</code></a> declaration associates a name with an item type, and allows the type
               to be referenced by name throughout the stylesheet package.</p>
                  <div class="example">
                     <p>The following example declares a named item type for colors, and uses it in three variable
                     declarations and a function declaration.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:item-type name="my:color" as="enum('red', 'green', 'blue')"/&gt;
   
&lt;xsl:variable name="RED" as="my:color" select="'red'"/&gt;
&lt;xsl:variable name="GREEN" as="my:color" select="'green'"/&gt;
&lt;xsl:variable name="BLUE" as="my:color" select="'blue'"/&gt;

&lt;xsl:function name="my:html-color" as="xs:string"&gt;
  &lt;xsl:param name="color" as="my:color"/&gt;
  &lt;xsl:switch select="$color"&gt;
    &lt;xsl:when test="$RED"&gt;#FF0000&lt;/xsl:when&gt;
    &lt;xsl:when test="$GREEN"&gt;#008000&lt;/xsl:when&gt;
    &lt;xsl:when test="$BLUE"&gt;#0000FF&lt;/xsl:when&gt;
  &lt;/xsl:switch&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     <p>The following example declares a named choice type for the two binary
                     types <code>xs:hexBinary</code> and <code>xs:base64Binary</code>
                     and uses it in a function declaration that compares two such values
                     for equality.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:item-type name="my:binary" as="(xs:hexBinary | xs:base64Binary)"/&gt;

&lt;xsl:function name="my:binary-equal" as="xs:boolean"&gt;
  &lt;xsl:param name="x" as="my:binary"/&gt;
  &lt;xsl:param name="y" as="my:binary"/&gt;
  &lt;xsl:sequence select="$x eq $y"/&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                  </div>
                  <p>Using named item types makes the stylesheet more readable, and improves potential for change: a change
               to the set of colors allowed by the type <code>my:color</code> is less likely to affect users of a function
               library. However, named item types do not provide true encapsulation or information hiding; users of the 
               function library can still treat enumeration values as simple strings if they wish.</p>
                  <p>The <a href="#element-item-type"><code>xsl:item-type</code></a> declaration adds an entry to the 
                  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-named-item-types">in-scope named item types</a><sup><small>XP</small></sup>
               component of the static context for XPath expressions, and also becomes available for use wherever
               XSLT allows an <code>ItemType</code> to appear.</p>
                  <p>The scope of a named item type is the <a title="package" class="termref" href="#dt-package">package</a> in which it is declared. If it
               is declared with <code>visibility="public"</code> then it also becomes available for use in using
               packages. (Since there is no mechanism for the using package to override the definition,
               <code>public</code> effectively means <code>final</code>.)</p>
                  <p>A named item type is essentially an abbreviation for the item type designator appearing in the
               <code>as</code> attribute, and the semantics can be defined in terms of textual replacement
               of the name by its definition. In consequence, named item types cannot be recursive, since
               this would make the textual expansion non-terminating.</p>
                  <p>The name of the item type is the expanded name formed by resolving the <code>name</code> attribute.
               A lexical QName with no prefix is treated as being in the 
               <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-default-namespace-elements-and-types">default namespace for elements and types</a><sup><small>XP</small></sup>.</p>
                  <p>If two <a href="#element-item-type"><code>xsl:item-type</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> have the same
               name, then the one with higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used. </p>
                  <p><a id="err-XTSE4030"><span class="error">[ERR XTSE4030] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package contains two 
                     <a href="#element-item-type"><code>xsl:item-type</code></a> or <a href="#element-record-type"><code>xsl:record-type</code></a>
                     declarations having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                        precedence</a>, unless there is another definition with the same
                     name and higher import precedence. It is also a static error if the name
                  of the item type uses a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>, or if it has the same
                  name as a type in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP</small></sup> of
                  the static context.</p>
                  <p><a id="err-XTSE4035"><span class="error">[ERR XTSE4035] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an item type named
                     <var>N</var> to contain in its <code>as</code> attribute a reference to <var>N</var>,
                     or to an item type that references <var>N</var> directly or indirectly.</p>
                  <p>It is permissible to use a private named item type in the declaration of a public
               variable, function, or template. A package that uses (or overrides) such a component
               will not be able to use the type name, but it can use the underlying type definition,
               or provide its own declaration of the relevant item type, using the same name or
               a different name.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="named-record-types"></a>5.4.2 <a href="#named-record-types" style="text-decoration: none">Named Record Types</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#defining-decimal-format">next</a> | <a href="#named-item-types">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     Named record types are introduced.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1485">1485</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1708">1708</a>&nbsp;16 January 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-record-type"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:record-type<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;constructor? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;extensible? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;visibility? = "private" | "public"〔'private'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-field">xsl:field</a>*) --&gt;<br>&lt;/xsl:record-type&gt;</code></p>
                  <p class="element-syntax"><a id="element-field"></a><code>&lt;xsl:field<br>&nbsp;&nbsp;<b>name</b> = <var>ncname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;required? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;default? = <var>expression</var>&nbsp;/&gt;</code></p>
                  <p>An <a href="#element-record-type"><code>xsl:record-type</code></a> declaration associates a name 
                  with a record type, and allows the record type
                  to be referenced by name throughout the stylesheet package.</p>
                  <div class="example">
                     <p>The following example declares a named record type for complex numbers, 
                     and uses it in a variable
                     declaration and a function declaration.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:record-type name="cx:complex"&gt;
    &lt;xsl:field name="r" as="xs:double"/&gt;
    &lt;xsl:field name="i" as="xs:double"/&gt;
&lt;/xsl:record-type&gt;
   
&lt;xsl:variable name="i" as="cx:complex" select="cx:complex(0, 1)"/&gt;
   
&lt;xsl:function name="cx:add" as="cx:complex"&gt;
  &lt;xsl:param name="x" as="cx:complex"/&gt;
  &lt;xsl:param name="y" as="cx:complex"/&gt;
  &lt;xsl:sequence select="cx:complex($x?r + $y?r, $x?i + $y?i)"/&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>Note how the record type declaration has implicitly declared a constructor function
                     <code>cx:complex</code> that can be used to create instances of the item type.</p>
                  </div>
                  <p><a id="err-XTSE4050"><span class="error">[ERR XTSE4050] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if the names of the fields in an <a href="#element-record-type"><code>xsl:record-type</code></a>
                     declaration are not distinct.</p>
                  <p><a id="err-XTSE4051"><span class="error">[ERR XTSE4051] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if an <a href="#element-field"><code>xsl:field</code></a> element has a <code>default</code>
                     attribute unless it specifies <code>required="no"</code>.</p>
                  <p>An <a href="#element-record-type"><code>xsl:record-type</code></a> declaration has two effects:</p>
                  <ul>
                     <li>
                        <p>In the same way as <a href="#element-item-type"><code>xsl:item-type</code></a>, it defines
                  a named item type in the static context, allowing the record type to
                  be referenced by name anywhere an <code>ItemType</code> can appear,
                  for example in the declarations of functions and variables. Unlike
                  types declared in <a href="#element-item-type"><code>xsl:item-type</code></a>, however,
                  named record types can be recursive.</p>
                     </li>
                     <li>
                        <p>An <a href="#element-record-type"><code>xsl:record-type</code></a> declaration also
                  implicitly defines a constructor function, of the same name,
                  and adds this to the set of 
                  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known function definitions</a><sup><small>XP</small></sup>
                  in the static context.</p>
                     </li>
                  </ul>
                  <p>Because of its dual role, the name of an <a href="#element-record-type"><code>xsl:record-type</code></a>
               declaration must be valid both as an item type name and as a function name.
               This means the name must be distinct from other type names and function names
               in the static context. It also means that the name must be in a namespace.</p>
                  <p>Considered as an item type, the <a href="#element-record-type"><code>xsl:record-type</code></a>
               declaration is equivalent to an <a href="#element-item-type"><code>xsl:item-type</code></a> declaration
               formed by the following template rule, evaluated in the context of 
               a namespace alias <code>&lt;xsl:namespace-alias stylesheet-prefix="t"
               result-prefix="xsl"/&gt;</code>:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="xsl:record-type" expand-text="yes"&gt;
   &lt;t:item-type name="{@name}"
                visibility="{@visibility otherwise 'private'}"&gt;
     &lt;xsl:attribute name="as"&gt;
        &lt;xsl:text&gt;record(&lt;/xsl:text&gt;
        &lt;xsl:for-each select="xsl:field" separator=", "&gt;
           &lt;xsl:variable name="optional"
                         as="xs:boolean"
                         select="normalize-space(@required) = ('no','false','0')"/&gt;
           {@name}{'?'[$optional]} as {@as otherwise 'item()*'}
        &lt;/xsl:for-each&gt;
        &lt;xsl:text&gt;)&lt;/xsl:text&gt;
      &lt;/xsl:attribute&gt;  
   &lt;/t:item-type&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>This generated <a href="#element-item-type"><code>xsl:item-type</code></a> declaration must
               meet all the constraints placed on user-written 
               <a href="#element-item-type"><code>xsl:item-type</code></a> declarations, including the rule
               requiring names to be unique, but not including the rule
               disallowing recursive references.</p>
                  <p>For example, the declaration:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:record-type name="cx:complex"&gt;
    &lt;xsl:field name="r" as="xs:double"/&gt;
    &lt;xsl:field name="i" as="xs:double" required="no" default="0"/&gt;
&lt;/xsl:record-type&gt;</pre>
                  </div>
                  <p>produces the equivalent item type declaration:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:item-type name="cx:complex"
       as="record(r as xs:double, i? as xs:double)"/&gt;</pre>
                  </div>
                  <p>Considered as a function declaration, an <a href="#element-record-type"><code>xsl:record-type</code></a>
               declaration is equivalent to an <a href="#element-function"><code>xsl:function</code></a> declaration
               formed by the following template rule, evaluated in the context of 
               a namespace alias <code>&lt;xsl:namespace-alias stylesheet-prefix="t"
               result-prefix="xsl"/&gt;</code>:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="xsl:record-type"&gt;
    &lt;t:function name="{@name}"
                as="{@name}"
                visibility="{(@visibility otherwise 'private')}"&gt;
                
             
      
      &lt;!-- declare the parameters --&gt;
      &lt;xsl:for-each select="xsl:field"&gt;
         &lt;t:param name="{@name}"
                  required="{@required otherwise 'yes'}"&gt;
            &lt;xsl:attribute name="as"&gt;
               &lt;xsl:variable name="as" 
                             select="normalize-space(@as otherwise 'item()*')"/&gt;
               &lt;xsl:variable name="optional" 
                             select="normalize-space(@required) = ('no', 'false', '0')"/&gt;
               &lt;xsl:choose&gt;
                  &lt;xsl:when test="not($optional)" select="$as"/&gt;
                  &lt;!-- for optional fields, amend the required type to allow () --&gt;
                  &lt;xsl:when test="matches($as, '[?*]$')" select="$as"/&gt;
                  &lt;xsl:when test="matches($as, '\+$')" select="replace($as, '\+$', '*')"/&gt;
                  &lt;xsl:otherwise select="$as || '?'"/&gt;
               &lt;/xsl:choose&gt;
            &lt;/xsl:attribute&gt;
            &lt;xsl:if test="@default"&gt;
               &lt;xsl:attribute name="select" select="@default"/&gt;
            &lt;/xsl:if&gt;   
         &lt;/t:param&gt;
      &lt;/xsl:for-each&gt;
      
        
      
      &lt;!-- function body: construct a map --&gt;
      &lt;t:map duplicates="fn($first, $second){{$first}}"&gt;
         &lt;xsl:for-each select="xsl:field"&gt;
            &lt;xsl:variable name="optional" 
                          select="normalize-space(@required) = ('no', 'false', '0')"/&gt;
            &lt;xsl:choose&gt;
              &lt;xsl:when test="$optional and not(@default)"&gt;
                 &lt;!-- omit map entries for optional fields if no value is supplied --&gt;
                 &lt;t:if test="exists(${@name})"&gt;
                    &lt;t:map-entry key="'{@name}'" select="${@name}"/&gt;
                 &lt;/t:if&gt;
              &lt;/xsl:when&gt;
              &lt;xsl:otherwise&gt;
                &lt;t:map-entry key="'{@name}'" select="${@name}"/&gt;
              &lt;/xsl:otherwise&gt;  
            &lt;/xsl:choose&gt;  
         &lt;/xsl:for-each&gt;
        


      &lt;/t:map&gt;
    &lt;/t:function&gt;          
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>For example, the declaration:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:record-type name="cx:complex"&gt;
    &lt;xsl:field name="r" as="xs:double"/&gt;
    &lt;xsl:field name="i" as="xs:double" required="no" default="0"/&gt;
&lt;/xsl:record-type&gt;</pre>
                  </div>
                  <p>produces the equivalent function declaration:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="cx:complex" as="cx:complex" visibility="private"&gt;
    &lt;xsl:param name="r" as="xs:double"/&gt;
    &lt;xsl:param name="i" as="xs:double" required="no" select="0"/&gt;
    &lt;xsl:map&gt;
       &lt;xsl:map-entry key="'r'" select="$r"/&gt;
       &lt;xsl:map-entry key="'i'" select="$i"/&gt;
    &lt;/xsl:map&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
                  <p>No entry is generated in the constructed map for a field that
               is declared as optional with no default. So the declaration:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:record-type name="cx:complex" visibility="public"&gt;
    &lt;xsl:field name="r" as="xs:double"/&gt;
    &lt;xsl:field name="i" as="xs:double" required="no"/&gt;
&lt;/xsl:record-type&gt;</pre>
                  </div>
                  <p>produces the equivalent function declaration:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="cx:complex" as="cx:complex" visibility="public"&gt;
    &lt;xsl:param name="r" as="xs:double"/&gt;
    &lt;xsl:param name="i" as="xs:double?" required="no"/&gt;
    &lt;xsl:map&gt;
       &lt;xsl:map-entry key="'r'" select="$r"/&gt;
       &lt;xsl:if test="exists($i)"&gt;
          &lt;xsl:map-entry key="'i'" select="$i"/&gt;
       &lt;/xsl:if&gt;   
    &lt;/xsl:map&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
                  <p>This generated <a href="#element-function"><code>xsl:function</code></a> declaration must
               meet all the constraints placed on user-written 
               <a href="#element-function"><code>xsl:function</code></a> declarations, including the rule
               requiring the combination of name and arity to be unique.</p>
                  <p>The generated <a href="#element-function"><code>xsl:function</code></a> declaration has the
               import precedence associated with the stylesheet module in which the
               <a href="#element-record-type"><code>xsl:record-type</code></a> declaration appears, and it may be
               overridden by another <a href="#element-function"><code>xsl:function</code></a> declaration with
               higher import precedence. If the visibility is <code>public</code>
               then it can also be overridden using <a href="#element-override"><code>xsl:override</code></a>
               in another <a title="package" class="termref" href="#dt-package">package</a>.</p>
                  <p>The scope of a named record type is the <a title="package" class="termref" href="#dt-package">package</a> in which it is declared. If it
               is declared with <code>visibility="public"</code> then it also becomes available for use in using
               packages. </p>
                  <p>The name of the record type is the expanded name formed by resolving the <code>name</code> attribute.
               Because function names are always in a namespace, the name must be prefixed.</p>
                  <p>If two <a href="#element-record-type"><code>xsl:record-type</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> have the same
               name, then the one with higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used. </p>
                  <p>A record type declaration may refer directly or indirectly to itself if
                  it satisfies the conditions defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-recursive-record-tests">3.2.8.3.1 Recursive Record Types</a>.
               This allows types to be declared that match recursive data structures such as linked lists
               and trees.</p>
                  <p>A named record type with visibility <code>private</code> may be used in the definition of a 
                  component (such as a variable, a function, a template, or another named record 
                  type) that is itself public. Another package may reference such a component 
                  even though it cannot reference the types used in its definition. The fact that the
                  record type is private, however, means that it is impossible to
                  override a variable or function that references the record type.</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e15956"></a>Example: Defining a Binary Tree</div>
                     <p>This example illustrates the definition of a recursive record type.
                  The record type represents a node of a binary tree containing a payload value
                  in each node, together with optional references to left and right subtrees.
                  As well as the data fields, the record type defines a <code>depth</code> function 
                  that returns the maximum depth of the tree, by making recursive calls on its
                  subtrees.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:record-type name="my:binary-tree"&gt;
   &lt;xsl:field name="left" as="my:binary-tree?"/&gt;
   &lt;xsl:field name="payload" as="item()*"/&gt;
   &lt;xsl:field name="right" as="my:binary-tree?"/&gt;
   &lt;xsl:field name="depth" as="fn(my:binary-tree) as xs:integer"
      default="fn {1 + max((?left =?&gt; depth(), ?right =?&gt; depth())) otherwise 0)}"/&gt;
&lt;/xsl:record-type&gt;</pre>
                     </div>
                     <p>Method calls (using the operator <code>=?&gt;</code>) are described in
                     <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-methods">4.15.4 Method Calls</a>. The effect is to
                     give a function item contained in a map access to the containing
                     map.
                  They thus mimic method invocation in object-oriented languages, though
                  there is no inheritance or encapsulation.</p>
                     <p>The following code builds a simple tree and calculates its depth:</p>
                     <div class="exampleInner">
                        <pre>
let $tree := my:binary-tree(
               my:binary-tree((), 17, ()),
               18,
               my:binary-tree((), 19, 
                 my:binary-tree((), 20, ())))
return $tree =?&gt; depth()</pre>
                     </div>
                     <p>Returning the result 3.</p>
                  </div>
                  <p>A more detailed example that uses a recursive named record type
               appears in the following section.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="id-atomic-set-example"></a>5.4.3 <a href="#id-atomic-set-example" style="text-decoration: none">Example: Defining an Atomic Set</a></h4>
                  <p>This example demonstrates a library package that provides a new data type
               to manipulate sets of atomic items.</p>
                  <p>A stylesheet that incorporates this package (by referencing
               it in an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration) can use constructs such as:</p>
                  <ul>
                     <li>
                        <p>
                     </p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:variable name="empty" 
       as="set:atomic-set"
       select="set:build(())"/&gt;</pre>
                        </div>
                        <p>
                  </p>
                     </li>
                     <li>
                        <p>
                     </p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:variable name="evens"
      as="set:atomic-set"                        
      select="set:build((1 to 100)[. mod 2 = 0])"/&gt;</pre>
                        </div>
                        <p>
                  </p>
                     </li>
                     <li>
                        <p>
                     </p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:variable name="odds"
      as="set:atomic-set"
      select="set:build((1 to 100)) ? except($evens)"/&gt;</pre>
                        </div>
                        <p>
                  </p>
                     </li>
                     <li>
                        <p>
                     </p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:function name="my:is-even" as="xs:boolean"&gt;
   &lt;xsl:param name="n" as="xs:integer"/&gt;
   &lt;xsl:sequence select="$evens ? contains($n)"/&gt;
&lt;/xsl:function&gt;</pre>
                        </div>
                        <p>
                  </p>
                     </li>
                  </ul>
                  <p>Here is the implementation of the package.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:package name="http://qt4cg.org/atomic-set"
             package-version="1.0.0"
             xmlns:set="http://qt4cg.org/atomic-set"
             xmlns:map="http://www.w3.org/2005/xpath-functions/map"
             xmlns:xs="http://www.w3.org/2001/XMLSchema"&gt;
   
   &lt;xsl:note&gt;
      This package defines a type set:atomic-set which represents
      a set of distinct atomic items. Atomic items are considered
      distinct based on the comparison function fn:atomic-equal.
      
      An instance of an atomic set can be constructed using a function
      call such as set:build((1, 3, 5, 7, 9)).
      
      If $A and $B are instances of set:atomic-set, then they
      can be manipulated using methods including:
      
      $A =?&gt; size() - returns the number of items in the set
      $A =?&gt; empty() - returns true if the set is empty
      $A =?&gt; contains($k) - determines whether $k is a member of the set
      $A =?&gt; contains-all($B) - returns true if $B is a subset of $A
      $A =?&gt; values() - returns the items in $A, as a sequence
      $A =?&gt; add($k) - returns a new atomic set containing an additional item
      $A =?&gt; remove($k) - returns a new atomic set in which the given item is absent
      $A =?&gt; union($B) - returns a new atomic set holding the union of $A and $B
      $A =?&gt; intersect($B) - returns a new atomic set holding the intersection of $A and $B
      $A =?&gt; except($B) - returns a new atomic set holding the difference of $A and $B
   &lt;/xsl:note&gt;
   
   &lt;xsl:record-type name="set:atomic-set" 
                    visibility="public"&gt;
      &lt;xsl:field name="_data" 
                 as="map(xs:anyAtomicType, xs:boolean)"/&gt;
      &lt;xsl:field name="size" 
                 as="fn(set:atomic-set) as xs:integer"/&gt;
      &lt;xsl:field name="empty" 
                 as="fn(set:atomic-set) as xs:boolean"/&gt;
      &lt;xsl:field name="contains" 
                 as="fn(set:atomic-set, xs:anyAtomicType) as xs:boolean"/&gt; 
      &lt;xsl:field name="contains-all" 
                 as="fn(set:atomic-set, set:atomic-set) as xs:boolean"/&gt; 
      &lt;xsl:field name="add" 
                 as="fn(set:atomic-set, xs:anyAtomicType) as set:atomic-set"/&gt; 
      &lt;xsl:field name="remove" 
                 as="fn(set:atomic-set, xs:anyAtomicType) as set:atomic-set"/&gt;
      &lt;xsl:field name="union" 
                 as="fn(set:atomic-set, set:atomic-set) as set:atomic-set"/&gt;
      &lt;xsl:field name="intersect" 
                 as="fn(set:atomic-set, set:atomic-set) as set:atomic-set"/&gt; 
      &lt;xsl:field name="except" 
                 as="fn(set:atomic-set, set:atomic-set) as set:atomic-set"/&gt; 
   &lt;/xsl:record-type&gt;
   
   &lt;xsl:variable name="DATA" select="'_data'" visibility="private"/&gt;
   
   &lt;xsl:note&gt;
      The private function set:replaceData processes the internal map
      by applying a supplied function, and returns a new atomic set
      with the resulting internal map 
   &lt;/xsl:note&gt;
   
   &lt;xsl:function name="set:replaceData" 
                 visibility="private" 
                 as="map(xs:anyAtomicType, xs:boolean)"&gt;
      &lt;xsl:param name="input" as="set:atomic-set"/&gt;
      &lt;xsl:param name="update" as="fn(map(*)) as map(*)"/&gt;
      &lt;xsl:sequence select="map:put($input, $DATA, $update($input?$DATA))"/&gt;
   &lt;/xsl:function&gt;   
   
   &lt;xsl:function name="set:build" as="set:atomic-set" visibility="public"&gt;
      &lt;xsl:param name="values" as="xs:anyAtomicType*" default="()"/&gt;
      &lt;xsl:record as="set:atomic-set"
         _data=
            "map:build($values, values:=true#0, {'duplicates': 'use-first'})"
         size=
            "fn($this as set:atomic-set) as xs:integer 
                     { map:size($this?$DATA) }"
         empty=
            "fn($this as set:atomic-set) as xs:boolean 
                     { map:empty($this?$DATA) }"
         contains=
            "fn($this as set:atomic-set, $value as xs:anyAtomicType) as xs:boolean 
                     { map:contains($this?$DATA, $value) }"
         contains-all=
            "fn($this as set:atomic-set, $other as set:atomic-set) as xs:boolean 
                     { every($other, map:contains($this?$DATA, ?)) }"
         values=
            "fn($this as set:atomic-set) as xs:anyAtomicType* 
                     { keys($this?$DATA) }"
         add=
            "fn($this as set:atomic-set, $value as xs:anyAtomicType) as xs:anyAtomicType*
                     { set:replaceData($this, map:put(?, $value, true())) }"
         remove=
            "fn($this as set:atomic-set, $value as xs:anyAtomicType) as xs:anyAtomicType* 
                     { set:replaceData($this, map:remove(?, $value)) }"
         union=
            "fn($this as set:atomic-set, $other as set:atomic-set) as set:atomic-set 
                     { set:replaceData($this, fn($m) {map:merge(($m, $other?$DATA),
                                                    {'duplicates': 'use-first'})})
                     }"
         intersect=
            "fn($this as set:atomic-set, $other as set:atomic-set) as set:atomic-set 
                     { set:replaceData($this, map:filter(?, $other?contains)) }"
         except=
            "fn($this as set:atomic-set, $other as set:atomic-set) as set:atomic-set 
                     { set:replaceData($this, map:remove(?, $other?values())) }"/&gt;
      
   &lt;/xsl:function&gt;
   
   
&lt;/xsl:package&gt;</pre>
                  </div>
                  <table class="ednote" caption="Editorial note">
                     <tr>
                        <td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td>
                        <td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td>
                     </tr>
                     <tr style="text-align: left; vertical-align: top;">
                        <td colspan="2">
                           <p>The example is not yet tested. </p>
                        </td>
                     </tr>
                  </table>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="defining-decimal-format"></a>5.5 <a href="#defining-decimal-format" style="text-decoration: none">Defining a Decimal Format</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#type-patterns">next</a> | <a href="#named-record-types">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The strings used in the formatted number to represent 
                     a decimal separator, grouping separator, exponent
                  separator, percent sign, per mille sign, or minus sign,
                  are no longer constrained to be single characters.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1048">1048</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1250">1250</a>&nbsp;3 June 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p>The definition of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function
               is now in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. This section is a specification of
               the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration, which provides the context for
               this function when used in an XSLT stylesheet.</p>
               <p class="element-syntax"><a id="element-decimal-format"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:decimal-format<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;decimal-separator? = <var>string</var>〔'.'〕<br>&nbsp;&nbsp;grouping-separator? = <var>string</var>〔','〕<br>&nbsp;&nbsp;infinity? = <var>string</var>〔'Infinity'〕<br>&nbsp;&nbsp;minus-sign? = <var>string</var>〔'-'〕<br>&nbsp;&nbsp;exponent-separator? = <var>string</var>〔'e'〕<br>&nbsp;&nbsp;NaN? = <var>string</var>〔'NaN'〕<br>&nbsp;&nbsp;percent? = <var>string</var>〔'%'〕<br>&nbsp;&nbsp;per-mille? = <var>string</var>〔'‰'〕<br>&nbsp;&nbsp;zero-digit? = <var>char</var>〔'0'〕<br>&nbsp;&nbsp;digit? = <var>char</var>〔'#'〕<br>&nbsp;&nbsp;pattern-separator? = <var>char</var>〔';'〕&nbsp;/&gt;</code></p>
               <p>The <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> element sets the
               <b>statically known decimal formats</b> component of the static context
               for XPath expressions, which controls the interpretation of a <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> used by the
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-picture-string" title="picture string"></a>The <b>picture string</b>
               is the string supplied as the second argument of the
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function.<span class="definition">]</span>
            </p>
               <p>A <a title="package" class="termref" href="#dt-package">package</a> may
               contain multiple <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations and may include or
               import <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> that also
               contain <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations. The name of an
               <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration is the value of its
               <code>name</code> attribute, if any.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-decimal-format" title="decimal format"></a>All the
                  <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in a package that share the same name are grouped into a named
                  <b>decimal format</b>; those that have no name are grouped into a single
                  unnamed decimal format.<span class="definition">]</span>
            </p>
               <p> The attributes of the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a>
               declaration define the value of the corresponding property in the relevant decimal
               format in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically known
                  decimal formats</a><sup><small>XP</small></sup> component of the static context for all XPath
               expressions in the package. The attribute names used in the XSLT 4.0 syntax are the
               same as the property names used in the definition of the static context. </p>
               <p>The scope of an <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> name is the
               package in which it is declared; the name is available for use only in calls to
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> that appear within the same package.</p>
               <p>If a <a title="package" class="termref" href="#dt-package">package</a> does not contain a declaration of
               the unnamed decimal format, a declaration equivalent to an
               <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> element with no attributes is implied.</p>
               <p>The attributes of the <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration establish
               values for a number of variables used as input to the algorithm followed by the
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function. An outline of the purpose of each
               attribute is given below; however, the definitive explanations are given as part of the specification of
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a>.</p>
               <p>For any named <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a>, the
               <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of each attribute is taken from an
               <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration that has that name, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import
                  precedence</a> is used.</p>
               <p>For any unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a>, the
               <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of each attribute is taken from an
               <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration that is unnamed, and that
               specifies an explicit value for the required attribute. If there is no such
               declaration, the default value of the attribute is used. If there is more than one
               such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import
                  precedence</a> is used.</p>
               <p>
               <a id="err-XTSE1290"><span class="error">[ERR XTSE1290] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a named or
                     unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a> contains two
                     conflicting values for the same attribute in different
                     <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is
                     another definition of the same attribute with higher import precedence.
            </p>
               <p>The following attributes control the interpretation of characters in the 
               <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> supplied to the
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function, and also specify characters that
               may appear in the result of formatting the number. In each case the value
               <span class="verb">must</span> either be a single character, or a string
               in the form <code>m:r</code> where <code>m</code> is a single character
               (the <b>marker</b>) used to represent the property in the picture
               string, and <code>r</code> (the <b>rendition</b>) 
               is an arbitrary string used to represent
               the property in the formatted result: <span class="error">[see <a href="#err-XTSE0020">ERR XTSE0020</a>]</span>.</p>
               <ul>
                  <li>
                     <p>
                     <code>decimal-separator</code> specifies the string used to separate the
                     integer part from the fractional part of the formatted number; the default
                     value is <span class="unicode-codepoint">U+002E</span> (<span class="unicode-name">FULL STOP, PERIOD</span>, <code>.</code>) .</p>
                  </li>
                  <li>
                     <p>
                     <code>exponent-separator</code> specifies the string used to separate the
                     mantissa from the exponent in scientific notation; the default value is 
                     <span class="unicode-codepoint">U+0065</span> (<span class="unicode-name">LATIN SMALL LETTER E</span>, <code>e</code>) .</p>
                  </li>
                  <li>
                     <p>
                     <code>grouping-separator</code> specifies the string typically used as a
                     thousands separator; the default value is <span class="unicode-codepoint">U+002C</span> (<span class="unicode-name">COMMA</span>, <code>,</code>) .</p>
                  </li>
                  <li>
                     <p>
                     <code>percent</code> specifies the string used to indicate that the number
                     is represented as a per-hundred fraction; the default value is <span class="unicode-codepoint">U+0025</span> (<span class="unicode-name">PERCENT SIGN</span>, <code>%</code>) .</p>
                  </li>
                  <li>
                     <p>
                     <code>per-mille</code> specifies the string used to indicate that the number
                     is represented as a per-thousand fraction; the default value is <span class="unicode-codepoint">U+2030</span> (<span class="unicode-name">PER MILLE SIGN</span>, <code>‰</code>) .</p>
                  </li>
               </ul>
               <p>
               <a id="err-XTSE1295"><span class="error">[ERR XTSE1295] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the character
                     specified in the <code>zero-digit</code> attribute is not a digit or is a digit
                     that does not have the numeric value zero. 
            </p>
               <p>The following attributes control the interpretation of characters in the <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> supplied to the
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function. In each case the value
               <span class="verb">must</span> be a single character <span class="error">[see <a href="#err-XTSE0020">ERR XTSE0020</a>]</span>.
               The <code>zero-digit</code> property also affects the characters used to render
               digits in the formatted result:
            </p>
               <ul>
                  <li>
                     <p>
                     <code>zero-digit</code> specifies the character used to represent the digit
                     zero; the default value is <span class="unicode-codepoint">U+0030</span> (<span class="unicode-name">DIGIT ZERO</span>, <code>0</code>) . This
                     character <span class="verb">must</span> be a digit (category <code>Nd</code> in the
                     Unicode property database), and it <span class="verb">must</span> have the numeric
                     value zero. This attribute implicitly defines the Unicode character that is
                     used to represent each of the values 0 to 9 in the final result string: Unicode
                     is organized so that each set of decimal digits forms a contiguous block of
                     characters in numerical sequence.</p>
                  </li>
                  <li>
                     <p>
                     <code>digit</code> specifies the character used in the <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> as a place-holder for an
                     optional digit; the default value is <span class="unicode-codepoint">U+0023</span> (<span class="unicode-name">NUMBER SIGN</span>, <code>#</code>) .</p>
                  </li>
                  <li>
                     <p>
                     <code>pattern-separator</code> specifies the character used to separate
                     positive and negative sub-pictures in a <a title="picture string" class="termref" href="#dt-picture-string">picture string</a>; 
                     the default value is <span class="unicode-codepoint">U+003B</span> (<span class="unicode-name">SEMICOLON</span>, <code>;</code>) .</p>
                  </li>
               </ul>
               <p>The following attributes specify strings that may appear in the result
               of formatting the number:</p>
               <ul>
                  <li>
                     <p>
                     <code>infinity</code> specifies the string used to represent the
                     <code>xs:double</code> value <code>INF</code>; the default value is the
                     string <code>Infinity</code>
                  </p>
                  </li>
                  <li>
                     <p>
                     <code>NaN</code> specifies the string used to represent the
                     <code>xs:double</code> value <code>NaN</code> (not-a-number); the default
                     value is the string <code>NaN</code>
                  </p>
                  </li>
                  <li>
                     <p>
                     <code>minus-sign</code> specifies the string used to indicate a negative
                     number; the default value is <span class="unicode-codepoint">U+002D</span> (<span class="unicode-name">HYPHEN-MINUS</span>, <code>-</code>) .</p>
                  </li>
               </ul>
               <p>
               <a id="err-XTSE1300"><span class="error">[ERR XTSE1300] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if, for any named
                     or unnamed decimal format, the properties identifying <b>marker</b> 
                     characters to be used in a
                     <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> do not identify
                     distinct values. These properties are <var>decimal-separator</var>,
                     <var>grouping-separator</var>, <var>exponent-separator</var>, <var>percent</var>,
                     <var>per-mille</var>, <var>zero-digit</var>, <var>digit</var>,
                     and <var>pattern-separator</var>.
            </p>
               <p>Every (named or unnamed) decimal format defined in a <a title="stylesheet" class="termref" href="#dt-stylesheet">package</a> is added to the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-decimal-formats">statically known decimal formats</a><sup><small>XP</small></sup> in the
               <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup> of every
               expression in the <a title="package" class="termref" href="#dt-package">package</a>, excluding expressions
               appearing in <code>[xsl:]use-when</code> attributes.</p>
            </div>
            <div class="div2">
               
               <h3><a id="value-templates"></a>5.6 <a href="#value-templates" style="text-decoration: none">Value Templates</a></h3>
               <p>The string value of an attribute or text node in the stylesheet may in particular
               circumstances contain embedded expressions enclosed between curly brackets.
               Attributes and text nodes that use (or are permitted to use) this mechanism are
               referred to respectively as <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute
                  value templates</a> and <a title="text value template" class="termref" href="#dt-text-value-template">text value
                  templates</a>.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-value-template" title="value template"></a>Collectively,
                  attribute value templates and text value templates are referred to as <b>value
                     templates</b>.<span class="definition">]</span></p>
               <p>A value template is a string consisting of an alternating sequence of fixed parts and
               variable parts:</p>
               <ul>
                  <li>
                     <p>A variable part consists of an optional XPath <a title="expression" class="termref" href="#dt-expression">expression</a> enclosed in curly brackets (<code>{}</code>):
                  more specifically, a string conforming 
                     to the XPath production <code>Expr?</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>An expression within a variable part may contain an unescaped curly bracket within
                        a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup> or within
                        a comment.</p>
                        <p>Currently no XPath expression starts with an opening curly
                        bracket, so the use of <code>{{</code> creates no ambiguity. If an enclosed
                        expression ends with a closing curly bracket, no whitespace is required between
                        this and the closing delimiter.</p>
                        <p>The fact that the expression is optional means that the
                     string contained between the curly brackets may be zero-length, may comprise whitespace
                     only, or may contain XPath comments. The effective value in this case is a zero-length
                     string, which is equivalent to omitting the variable part entirely, together with its 
                     curly-bracket delimiters. </p>
                     </div>
                  </li>
                  <li>
                     <p>A fixed part
                  may contain any characters, except that a left curly bracket <span class="verb">must</span>
                  be written as <code>{{</code> and a right curly bracket <span class="verb">must</span> be
                  written as <code>}}</code>. </p>
                  </li>
               </ul>
               <p>
               <a id="err-XTSE0350"><span class="error">[ERR XTSE0350] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped
                     left curly bracket appears in a fixed part of a value template without a
                     matching right curly bracket.
            </p>
               <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the string contained
               between matching curly brackets in a value template does not match the XPath
               production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr?</a><sup><small>XP</small></sup>, or if it contains
               other XPath static errors. The error is raised using the appropriate XPath error
               code.</p>
               <p>
               <a id="err-XTSE0370"><span class="error">[ERR XTSE0370] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped
                     right curly bracket occurs in a fixed part of a value template.
            </p>
               <p>The result of evaluating a
               value template is referred to as its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>. The
               effective value is the string obtained by concatenating the expansions of the fixed
               and variable parts:</p>
               <ul>
                  <li>
                     <p>The expansion of a fixed part is obtained by replacing any double curly
                     brackets (<code>{{</code> or <code>}}</code>) by the corresponding single curly
                     bracket.</p>
                  </li>
                  <li>
                     <p>The expansion of a variable part is as follows:</p>
                     <ul>
                        <li>
                           <p>If an expression is present, the result of evaluating the enclosed XPath
                        <a title="expression" class="termref" href="#dt-expression">expression</a> and converting the
                        resulting value to a string. This conversion is done using the rules given in
                        <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
                        </li>
                        <li>
                           <p>If the expression is omitted, a zero-length string.</p>
                        </li>
                     </ul>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This process can raise dynamic errors, for example if the sequence contains an
                  element with a complex content type (which cannot be atomized).</p>
               </div>
               <p>In the case of an attribute value template, the effective value becomes the string
               value of the new attribute node. In the case of a text value template, the effective
               value becomes the string value of the new text node.</p>
               <div class="div3">
                  
                  <h4><a id="attribute-value-templates"></a>5.6.1 <a href="#attribute-value-templates" style="text-decoration: none">Attribute Value Templates</a></h4>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-attribute-value-template" title="attribute value template"></a>In an
                     attribute that is designated as an <b>attribute value template</b>, such
                     as an attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result
                        element</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a> can
                     be used by surrounding the expression with curly brackets (<code>{}</code>),
                     following the general rules for <a title="value template" class="termref" href="#dt-value-template">value
                        templates</a><span class="definition">]</span>.</p>
                  <p>Curly brackets are not treated specially in an attribute value in an XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> unless the attribute is specifically
                  designated as one that permits an attribute value template; in an element syntax
                  summary, the value of such attributes is surrounded by curly brackets.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Not all attributes are designated as attribute value templates. Attributes
                     whose value is an <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, attributes of <a title="declaration" class="termref" href="#dt-declaration">declaration</a> elements and attributes that
                     refer to named XSLT objects are generally not designated as attribute value
                     templates (an exception is the <code>format</code> attribute of
                        <a href="#element-result-document"><code>xsl:result-document</code></a>). Namespace declarations are not XDM
                     attribute nodes and are therefore never treated as attribute value
                     templates.</p>
                  </div>
                  <p>If the element containing the attribute is processed
                     with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then the
                     rules for converting the value of the expression to a string (given in <a href="#value-templates"><i>5.6 Value Templates</i></a>) are modified as follows. After <a title="atomize" class="termref" href="#dt-atomization">atomizing</a> the result of the expression, all
                     items other than the first item in the resulting sequence are discarded, and
                     the effective value is obtained by converting the first item in the sequence to
                     a string. If the atomized sequence is empty, the result is a zero-length
                     string.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The above rule applies to attribute value templates but not
                     to text value templates, since the latter were not available in XSLT 1.0.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e16560"></a>Example: Attribute Value Templates</div>
                     <p>The following example creates an <code>img</code> result element from a
                        <code>photograph</code> element in the source; the value of the
                        <code>src</code> and <code>width</code> attributes are computed using XPath
                     expressions enclosed in attribute value templates:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="image-dir" select="'/images'"/&gt;

&lt;xsl:template match="photograph"&gt;
  &lt;img src="{ $image-dir }/{ href }" width="{ size/@width }"/&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>With this source</p>
                     <div class="exampleInner">
                        <pre>&lt;photograph&gt;
  &lt;href&gt;headquarters.jpg&lt;/href&gt;
  &lt;size width="300"/&gt;
&lt;/photograph&gt;</pre>
                     </div>
                     <p>the result would be</p>
                     <div class="exampleInner">
                        <pre>&lt;img src="/images/headquarters.jpg" width="300"/&gt;</pre>
                     </div>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e16584"></a>Example: Producing a Space-Separated List</div>
                     <p>The following example shows how the values in a sequence are output as a
                     space-separated list. The following literal result element:</p>
                     <div class="exampleInner">
                        <pre>&lt;temperature readings="{10.32, 5.50, 8.31}"/&gt;</pre>
                     </div>
                     <p>produces the output node:</p>
                     <div class="exampleInner">
                        <pre>&lt;temperature readings="10.32 5.5 8.31"/&gt;</pre>
                     </div>
                  </div>
                  <p>Curly brackets are <em>not</em> recognized recursively inside expressions.</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e16596"></a>Example: Curly Brackets cannot be Nested</div>
                     <p>For example:</p>
                     <div class="exampleInner">
                        <pre>&lt;a href="#{id({@ref})/title}"/&gt;</pre>
                     </div>
                     <p>is <em>not</em> allowed. Instead, use simply:</p>
                     <div class="exampleInner">
                        <pre>&lt;a href="#{id(@ref)/title}"/&gt;</pre>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="text-value-templates"></a>5.6.2 <a href="#text-value-templates" style="text-decoration: none">Text Value Templates</a></h4>
                  <p>The <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attribute</a>
                  <code>[xsl:]expand-text</code> may appear on any element in the stylesheet, and
                  determines whether descendant text nodes of that element are treated as text value
                  templates. A text node in the stylesheet is treated as a text value template if
                  (a) it is part of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a>, (b) there is an ancestor element with an
                     <code>[xsl:]expand-text</code> attribute, and (c) on the innermost ancestor
                  element that has such an attribute, the value of the attribute is
                  <code>yes</code>. The attribute is boolean and
                        <span class="verb">must</span> therefore take one of the values <code>yes</code>
                     (synonyms <code>true</code> or <code>1</code>) or <code>no</code> (synonyms
                        <code>false</code> or <code>0</code>). </p>
                  <p>This section describes how text nodes  are processed when the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is
                     <code>yes</code>. Such text nodes are referred to as text value templates.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-text-value-template" title="text value template"></a>In a text node
                     that is designated as a <b>text value template</b>, <a title="expression" class="termref" href="#dt-expression">expressions</a> can be used by surrounding each
                     expression with curly brackets (<code>{}</code>).<span class="definition">]</span></p>
                  <p>The rules for text value templates are given in <a href="#value-templates"><i>5.6 Value Templates</i></a>.
                  A text node 
                  whose value is a text value template results in the construction of a text node in
                  the result of the containing sequence
                     constructor. The string value
                  of that text node is obtained by computing the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the value
                  template.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The result of evaluating a text value template is a (possibly zero-length) text
                     node. This text node becomes part of the result of the containing sequence
                     constructor, and is thereafter handled
                     exactly as if the value had appeared explicitly as a text node in the
                     stylesheet.</p>
                     <p>The way in which the effective value is computed does not depend on any
                        <code>separator</code> attribute on a containing
                        <a href="#element-text"><code>xsl:text</code></a>, <a href="#element-value-of"><code>xsl:value-of</code></a> or 
                     <a href="#element-attribute"><code>xsl:attribute</code></a> instruction.
                     The <code>separator</code> attribute only affects how the text node is combined
                     with adjacent items in the result of the containing sequence constructor.</p>
                     <p>Fixed parts consisting entirely of whitespace are significant and are handled
                     in the same way as any other fixed part. This is different from the default
                     treatment of “boundary space” in XQuery.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e16690"></a>Example: Using a text value template to construct message output</div>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="id" select="'A123'"/&gt;
&lt;xsl:variable name="step" select="5"/&gt;
&lt;xsl:message expand-text="yes"
     &gt;Processing id={ $id }, step={ $step }&lt;/xsl:message&gt;</pre>
                     </div>
                     <p>This will typically output the message text <code>Processing id=A123,
                        step=5</code>.</p>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e16699"></a>Example: Using a text value template to define the result of a function</div>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="f:sum" expand-text="yes" as="xs:integer"&gt;
&lt;xsl:param name="x" as="xs:integer"/&gt;
&lt;xsl:param name="y" as="xs:integer"/&gt;
  { $x + $y }
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>Note that although this is a very readable way of expressing the computation
                     performed by the function, the semantics are somewhat complex, and this could
                     mean that execution is inefficient. The function computes the value of <code>$x
                        + $y</code> as an integer, and then constructs a text node containing the
                     string representation of this integer (preceded and followed by whitespace).
                     Because the declared result type of the function is <code>xs:integer</code>,
                     this text node is then atomized, giving an <code>xs:untypedAtomic</code> item,
                     and the <code>xs:untypedAtomic</code> item is then cast to an
                        <code>xs:integer</code>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The main motivations for adding text value templates to the XSLT language are
                     firstly, to make it easier to construct parameterized text in contexts such as
                        <a href="#element-text"><code>xsl:text</code></a>, <a href="#element-value-of"><code>xsl:value-of</code></a>, 
                     and <a href="#element-message"><code>xsl:message</code></a>, and
                     secondly, to allow use of complex multi-line XPath expressions where
                     maintaining correct indentation is important for readability. The fact that XML
                     processors are required to normalize whitespace in attribute values means that
                     writing such expressions within a <code>select</code> attribute is not
                     ideal.</p>
                     <p>The facility is only present if enabled using the
                        <code>[xsl:]expand-text</code> attribute. This is partly for backwards
                     compatibility, and partly to avoid creating difficulties when constructing
                     content that is rich in curly brackets, for example JavaScript code or CSS
                     style sheets.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="sequence-constructors"></a>5.7 <a href="#sequence-constructors" style="text-decoration: none">Sequence Constructors</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-constructor" title="sequence constructor"></a>A <b>sequence
                     constructor</b> is a sequence of zero or more sibling nodes in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be evaluated to return a
                  sequence of nodes, atomic items, and function
                     items. The way that the resulting sequence is used depends on the
                  containing instruction.<span class="definition">]</span>
            </p>
               <p>Many <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>, and also <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, are defined to
               take a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> as their content.</p>
               <p>Four kinds of nodes may be encountered in a sequence constructor:</p>
               <ol class="enumar">
                  <li>
                     <p> A <em>Text node</em> appearing in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (if it has not been removed in the process of
                     whitespace stripping: see <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>) is processed as follows:</p>
                     <ol class="enumla">
                        <li>
                           <p>if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the standard attribute
                              <code>[xsl:]expand-text</code> is <code>no</code>, or in the absence
                           of this attribute, the text node in the stylesheet is copied to create a
                           new parentless text node in the result of the sequence constructor.</p>
                        </li>
                        <li>
                           <p>Otherwise (the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of <code>[xsl:]expand-text</code> is
                              <code>yes</code>), the text node in the stylesheet is processed as
                           described in <a href="#text-value-templates"><i>5.6.2 Text Value Templates</i></a>.</p>
                        </li>
                     </ol>
                  </li>
                  <li>
                     <p> A <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a> is
                     evaluated to create a new parentless element node, having the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as the literal result
                     element: see <a href="#literal-result-element"><i>11.1 Literal Result Elements</i></a>. </p>
                  </li>
                  <li>
                     <p>An XSLT <a title="instruction" class="termref" href="#dt-instruction">instruction</a> produces a sequence
                     of zero, one, or more items as its result. For most XSLT instructions, these
                     items are nodes, but some instructions (such
                        as <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-select"><code>xsl:select</code></a>, 
                     <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-array"><code>xsl:array</code></a>, and <a href="#element-copy-of"><code>xsl:copy-of</code></a>) can also
                     produce atomic items or function items.</p>
                     <p>Several instructions, such as <a href="#element-element"><code>xsl:element</code></a>, return a newly
                     constructed parentless node (which may have its own attributes, namespaces,
                     children, and other descendants). Other instructions, such as
                        <a href="#element-if"><code>xsl:if</code></a>, pass on the items produced by their own nested
                     sequence constructors.</p>
                     <p>Three instructions serve primarily to evaluate XPath expressions:</p>
                     <ul>
                        <li>
                           <p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction evaluates an
                        XPath expression written statically in its <code>select</code>
                        attribute.</p>
                        </li>
                        <li>
                           <p>The <a href="#element-select"><code>xsl:select</code></a> instruction evaluates
                        an XPath expression written statically in its contained text node.</p>
                        </li>
                        <li>
                           <p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction
                        compiles and evaluates an XPath expression that is constructed
                        dynamically as a character string.</p>
                        </li>
                     </ul>
                     <p>These three instructions may return
                     atomic items, function items, or nodes.</p>
                  </li>
                  <li>
                     <p> An <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>) also produces a sequence of items as its
                     result.</p>
                  </li>
               </ol>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-immediate-result" title="immediate result"></a>The result of evaluating
               a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the sequence
               of items formed by concatenating the results of evaluating each of the nodes in the
               sequence constructor, retaining order. This is 
                  referred to as the <b>immediate result</b>
            of the sequence constructor.<span class="definition">]</span></p>
               <p>However:</p>
               <ul>
                  <li>
                     <p>For the effect of the <a href="#element-fallback"><code>xsl:fallback</code></a> instruction, see <a href="#fallback"><i>24.3.3 Fallback</i></a>.</p>
                  </li>
                  <li>
                     <p>For the effect of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> and
                        <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions, see <a href="#conditional-content-construction"><i>8.5 Conditional Content Construction</i></a>.</p>
                  </li>
               </ul>
               <p>The way that <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
               is used depends on the containing element in the stylesheet, and is specified in the rules 
               for that element. It is typically one of the following:</p>
               <ul>
                  <li>
                     <p>The <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> may be bound to a <a title="variable" class="termref" href="#dt-variable">variable</a> or 
                     delivered as the result of a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>.
                     In this case the <code>as</code> attribute of the containing <a href="#element-variable"><code>xsl:variable</code></a>
                     or <a href="#element-function"><code>xsl:function</code></a> element may be used to declare its required type, 
                     and the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> is then converted to the required type 
                     by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <ul>
                           <li>
                              <p>In the absence of an <code>as</code> attribute, the result of a 
                              function is the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the sequence constructor; 
                              but the value of a variable (for backwards compatibility reasons) is a document node 
                              whose content is formed by applying the rules in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a> 
                              to the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a>.
                           </p>
                           </li>
                           <li>
                              <p>The coercion rules do not merge adjacent text nodes 
                              or insert separators between adjacent items. This means it is often inappropriate 
                              to use <a href="#element-value-of"><code>xsl:value-of</code></a> in the body of <a href="#element-variable"><code>xsl:variable</code></a> or 
                              <a href="#element-function"><code>xsl:function</code></a>, especially when the intent is to return an atomic result. 
                              The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is designed for this purpose, and 
                              is usually a better choice.
                           </p>
                           </li>
                           <li>
                              <p>The result of a function, or the value of a variable, may contain nodes 
                              (such as elements, attributes, and text nodes) that are not attached to any parent node 
                              in a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.  The semantics of XPath expressions when applied to parentless nodes 
                              are well-defined; however, such expressions should be used with care. For example, 
                              the expression <code>/</code> causes a type error if the root of the tree containing 
                              the context node is not a document node.
                           </p>
                           </li>
                           <li>
                              <p>Parentless attribute nodes require particular care because they have no
                              namespace nodes associated with them. A parentless attribute node is not
                              permitted to contain namespace-sensitive content (for example, a QName or an
                              XPath expression) because there is no information enabling the prefix to be
                              resolved to a namespace URI. Parentless attributes can be useful in an
                              application (for example, they provide an alternative to the use of
                              attribute sets: see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>) but they need to be
                              handled with care.</p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li>
                     <p>The sequence may be returned as the result of the containing element. This
                     happens, for example, when 
                     the element containing the
                     sequence constructor is 
                        <a href="#element-break"><code>xsl:break</code></a>,
                        <a href="#element-catch"><code>xsl:catch</code></a>, 
                        <a href="#element-fallback"><code>xsl:fallback</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>,
                        <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, <a href="#element-fork"><code>xsl:fork</code></a>, <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-iterate"><code>xsl:iterate</code></a>,
                        <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>, 
                        <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>, <a href="#element-on-completion"><code>xsl:on-completion</code></a>,
                        <a href="#element-otherwise"><code>xsl:otherwise</code></a>, <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>,
                        <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-try"><code>xsl:try</code></a>, or <a href="#element-when"><code>xsl:when</code></a>. </p>
                  </li>
                  <li>
                     <p>The sequence may be used to construct the content of a new element or document
                     node. This happens when the sequence constructor appears as the content of a
                        <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>,
                     or of one of the instructions <a href="#element-copy"><code>xsl:copy</code></a>,
                        <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-document"><code>xsl:document</code></a>,
                        <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-assert"><code>xsl:assert</code></a>, or <a href="#element-message"><code>xsl:message</code></a>.
                     It also happens when the sequence constructor is contained in one of the
                     elements <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, or
                        <a href="#element-with-param"><code>xsl:with-param</code></a>,  when this instruction has no
                        <code>as</code> attribute. For details, see <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p>
                  </li>
                  <li>
                     <p>The sequence may be used to construct the <a title="string value" class="termref" href="#dt-string-value">string
                        value</a> of an attribute node, text node, namespace node, comment
                     node, or processing instruction node. This happens when the sequence
                     constructor is contained in one of the elements <a href="#element-attribute"><code>xsl:attribute</code></a>,
                        <a href="#element-text"><code>xsl:text</code></a>, <a href="#element-value-of"><code>xsl:value-of</code></a>, <a href="#element-namespace"><code>xsl:namespace</code></a>,
                        <a href="#element-comment"><code>xsl:comment</code></a>, or
                     <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>. For details, see <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
                  </li>
               </ul>
               <div class="div3">
                  
                  <h4><a id="constructing-complex-content"></a>5.7.1 <a href="#constructing-complex-content" style="text-decoration: none">Constructing Complex Content</a></h4>
                  <p>Many instructions, for example <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, 
                  <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, and 
                  <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>, 
                  create a new parent node, and evaluate a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
                  forming the content of the instruction to create the attributes, 
                  namespaces, and children of the new parent node. The <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> 
                  of the sequence constructor is processed to create the content of the new parent 
                  node as described in this section.</p>
                  <p>When constructing the content of an element, the <code>inherit-namespaces</code>
                  attribute of the <a href="#element-element"><code>xsl:element</code></a> or <a href="#element-copy"><code>xsl:copy</code></a>
                  instruction, or the <code>xsl:inherit-namespaces</code> property of the literal
                  result element, determines whether namespace nodes are to be inherited. The effect
                  of this attribute is described in the rules that follow.</p>
                  <p>The <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
                  is processed as follows (applying the rules in the order they are listed):</p>
                  <ol class="enumar">
                     <li>
                        <p>The containing instruction may generate attribute nodes and/or namespace
                        nodes, as specified in the rules for the individual instruction. For
                        example, these nodes may be produced by expanding an
                           <code>[xsl:]use-attribute-sets</code> attribute, or by expanding the
                        attributes of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result
                           element</a>. Any such nodes are prepended to the 
                        <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a> of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p>
                     </li>
                     <li>
                        <p>Any array item in the sequence (see <a href="#arrays"><i>22 Arrays</i></a>)
                     is replaced by its members, recursively. This is equivalent to applying
                     the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function defined in 
                     <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p>
                     </li>
                     <li>
                        <p>Any atomic item in the sequence is cast to a string.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>Casting from <code>xs:QName</code> or <code>xs:NOTATION</code> to
                              <code>xs:string</code> always succeeds, because these values retain a
                           prefix for this purpose. However, there is no guarantee that the prefix
                           used will always be meaningful in the context where the resulting string
                           is used.</p>
                        </div>
                     </li>
                     <li>
                        <p>Any consecutive sequence of strings in the sequence is converted
                        to a single text node, whose <a title="string value" class="termref" href="#dt-string-value">string
                           value</a> contains the content of each of the strings in turn, with
                        <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>)  used as a separator between successive strings.</p>
                     </li>
                     <li>
                        <p>Any document node within the sequence is replaced by a sequence
                        containing each of its children, in document order.</p>
                     </li>
                     <li>
                        <p>Zero-length text nodes within the sequence are removed.</p>
                     </li>
                     <li>
                        <p>Adjacent text nodes within the sequence are merged into a single text
                        node.</p>
                     </li>
                     <li>
                        <p>Invalid items in the sequence are
                        detected as follows.</p>
                        <p>
                        <a id="err-XTDE0410"><span class="error">[ERR XTDE0410] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence used to construct the content of an element node contains a
                              namespace node or attribute node that is preceded in the sequence by a
                              node that is neither a namespace node nor an attribute node.
                     </p>
                        <p>
                        <a id="err-XTDE0420"><span class="error">[ERR XTDE0420] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence used to construct the content of a document node contains a
                              namespace node or attribute node.
                     </p>
                        <p>
                        <a id="err-XTDE0430"><span class="error">[ERR XTDE0430] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence contains two or more namespace nodes having the same name but
                              different <a title="string value" class="termref" href="#dt-string-value">string values</a> (that
                              is, namespace nodes that map the same prefix to different namespace
                              URIs).
                     </p>
                        <p>
                        <a id="err-XTDE0440"><span class="error">[ERR XTDE0440] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence contains a namespace node with no name and the element node
                              being constructed has a null namespace URI (that is, it is an error to
                              define a default namespace when the element is in no namespace). 
                     </p>
                        <p>
                        <a id="err-XTDE0450"><span class="error">[ERR XTDE0450] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result
                              sequence contains a function item. 
                     </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The error code reflects the fact that this error was at one time classified 
                           as a dynamic error rather than a type error.</p>
                        </div>
                     </li>
                     <li>
                        <p>If the sequence contains two or more namespace nodes with the same
                        name (or no name) and the same <a title="string value" class="termref" href="#dt-string-value">string
                           value</a> (that is, two namespace nodes mapping the same prefix to
                        the same namespace URI), then all but one of the duplicate nodes are
                        discarded.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>Since the order of namespace nodes is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>,
                           it is not significant which of the duplicates is retained.</p>
                        </div>
                     </li>
                     <li>
                        <p>If an attribute <var>A</var> in the sequence has the same name as
                        another attribute <var>B</var> that appears later in the sequence,
                        then attribute <var>A</var> is discarded from the sequence. Before
                        discarding attribute <var>A</var>, the processor <span class="verb">may</span>
                        raise any <a title="type error" class="termref" href="#dt-type-error">type errors</a> that would be
                        raised if attribute <var>B</var> were not present. </p>
                     </li>
                     <li>
                        <p>Each node in the resulting sequence is attached as a namespace, attribute,
                        or child of the newly constructed element or document node. Conceptually
                        this involves making a deep copy of the node; in practice, however, copying
                        the node will only be necessary if the existing node can be referenced
                        independently of the parent to which it is being attached. When copying an
                        element or processing instruction node, its base URI property is changed to
                        be the same as that of its new parent, unless it has an
                           <code>xml:base</code> attribute (see <a href="#xmlbase">[XML Base]</a>) that
                        overrides this. If the copied element has an <code>xml:base</code>
                        attribute, its base URI is the value of that attribute, resolved (if it is
                        relative) against the base URI of the new parent node.</p>
                        <p>Except for the handling of base URI, the copying
                        of a node follows the rules of the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction
                        with attributes <code>copy-namespaces="yes" copy-accumulators="no"
                           validation="preserve"</code>.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This has the consequence that the type annotation and the values of the
                              <code>nilled</code>, <code>is-id</code>, and <code>is-idrefs</code>
                           properties are retained. However, if the node under construction (the new
                           parent of the node being copied) uses a validation mode other than
                              <code>preserve</code>, this will be transient: the values will be
                           recomputed when the new parent node is validated.</p>
                        </div>
                     </li>
                     <li>
                        <p>If the newly constructed node is an element node, then namespace fixup is
                        applied to this node, as described in <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>.</p>
                     </li>
                     <li>
                        <p>If the newly constructed node is an element node, and if namespaces are
                        inherited, then each namespace node of the newly constructed element
                        (including any produced as a result of the namespace fixup process) is
                        copied to each descendant element of the newly constructed element, unless
                        that element or an intermediate element already has a namespace node with
                        the same name (or absence of a name) or that descendant element or an
                        intermediate element is in no namespace and the namespace node has no
                        name.</p>
                     </li>
                  </ol>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e17258"></a>Example: A Sequence Constructor for Complex Content</div>
                     <p>Consider the following stylesheet fragment:</p>
                     <div class="exampleInner">
                        <pre>&lt;td&gt;
  &lt;xsl:attribute name="valign"&gt;top&lt;/xsl:attribute&gt;
  &lt;xsl:value-of select="@description"/&gt;
&lt;/td&gt;</pre>
                     </div>
                     <p>This fragment consists of a literal result element <code>td</code>, containing
                     a sequence constructor that consists of two instructions:
                        <a href="#element-attribute"><code>xsl:attribute</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a>. The
                     sequence constructor is evaluated to produce a sequence of two nodes: a
                     parentless attribute node, and a parentless text node. The <code>td</code>
                     instruction causes a <code>td</code> element to be created; the new attribute
                     therefore becomes an attribute of the new <code>td</code> element, while the
                     text node created by the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction becomes a
                     child of the <code>td</code> element (unless it is zero-length, in which case
                     it is discarded).</p>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e17287"></a>Example: Space Separators in Element Content</div>
                     <p>Consider the following stylesheet fragment:</p>
                     <div class="exampleInner">
                        <pre>&lt;doc&gt;
  &lt;e&gt;&lt;xsl:sequence select="1 to 5"/&gt;&lt;/e&gt;
  &lt;f&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/f&gt;
&lt;/doc&gt;</pre>
                     </div>
                     <p>This produces the output (when indented):</p>
                     <div class="exampleInner">
                        <pre>&lt;doc&gt;
  &lt;e&gt;1 2 3 4 5&lt;/e&gt;
  &lt;f&gt;12345&lt;/f&gt;
&lt;/doc&gt;</pre>
                     </div>
                     <p>The difference between the two cases is that for the <code>e</code> element,
                     the sequence constructor generates a sequence of five atomic items, which are
                     therefore separated by spaces. For the <code>f</code> element, the content is a
                     sequence of five text nodes, which are concatenated without space
                     separation.</p>
                     <p>It is important to be aware of the distinction between
                        <a href="#element-sequence"><code>xsl:sequence</code></a>, which returns the value of its
                        <code>select</code> expression unchanged, and <a href="#element-value-of"><code>xsl:value-of</code></a>,
                     which constructs a text node.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="constructing-simple-content"></a>5.7.2 <a href="#constructing-simple-content" style="text-decoration: none">Constructing Simple Content</a></h4>
                  <p>The instructions <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-comment"><code>xsl:comment</code></a>,
                     <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, <a href="#element-namespace"><code>xsl:namespace</code></a>,
                  <a href="#element-text"><code>xsl:text</code></a>, and <a href="#element-value-of"><code>xsl:value-of</code></a> 
                  all create nodes that cannot have children.
                  Specifically, the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction creates an attribute
                  node, <a href="#element-comment"><code>xsl:comment</code></a> creates a comment node,
                     <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> creates a processing instruction
                  node, <a href="#element-namespace"><code>xsl:namespace</code></a> creates a namespace node, and
                     <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> create text nodes. 
                  The string value of the new
                  node is constructed using either the <code>select</code> attribute of the
                  instruction, or the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a> that forms the content of the instruction. The
                     <code>select</code> attribute allows the content to be specified by means of an
                  XPath expression, while the sequence constructor allows it to be specified by
                  means of a sequence of XSLT instructions. The <code>select</code> attribute or
                  sequence constructor is evaluated to produce a result sequence, and the <a title="string value" class="termref" href="#dt-string-value">string value</a> of the new node is derived from
                  this result sequence according to the rules below.</p>
                  <p>These rules are also used to compute the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of a <a title="value template" class="termref" href="#dt-value-template">value template</a>. In this case the
                  sequence being processed is the result of evaluating an XPath expression enclosed
                  between curly brackets, and the separator is a single space character.</p>
                  <ol class="enumar">
                     <li>
                        <p>Zero-length text nodes in the sequence are discarded.</p>
                     </li>
                     <li>
                        <p>Adjacent text nodes in the sequence are merged into a single text node.</p>
                     </li>
                     <li>
                        <p>The sequence is <a title="atomize" class="termref" href="#dt-atomization">atomized</a>
                        (which may cause a dynamic error).</p>
                     </li>
                     <li>
                        <p>Every value in the atomized sequence is cast to a string.</p>
                     </li>
                     <li>
                        <p>The strings within the resulting sequence are concatenated, with a (possibly
                        zero-length) separator inserted between successive strings. The default
                        separator depends on the containing instruction; except where
                        otherwise specified, it is a single space.</p>
                        <p>In the case of <a href="#element-attribute"><code>xsl:attribute</code></a>,
                        <a href="#element-text"><code>xsl:text</code></a>, and <a href="#element-value-of"><code>xsl:value-of</code></a>,
                        the default separator is a single space
                     when the <code>select</code> attribute is used, or a zero-length string otherwise; 
                     a different separator can be specified
                        using the <code>separator</code> attribute of the instruction.</p>
                        <p>In the case of <a href="#element-comment"><code>xsl:comment</code></a>,
                        <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, and
                           <a href="#element-namespace"><code>xsl:namespace</code></a>, and when expanding a <a title="value template" class="termref" href="#dt-value-template">value
                        template</a>, the default separator cannot be changed.</p>
                     </li>
                     <li>
                        <p>In the case of <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>, any leading
                        spaces in the resulting string are removed.</p>
                     </li>
                     <li>
                        <p>The resulting string forms the <a title="string value" class="termref" href="#dt-string-value">string
                           value</a> of the new attribute, namespace, comment,
                        processing instruction, or text node.</p>
                     </li>
                  </ol>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e17417"></a>Example: Space Separators in Attribute Content</div>
                     <p>Consider the following stylesheet fragment:</p>
                     <div class="exampleInner">
                        <pre>&lt;doc&gt;
  &lt;xsl:attribute name="e" select="1 to 5"/&gt;
  &lt;xsl:attribute name="f"&gt;
    &lt;xsl:for-each select="1 to 5"&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="g" expand-text="yes"&gt;{1 to 5}&lt;/xsl:attribute&gt;
&lt;/doc&gt;</pre>
                     </div>
                     <p>This produces the output:</p>
                     <div class="exampleInner">
                        <pre>&lt;doc e="1 2 3 4 5" f="12345" g="1 2 3 4 5"/&gt;</pre>
                     </div>
                     <p>The difference between the three cases is as follows. For the
                        <code>e</code> attribute, the sequence constructor generates a sequence of
                     five atomic items, which are therefore separated by spaces. For the
                        <code>f</code> attribute, the content is supplied as a sequence of five text
                     nodes, which are concatenated without space separation. For the <code>g</code>
                     attribute, the <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a> constructs a text node
                     using the rules for constructing simple content, which insert space separators
                     between atomic items; the text node is then atomized to form the value of the
                     attribute.</p>
                     <p>Specifying <code>separator=""</code> on the first
                        <a href="#element-attribute"><code>xsl:attribute</code></a> instruction would cause the attribute value
                     to be <code>e="12345"</code>. A <code>separator</code> attribute on the second
                        <a href="#element-attribute"><code>xsl:attribute</code></a> instruction would have no effect, since the
                     separator only affects the way adjacent atomic items are handled: separators
                     are never inserted between adjacent text nodes. A
                           <code>separator</code> on the third <a href="#element-attribute"><code>xsl:attribute</code></a>
                        instruction would also have no effect, because text value templates are
                        evaluated without regard to the containing instruction.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If an attribute value template contains a sequence of fixed and variable parts,
                     no additional whitespace is inserted between the expansions of the fixed and
                     variable parts. For example, the <a title="effective value" class="termref" href="#dt-effective-value">effective
                        value</a> of the attribute <code>a="chapters{4 to 6}"</code> is
                        <code>a="chapters4 5 6"</code>.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="namespace-fixup"></a>5.7.3 <a href="#namespace-fixup" style="text-decoration: none">Namespace Fixup</a></h4>
                  <p>In a tree supplied to or constructed by an XSLT processor, the constraints
                  relating to namespace nodes that are specified in <a href="#xpath-datamodel-40">[XDM 4.0]</a>
                  <span class="verb">must</span> be satisfied. For example:</p>
                  <ul>
                     <li>
                        <p>If an element node has an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> with a non-null namespace URI, then that element node
                           <span class="verb">must</span> have at least one namespace node whose <a title="string value" class="termref" href="#dt-string-value">string value</a> is the same as that
                        namespace URI.</p>
                     </li>
                     <li>
                        <p>If an element node has an attribute node whose <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has a non-null namespace
                        URI, then the element <span class="verb">must</span> have at least one namespace
                        node whose <a title="string value" class="termref" href="#dt-string-value">string value</a> is the same
                        as that namespace URI and whose name is non-empty.</p>
                     </li>
                     <li>
                        <p>Every element <span class="verb">must</span> have a namespace node whose <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has local-part
                           <code>xml</code> and whose <a title="string value" class="termref" href="#dt-string-value">string
                           value</a> is <code>http://www.w3.org/XML/1998/namespace</code>. The
                        namespace prefix <code>xml</code>
                        <span class="verb">must</span> not be associated with any other namespace URI, and
                        the namespace URI <code>http://www.w3.org/XML/1998/namespace</code>
                        <span class="verb">must</span> not be associated with any other prefix.</p>
                     </li>
                     <li>
                        <p>A namespace node <span class="verb">must not</span> have the name
                           <code>xmlns</code> or the string value
                           <code>http://www.w3.org/2000/xmlns/</code>.</p>
                     </li>
                  </ul>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-namespace-fixup" title="namespace fixup"></a>The rules for the
                     individual XSLT instructions that construct a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> (see <a href="#creating-new-nodes"><i>11 Creating Nodes</i></a>) prescribe
                     some of the situations in which namespace nodes are written to the tree. These
                     rules, however, are not sufficient to ensure that the prescribed constraints
                     are always satisfied. The XSLT processor <span class="verb">must</span> therefore add
                     additional namespace nodes to satisfy these constraints. This process is
                     referred to as <b>namespace fixup</b>.<span class="definition">]</span>
               </p>
                  <p>The actual namespace nodes that are added to the tree by the namespace fixup
                  process are <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, provided firstly, that at the end of the
                  process the above constraints <span class="verb">must</span> all be satisfied, and
                  secondly, that a namespace node <span class="verb">must not</span> be added to the tree
                  unless the namespace node is necessary either to satisfy these constraints, or to
                  enable the tree to be serialized using the original namespace prefixes from the
                  source document or <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>.</p>
                  <p>Namespace fixup <span class="verb">must not</span> result in an element having multiple
                  namespace nodes with the same name.</p>
                  <p>Namespace fixup <span class="verb">may</span>, if necessary to resolve conflicts, change
                  the namespace prefix contained in the QName value that holds the name of an
                  element or attribute node. This includes the option to add or remove a prefix.
                  However, namespace fixup <span class="verb">must not</span> change the prefix component
                  contained in a value of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                  that forms the typed value of an element or attribute node.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Namespace fixup is not used to create namespace declarations for
                        <code>xs:QName</code> or <code>xs:NOTATION</code> values appearing in the
                     content of an element or attribute.</p>
                     <p>Where values acquire such types as the result of validation, namespace fixup
                     does not come into play, because namespace fixup happens before validation: in
                     this situation, it is the user’s responsibility to ensure that the
                     element being validated has the required namespace nodes to enable validation
                     to succeed.</p>
                     <p>Where existing elements are copied along with their existing <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a>
                        (<code>validation="preserve"</code>) the rules require that existing
                     namespace nodes are also copied, so that any namespace-sensitive values remain
                     valid.</p>
                     <p>Where existing attributes are copied along with their existing type
                     annotations, the rules of the XDM data model require that a parentless
                     attribute node cannot contain a namespace-sensitive typed value; this means
                     that it is an error to copy an attribute using
                        <code>validation="preserve"</code> if it contains namespace-sensitive
                     content.</p>
                  </div>
                  <p>Namespace fixup is applied to every element that is constructed using a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, or one of the
                  instructions <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, or
                     <a href="#element-copy-of"><code>xsl:copy-of</code></a>. An implementation is not
                     <span class="verb">required</span> to perform namespace fixup for elements in any
                  source document, that is, for a document in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, documents loaded using the
                     <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> function, documents supplied as the value of
                  a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, or
                  documents returned by an <a title="extension function" class="termref" href="#dt-extension-function">extension
                     function</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension
                     instruction</a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>A source document (an input document, a document returned by the
                        <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or
                        <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions, a document returned by an
                     extension function or extension instruction, or a document supplied as a
                     stylesheet parameter) is required to satisfy the constraints described in
                        <a href="#xpath-datamodel-40">[XDM 4.0]</a>, including the constraints imposed by the
                     namespace fixup process. The effect of supplying a pseudo-document that does
                     not meet these constraints is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
                  </div>
                  <p>In an Infoset (see <a href="#xml-infoset">[XML Information Set]</a>) created from a document conforming
                  to <a href="#xml-names">[Namespaces in XML]</a>, it will always be true that if a parent element has
                  an in-scope namespace with a non-empty namespace prefix, then its child elements
                  will also have an in-scope namespace with the same namespace prefix, though
                  possibly with a different namespace URI. This constraint is removed in <a href="#xml-names11">[Namespaces in XML 1.1]</a>. XSLT 4.0 supports the
                  creation of result trees that do not satisfy this constraint: the namespace fixup
                  process does not add a namespace node to an element merely because its parent node
                  in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> has such a namespace
                  node. However, the process of constructing the children of a new element, which is
                  described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>, does cause the
                  namespaces of a parent element to be inherited by its children unless this is
                  prevented using <code>[xsl:]inherit-namespaces="no"</code> on the instruction that
                  creates the parent element.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This has implications on serialization, defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>. It means that it is possible to create
                        <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> that cannot
                     be faithfully serialized as XML 1.0 documents. When such a result tree is
                     serialized as XML 1.0, namespace declarations written for the parent element
                     will be inherited by its child elements as if the corresponding namespace nodes
                     were present on the child element, except in the case of the default namespace,
                     which can be undeclared using the construct <code>xmlns=""</code>. When the
                     same result tree is serialized as XML 1.1, however, it is possible to undeclare
                     any namespace on the child element (for example, <code>xmlns:foo=""</code>) to
                     prevent this inheritance taking place.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="uri-references"></a>5.8 <a href="#uri-references" style="text-decoration: none">URI References</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-uri-reference" title="URI Reference"></a>Within this specification, the
                  term <b>URI Reference</b>, unless otherwise stated, refers to a string in
                  the lexical space of the <code>xs:anyURI</code> datatype as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.<span class="definition">]</span> Note that this is a wider definition than that
               in <a href="#RFC3986">[RFC3986]</a>: in particular, it is designed to accommodate
               Internationalized Resource Identifiers (IRIs) as described in <a href="#RFC3987">[RFC3987]</a>, and thus allows the use of non-ASCII characters without escaping.</p>
               <p>URI References are used in XSLT with three main roles:</p>
               <ul>
                  <li>
                     <p>As namespace URIs</p>
                  </li>
                  <li>
                     <p>As collation URIs</p>
                  </li>
                  <li>
                     <p>As identifiers for resources such as stylesheet modules; these resources are
                     typically accessible using a protocol such as HTTP. Examples of such
                     identifiers are the URIs used in the <code>href</code> attributes of
                        <a href="#element-import"><code>xsl:import</code></a>, <a href="#element-include"><code>xsl:include</code></a>, 
                        <a href="#element-result-document"><code>xsl:result-document</code></a>, and <a href="#element-package-location"><code>xsl:package-location</code></a>.</p>
                  </li>
               </ul>
               <p>The rules for namespace URIs are given in <a href="#xml-names">[Namespaces in XML]</a> and <a href="#xml-names11">[Namespaces in XML 1.1]</a>. Those specifications deprecate the use of relative URI
                  references as namespace URIs.</p>
               <p>The rules for collation URIs are given in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#collations">5.3.1 Collations</a>.</p>
               <p>URI references used to identify external resources must conform to the same rules as
               the locator attribute (<code>href</code>) defined in section 5.4 of <a href="#xlink">[XLink]</a>. If the URI reference is relative, then it is resolved (unless
               otherwise specified) against the base URI of the containing element node, according
               to the rules of <a href="#RFC3986">[RFC3986]</a>, after first escaping all characters that
               need to be escaped to make it a valid RFC3986 URI reference. (But a relative URI
                  reference in the <code>href</code> attribute of
                  <a href="#element-result-document"><code>xsl:result-document</code></a> is resolved against the <a title="base output URI" class="termref" href="#dt-base-output-uri">Base Output URI</a>.)</p>
               <p>Other URI references appearing in an XSLT stylesheet document, for example the system
               identifiers of external entities or the value of the <code>xml:base</code> attribute,
               must follow the rules in their respective specifications.</p>
               <p>The base URI of an element node in the stylesheet
               is determined as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-base-uri">7.6.2 base-uri Accessor</a>. Some
               implementations may allow the output of the static analysis phase of stylesheet
               processing (a “compiled stylesheet”) to be evaluated in a different location from
               that where static analysis took place. Furthermore, stylesheet authors may in such
               cases wish to avoid exposing the location of resources that are private to the
               development environment. If the base URI of an element in the stylesheet is defined
               by an absolute URI appearing in an <code>xml:base</code> attribute within the
               stylesheet, this value <span class="verb">must</span> be used as the static base URI. In
               other cases where processing depends on the static base URI of a stylesheet module,
               implementations <span class="verb">may</span> use different values for the static base URI
               during static analysis and during dynamic evaluation (for example, an implementation
                  <span class="verb">may</span> use different base URIs for resolving
                  <a href="#element-import"><code>xsl:import</code></a> module references and for resolving a relative
               reference used as an argument to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function). In such
               cases an implementation <span class="verb">must</span> document how the static base URI is
               computed for each situation in which it is required. </p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="rules"></a>6 <a href="#rules" style="text-decoration: none">Template Rules</a></h2>
            <p>Template rules define the processing that can be applied to items that match a particular <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p>
            <div class="div2">
               
               <h3><a id="defining-templates"></a>6.1 <a href="#defining-templates" style="text-decoration: none">Defining Templates</a></h3>
               <p class="element-syntax"><a id="element-template"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:template<br>&nbsp;&nbsp;match? = <var>pattern</var><br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;priority? = <var>decimal</var><br>&nbsp;&nbsp;mode? = <var>tokens</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-context-item">xsl:context-item</a>?, <a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:template&gt;</code></p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-template" title="template"></a>An <a href="#element-template"><code>xsl:template</code></a>
                  declaration defines a <b>template</b>, which contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>;
                  this sequence constructor is evaluated to determine
                     the result of the template. A template can serve either as a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, invoked by matching items against a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, or as a <a title="named template" class="termref" href="#dt-named-template">named
                     template</a>, invoked explicitly by name. It is also possible for the
                  same template to serve in both capacities.<span class="definition">]</span>
            </p>
               <p>
               <a id="err-XTSE0500"><span class="error">[ERR XTSE0500] </span></a>An <a href="#element-template"><code>xsl:template</code></a> element <span class="verb">must</span> have either a
                        <code>match</code> attribute or a <code>name</code> attribute, or both. An
                        <a href="#element-template"><code>xsl:template</code></a> element that has no <code>match</code>
                     attribute <span class="verb">must</span> have no <code>mode</code> attribute and no
                        <code>priority</code> attribute. An
                           <a href="#element-template"><code>xsl:template</code></a> element that has no <code>name</code>
                        attribute <span class="verb">must</span> have no <code>visibility</code>
                        attribute.
            </p>
               <p>If an <a href="#element-template"><code>xsl:template</code></a> element has a <code>match</code> attribute, then
               it is a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>. If it has a
                  <code>name</code> attribute, then it is a <a title="named template" class="termref" href="#dt-named-template">named
                  template</a>.</p>
               <p>A <a title="template" class="termref" href="#dt-template">template</a> may be invoked in a number of ways,
               depending on whether it is a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>,
               a <a title="named template" class="termref" href="#dt-named-template">named template</a>, or both. The result of
               invoking the template is the result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the
                  <a href="#element-template"><code>xsl:template</code></a> element (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>).</p>
               <p>For details of the optional <a href="#element-context-item"><code>xsl:context-item</code></a> child
               element, see <a href="#declaring-context-item"><i>10.1.4 Declaring the Context Item for a Template</i></a>.</p>
               <p>If an <code>as</code> attribute of the <a href="#element-template"><code>xsl:template</code></a> element is
               present, the <code>as</code> attribute defines the required type of the result. The
               result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                  constructor</a> is then converted to the required type using the 
               <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If no
                  <code>as</code> attribute is specified, the default value is <code>item()*</code>,
               which permits any value. No conversion then takes place.</p>
               <p>
               <a id="err-XTTE0505"><span class="error">[ERR XTTE0505] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                     evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a> cannot be coerced to the required type.
            </p>
               <p>If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then (a) the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
               defining the template body <span class="verb">must</span> be empty: that is, the only
               permitted children are <a href="#element-context-item"><code>xsl:context-item</code></a> and
                  <a href="#element-param"><code>xsl:param</code></a>, and (b) there <span class="verb">must</span> be no
                  <code>match</code> attribute.</p>
               <p>If the parent of the <a href="#element-template"><code>xsl:template</code></a> element is an
               <a href="#element-override"><code>xsl:override</code></a> element, then either or both of the following conditions
               must be true:</p>
               <ol class="enumar">
                  <li>
                     <p>There is a <code>name</code> attribute, and the <a title="package" class="termref" href="#dt-package">package</a> identified by the containing
                  <a href="#element-use-package"><code>xsl:use-package</code></a> element contains among its <a title="component" class="termref" href="#dt-component">components</a> a <a title="named template" class="termref" href="#dt-named-template">named
                        template</a> whose <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic
                           identifier</a> is the same as that of this named template, and which has a <a title="compatible" class="termref" href="#dt-compatible">compatible</a> signature.</p>
                  </li>
                  <li>
                     <p>Both the following conditions are true:</p>
                     <ol class="enumla">
                        <li>
                           <p>There is a <code>match</code> attribute.</p>
                        </li>
                        <li>
                           <p>The value of the <code>mode</code> attribute,
                        or in its absence the string <code>#default</code>,
                        is a whitespace-separated sequence of tokens in which each token satisfies
                        one of the following conditions:</p>
                           <ol class="enumlr">
                              <li>
                                 <p>The token is an EQName representing the name of a mode that is exposed,
                           with visibility equal to <code>public</code>, by the package identified by the containing
                           <a href="#element-use-package"><code>xsl:use-package</code></a> element.</p>
                              </li>
                              <li>
                                 <p>The token is <code>#default</code>, and there is an ancestor-or-self element with
                              a <code>default-mode</code> attribute whose value is an EQName representing the name of a mode that is exposed,
                              with visibility equal to <code>public</code>, by the package identified by the containing
                              <a href="#element-use-package"><code>xsl:use-package</code></a> element.</p>
                              </li>
                           </ol>
                        </li>
                     </ol>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The token <code>#unnamed</code> is not allowed because the unnamed mode never has public visibility. 
                     The token <code>#all</code> is not allowed because its intended meaning would not be obvious.
                  </p>
                     </div>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="defining-template-rules"></a>6.2 <a href="#defining-template-rules" style="text-decoration: none">Defining Template Rules</a></h3>
               <p>This section describes <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>.
                  <a title="named template" class="termref" href="#dt-named-template">Named templates</a> are described in
                  <a href="#named-templates"><i>10.1 Named Templates</i></a>.</p>
               <p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is specified using the
                  <a href="#element-template"><code>xsl:template</code></a> element with a <code>match</code> attribute. The
                  <code>match</code> attribute is a <a href="#doc-xslt40-Pattern">Pattern</a> that identifies
               the items to which the rule applies. The result of
               applying the template rule is the result of evaluating the sequence constructor
               contained in the <a href="#element-template"><code>xsl:template</code></a> element, with the matching item used as the <a title="context item" class="termref" href="#dt-context-item">context item</a>.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e18086"></a>Example: A Simple Template Rule</div>
                  <p>For example, an XML document might contain:</p>
                  <div class="exampleInner">
                     <pre>This is an &lt;emph&gt;important&lt;/emph&gt; point.</pre>
                  </div>
                  <p>The following <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> matches
                     <code>emph</code> elements and produces a <code>fo:wrapper</code> element with
                  a <code>font-weight</code> property of <code>bold</code>.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="emph"&gt;
  &lt;fo:wrapper font-weight="bold" 
              xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is evaluated when an
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that matches the pattern specified in the <code>match</code>
               attribute. The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is described in the
               next section. If several template rules match a selected item, only one of them is evaluated, as described in <a href="#conflict"><i>6.6 Conflict Resolution for Template Rules</i></a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="patterns"></a>6.3 <a href="#patterns" style="text-decoration: none">Patterns</a></h3>
               <p>In XSLT 4.0, patterns can match any kind of item: atomic items and
               function items as well as nodes.</p>
               <p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> identifies the items to which it applies by means of a pattern. As
               well as being used in template rules, patterns are used for numbering (see <a href="#number"><i>12 Numbering</i></a>), for grouping (see <a href="#grouping"><i>14 Grouping</i></a>), and for declaring
                  <a title="key" class="termref" href="#dt-key">keys</a> (see <a href="#key"><i>20.2 Keys</i></a>).</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-pattern" title="pattern"></a>A <b>pattern</b> specifies a set of
                  conditions on an item. An item that satisfies the conditions matches the pattern; an
                     item that does not satisfy the conditions
                  does not match the pattern.<span class="definition">]</span></p>
               <p>There are several kinds of pattern:</p>
               <ul>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-predicate-pattern" title="predicate pattern"></a>A <b>predicate pattern</b> is written as
                           <code>.</code> (dot) followed by zero or more predicates in square
                        brackets, and it matches any item for which each of the predicates evaluates
                        to <code>true</code>.<span class="definition">]</span></p>
                     <p>The detailed semantics are given in <a href="#predicate-patterns"><i>6.3.2.1 Predicate Patterns</i></a>. This construct can be used to match items of any
                     kind (nodes, atomic items, and function items). For example, the pattern
                     <code>.[starts-with(., '$')]</code> matches any string that starts with the
                     character <code>$</code>, or a node whose atomized value starts with 
                     <code>$</code>. This example shows a predicate pattern with a single
                     predicate, but the grammar allows any number of predicates (zero or more).</p>
                  </li>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-type-pattern" title="type pattern"></a>A <b>type pattern</b> is written as
                     <code>~T</code> (where <var>T</var> is an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>)
                     followed by zero or more predicates in square
                     brackets, and it matches any item that is coercible to type <var>T</var> for which each of the predicates evaluates
                     to <code>true</code>.<span class="definition">]</span></p>
                     <p>The parameter <var>T</var> can also be a <span class="markup-error">[TERMDEF  IN XP40]</span>, 
                     consisting of a parenthesized sequence of item types separated by <code>"|"</code>.
                  For example, <code>~(array(*) | map(*))</code> matches arrays and maps, while 
                  <code>~(text() | comment())</code> matches text nodes and comment nodes.</p>
                     <p>The type pattern <code>match="~(text() | comment())"</code> has almost the same effect as
                  the <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode pattern</a> <code>match="text() | comment()"</code>, 
                     but the rules for calculating a default priority
                  are different: see <a href="#default-priority"><i>6.3.3 Default Priority for Patterns</i></a>.</p>
                  </li>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-gnode-pattern" title="GNode pattern"></a>An <b>GNode pattern</b> uses a subset of
                        the syntax for path expressions, and is defined to match a GNode if the
                        corresponding path expression would select the GNode.<span class="definition">]</span></p>
                     <p>The syntax for GNode patterns
                        (<a href="#doc-xslt40-GNodePattern">GNodePattern</a> in the grammar:
                        see <a href="#pattern-syntax"><i>6.3.2 Syntax of Patterns</i></a>) is a subset of the syntax for
                        <a title="expression" class="termref" href="#dt-expression">expressions</a>. GNode patterns
                        are used only for matching nodes, and the same syntax may match either
                        an XNode or a JNode.
                     As explained in detail below, a GNode matches a GNode pattern if the
                     equivalent XPath expression selects the GNode when evaluated with respect
                     to some appropriate context.</p>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The specification uses the phrases <em>an item matches a pattern</em> and
                     <em>a pattern matches an item</em> interchangeably. They are equivalent: an
                  item matches a pattern if and only if the pattern matches the item.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="pattern-examples"></a>6.3.1 <a href="#pattern-examples" style="text-decoration: none">Examples of Patterns</a></h4>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="pattern-examples-1"></a>Example: Patterns</div>
                     <p>Here are some examples of patterns:</p>
                     <ul>
                        <li>
                           <p><em>Predicate Patterns:</em></p>
                           <ol class="enumar">
                              <li>
                                 <p><code>.</code> matches any item.</p>
                              </li>
                              <li>
                                 <p><code>.[. castable as xs:date]</code> matches any item
                                 that can be successfully cast to <code>xs:date</code>: for example,
                              an <code>xs:date</code> or <code>xs:dateTime</code> value, or a string
                              in the lexical form of a date, or a node whose typed value is an <code>xs:date</code>
                              or a string in the form of a date.</p>
                              </li>
                              <li>
                                 <p><code>.[string() =&gt; matches('^[0-9]$')]</code> matches any
                                 item whose string value is a sequence of digits.</p>
                              </li>
                              <li>
                                 <p><code>.[. castable as xs:date][xs:date(.) le current-date()]</code> matches any
                                 item that is castable to <code>xs:date</code> provided that the result of casting
                                 the value to <code>xs:date</code> is a date in the past.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p><em>Type Patterns</em></p>
                           <ol class="enumar">
                              <li>
                                 <p><code>~item()</code> matches any item.</p>
                              </li>
                              <li>
                                 <p><code>~node()</code> matches any XNode.
                                 (Note the distinction from the pattern <code>node()</code>.)</p>
                              </li>
                              <li>
                                 <p><code>~xs:date</code> matches any
                                 atomic item of type <code>xs:date</code> (or a type derived by
                                 restriction from <code>xs:date</code>).</p>
                              </li>
                              <li>
                                 <p><code>~xs:date[. gt current-date()]</code> matches any date in
                                 the future.</p>
                              </li>
                              <li>
                                 <p><code>~xs:string[starts-with(., 'e')]</code> matches any <code>xs:string</code>
                                 value that starts with the letter <code>e</code>. Note there is no type conversion; the pattern
                              will not match an <code>xs:untypedAtomic</code> or <code>xs:anyURI</code> value,
                              nor will it match a node.</p>
                              </li>
                              <li>
                                 <p><code>~fn(*)</code> matches any
                                 function item.</p>
                              </li>
                              <li>
                                 <p><code>~(fn($x as xs:integer) as xs:boolean)[.(42)]</code> matches any function that
                                 accepts an <code>xs:integer</code> argument and returns a boolean result, provided
                                 that the result of calling the function with the argument value <code>42</code> is <code>true</code>.</p>
                              </li>
                              <li>
                                 <p><code>~(xs:date | xs:dateTime | xs:time)</code> matches any atomic item
                                 that is an instance of <code>xs:date</code>, <code>xs:dateTime</code>, or <code>xs:time</code>.</p>
                              </li>
                              <li>
                                 <p><code>~(array(xs:date) | array(xs:dateTime) | array(xs:time))</code> matches any array whose
                                 members are all of type <code>xs:date</code>, any array whose
                                 members are all of type <code>xs:dateTime</code>, or any array whose
                                 members are all of type <code>xs:time</code>. Contrast 
                              <code>~array(xs:date | xs:dateTime | xs:time)</code> which allows
                              the three types to be mixed within a single array.</p>
                              </li>
                              <li>
                                 <p><code>~map((xs:string | xs:untypedAtomic), *)</code> matches any map
                                 whose keys are all instances of <code>xs:string</code> or <code>xs:untypedAtomic</code>.</p>
                              </li>
                              <li>
                                 <p><code>~enum("red", "green", "blue")</code> matches any one of the three strings
                                 <code>"red"</code>, <code>"green"</code>, or <code>"blue"</code>.</p>
                              </li>
                              <li>
                                 <p><code>~record(first, last)[?location = 'UK']</code> matches any map whose keys include the strings <code>"first"</code>
                                 and <code>"last"</code>, and that also has an entry with key <code>"location"</code> whose
                              value is <code>"UK"</code>.</p>
                                 <p>This can also be written <code>~record(first, last, location as enum('UK'))</code>.</p>
                              </li>
                              <li>
                                 <p><code>~record(longitude, latitude)</code> matches any map with exactly two entries,
                                 whose keys are the strings <code>"longitude"</code>
                                 and <code>"latitude"</code>.</p>
                              </li>
                              <li>
                                 <p><code>~record(title, author as enum("Dickens"))</code> matches having an entry whose keys is the string <code>"title"</code>,
                                 plus an entry whose key is the string <code>"author"</code> and whose associated value
                                 is the string <code>"Dickens"</code>.</p>
                              </li>
                              <li>
                                 <p><code>~array(xs:integer)[array:size(.) eq 4]</code> matches any array of four integers.</p>
                              </li>
                              <li>
                                 <p><code>~array(record(first, last))</code> matches any array of maps where each map
                                 contains entries with keys <code>"first"</code> and <code>"last"</code>. Note that
                              this includes the empty array.</p>
                              </li>
                              <li>
                                 <p><code>~array(record(first, last))[array:size(.) gt 0]</code> matches any non-empty array of maps where each map
                                 contains entries with keys <code>"first"</code> and <code>"last"</code>. </p>
                              </li>
                              <li>
                                 <p><code>~complex</code> matches any value that is an instance of the item type 
                                 declared in an <a href="#element-item-type"><code>xsl:item-type</code></a> or <a href="#element-record-type"><code>xsl:record-type</code></a>
                                 declaration with name <code>"complex"</code></p>
                              </li>
                              <li>
                                 <p><code>~complex[?i eq 0]</code> matches any value that is an instance of the 
                                 item type declared in an <a href="#element-item-type"><code>xsl:item-type</code></a> or <a href="#element-record-type"><code>xsl:record-type</code></a>
                                 declaration with name <code>"complex"</code> and that is a map with an entry having key <code>i</code> and value zero.</p>
                              </li>
                              <li>
                                 <p><code>~jnode("date of birth", xs:date)</code> matches a JNode that encapsulates a map entry
                              whose key is the string <code>"date of birth"</code> and whose associated value is an atomic item
                              of type <code>xs:date</code>.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p><em>Patterns Matching XNodes</em></p>
                           <ol class="enumar">
                              <li>
                                 <p><code>*</code> matches any element node.</p>
                              </li>
                              <li>
                                 <p><code>para</code> matches any <code>para</code> element.</p>
                              </li>
                              <li>
                                 <p><code>chapter|appendix</code> matches any <code>chapter</code> element
                              and any <code>appendix</code> element.</p>
                              </li>
                              <li>
                                 <p><code>child::(chapter|appendix)</code> matches any <code>chapter</code> element
                                 and any <code>appendix</code> element. Note that although the <code>child</code> axis
                              is explicitly written, an element can match even though it has no parent.</p>
                              </li>
                              <li>
                                 <p><code>olist/entry</code> matches any <code>entry</code> element with an
                              <code>olist</code> parent.</p>
                              </li>
                              <li>
                                 <p><code>appendix//para</code> matches any <code>para</code> element with an
                              <code>appendix</code> ancestor element.</p>
                              </li>
                              <li>
                                 <p><code>appendix/descendant::(para|table)</code> matches any <code>para</code> 
                                 or <code>table</code>element with an
                                 <code>appendix</code> ancestor element.</p>
                              </li>
                              <li>
                                 <p><code>schema-element(us:address)</code> matches any element that is
                              annotated as an instance of the type defined by the schema element
                              declaration <code>us:address</code>, and whose name is either
                              <code>us:address</code> or the name of another element in its
                              substitution group. </p>
                              </li>
                              <li>
                                 <p><code>attribute(*, xs:date)</code> matches any attribute annotated as
                              being of type <code>xs:date</code>.</p>
                              </li>
                              <li>
                                 <p><code>/</code> matches a document node.</p>
                              </li>
                              <li>
                                 <p><code>document-node()</code> matches a document node.</p>
                              </li>
                              <li>
                                 <p><code>document-node(schema-element(my:invoice))</code> matches the
                              document node of a document whose document element is named
                              <code>my:invoice</code> and matches the type defined by the global
                              element declaration <code>my:invoice</code>.</p>
                              </li>
                              <li>
                                 <p><code>text()</code> matches any text node.</p>
                              </li>
                              <li>
                                 <p><code>namespace-node()</code> matches any namespace
                              node.</p>
                              </li>
                              <li>
                                 <p><code>node()</code> matches any node other than an attribute node,
                              namespace node, or document node.</p>
                              </li>
                              <li>
                                 <p><code>id("W33")</code> matches the element with unique ID
                              <code>W33</code>. </p>
                              </li>
                              <li>
                                 <p><code>para[1]</code> matches any <code>para</code> element that is the
                              first <code>para</code> child element of its parent. It also matches a
                              parentless <code>para</code> element.</p>
                              </li>
                              <li>
                                 <p><code>//para</code> matches any <code>para</code> element in a tree that is rooted at a document node.</p>
                              </li>
                              <li>
                                 <p><code>bullet[position() mod 2 = 0]</code> matches any <code>bullet</code>
                              element that is an even-numbered <code>bullet</code> child of its
                              parent.</p>
                              </li>
                              <li>
                                 <p><code>div[@class="appendix"]//p</code> matches any <code>p</code> element
                              with a <code>div</code> ancestor element that has a <code>class</code>
                              attribute with value <code>appendix</code>. </p>
                              </li>
                              <li>
                                 <p><code>@class</code> matches any <code>class</code> attribute
                              (<em>not</em> any element that has a <code>class</code>
                              attribute).</p>
                              </li>
                              <li>
                                 <p><code>@(class|type|kind)</code> matches any attribute named <code>class</code> 
                              or <code>type</code> or <code>kind</code>.</p>
                              </li>
                              <li>
                                 <p><code>@*</code> matches any attribute node.</p>
                              </li>
                              <li>
                                 <p><code>$xyz</code> matches any GNode that is present in
                              the value of the variable <code>$xyz</code>. Note that it will not
                              match any other item that is present in the value of the variable.</p>
                              </li>
                              <li>
                                 <p><code>$xyz//*</code> matches any element that is a
                              descendant of a node that is present in the value of the variable
                              <code>$xyz</code>. It will also match certain JNodes if the
                              variable <code>$xyz</code> includes JNodes.</p>
                              </li>
                              <li>
                                 <p><code>doc('product.xml')//*</code> matches any element
                              within the document whose document URI is <code>product.xml</code>.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p><em>Patterns matching JNodes</em></p>
                           <ol class="enumar">
                              <li>
                                 <p>The patterns <code>jnode()</code>, <code>jnode(*)</code>, and <code>jnode(*, *)</code> 
                                 are equivalent, and match any JNode.</p>
                              </li>
                              <li>
                                 <p><code>jnode("date of birth", *)</code> matches any JNode representing a map
                                 entry with key <code>"date of birth"</code>.</p>
                              </li>
                              <li>
                                 <p><code>jnode(*, array(xs:integer))</code> matches any JNode representing a map
                                 entry or array item whose value is an array of integers.</p>
                              </li>
                              <li>
                                 <p><code>jnode(books, array(record(Author, Title)))</code> 
                                 matches any JNode representing a map
                                 entry whose key is <code>"books"</code> and whose content is an array of records,
                                 each record having entries named <code>"Author"</code> and <code>"Title"</code> (with other
                                 entries also allowed).</p>
                              </li>
                              <li>
                                 <p><code>jnode(*, record(Author as enum("Dickens"), Title))</code> 
                                 matches any JNode whose content is a map
                                 having an entry with key <code>"Author"</code> and value <code>"Dickens"</code>,
                                 plus an entry with key <code>"Title"</code> (with other
                                 entries also allowed).</p>
                              </li>
                              <li>
                                 <p><code>jnode(())</code> matches any root JNode (that is, a JNode whose <b>·selector·</b> property
                              is absent).</p>
                              </li>
                              <li>
                                 <p><code>jnode((), array(map(*)))</code> matches any root JNode whose <b>·content·</b> property
                                 is an array of maps.</p>
                              </li>
                           </ol>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="pattern-syntax"></a>6.3.2 <a href="#pattern-syntax" style="text-decoration: none">Syntax of Patterns</a></h4>
                  <p>
                  <a id="err-XTSE0340"><span class="error">[ERR XTSE0340] </span></a>Where an attribute is defined to contain a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, it is a <a title="static error" class="termref" href="#dt-static-error">static
                           error</a> if the pattern does not match the production <a href="#doc-xslt40-Pattern">Pattern</a>.</p>
                  <p>The complete grammar for patterns is listed in <a href="#pattern-syntax-summary"><i>E Pattern Syntax Summary</i></a>. 
                  It uses the notation defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#EBNFNotation">A.1.1 Notation</a>. </p>
                  <p>The lexical rules for patterns are the same as the lexical rules
                  for XPath expressions, as defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#lexical-structure">A.3 Lexical structure</a>. Comments are permitted between tokens, using the
                  syntax <code>(: ... :)</code>. All other provisions of the XPath grammar apply
                  where relevant, for example the rules for whitespace handling and
                  extra-grammatical constraints.</p>
                  <table class="scrap">
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xslt40-Pattern"></a><code>Pattern</code></td>
                           <td>::=</td>
                           <td><code><a href="#doc-xslt40-Pattern-PredicatePattern">PredicatePattern</a>  |  <a href="#doc-xslt40-Pattern-TypePattern">TypePattern</a>  |  <a href="#doc-xslt40-Pattern-GNodePattern">GNodePattern</a></code></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xslt40-Pattern-PredicatePattern"></a><code>PredicatePattern</code></td>
                           <td>::=</td>
                           <td><code>"."  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xslt40-Pattern-TypePattern"></a><code>TypePattern</code></td>
                           <td>::=</td>
                           <td><code>"~"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                        </tr>
                     </tbody>
                     <tbody>
                        <tr style="vertical-align:baseline;">
                           <td><a id="doc-xslt40-Pattern-GNodePattern"></a><code>GNodePattern</code></td>
                           <td>::=</td>
                           <td><code><a href="#prod-xslt40-UnionExprP">UnionExprP</a></code></td>
                        </tr>
                     </tbody>
                  </table>
                  <p>Patterns fall into three groups:</p>
                  <ul>
                     <li>
                        <p>A <code>PredicatePattern</code> matches items according to conditions that the item must
                  satisfy: for example <code>.[. castable as xs:integer]</code> matches any value (it might
                  be an atomic item, a node, or an array) that is castable as an integer.</p>
                     </li>
                     <li>
                        <p>A <code>TypePattern</code> matches items according to their type. For example
                  <code>~xs:integer</code> matches an atomic item that is an instance of <code>xs:integer</code>,
                  while <code>~record(longitude, latitude)</code> matches a map that has exactly two entries, with
                  keys <code>"longitude"</code> and <code>"latitude"</code></p>
                     </li>
                     <li>
                        <p>An <code>GNodePattern</code> matches GNodes in a GTree (for example, a tree
                     representing the contents of an XML or JSON document), by specifying a path that
                  can be used to locate the nodes: for example <code>order</code> matches an element node
                  named <code>order</code> within an XTree, or a JNode with ·selector· <code>"order"</code>
                        within a JTree; similarly, <code>billing-address/city</code> matches an element node named <code>city</code>
                  whose parent node is an element named <code>billing-address</code>, or a JNode with ·selector· <code>"city"</code>
                  whose parent is a JNode with ·selector· <code>"billing-address"</code>.</p>
                     </li>
                  </ul>
                  <p>The following sections define the rules for each of these groups.</p>
                  <div class="div4">
                     
                     <h5><a id="predicate-patterns"></a>6.3.2.1 <a href="#predicate-patterns" style="text-decoration: none">Predicate Patterns</a></h5>
                     <table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern"></a><code>PredicatePattern</code></td>
                              <td>::=</td>
                              <td><code>"."  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-Predicate"></a><code>Predicate</code></td>
                              <td>::=</td>
                              <td><code>"["  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  "]"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-Expr"></a><code>Expr</code></td>
                              <td>::=</td>
                              <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup> ++ ",")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-ExprSingle"></a><code>ExprSingle</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForExpr">ForExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetExpr">LetExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QuantifiedExpr">QuantifiedExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-IfExpr">IfExpr</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-ForExpr"></a><code>ForExpr</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForClause">ForClause</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForLetReturn">ForLetReturn</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-ForClause"></a><code>ForClause</code></td>
                              <td>::=</td>
                              <td><code>"for"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForBinding">ForBinding</a><sup><small>XP</small></sup> ++ ",")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-ForLetReturn"></a><code>ForLetReturn</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForExpr">ForExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetExpr">LetExpr</a><sup><small>XP</small></sup>  |  ("return"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>)</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-LetExpr"></a><code>LetExpr</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetClause">LetClause</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForLetReturn">ForLetReturn</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-LetClause"></a><code>LetClause</code></td>
                              <td>::=</td>
                              <td><code>"let"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetBinding">LetBinding</a><sup><small>XP</small></sup> ++ ",")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-QuantifiedExpr"></a><code>QuantifiedExpr</code></td>
                              <td>::=</td>
                              <td><code>("some"  |  "every")  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QuantifierBinding">QuantifierBinding</a><sup><small>XP</small></sup> ++ ",")  "satisfies"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-QuantifierBinding"></a><code>QuantifierBinding</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup>  "in"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-IfExpr"></a><code>IfExpr</code></td>
                              <td>::=</td>
                              <td><code>"if"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  ")"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnbracedActions">UnbracedActions</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-BracedAction">BracedAction</a><sup><small>XP</small></sup>)</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-UnbracedActions"></a><code>UnbracedActions</code></td>
                              <td>::=</td>
                              <td><code>"then"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>  "else"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-PredicatePattern-BracedAction"></a><code>BracedAction</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnclosedExpr">EnclosedExpr</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>A <a href="#doc-xslt40-PredicatePattern">PredicatePattern</a>
                     <var>PP</var> matches an item <var>J</var> if and only if the XPath expression taking
                     the same form as <var>PP</var> returns a non-empty sequence when evaluated with a
                     <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>J</var>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The pattern <code>.</code>, which is a <code>PredicatePattern</code> with no predicates,
                        matches every item.</p>
                        <p>A predicate with the numeric value 1 (one) always matches, and a predicate with
                        any other numeric value never matches. Numeric predicates in a
                        <code>PredicatePattern</code> are therefore not useful, but are defined this
                        way in the interests of consistency with XPath.</p>
                        <p>The predicate pattern <code>.[<var>P<sub>1</sub></var>][<var>P<sub>2</sub></var>][<var>P<sub>3</sub></var>]</code>
                     is equivalent to the type pattern <code>~item()[<var>P<sub>1</sub></var>][<var>P<sub>2</sub></var>][<var>P<sub>3</sub></var>]</code>.</p>
                     </div>
                     <p>For example, the pattern <code>.[contains(., "XSLT")]</code>
                  matches any item whose atomized value contains <code>"XSLT"</code> as a substring. 
                  It matches values such as the string <code>"XSLT Transformations"</code>, the
                     <code>xs:anyURI</code> value
                     <code>http://www.w3.org/TR/XSLT</code>, the attribute node 
                     <code>class="XSD XSLT XPath"</code>, and the singleton array <code>[ "XSLT 4.0" ]</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>
                     Evaluation of this example pattern may fail with a dynamic error if the item in question
                     has an atomized value that is not a string, or that is a sequence of strings: an example might
                     be the array <code>[ "XSLT", 1999 ]</code>. It will also fail if the item cannot be atomized,
                     for example if it is a map. The rules in <a href="#pattern-errors"><i>6.3.4 Errors in Patterns</i></a> cause these errors
                     to be masked: they simply result in the pattern being treated as non-matching.
                  </p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="type-patterns"></a>6.3.2.2 <a href="#type-patterns" style="text-decoration: none">Type Patterns</a></h5>
                     <div class="changes">
                        <p class="changesHeading">
        Changes in 4.0
        (<a href="#node-patterns">next</a> | <a href="#defining-decimal-format">previous</a>)</p>
                        <ol>
                           <li>
                              <p>
                        Patterns (especially those used in template rules) can now be defined
                        by reference to item types, so any item type can be used as a match
                        pattern. For example <code>match="~record(longitude, latitude)"</code>
                        matches any map that includes the key values <code>"longitude"</code>
                        and <code>"latitude"</code>.
                     <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/400">400</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/401">401</a>&nbsp;21 March 2023]</i></p>
                           </li>
                           <li>
                              <p>
                        Extensible map types are dropped; instead, the coercion rules cause undefined
                        map entries to be discarded.
                     <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2365">2365</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2413">2413</a>&nbsp;28 January 2026]</i></p>
                           </li>
                        </ol>
                     </div>
                     <table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern"></a><code>TypePattern</code></td>
                              <td>::=</td>
                              <td><code>"~"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ItemType"></a><code>ItemType</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RegularItemType">RegularItemType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionType">FunctionType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeName">TypeName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ChoiceItemType">ChoiceItemType</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-RegularItemType"></a><code>RegularItemType</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyItemTest">AnyItemTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeKindTest">NodeKindTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-GNodeType">GNodeType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-JNodeType">JNodeType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MapType">MapType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrayType">ArrayType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RecordType">RecordType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnumerationType">EnumerationType</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AnyItemTest"></a><code>AnyItemTest</code></td>
                              <td>::=</td>
                              <td><code>"item"  "("  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-NodeKindTest"></a><code>NodeKindTest</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-DocumentTest">DocumentTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AttributeTest">AttributeTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaAttributeTest">SchemaAttributeTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PITest">PITest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-CommentTest">CommentTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TextTest">TextTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NamespaceNodeTest">NamespaceNodeTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyNodeKindTest">AnyNodeKindTest</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-DocumentTest"></a><code>DocumentTest</code></td>
                              <td>::=</td>
                              <td><code>"document-node"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTestUnion">NameTestUnion</a><sup><small>XP</small></sup>)?  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ElementTest"></a><code>ElementTest</code></td>
                              <td>::=</td>
                              <td><code>"element"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTestUnion">NameTestUnion</a><sup><small>XP</small></sup>  (","  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeName">TypeName</a><sup><small>XP</small></sup>  "?"?)?)?  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-SchemaElementTest"></a><code>SchemaElementTest</code></td>
                              <td>::=</td>
                              <td><code>"schema-element"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementName">ElementName</a><sup><small>XP</small></sup>  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-NameTestUnion"></a><code>NameTestUnion</code></td>
                              <td>::=</td>
                              <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> ++ "|")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-TypeName"></a><code>TypeName</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AttributeTest"></a><code>AttributeTest</code></td>
                              <td>::=</td>
                              <td><code>"attribute"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTestUnion">NameTestUnion</a><sup><small>XP</small></sup>  (","  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeName">TypeName</a><sup><small>XP</small></sup>)?)?  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ElementName"></a><code>ElementName</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-SchemaAttributeTest"></a><code>SchemaAttributeTest</code></td>
                              <td>::=</td>
                              <td><code>"schema-attribute"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AttributeName">AttributeName</a><sup><small>XP</small></sup>  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AttributeName"></a><code>AttributeName</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-PITest"></a><code>PITest</code></td>
                              <td>::=</td>
                              <td><code>"processing-instruction"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup>)?  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-StringLiteral"></a><code>StringLiteral</code></td>
                              <td>::=</td>
                              <td><code><a href="#doc-xslt40-TypePattern-AposStringLiteral">AposStringLiteral</a>  |  <a href="#doc-xslt40-TypePattern-QuotStringLiteral">QuotStringLiteral</a></code></td>
                           </tr>
                           <tr>
                              <td></td>
                              <td></td>
                              <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-CommentTest"></a><code>CommentTest</code></td>
                              <td>::=</td>
                              <td><code>"comment"  "("  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-TextTest"></a><code>TextTest</code></td>
                              <td>::=</td>
                              <td><code>"text"  "("  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-NamespaceNodeTest"></a><code>NamespaceNodeTest</code></td>
                              <td>::=</td>
                              <td><code>"namespace-node"  "("  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AnyNodeKindTest"></a><code>AnyNodeKindTest</code></td>
                              <td>::=</td>
                              <td><code>"node"  "("  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-GNodeType"></a><code>GNodeType</code></td>
                              <td>::=</td>
                              <td><code>"gnode"  "("  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-JNodeType"></a><code>JNodeType</code></td>
                              <td>::=</td>
                              <td><code>"jnode"  "("  (("*"  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-JRootSelector">JRootSelector</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Constant">Constant</a><sup><small>XP</small></sup>)  (","  ("*"  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>))?)?  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-JRootSelector"></a><code>JRootSelector</code></td>
                              <td>::=</td>
                              <td><code>"("  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-Constant"></a><code>Constant</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup>  |  ("-"?  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NumericLiteral">NumericLiteral</a><sup><small>XP</small></sup>)  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QNameLiteral">QNameLiteral</a><sup><small>XP</small></sup>  |  ("true"  "("  ")")  |  ("false"  "("  ")")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-NumericLiteral"></a><code>NumericLiteral</code></td>
                              <td>::=</td>
                              <td><code><a href="#prod-xslt40-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xslt40-HexIntegerLiteral">HexIntegerLiteral</a>  |  <a href="#prod-xslt40-BinaryIntegerLiteral">BinaryIntegerLiteral</a>  |  <a href="#prod-xslt40-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-xslt40-DoubleLiteral">DoubleLiteral</a></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-QNameLiteral"></a><code>QNameLiteral</code></td>
                              <td>::=</td>
                              <td><code>"#"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-SequenceType"></a><code>SequenceType</code></td>
                              <td>::=</td>
                              <td><code>("empty-sequence"  "("  ")")<br>|  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a><sup><small>XP</small></sup>?)</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-OccurrenceIndicator"></a><code>OccurrenceIndicator</code></td>
                              <td>::=</td>
                              <td><code>"?"  |  "*"  |  "+"</code></td>
                           </tr>
                           <tr>
                              <td></td>
                              <td></td>
                              <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-occurrence-indicators">xgs: occurrence-indicators</a> */</td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-MapType"></a><code>MapType</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyMapType">AnyMapType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedMapType">TypedMapType</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AnyMapType"></a><code>AnyMapType</code></td>
                              <td>::=</td>
                              <td><code>"map"  "("  "*"  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-TypedMapType"></a><code>TypedMapType</code></td>
                              <td>::=</td>
                              <td><code>"map"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>  ","  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ArrayType"></a><code>ArrayType</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyArrayType">AnyArrayType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedArrayType">TypedArrayType</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AnyArrayType"></a><code>AnyArrayType</code></td>
                              <td>::=</td>
                              <td><code>"array"  "("  "*"  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-TypedArrayType"></a><code>TypedArrayType</code></td>
                              <td>::=</td>
                              <td><code>"array"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-RecordType"></a><code>RecordType</code></td>
                              <td>::=</td>
                              <td><code>"record"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FieldDeclaration">FieldDeclaration</a><sup><small>XP</small></sup> ** ",")  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-FieldDeclaration"></a><code>FieldDeclaration</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FieldName">FieldName</a><sup><small>XP</small></sup>  "?"?  ("as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>)?</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-FieldName"></a><code>FieldName</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-EnumerationType"></a><code>EnumerationType</code></td>
                              <td>::=</td>
                              <td><code>"enum"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup> ++ ",")  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AposStringLiteral"></a><code>AposStringLiteral</code></td>
                              <td>::=</td>
                              <td><code>"'"  (<a href="#prod-xslt40-EscapeApos">EscapeApos</a>  |  [^'])*  "'"</code></td>
                           </tr>
                           <tr>
                              <td></td>
                              <td></td>
                              <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-QuotStringLiteral"></a><code>QuotStringLiteral</code></td>
                              <td>::=</td>
                              <td><code>'"'  (<a href="#prod-xslt40-EscapeQuot">EscapeQuot</a>  |  [^"])*  '"'</code></td>
                           </tr>
                           <tr>
                              <td></td>
                              <td></td>
                              <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-FunctionType"></a><code>FunctionType</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyFunctionType">AnyFunctionType</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedFunctionType">TypedFunctionType</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-AnyFunctionType"></a><code>AnyFunctionType</code></td>
                              <td>::=</td>
                              <td><code>("function"  |  "fn")  "("  "*"  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-TypedFunctionType"></a><code>TypedFunctionType</code></td>
                              <td>::=</td>
                              <td><code>("function"  |  "fn")  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedFunctionParam">TypedFunctionParam</a><sup><small>XP</small></sup> ** ",")  ")"  "as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-TypedFunctionParam"></a><code>TypedFunctionParam</code></td>
                              <td>::=</td>
                              <td><code>("$"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  "as")?  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-EQName"></a><code>EQName</code></td>
                              <td>::=</td>
                              <td><code><a href="#prod-xslt40-QName">QName</a>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-URIQualifiedName">URIQualifiedName</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-URIQualifiedName"></a><code>URIQualifiedName</code></td>
                              <td>::=</td>
                              <td><code><a href="#prod-xslt40-BracedURILiteral">BracedURILiteral</a>  (<a href="#prod-xslt40-NCName">NCName</a>  ":")?  <a href="#prod-xslt40-NCName">NCName</a></code></td>
                           </tr>
                           <tr>
                              <td></td>
                              <td></td>
                              <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ChoiceItemType"></a><code>ChoiceItemType</code></td>
                              <td>::=</td>
                              <td><code>"("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup> ++ "|")  ")"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-Predicate"></a><code>Predicate</code></td>
                              <td>::=</td>
                              <td><code>"["  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  "]"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-Expr"></a><code>Expr</code></td>
                              <td>::=</td>
                              <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup> ++ ",")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ExprSingle"></a><code>ExprSingle</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForExpr">ForExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetExpr">LetExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QuantifiedExpr">QuantifiedExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-IfExpr">IfExpr</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ForExpr"></a><code>ForExpr</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForClause">ForClause</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForLetReturn">ForLetReturn</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ForClause"></a><code>ForClause</code></td>
                              <td>::=</td>
                              <td><code>"for"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForBinding">ForBinding</a><sup><small>XP</small></sup> ++ ",")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-ForLetReturn"></a><code>ForLetReturn</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForExpr">ForExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetExpr">LetExpr</a><sup><small>XP</small></sup>  |  ("return"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>)</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-LetExpr"></a><code>LetExpr</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetClause">LetClause</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForLetReturn">ForLetReturn</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-LetClause"></a><code>LetClause</code></td>
                              <td>::=</td>
                              <td><code>"let"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetBinding">LetBinding</a><sup><small>XP</small></sup> ++ ",")</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-QuantifiedExpr"></a><code>QuantifiedExpr</code></td>
                              <td>::=</td>
                              <td><code>("some"  |  "every")  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QuantifierBinding">QuantifierBinding</a><sup><small>XP</small></sup> ++ ",")  "satisfies"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-QuantifierBinding"></a><code>QuantifierBinding</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup>  "in"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-IfExpr"></a><code>IfExpr</code></td>
                              <td>::=</td>
                              <td><code>"if"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  ")"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnbracedActions">UnbracedActions</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-BracedAction">BracedAction</a><sup><small>XP</small></sup>)</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-UnbracedActions"></a><code>UnbracedActions</code></td>
                              <td>::=</td>
                              <td><code>"then"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>  "else"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-TypePattern-BracedAction"></a><code>BracedAction</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnclosedExpr">EnclosedExpr</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>A type pattern matches an item if both the following conditions are true:</p>
                     <ul>
                        <li>
                           <p>The item can be successfully coerced to the given item type, by applying the
                     <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                        </li>
                        <li>
                           <p>The item (after such coercion) satisfies each of the predicates.</p>
                        </li>
                     </ul>
                     <p>For example:</p>
                     <ul>
                        <li>
                           <p><code>~xs:integer</code> matches any instance of
                        <code>xs:integer</code></p>
                        </li>
                        <li>
                           <p><code>~xs:integer[. gt 0]</code> matches
                        any positive integer.</p>
                        </li>
                        <li>
                           <p><code>~(xs:string | xs:untypedAtomic)[matches(., '[0-9]+')]</code> matches
                        any instance of <code>xs:string</code> or <code>xs:untypedAtomic</code> that
                        contains a sequence of decimal digits.</p>
                        </li>
                        <li>
                           <p><code>~node()</code> matches any XNode. (This is not the same as the pattern
                        <code>node()</code>, which for historical reasons only matches  element, text, comment, 
                        and processing instruction nodes).</p>
                        </li>
                        <li>
                           <p><code>~record(first as enum("Sharon"), last)</code>
                        matches any map having entries with the string-valued keys <code>"first"</code> and <code>"last"</code>,
                        where the entry for the key <code>"first"</code> is equal to the string <code>"Sharon"</code></p>
                        </li>
                        <li>
                           <p><code>~jnode(address, record(address-line-1, address-line-2))</code> matches a JNode whose
                     ·selector· property is the string <code>"address"</code>, and whose content matches the given record type.</p>
                        </li>
                     </ul>
                     <p>More formally, an item <var>$J</var> matches a pattern <code>~<var>T</var>[<var>P<sub>1</sub></var>][<var>P<sub>2</sub></var>][<var>P<sub>3</sub></var>]</code> if
                  the XPath expression <code>let $JJ as <var>T</var> := J return exists($JJ[<var>P<sub>1</sub></var>][<var>P<sub>2</sub></var>][<var>P<sub>3</sub></var>])</code> is true.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>As with predicate patterns, numeric predicates are allowed, but serve no useful purpose.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>An error in evaluating the equivalent expression (for example, when the item
                        cannot be coerced to the required type) means that the item is treated as not matching the pattern.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The item type in a pattern can be any <code>ItemType</code>, but patterns that match
                        XNodes or JNodes can usually be expressed more concisely
                        as a <code>NodePattern</code> (see <a href="#node-patterns"><i>6.3.2.3 GNode Patterns</i></a>): 
                        for example <code>match="~element(PERSON)"</code> has the same meaning as
                        <code>match="element(PERSON)"</code>, which in turn is usually abbreviated to 
                        <code>match="PERSON"</code> (although <code>match="PERSON"</code> will also match JNodes).</p>
                     </div>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="node-patterns"></a>6.3.2.3 <a href="#node-patterns" style="text-decoration: none">GNode Patterns</a></h5>
                     <div class="changes">
                        <p class="changesHeading">
        Changes in 4.0
        (<a href="#default-priority">next</a> | <a href="#type-patterns">previous</a>)</p>
                        <ol>
                           <li>
                              <p>
                        A function call at the outermost level can now be named using any valid <code>EQName</code>
                        (for example <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a>) provided it binds to one of the permitted functions
                        <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>fn:id</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-element-with-id"><code>fn:element-with-id</code></a>, 
                        <a href="#func-key"><code>fn:key</code></a>, or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-root"><code>fn:root</code></a>. 
                        If two functions are called, for example <code>doc('a.xml')/id('abc')</code>,
                        it is no longer necessary to put the second call in parentheses.
                     <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/1375">1375</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/1522">1522</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1378">1378</a>&nbsp;15 October 2024]</i></p>
                           </li>
                        </ol>
                     </div>
                     <table class="scrap">
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern"></a><code>GNodePattern</code></td>
                              <td>::=</td>
                              <td><code><a href="#doc-xslt40-GNodePattern-UnionExprP">UnionExprP</a></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-UnionExprP"></a><code>UnionExprP</code></td>
                              <td>::=</td>
                              <td><code><a href="#doc-xslt40-GNodePattern-IntersectExceptExprP">IntersectExceptExprP</a>  (("union"  |  "|")  <a href="#doc-xslt40-GNodePattern-IntersectExceptExprP">IntersectExceptExprP</a>)*</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-IntersectExceptExprP"></a><code>IntersectExceptExprP</code></td>
                              <td>::=</td>
                              <td><code><a href="#doc-xslt40-GNodePattern-PathExprP">PathExprP</a>  (("intersect"  |  "except")  <a href="#doc-xslt40-GNodePattern-PathExprP">PathExprP</a>)*</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-PathExprP"></a><code>PathExprP</code></td>
                              <td>::=</td>
                              <td><code><a href="#doc-xslt40-GNodePattern-RootedPath">RootedPath</a><br>|  ("/"  <a href="#doc-xslt40-GNodePattern-RelativePathExprP">RelativePathExprP</a>?)<br>|  ("//"  <a href="#doc-xslt40-GNodePattern-RelativePathExprP">RelativePathExprP</a>)<br>|  <a href="#doc-xslt40-GNodePattern-RelativePathExprP">RelativePathExprP</a></code></td>
                           </tr>
                           <tr>
                              <td></td>
                              <td></td>
                              <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-leading-lone-slash">xgs: leading-lone-slash</a> */</td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-RootedPath"></a><code>RootedPath</code></td>
                              <td>::=</td>
                              <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*  (("/"  |  "//")  <a href="#doc-xslt40-GNodePattern-RelativePathExprP">RelativePathExprP</a>)?</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-VarRef"></a><code>VarRef</code></td>
                              <td>::=</td>
                              <td><code>"$"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-Predicate"></a><code>Predicate</code></td>
                              <td>::=</td>
                              <td><code>"["  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  "]"</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-RelativePathExprP"></a><code>RelativePathExprP</code></td>
                              <td>::=</td>
                              <td><code><a href="#doc-xslt40-GNodePattern-StepExprP">StepExprP</a>  (("/"  |  "//")  <a href="#doc-xslt40-GNodePattern-StepExprP">StepExprP</a>)*</code></td>
                           </tr>
                        </tbody>
                        <tbody>
                           <tr style="vertical-align:baseline;">
                              <td><a id="doc-xslt40-GNodePattern-StepExprP"></a><code>StepExprP</code></td>
                              <td>::=</td>
                              <td><code><a href="#prod-xslt40-PostfixExprP">PostfixExprP</a>  |  <a href="#prod-xslt40-AxisStepP">AxisStepP</a></code></td>
                           </tr>
                        </tbody>
                     </table>
                     <p>GNode patterns are used to match GNodes: that is, XNodes or JNodes.</p>
                     <p>Many of the constructs within a GNode pattern have names that are chosen to align 
                  with the XPath 4.0 grammar.
                  Constructs whose names are suffixed with <code>P</code> are restricted forms of
                  the corresponding XPath 4.0 construct without the suffix: for example,
                  <code>StepExprP</code> is a restricted form of <code>StepExpr</code>. Constructs labeled with
                  the subpercript “XP” are defined in <a href="#xpath-40">[XPath 4.0]</a>.</p>
                     <p>The syntax of a <a href="#doc-xslt40-GNodePattern">GNodePattern</a> is a subset of the syntax
               of an XPath path expression, and the semantics are defined by reference to the semantics
               of XPath expressions.</p>
                     <p>In a <a href="#prod-xslt40-FunctionCallP">FunctionCallP</a>, the
                     <code>EQName</code> used for the function name must bind to
                  one of the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc#1</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>fn:id#1</code></a>, 
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>fn:id#2</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-element-with-id"><code>fn:element-with-id#1</code></a>,
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-element-with-id"><code>fn:element-with-id#2</code></a>
                  <a href="#func-key"><code>fn:key#2</code></a>, <a href="#func-key"><code>fn:key#3</code></a>
                  or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-root"><code>fn:root#0</code></a>, and the arguments (if any) must
                  either be variable references or constants.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>In the case of a call to the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-root"><code>fn:root</code></a> function, the argument list must be empty: that is,
                  only the zero-arity form of the function is allowed.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>As with XPath expressions, the pattern <code>/ union /*</code> can be parsed in
                     two different ways, and the chosen interpretation is to treat
                        <code>union</code> as an element name rather than as an operator. The other
                     interpretation can be achieved by writing <code>(/) union (/*)</code></p>
                     </div>
                     <div class="div5">
                        
                        <h6><a id="pattern-semantics"></a>6.3.2.3.1 <a href="#pattern-semantics" style="text-decoration: none">The Meaning of a GNode Pattern</a></h6>
                        <p>This section defines the formal meaning of a <a href="#doc-xslt40-GNodePattern">GNodePattern</a>.</p>
                        <p>The process for determining whether a GNode matches a 
            <a href="#doc-xslt40-GNodePattern">GNodePattern</a> is as follows:</p>
                        <ol class="enumar">
                           <li>
                              <p>The <a href="#doc-xslt40-GNodePattern">GNodePattern</a> is converted to an 
               <a title="expression" class="termref" href="#dt-expression">expression</a>, 
               called the <b>equivalent expression</b>. The
               equivalent expression to a <a href="#doc-xslt40-GNodePattern">GNodePattern</a> is the XPath
               expression that takes the same lexical form as the <a href="#doc-xslt40-GNodePattern">GNodePattern</a> as
               written, except that two adjustments are made to any
               <a href="#prod-xslt40-AxisStepP">AxisStepP</a> that is a <a title="leading step" class="termref" href="#dt-leading-step">leading step</a>.</p>
                              <p><span class="definition">[Definition:&nbsp;</span><a id="dt-leading-step" title="leading step"></a>An <a href="#prod-xslt40-AxisStepP">AxisStepP</a>
               within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> is a <b>leading step</b> if
               (a) it is not the right-hand operand of a <code>/</code> or <code>//</code>
               operator, and (b) it is not contained (directly or indirectly) within a
               <a href="#prod-xslt40-ParenthesizedPattern">ParenthesizedPattern</a> that is the right-hand operand of a 
               <code>/</code> or <code>//</code> operator<span class="definition">]</span>.</p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>An <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#AxisStep">AxisStep</a><sup><small>XP</small></sup>
               within a predicate is unaffected, since it is not an <a href="#prod-xslt40-AxisStepP">AxisStepP</a>.</p>
                              </div>
                              <p>The adjustments that are made to a <a title="leading step" class="termref" href="#dt-leading-step">leading step</a> are:</p>
                              <ol class="enumla">
                                 <li>
                                    <p>The <code>NodeTest</code> is adjusted to ensure that the pattern will (in most cases) match
                           XNodes or JNodes but not both. Specifically, if the principal node kind of the
                           axis is <code>element</code>, then any <code>Selector</code> within the <code>NodeTest</code>
                           that takes the form of an <code>EQName</code> or <code>Wildcard</code> is wrapped in an <code>ElementTest</code> 
                           so it only selects element nodes. For example, <code>match="*"</code> is interpreted as
                           <code>match="element(*)"</code>, and <code>match="employee"</code> is interpreted
                           as <code>match="element(employee)"</code>.</p>
                                    <div class="note">
                                       <p class="prefix"><b>Note:</b></p>
                                       <p>The rationale for this is firstly, that it improves the clarity of the code
                           if it is clear whether patterns are intended to match XNodes or JNodes; and secondly,
                           that it enables pattern matching to be optimized and simplifies streamability analysis.</p>
                                    </div>
                                 </li>
                                 <li>
                                    <p>In addition, the axis is adjusted to allow the step to match a parentless GNode. The
                        adjustment depends on the axis used in this step, whether it appears
                        explicitly or implicitly (according to the rules of <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#abbrev">4.7.8 Abbreviated Syntax</a>), 
                        and is made as follows:</p>
                                    <ol class="enumlr">
                                       <li>
                                          <p>If the <code>NodeTest</code> in <var>PS</var> is
                                 <code>document-node()</code> (optionally with arguments), and if no
                              explicit axis is specified, then the axis in step <var>PS</var> is
                              taken as <code>self</code> rather than <code>child</code>.</p>
                                       </li>
                                       <li>
                                          <p>If <var>PS</var> uses the child axis (explicitly or implicitly), and
                              if the <code>NodeTest</code> in <var>PS</var> is not
                                 <code>document-node()</code> (optionally with arguments), then the
                              axis in step <var>PS</var> is replaced by <code>child-or-top</code>,
                              which is defined as follows. If the context node is a parentless
                              element, comment, processing instruction, or text node then the
                                 <code>child-or-top</code> axis selects the context node; otherwise
                              it selects the children of the context node. It is a forwards axis
                              whose principal node kind is element.</p>
                                       </li>
                                       <li>
                                          <p>If <var>PS</var> uses the attribute axis (explicitly or implicitly),
                              then the axis in step <var>PS</var> is replaced by
                                 <code>attribute-or-top</code>, which is defined as follows. If the
                              context node is an attribute node with no parent, then the
                                 <code>attribute-or-top</code> axis selects the context node;
                              otherwise it selects the attributes of the context node. It is a
                              forwards axis whose principal node kind is attribute.</p>
                                       </li>
                                       <li>
                                          <p>If <var>PS</var> uses the namespace axis (explicitly or implicitly), then the axis in step
                                 <var>PS</var> is replaced by <code>namespace-or-top</code>, which
                              is defined as follows. If the context node is a namespace node with no
                              parent, then the <code>namespace-or-top</code> axis selects the
                              context node; otherwise it selects the namespace nodes of the context
                              node. It is a forwards axis whose principal node kind is
                              namespace.</p>
                                       </li>
                                    </ol>
                                    <p>The axes <code>child-or-top</code>, <code>attribute-or-top</code>, and
                           <code>namespace-or-top</code> are introduced only for definitional
                        purposes. They cannot be used explicitly in a user-written pattern or
                        expression.</p>
                                    <div class="note">
                                       <p class="prefix"><b>Note:</b></p>
                                       <p>The purpose of this adjustment is to ensure that a pattern such as
                              <code>person</code> matches any element named <code>person</code>,
                           even if it has no parent; and similarly, that the pattern
                              <code>@width</code> matches any attribute named <code>width</code>,
                           even a parentless attribute. The rule also ensures that a pattern using a
                              <code>NodeTest</code> of the form <code>document-node(...)</code>
                           matches a document node. The pattern <code>node()</code> will match any
                           element, text node, comment, or processing instruction, whether or not it
                           has a parent. For backwards compatibility reasons, the pattern
                              <code>node()</code>, when used without an explicit axis, does not
                           match document nodes, attribute nodes, or namespace nodes. The rules are
                           also phrased to ensure that positional patterns of the form
                              <code>para[1]</code> continue to count nodes relative to their parent,
                           if they have one. To match any XNode at all,
                              XSLT 4.0 allows the pattern <code>~node()</code> to be
                              used.</p>
                                       <p>The adjustment is not necessary in the case of JNodes, because a JNode
                        with ·selector· value <code>"person"</code> will necessarily have a parent JNode.</p>
                                    </div>
                                 </li>
                              </ol>
                           </li>
                           <li>
                              <p>The meaning of the pattern is then defined in terms of the semantics of the
                     equivalent expression, denoted below as <code>EE</code>.</p>
                              <p>Specifically, an item <var>N</var> matches a <a href="#doc-xslt40-GNodePattern">GNodePattern</a>
                      <var>P</var> if and only if the following applies, where
                        <code>EE</code> is the <b>equivalent expression</b> to <var>P</var>:</p>
                              <ul>
                                 <li>
                                    <p><var>N</var> is a GNode, and the result of evaluating the expression
                              <code>root(.)//(EE)</code> with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> 
                           based on <var>N</var> is a sequence that includes the GNode <var>N</var>.
                        </p>
                                 </li>
                              </ul>
                              <p>If a pattern appears in an attribute of an XSLT element that
                        is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0
                           behavior</a> (see <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>), then the
                     semantics of the pattern are defined on the basis that the equivalent XPath
                     expression is evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0
                        compatibility mode</a> set to <code>true</code>.</p>
                           </li>
                        </ol>
                        <div class="example">
                           
                           <div class="exampleHeader"><a id="d5e20328"></a>Example: Matching XNodes</div>
                           <p>The <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode pattern</a>
                     <code>p</code> matches any <code>p</code> element. The equivalent expression,
                     after adjustment, is <code>child-or-top::element(p)</code>, and the pattern matches because a <code>p</code>
                     element will always be present in the result of evaluating the 
                     equivalent <a title="expression" class="termref" href="#dt-expression">expression</a>
                     <code>root(.)//(child-or-top::element(p))</code>.</p>
                           <p>Similarly, <code>/</code> matches a
                     document node, and only a document node. The equivalent expression, after adjustment,
                     is <code>self::document-node()</code>, and the pattern matches because the result 
                     of the equivalent <a title="expression" class="termref" href="#dt-expression">expression</a>
                     <code>root(.)//(self::document-node())</code> returns the root node of the tree containing the
                     context node if and only if it is a document node.</p>
                           <p>The <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode pattern</a>
                     <code>node()</code> matches all XNodes selected by the expression
                        <code>root(.)//(child-or-top::node())</code>, that is, all element, text,
                     comment, and processing instruction nodes, whether or not they have a parent.
                     It does not match attribute or namespace nodes because the expression does not
                     select nodes using the attribute or namespace axes. It does not match document
                     nodes because for backwards compatibility reasons the <code>child-or-top</code>
                     axis does not match a document node.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The pattern <code>~node()</code> matches all XNodes.</p>
                           </div>
                           <p>The <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode pattern</a>
                     <code>$V</code> matches all XNodes selected by the expression
                        <code>root(.)//($V)</code>, that is, all XNodes in the value of $V (which
                     will typically be a global variable, though when the pattern is used in
                     contexts such as the <a href="#element-number"><code>xsl:number</code></a> or
                        <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instructions, it can also be a local
                     variable).</p>
                           <p>The <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode pattern</a>
                     <code>doc('product.xml')//product</code> matches all XNodes selected by the
                     expression <code>root(.)//(doc('product.xml')//product)</code>, that is, all
                        <code>product</code> elements in the document whose URI is
                        <code>product.xml</code>.</p>
                           <p>The <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode pattern</a>
                     <code>root(.)/self::E</code> matches an <code>E</code> element that is the root
                     of a tree (that is, an <code>E</code> element with no parent node).</p>
                        </div>
                        <p>Although the semantics of <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode patterns</a> are
                  specified formally in terms of expression evaluation, it is possible to understand
                  pattern matching using a different model. A <a title="GNode pattern" class="termref" href="#dt-gnode-pattern">GNode pattern</a> such as
                     <code>book/chapter/section</code> can be examined from right to left. A node
                  will only match this pattern if it is a <code>section</code> element; and then,
                  only if its parent is a <code>chapter</code>; and then, only if the parent of that
                     <code>chapter</code> is a <code>book</code>. When the pattern uses the
                     <code>//</code> operator, one can still read it from right to left, but this
                  time testing the ancestors of a node rather than its parent. For example
                     <code>appendix//section</code> matches every <code>section</code> element that
                  has an ancestor <code>appendix</code> element.</p>
                        <p>The formal definition, however, is useful for understanding the meaning of a
                  pattern such as <code>para[1]</code>. This matches any node selected by the
                  expression <code>root(.)//(child-or-top::para[1])</code>: that is, any
                     <code>para</code> element that is the first <code>para</code> child of its
                  parent, or a <code>para</code> element that has no parent.</p>
                        <div class="example">
                           
                           <div class="exampleHeader"><a id="d5e20481"></a>Example: Matching JNodes</div>
                           <ul>
                              <li>
                                 <p>The pattern <code>jnode(code, xs:string)</code> matches any
                     JNode whose ·selector· is the string <code>"code"</code> and whose ·content·
                     is an instance of <code>xs:string</code>.</p>
                              </li>
                              <li>
                                 <p>The pattern <code>jnode("date of birth", xs:date)</code> matches any
                     JNode whose ·selector· is the string <code>"date of birth"</code> and whose ·content·
                     is an instance of <code>xs:date</code>.</p>
                              </li>
                              <li>
                                 <p>The pattern <code>jnode(*, array(*))</code> matches any
                     JNode whose ·content· is an array, regardless of its ·selector· property.</p>
                              </li>
                              <li>
                                 <p>The pattern <code>jnode(*, record(Author, Title))[ancestor::books]</code> matches any
                     JNode whose ·content· is an instance of the type <code>record(Author, Title)</code>, 
                     provided it has an ancestor with the ·selector· value <code>"books"</code>.</p>
                              </li>
                              <li>
                                 <p>The pattern <code>jnode(*, record(Author as enum("Dickens"), Title))</code> matches any
                     JNode whose ·content· is a map having an <code>Author</code> entry with the value
                     <code>"Dickens"</code>, a <code>Title</code> entry with any value, and optionally
                     other entries.</p>
                              </li>
                              <li>
                                 <p>The pattern <code>jnode(*, *)[jnode-selector() = current-date()]</code> matches any
                     JNode whose ·selector· property is an <code>xs:date</code> value equal to the current date.
                     The comparison uses the implicit timezone from the dynamic context. The rules for error
                  handling in patterns ensure that any JNode whose ·selector· value is of a type other
                  than <code>xs:date</code> does not match, because evaluation of the predicate raises an error.</p>
                              </li>
                           </ul>
                        </div>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The <code>intersect</code> and <code>except</code> operators
                  do not always have the intuitive meaning. Simple cases such as
                  <code>* except A</code>, or <code>@* except (@code, @name)</code>
                  are unproblematic, but expressions using the descendant axis can
                  be surprising.</p>
                           <p>Consider the pattern <code>para except appendix//para</code>.
                  Perhaps unexpectedly, this matches the <code>para</code> element 
                  in the XML tree shown below:</p>
                           <div class="exampleInner">
                              <pre>&lt;appendix&gt;
  &lt;section&gt;
     &lt;para/&gt;
  &lt;/section&gt;
&lt;/appendix&gt;</pre>
                           </div>
                           <p>This is because there is an element <code>$S</code> (specifically, 
                     the <code>section</code> element), such that the expression
                     <code>$S//(para except appendix//para)</code> selects this
                     <code>para</code> element.</p>
                        </div>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>An implementation, of course, may use any algorithm it wishes for evaluating
                     patterns, so long as the result corresponds with the formal definition above.
                     An implementation that followed the formal definition by evaluating the
                     equivalent expression and then testing the membership of a specific node in the
                     result would probably be very inefficient.</p>
                        </div>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="default-priority"></a>6.3.3 <a href="#default-priority" style="text-decoration: none">Default Priority for Patterns</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#applying-templates">next</a> | <a href="#node-patterns">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                  Default priorities are added for new forms of <code>ElementTest</code> and <code>AttributeTest</code>,
                  for example <code>element(p:*)</code> and <code>element(a|b)</code>.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1394">1394</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1442">1442</a>&nbsp;15 September 2024]</i></p>
                        </li>
                        <li>
                           <p>
                  The default priority for a template rule using a union pattern has changed.
                  This change may cause incompatible behavior.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1770">1770</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1772">1772</a>&nbsp;11 February 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-default-priority" title="default priority"></a>If no <code>priority</code>
                  attribute is specified on an <a href="#element-template"><code>xsl:template</code></a> element, a
                     <b>default priority</b> is computed, based on the syntactic form of 
                  the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> 
               supplied in the <code>match</code> attribute.<span class="definition">]</span> 
               The default priority of a pattern is always greater than or equal to −1 (minus one),
               and less than 1 (plus one). The rules are as follows. </p>
                  <p>Unless otherwise specified, the default priority for a pattern is +0.5. For some simple patterns,
               listed below, there is a lower default priority in the range -1 (minus one) to +0.5.</p>
                  <div class="div4">
                     
                     <h5><a id="default-priority-for-predicate-patterns"></a>6.3.3.1 <a href="#default-priority-for-predicate-patterns" style="text-decoration: none">Default Priority for Predicate Patterns</a></h5>
                     <p>The default priority for the pattern <code>.</code> (a predicate pattern with
               no predicates, which matches any item) is −1.</p>
                     <p>For a <a href="#doc-xslt40-PredicatePattern">PredicatePattern</a> having one or more
                  predicates, the default priority is 0.5.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="default-priority-for-type-patterns"></a>6.3.3.2 <a href="#default-priority-for-type-patterns" style="text-decoration: none">Default Priority for Type Patterns</a></h5>
                     <p>For a <a href="#doc-xslt40-TypePattern">TypePattern</a> with no predicates, the default
               priority depends on the item type:</p>
                     <ul>
                        <li>
                           <p>For a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-choice-item-type">choice item type</a><sup><small>XP</small></sup>, 
                        the default priority is the maximum priority of the item types included
                        in the choice, computed according to the rules below.</p>
                        </li>
                        <li>
                           <p>For the item type <code>item()</code>, the default priority is −1.</p>
                        </li>
                        <li>
                           <p>For any item type that is a 
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#GNodeType">GNodeType</a><sup><small>XP</small></sup>, <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#NodeKindTest">NodeKindTest</a><sup><small>XP</small></sup>
                        or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#JNodeType">JNodeType</a><sup><small>XP</small></sup>
                  (for example <code>jnode(*)</code>, <code>element()</code> or <code>element(N)</code>), the default
                  priority is the same as that of the corresponding GNode Pattern: 
                  see <a href="#default-priority-for-gnode-patterns"><i>6.3.3.3 Default Priority for GNode Patterns</i></a>.</p>
                        </li>
                        <li>
                           <p>For the item type <code>function(*)</code>,
                  the default priority is −0.5.</p>
                        </li>
                        <li>
                           <p>For the item types <code>array(*)</code> and <code>map(*)</code>,
                        the default priority is −0.25.</p>
                        </li>
                        <li>
                           <p>For the item type <code>xs:anyAtomicType</code>,
                  the default priority is −0.5.</p>
                        </li>
                        <li>
                           <p>For the 19 XSD-defined primitive atomic types, and for <code>xs:untypedAtomic</code>,
                        the default priority is 0.</p>
                        </li>
                        <li>
                           <p>For an atomic type other than a primitive type, the default priority is a value greater than
                  0 (zero) and less than 0.5 that reflects its depth in the type hierarchy. Specifically, the priority
                  is computed as <code>0.5 - 2^-<var>N</var></code> where <var>N</var> is the number of
                  derivation steps from <code>xs:anyAtomicType</code>. This formula also works for primitive types. For example:</p>
                           <table style="border:1px solid; padding:5px; width:100%">
                              <caption>Examples of default priorities for atomic types</caption>
                              <thead>
                                 <tr>
                                    <th style="text-align:left; vertical-align:top">Type</th>
                                    <th style="text-align:left; vertical-align:top">Depth (<var>N</var>)</th>
                                    <th style="text-align:left; vertical-align:top">Priority</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top"><code>xs:decimal</code></td>
                                    <td style="text-align:left; vertical-align:top">1</td>
                                    <td style="text-align:left; vertical-align:top">0</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top"><code>xs:integer</code></td>
                                    <td style="text-align:left; vertical-align:top">2</td>
                                    <td style="text-align:left; vertical-align:top">0.25</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top"><code>xs:long</code></td>
                                    <td style="text-align:left; vertical-align:top">3</td>
                                    <td style="text-align:left; vertical-align:top">0.375</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top"><code>xs:int</code></td>
                                    <td style="text-align:left; vertical-align:top">4</td>
                                    <td style="text-align:left; vertical-align:top">0.4375</td>
                                 </tr>
                              </tbody>
                           </table>
                        </li>
                        <li>
                           <p>For an <code>enum</code> type, the default priority is 0.25.</p>
                        </li>
                        <li>
                           <p>For any other item type, the default priority is 0.</p>
                        </li>
                     </ul>
                     <p>For a <a href="#doc-xslt40-TypePattern">TypePattern</a> having one or more predicates,
               the default priority is 0.5</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="default-priority-for-gnode-patterns"></a>6.3.3.3 <a href="#default-priority-for-gnode-patterns" style="text-decoration: none">Default Priority for GNode Patterns</a></h5>
                     <ol class="enumar">
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-ParenthesizedPattern">ParenthesizedPattern</a> then the default
                     priority is the default priority of the contained pattern.</p>
                        </li>
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-UnionExprP">UnionExprP</a> then the default
                     priority is the maximum of the default priorities of the alternatives.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>This is a backwards incompatible change from XSLT 3.0 and earlier
                     versions, which treated the template rule as equivalent to multiple
                     template rules with different priorities.</p>
                              <p>The change is made because of the increasing complexity of extending
                     the rule to patterns like <code>@(a|b)</code>, or <code>attribute(a|b, xs:integer)</code>
                     which are defined to be semantically identical to equivalent union patterns;
                     and to prevent confusion with type patterns such as 
                     <code>type(element(a)|element(b))</code>, where different rules apply.</p>
                              <p>The change affects any template rule with a union pattern that 
                        (a) has no explicit priority attribute, and (b) has multiple branches with
                     different default priority. It is <span class="verb">recommended</span> that processors
                     should output a compatibility warning when such template rules are encountered.</p>
                              <p>The change has two effects. Firstly, if two alternatives 
                        in a union pattern have different priority
                     (for example in a pattern such as <code>a | b/c</code>, the priority of one of
                     the branches will be raised to that of the other branch. Secondly, in cases where
                     the same item matches both branches, a call on <code>xsl:next-match</code> will
                     never cause the same template rule to be evaluated repeatedly.</p>
                           </div>
                        </li>
                        <li>
                           <p>If the pattern is an <a href="#prod-xslt40-IntersectExceptExprP">IntersectExceptExprP</a> 
                     then the default priority of the pattern is that of the first operand pattern. </p>
                        </li>
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-PathExprP">PathExprP</a> taking the form
                        <code>/</code>, then the priority is −0.5.</p>
                        </li>
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-PathExprP">PathExprP</a> taking the form of an
                        <a title="EQName" class="termref" href="#dt-eqname">EQName</a> optionally preceded by a <a href="#prod-xslt40-ForwardAxisP">ForwardAxisP</a> or has the form
                        <code>processing-instruction(</code>
                     <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup>
                     <code>)</code> or <code>processing-instruction(</code>
                     <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>
                     <code>)</code> optionally preceded by a <a href="#prod-xslt40-ForwardAxisP">ForwardAxisP</a>, then the priority is 0.</p>
                        </li>
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-PathExprP">PathExprP</a> taking the form of an
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup> 
                     or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AttributeTest">AttributeTest</a><sup><small>XP</small></sup>, optionally
                     preceded by a <a href="#prod-xslt40-ForwardAxisP">ForwardAxisP</a>, then the priority is as
                     shown in the table below. In this table:</p>
                           <ul>
                              <li>
                                 <p>The symbols <var>E</var>,
                        <var>A</var>, and <var>T</var> represent an arbitrary element name, attribute
                        name, and type name respectively;</p>
                              </li>
                              <li>
                                 <p>The symbol <var>W</var> represents a 
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Wildcard">Wildcard</a><sup><small>XP</small></sup> other than <code>*</code>
                        (for example <code>prefix:*</code> or <code>*:local</code>);</p>
                              </li>
                              <li>
                                 <p>The symbol <code>*</code> represents
                        itself.</p>
                              </li>
                           </ul>
                           <p>The presence or absence of the symbol <code>?</code> following a type
                     name does not affect the priority.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The default priority of a pattern is always less than one, which means that user-allocated
                     priorities greater than or equal to one will always rank higher than a defaulted priority.</p>
                           </div>
                           <table class="data">
                              <caption>Default Priority of Patterns</caption>
                              <thead>
                                 <tr>
                                    <th style="text-align:left; vertical-align:top">Format</th>
                                    <th style="text-align:left; vertical-align:top">Priority</th>
                                    <th style="text-align:left; vertical-align:top">Notes</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>element()</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">−0.5</td>
                                    <td style="text-align:left; vertical-align:top">(equivalent to <code>*</code>)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>element(*)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">−0.5</td>
                                    <td style="text-align:left; vertical-align:top">(equivalent to <code>*</code>)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>attribute()</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">−0.5</td>
                                    <td style="text-align:left; vertical-align:top">(equivalent to <code>@*</code>)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>attribute(*)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">−0.5</td>
                                    <td style="text-align:left; vertical-align:top">(equivalent to <code>@*</code>)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>element(<var>W</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">−0.25</td>
                                    <td style="text-align:left; vertical-align:top"></td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>attribute(<var>W</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">−0.25</td>
                                    <td style="text-align:left; vertical-align:top"></td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>element(<var>E</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0</td>
                                    <td style="text-align:left; vertical-align:top">(equivalent to E)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>element(*, <var>T</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0</td>
                                    <td style="text-align:left; vertical-align:top">(matches by type only)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>attribute(<var>A</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0</td>
                                    <td style="text-align:left; vertical-align:top">(equivalent to <code>@A</code>)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>attribute(*, <var>T</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0</td>
                                    <td style="text-align:left; vertical-align:top">(matches by type only)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>element(<var>W</var>, <var>T</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0.125</td>
                                    <td style="text-align:left; vertical-align:top"></td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>element(<var>E</var>, <var>T</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0.25</td>
                                    <td style="text-align:left; vertical-align:top">(matches by name and type)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>schema-element(<var>E</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0.25</td>
                                    <td style="text-align:left; vertical-align:top">(matches by substitution group and type)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>attribute(<var>W</var>, <var>T</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0.125</td>
                                    <td style="text-align:left; vertical-align:top"></td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>attribute(<var>A</var>, <var>T</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0.25</td>
                                    <td style="text-align:left; vertical-align:top">(matches by name and type)</td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <code>schema-attribute(<var>A</var>)</code>
                                       </td>
                                    <td style="text-align:left; vertical-align:top">0.25</td>
                                    <td style="text-align:left; vertical-align:top">(matches by name and type)</td>
                                 </tr>
                              </tbody>
                           </table>
                        </li>
                        <li>
                           <p>For a pattern such as <code>element(A|B)</code> or <code>attribute(A|B)</code>
               (more specifically, for any <a href="#prod-xslt40-ElementTest">ElementTest</a> or
               <a href="#prod-xslt40-AttributeTest">AttributeTest</a> whose <a href="#prod-xslt40-NameTestUnion">NameTestUnion</a>
               contains more than one <a href="#prod-xslt40-NameTest">NameTest</a>) the default priority is the
               highest of the priorities obtained by considering each of the <a href="#prod-xslt40-NameTest">NameTests</a>
               individually.</p>
                           <p>For example, the default priority of <code>element(x|y)</code> is 0, and
                     the default priority of <code>element(p:*|q:*, t)</code> is 0.125.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The effect of this rule is to make the pattern <code>element(A|B)</code>
                  equivalent to <code>element(A)|element(B)</code>.</p>
                           </div>
                        </li>
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-PathExprP">PathExprP</a> taking the form of a
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-DocumentTest">DocumentTest</a><sup><small>XP</small></sup>, then if
                     it includes no <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup> or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP</small></sup> the priority is −0.5. If it does include an
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup> or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP</small></sup>,
                     then the priority is the same as the priority of that <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup> or <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP</small></sup>, computed
                     according to the table above.</p>
                        </li>
                        <li>If the default namespace for elements and types is <code>#any</code>, and the pattern includes
                           an unprefixed element name <code>E</code>, then the default priority is calculated as if this had been written
                           <code>*:E</code>.</li>
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-PathExprP">PathExprP</a> taking the form of an
                        <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup><code>:*</code><span>, 
                           <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-BracedURILiteral">BracedURILiteral</a><sup><small>XP</small></sup>*,</span> or
                        <code>*:</code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, optionally
                     preceded by a <a href="#prod-xslt40-ForwardAxisP">ForwardAxisP</a>, then the priority is
                     −0.25. </p>
                        </li>
                        <li>
                           <p>If the pattern is a <a href="#prod-xslt40-PathExprP">PathExprP</a> taking the form of any
                     other <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeTest">NodeTest</a><sup><small>XP</small></sup>, optionally
                     preceded by a <a href="#prod-xslt40-ForwardAxisP">ForwardAxisP</a>, then the priority is
                     −0.5.</p>
                        </li>
                        <li>
                           <p>The default priority of the pattern <code>jnode(*, *)</code> is −0.5.</p>
                           <p>The default priority of the equivalent pattern 
                        <code>jnode(*, item()*)</code> is also −0.5.</p>
                        </li>
                        <li>
                           <p>The default priority of the pattern <code>jnode(<var>S</var>, *)</code>,
                        where <var>S</var> is any constant, is 0 (zero).</p>
                           <p>The default priority of the equivalent pattern <code>jnode(<var>S</var>, item()*)</code>,
                        where <var>S</var> is any constant, is also 0 (zero).</p>
                        </li>
                        <li>
                           <p>The default priority of the pattern <code>jnode((), *)</code> is 0 (zero).</p>
                           <p>The default priority of the equivalent pattern <code>jnode((), item()*)</code> is also 0 (zero).</p>
                        </li>
                        <li>
                           <p>The default priority of the pattern <code>jnode(*, <var>T</var>)</code>,
                        where <var>T</var> is any sequence type other than <code>item()*</code>, is 0 (zero).</p>
                        </li>
                        <li>
                           <p>The default priority of the pattern <code>jnode(<var>S</var>, <var>T</var>)</code>,
                        where <var>S</var> is any constant, and <var>T</var> is any sequence type other 
                        than <code>item()*</code>, is +0.25.</p>
                        </li>
                        <li>
                           <p>The default priority of the pattern <code>jnode((), <var>T</var>)</code>, 
                        where <var>T</var> is any sequence type other 
                        than <code>item()*</code>, is +0.25.</p>
                        </li>
                        <li>
                           <p>In all other cases, the default priority is +0.5.</p>
                        </li>
                     </ol>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>In many cases this means that highly selective patterns have higher priority than
                  less selective patterns. The most common kind of pattern (a pattern that tests for
                  a node of a particular kind, with a particular <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> or a particular type) has priority 0. The next less
                  specific kind of pattern (a pattern that tests for a node of a particular kind and
                  an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> with a particular
                  namespace URI) has priority −0.25. Patterns less specific than this
                  (patterns that just test for nodes of a given kind) have priority −0.5.
                  Patterns that specify both the name and the required type have a priority of
                  +0.25, putting them above patterns that only specify the name <em>or</em> the
                  type. Patterns more specific than this, for example patterns that include
                  predicates or that specify the ancestry of the required node, have priority
                  0.5.</p>
                        <p>However, it is not invariably true that a more selective pattern has higher
                  priority than a less selective pattern. For example, the priority of the pattern
                     <code>node()[self::*]</code> is higher than that of the pattern
                     <code>salary</code>. Similarly, the patterns <code>attribute(*,
                     xs:decimal)</code> and <code>attribute(*, xs:short)</code> have the same
                  priority, despite the fact that the latter pattern matches a subset of the nodes
                  matched by the former. Therefore, to achieve clarity in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> it is good practice to allocate
                  explicit priorities.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The patterns <code>element(N)</code> and <code>element(N, xs:anyType?)</code>
               have different default priority even though they match exactly the same nodes.
               Conversely, <code>element(N, xs:anyType)</code> and <code>element(N, xs:anyType?)</code>
               have the same default priority even though the first is more restrictive (it does not match 
               elements that are nilled).</p>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="pattern-errors"></a>6.3.4 <a href="#pattern-errors" style="text-decoration: none">Errors in Patterns</a></h4>
                  <p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> or <a title="type error" class="termref" href="#dt-type-error">type error</a> that occurs during the evaluation of a
                     <a title="pattern" class="termref" href="#dt-pattern">pattern</a> against a particular item has the effect that the item being tested is
                  treated as not matching the pattern. The error does not cause the transformation
                  to fail, and cannot be caught by a try/catch expression surrounding the
                  instruction that causes the pattern to be evaluated.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The reason for this provision is that it is difficult for the stylesheet author
                     to predict which predicates in a pattern will actually be evaluated. In the
                     case of match patterns in template rules, it is not even possible to predict
                     which patterns will be evaluated against a particular node.</p>
                     <p>There is a risk that ignoring errors in this way may make programming mistakes
                     harder to debug. Implementations may mitigate this by providing warnings or
                     other diagnostics when evaluation of a pattern triggers an error condition.</p>
                     <p>Static errors in patterns, including dynamic and type errors that are raised
                     statically as permitted by the specification, are raised in the normal way
                     and cause the transformation to fail.</p>
                  </div>
                  <p>The requirement to detect and raise a <a title="circularity" class="termref" href="#dt-circularity">circularity</a> as a dynamic error overrides this rule.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="applying-templates"></a>6.4 <a href="#applying-templates" style="text-decoration: none">Applying Template Rules</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#declaring-modes">next</a> | <a href="#default-priority">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  instructions acquire an attribute <code>separator</code> that can be
                  used to insert content between adjacent items. [This change was in the
                  editor's draft adopted as a baseline when the WG commenced work.]
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/85">85</a>&nbsp;&nbsp;1 January 2022]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-apply-templates"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:apply-templates<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;mode? = <var>token</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br>&lt;/xsl:apply-templates&gt;</code></p>
               <p>The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction takes as input a sequence of
                  items (typically nodes in a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>), and produces as output a sequence of
               items; these will often be nodes to be added to a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p>
               <p>If the instruction has one or more <a href="#element-sort"><code>xsl:sort</code></a> children, then the input
               sequence is sorted as described in <a href="#sorting"><i>13 Sorting</i></a>. The result of this sort
               is referred to below as the <b>sorted sequence</b>; if there are no
                  <a href="#element-sort"><code>xsl:sort</code></a> elements, then the sorted sequence is the same as the
               input sequence.</p>
               <p>Each item in the input sequence is processed by
               finding a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> whose <a title="pattern" class="termref" href="#dt-pattern">pattern</a> matches that item. If there is more than one such template rule, the best among them
               is chosen, using rules described in <a href="#conflict"><i>6.6 Conflict Resolution for Template Rules</i></a>. If there is no
               template rule whose pattern matches the item, a
               built-in template rule is used (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>). The chosen
               template rule is evaluated. The rule that matches the <var>N</var>th item in the sorted sequence is evaluated with that
                  item as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, with <var>N</var> as the <a title="context position" class="termref" href="#dt-context-position">context position</a>, and with the length of the
               sorted sequence as the <a title="context size" class="termref" href="#dt-context-size">context size</a>. Each
               template rule that is evaluated produces a sequence of items as its result. The
               resulting sequences (one for each item in the
               sorted sequence) are then concatenated, to form a single sequence. They are
               concatenated retaining the order of the items in
               the sorted sequence. The final concatenated sequence forms the result of the
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21478"></a>Example: Applying Template Rules</div>
                  <p>Suppose the source document is as follows:</p>
                  <div class="exampleInner">
                     <pre>&lt;message&gt;Proceed &lt;emph&gt;at once&lt;/emph&gt; to the exit!&lt;/message&gt;</pre>
                  </div>
                  <p>This can be processed using the two template rules shown below.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="message"&gt;
  &lt;p&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="emph"&gt;
  &lt;b&gt;
    &lt;xsl:apply-templates select="child::node()"/&gt;
  &lt;/b&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>There is no template rule for the document node; the built-in template rule for
                  this node will cause the <code>message</code> element to be processed. The
                  template rule for the <code>message</code> element causes a <code>p</code> element
                  to be written to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>; the
                  contents of this <code>p</code> element are constructed as the result of the
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. This instruction selects the
                  three child nodes of the <code>message</code> element (a text node containing the
                  value <code>Proceed </code>, an <code>emph</code> element node, and a text node
                  containing the value <code> to the exit!</code>). The two text nodes are
                  processed using the built-in template rule for text nodes, which returns a copy of
                  the text node. The <code>emph</code> element is processed using the explicit
                  template rule that specifies <code>match="emph"</code>.</p>
                  <p>When the <code>emph</code> element is processed, this template rule constructs a
                     <code>b</code> element. The contents of the <code>b</code> element are
                  constructed by means of another <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction,
                  which in this case selects a single node (the text node containing the value
                     <code>at once</code>). This is again processed using the built-in template
                  rule for text nodes, which returns a copy of the text node.</p>
                  <p>The final result of the <code>match="message"</code> template rule thus consists
                  of a <code>p</code> element node with three children: a text node containing the
                  value <code>Proceed </code>, a <code>b</code> element that is the parent of a
                  text node containing the value <code>at once</code>, and a text node containing
                  the value <code> to the exit!</code>. This <a title="result tree" class="termref" href="#dt-result-tree">result
                     tree</a> might be serialized as:</p>
                  <div class="exampleInner">
                     <pre>&lt;p&gt;Proceed &lt;b&gt;at once&lt;/b&gt; to the exit!&lt;/p&gt;</pre>
                  </div>
               </div>
               <p>The default value of the <code>select</code> attribute is <code>child::node()</code>,
               which causes all the children of the context node to be processed.</p>
               <p>
               <a id="err-XTTE0510"><span class="error">[ERR XTTE0510] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>select</code>
                     attribute is evaluated when the <a title="context item" class="termref" href="#dt-context-item">context
                        item</a> is not a node. 
            </p>
               <p>A <code>select</code> attribute can be used to process items selected by an expression instead of processing all children. The
               value of the <code>select</code> attribute is an <a title="expression" class="termref" href="#dt-expression">expression</a>. </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21603"></a>Example: Applying Templates to Selected Nodes</div>
                  <p>The following example processes all of the <code>given-name</code> children of the
                     <code>author</code> elements that are children of
                  <code>author-group</code>:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="author-group"&gt;
  &lt;fo:wrapper&gt;
    &lt;xsl:apply-templates select="author/given-name"/&gt;
  &lt;/fo:wrapper&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21619"></a>Example: Applying Templates to Nodes that are not Descendants</div>
                  <p>It is also possible to process elements that are not descendants of the context
                  node. This example assumes that a <code>department</code> element has
                     <code>group</code> children and <code>employee</code> descendants. It finds an
                  employee’s department and then processes the <code>group</code> children of
                  the <code>department</code>.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="employee"&gt;
  &lt;fo:block&gt;
    Employee &lt;xsl:apply-templates select="name"/&gt; belongs to group
    &lt;xsl:apply-templates select="ancestor::department/group"/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21640"></a>Example: Matching Nodes by Schema-Defined Types</div>
                  <p>It is possible to write template rules that are matched according to the
                  schema-defined type of an element or attribute. The following example applies
                  different formatting to the children of an element depending on their type:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="*"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="3"&gt;
  &lt;tr&gt;
    &lt;td&gt;&lt;xsl:value-of select="name()"/&gt;&lt;/td&gt;
    &lt;td&gt;&lt;xsl:next-match/&gt;&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:decimal) | 
                     product/element(*, xs:double)" priority="2"&gt;  
  &lt;xsl:value-of select="format-number(xs:double(.), '#,###0.00')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/element(*, xs:date)" priority="2"&gt;
  &lt;xsl:value-of select="format-date(., '[Mn] [D], [Y]')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="product/*" priority="1.5"&gt;
  &lt;xsl:value-of select="."/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The <a href="#element-next-match"><code>xsl:next-match</code></a> instruction is described in <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21651"></a>Example: Re-ordering Elements in the Result Tree</div>
                  <p>Multiple <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements can be used within a single
                  template to do simple reordering. The following example creates two HTML tables.
                  The first table is filled with domestic sales while the second table is filled
                  with foreign sales.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="product"&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/domestic"/&gt;
  &lt;/table&gt;
  &lt;table&gt;
    &lt;xsl:apply-templates select="sales/foreign"/&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21659"></a>Example: Processing Recursive Structures</div>
                  <p>It is possible for there to be two matching descendants where one is a descendant
                  of the other. This case is not treated specially: both descendants will be
                  processed as usual.</p>
                  <p> For example, given a source document</p>
                  <div class="exampleInner">
                     <pre>&lt;doc&gt;&lt;div&gt;&lt;div&gt;&lt;/div&gt;&lt;/div&gt;&lt;/doc&gt;</pre>
                  </div>
                  <p>the rule</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="doc"&gt;
  &lt;xsl:apply-templates select=".//div"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>will process both the outer <code>div</code> and inner <code>div</code>
                  elements.</p>
                  <p>This means that if the template rule for the <code>div</code> element processes
                  its own children, then these grandchildren will be processed more than once, which
                  is probably not what is required. The solution is to process one level at a time
                  in a recursive descent, by using <code>select="div"</code> in place of
                     <code>select=".//div"</code>
               </p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21687"></a>Example: Applying Templates to Atomic Items</div>
                  <p>This example reads a non-XML text file and processes it line-by-line, applying
                  different template rules based on the content of each line:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template name="main"&gt;
  &lt;xsl:apply-templates select="unparsed-text-lines('input.txt')"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)[starts-with(., '==')]"&gt;
  &lt;h2&gt;&lt;xsl:value-of select="replace(., '==', '')"/&gt;&lt;/h2&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)[starts-with(., '::')]"&gt;
  &lt;p class="indent"&gt;&lt;xsl:value-of select="replace(., '::', '')"/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(xs:string)"&gt;
  &lt;p class="body"&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e21692"></a>Example: Applying Templates to JSON Documents</div>
                  <p>This example reads a JSON data file and formats it as XHTML.</p>
                  <p>It takes the following JSON data as input:</p>
                  <div class="exampleInner">
                     <pre>[
  { "Title": "Computer Architecture",
    "Authors": [ "Enid Blyton"] ,
    "Category": "Computers",
    "Price": 42.60
  },
  { "Title": "Steppenwolf",
    "Authors": [ "Hermann Hesse" ],
    "Category": "Fiction",
    "Price": 12.00
  },
  {  "Title": "How to Explore Outer Space with Binoculars",
     "Authors": [ "Bruce Betts", "Erica Colon" ],
     "Category": "Science",
     "Price": 10.40
  }
]</pre>
                  </div>
                  <p>The following template rules are used. The setting <code>expand-text="yes"</code> is assumed:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:record-type name="book"&gt;
  &lt;xsl:field name="Title"/&gt;
  &lt;xsl:field name="Authors"/&gt;
  &lt;xsl:field name="Category"/&gt;
&lt;/xsl:record-type&gt;

&lt;xsl:template name="xsl:initial-template"&gt;
  &lt;xsl:apply-templates select="parse-json('input.json')"/&gt;
&lt;/xsl:template&gt;  

&lt;xsl:template match="array(book)"&gt;
  &lt;h1&gt;Christmas Book Selection&lt;/h1&gt;
  &lt;table&gt;
    &lt;thead&gt;
       &lt;tr&gt;
         &lt;th&gt;Title&lt;/th&gt;
         &lt;th&gt;Authors&lt;/th&gt;
         &lt;th&gt;Category&lt;/th&gt;
         &lt;th&gt;Price&lt;/th&gt;
       &lt;/tr&gt;
    &lt;/thead&gt;
    &lt;tbody&gt;
      &lt;xsl:apply-templates select="?*"/&gt;
    &lt;/tbody&gt;
  &lt;/table&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="type(book)"&gt;
  &lt;tr&gt;
    &lt;td&gt;{?Title}&lt;/td&gt;
    &lt;td&gt;{?Authors?* =&gt; string-join(", ")}&lt;/td&gt;
    &lt;td&gt;{?Category}&lt;/td&gt;
    &lt;td&gt;${?Price}&lt;/td&gt;
  &lt;/tr&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction is most commonly used to
                  process nodes that are descendants of the context node. Such use of
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> cannot result in non-terminating
                  processing loops. However, when <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used to
                  process elements that are not descendants of the context node, the possibility
                  arises of non-terminating loops. For example,</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="foo"&gt;
  &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>Implementations may be able to detect such loops in some cases, but the
                  possibility exists that a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> may
                  enter a non-terminating loop that an implementation is unable to detect. This may
                  present a denial of service security risk.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="apply-templates-separator"></a>6.5 <a href="#apply-templates-separator" style="text-decoration: none">The <code>separator</code> attribute</a></h3>
               <p>If the <code>separator</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
               is present, then its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
               is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted
               sequence other than the last.</p>
               <p>For example, if the <code>ARTICLE</code> element has a number of element children named <code>AUTHOR</code>,
               the following code will produce a sorted, comma-separated list of authors:</p>
               <div class="exampleInner">
                  <pre>
&lt;xsl:template match="ARTICLE"&gt;
  &lt;article&gt;
     ...
     &lt;xsl:text&gt;Author(s): &lt;/xsl:text&gt;
     &lt;xsl:apply-templates select="AUTHOR" separator=", "&gt;
       &lt;xsl:sort select="LAST-NAME"/&gt;
       &lt;xsl:sort select="FIRST-NAME"/&gt;
     &lt;/xsl:apply-templates&gt;
     ...
  &lt;/article&gt;
&lt;/xsl:template&gt;
&lt;xsl:template match="AUTHOR" expand-text="yes"&gt;
  &lt;xsl:text&gt;{FIRST-NAME} {LAST-NAME}&lt;/xsl:text&gt;
&lt;/xsl:template&gt;</pre>
               </div>
               <p>The node identity of any text nodes that are inserted is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Specifically,
               it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical
               to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this
               instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p>
               <p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the
               sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see
               <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a> and <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.)</p>
            </div>
            <div class="div2">
               
               <h3><a id="conflict"></a>6.6 <a href="#conflict" style="text-decoration: none">Conflict Resolution for Template Rules</a></h3>
               <p>It is possible for a selected item to match more
               than one <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> with a given
                  <a title="mode" class="termref" href="#dt-mode">mode</a>
               <var>M</var>. When this happens, only one template rule is evaluated for the item. The template rule to be used is determined as
               follows:</p>
               <ol class="enumar">
                  <li>
                     <p>First, only the matching template rule or rules with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> are considered. Other
                     matching template rules with lower precedence are eliminated from
                     consideration.</p>
                  </li>
                  <li>
                     <p>Next, of the remaining matching rules, only those with the highest priority are
                     considered. Other matching template rules with lower priority are eliminated
                     from consideration.</p>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-priority" title="priority"></a>The <b>priority</b> of a
                        template rule is specified by the <code>priority</code> attribute on the
                           <a href="#element-template"><code>xsl:template</code></a> declaration. If no priority is specified
                        explicitly for a template rule, its <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> 
                        is used, as defined in <a href="#default-priority"><i>6.3.3 Default Priority for Patterns</i></a>.<span class="definition">]</span></p>
                     <p>
                     <a id="err-XTSE0530"><span class="error">[ERR XTSE0530] </span></a>The value of the <code>priority</code> attribute 
                           <span class="verb">must</span> conform to the rules for the
                              <code>xs:decimal</code> type defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.
                           Negative values are permitted.
                  </p>
                  </li>
                  <li>
                     <p>If this leaves more than one matching template rule, then:</p>
                     <ol class="enumla">
                        <li>
                           <p>If the <a title="mode" class="termref" href="#dt-mode">mode</a>
                           <var>M</var> has an <a href="#element-mode"><code>xsl:mode</code></a> declaration, and the
                           attribute value <code>on-multiple-match="fail"</code> is specified in the
                           mode declaration, a dynamic error is raised. The error is treated as
                           occurring in the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, and
                           can be recovered by wrapping that instruction in an
                              <a href="#element-try"><code>xsl:try</code></a> instruction.</p>
                           <p>
                           <a id="err-XTDE0540"><span class="error">[ERR XTDE0540] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the
                                 conflict resolution algorithm for template rules leaves more than
                                 one matching template rule  when the
                                    declaration of the relevant <a title="mode" class="termref" href="#dt-mode">mode</a> has an <code>on-multiple-match</code>
                                    attribute with the value <code>fail</code>.</p>
                        </li>
                        <li>
                           <p>Otherwise, of the matching template rules that remain, the one that
                           occurs last in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration
                              order</a> is used.</p>
                        </li>
                     </ol>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This was a recoverable error in XSLT 2.0, meaning that it was
                        implementation-defined whether the error was raised, or whether the
                        ambiguity was resolved by taking the last matching rule in declaration
                        order.  In XSLT 3.0 and 4.0 this situation is not an error unless the
                        attribute value <code>on-multiple-match="fail"</code> is specified in the
                        mode declaration. It is also possible to request warnings when this
                        condition arises, by means of the attribute <code>warning-on-multiple-match="yes"</code>. </p>
                     </div>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="modes"></a>6.7 <a href="#modes" style="text-decoration: none">Modes</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-mode" title="mode"></a> A <b>mode</b> is a set of template rules;
                  when the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects a set of items
                  for processing, it identifies the rules to be used for processing those items by
                  nominating a mode, explicitly or implicitly.<span class="definition">]</span> Modes allow a node in a
                  <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> (for example) to be processed
               multiple times, each time producing a different result. They also allow different
               sets of <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> to be active when
               processing different trees, for example when processing documents loaded using the
                  <a href="#func-document"><code>document</code></a> function (see <a href="#func-document"><i>20.1 fn:document</i></a>). </p>
               <p>Modes are identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>; in addition to any named modes, there is always one
               unnamed mode available. Whether a mode is named or unnamed, its properties
                  <span class="verb">may</span> be defined in an <a href="#element-mode"><code>xsl:mode</code></a> declaration. If
               a mode name is used (for example in an <a href="#element-template"><code>xsl:template</code></a> declaration or
               an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction) and no declaration of that mode
               appears in the stylesheet, the mode is implicitly declared with default
               properties.</p>
               <div class="div3">
                  
                  <h4><a id="declaring-modes"></a>6.7.1 <a href="#declaring-modes" style="text-decoration: none">Declaring Modes</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#apply-templates-function">next</a> | <a href="#applying-templates">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute
                     <code>as="sequence-type"</code> which declares the return type of 
                     all template rules in that mode.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/750">750</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/751">751</a>&nbsp;16 October 2023]</i></p>
                        </li>
                        <li>
                           <p>
                     The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute
                     <code>copy-namespaces</code> which determines whether or not the built-in
                     template rule copies unused namespace bindings.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1724">1724</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1929">1929</a>&nbsp;13 April 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-mode"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:mode<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var>〔''〕<br>&nbsp;&nbsp;on-no-match? = "deep-copy" | "shallow-copy" | "shallow-copy-all" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail"〔'text-only-copy'〕<br>&nbsp;&nbsp;on-multiple-match? = "use-last" | "fail"〔'use-last'〕<br>&nbsp;&nbsp;warning-on-no-match? = <var>boolean</var><br>&nbsp;&nbsp;warning-on-multiple-match? = <var>boolean</var><br>&nbsp;&nbsp;typed? = <var>string</var>〔'unspecified'〕<br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final"〔'private'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a>*) --&gt;<br>&lt;/xsl:mode&gt;</code></p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-unnamed-mode" title="unnamed mode"></a>The <b>unnamed mode</b> is the default mode used when no
                        <code>mode</code> attribute is specified on an
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction or
                        <a href="#element-template"><code>xsl:template</code></a> declaration, unless a different <a title="default mode" class="termref" href="#dt-default-mode">default mode</a>
                     has been specified using the <code>[xsl:]default-mode</code> attribute of a containing
                        element.<span class="definition">]</span>
               </p>
                  <p>Every <a title="mode" class="termref" href="#dt-mode">mode</a> other than the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> is identified by an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p>
                  <p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> may contain multiple
                     <a href="#element-mode"><code>xsl:mode</code></a> declarations and may include or import <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> that also contain
                     <a href="#element-mode"><code>xsl:mode</code></a> declarations. The name of an
                     <a href="#element-mode"><code>xsl:mode</code></a> declaration is the value of its <code>name</code>
                  attribute, if any.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-mode-definition" title="mode definition"></a>All the
                        <a href="#element-mode"><code>xsl:mode</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> that share the same
                     name are grouped into a named <b>mode definition</b>; those that have no
                     name are grouped into a single unnamed mode definition.<span class="definition">]</span>
               </p>
                  <p>The <code>declared-modes</code> attribute of
                     the <a href="#element-package"><code>xsl:package</code></a> element determines whether implicit mode
                     declarations are allowed, as described in <a href="#requiring-explicit-modes"><i>3.4.5.1 Requiring Explicit Mode Declarations</i></a>. If the package allows implicit mode
                     declarations, then  if a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> does not contain a declaration of the unnamed mode, a
                  declaration is implied equivalent to an <a href="#element-mode"><code>xsl:mode</code></a> element with
                     no attributes. Similarly, if there
                  is a mode that is named in an <a href="#element-template"><code>xsl:template</code></a> or
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element, or in the <code>[xsl:]default-mode</code> attribute of a containing
                     element, and the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                  does not contain a declaration of that mode, then a declaration is implied
                  comprising an <a href="#element-mode"><code>xsl:mode</code></a> element with a <code>name</code> attribute
                     equal to that mode name, plus the attribute
                        <code>visibility="private"</code>. </p>
                  <p>The attributes of the <a href="#element-mode"><code>xsl:mode</code></a> declaration establish values for a
                  number of properties of a mode. The allowed values and meanings of the attributes
                  are given in the following table.</p>
                  <table class="data">
                     <caption>Attributes of the <code>xsl:mode</code> Element</caption>
                     <thead>
                        <tr>
                           <th style="text-align:left; vertical-align:top">Attribute</th>
                           <th style="text-align:left; vertical-align:top">Values</th>
                           <th style="text-align:left; vertical-align:top">Meaning</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="vertical-align:top; text-align:left">name</td>
                           <td style="vertical-align:top; text-align:left">An <a title="EQName" class="termref" href="#dt-eqname">EQName</a></td>
                           <td style="vertical-align:top; text-align:left">Specifies the name of the mode. If omitted, this
                              <a href="#element-mode"><code>xsl:mode</code></a> declaration provides properties of the
                              <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a></td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">as</td>
                           <td style="vertical-align:top; text-align:left">A <code>SequenceType</code></td>
                           <td style="vertical-align:top; text-align:left">Declares the type of value returned by all
                              template rules in this mode. If any template rules in this mode declare their
                              return type using an <code>as</code> attribute on <a href="#element-template"><code>xsl:template</code></a>,
                              the values must be consistent.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">streamable</td>
                           <td style="vertical-align:top; text-align:left"><code>yes</code> or <code>no</code> (default
                              <code>no</code>)</td>
                           <td style="vertical-align:top; text-align:left">Determines whether template rules in this mode are to be
                              capable of being processed using <a title="streaming" class="termref" href="#dt-streaming">streaming</a>. If the
                              value <code>yes</code> is specified, then the body of any <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that uses this mode
                              <span class="verb">must</span> conform to the rules for streamable templates
                              given in <a href="../xslt-streaming-40/#streamable-templates">5 Streamable Templates</a><sup><small>SG</small></sup>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">use-accumulators</td>
                           <td style="vertical-align:top; text-align:left">List of accumulator names, or <code>#all</code> (default is the empty list)</td>
                           <td style="vertical-align:top; text-align:left">Relevant only when this mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>
                              of the transformation, determines which accumulators are applicable to documents
                              containing nodes in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>. For
                              further details see <a href="#applicability-of-accumulators"><i>19.2 Applicability of Accumulators</i></a>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">on-no-match</td>
                           <td style="vertical-align:top; text-align:left">One of <code>deep-copy</code>,
                              <code>shallow-copy</code>, <code>deep-skip</code>,
                              <code>shallow-skip</code>, <code>text-only-copy</code> or
                              <code>fail</code> (default
                              <code>text-only-copy</code>)</td>
                           <td style="vertical-align:top; text-align:left">Determines selection of the built-in <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> that are used to
                              process an item when an
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that does not match any
                              user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in
                              the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For details, see
                              <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">on-multiple-match</td>
                           <td style="vertical-align:top; text-align:left">One of <code>fail</code> or <code>use-last</code> (default
                              <code>use-last</code>)</td>
                           <td style="vertical-align:top; text-align:left">Defines the action to be taken when
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> is used in this mode and more
                              than one user-written <a title="template rule" class="termref" href="#dt-template-rule">template
                                 rule</a> is available to process an item, each having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a>. The value <code>fail</code>
                              indicates that it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if more
                              than one template rule matches an
                              item. The value <code>use-last</code> indicates that the
                              situation is not to be treated as an error (the last template in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a> is the one that
                              is used). </td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">warning-on-no-match</td>
                           <td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is
                              <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">Requests the <a title="processor" class="termref" href="#dt-processor">processor</a> to output (or not to output) a warning message in
                              the case where an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction
                              selects an item that matches
                              no user-written template rule. The form and destination of such warnings
                              is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The processor
                              <span class="verb">may</span> ignore this attribute, for example if the
                              environment provides no suitable means of communicating with the user.
                              </td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">warning-on-multiple-match</td>
                           <td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is
                              <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>
                              </td>
                           <td style="vertical-align:top; text-align:left">Requests the <a title="processor" class="termref" href="#dt-processor">processor</a> to output a warning message in the case where an
                              <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects an item that matches multiple
                              template rules having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                                 precedence</a> and <a title="priority" class="termref" href="#dt-priority">priority</a>. The form and destination of such warnings is
                              <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The processor
                              <span class="verb">may</span> ignore this attribute, for example if the
                              environment provides no suitable means of communicating with the
                              user.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">typed</td>
                           <td style="vertical-align:top; text-align:left">One of <code>yes</code>, <code>no</code>,
                              <code>strict</code>, <code>lax</code>, or <code>unspecified</code>.
                              The default is <code>unspecified</code>.</td>
                           <td style="vertical-align:top; text-align:left">See <a href="#xsl-mode-typed"><i>6.7.4 Declaring the Type of Values Processed by a Mode</i></a>.</td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">copy-namespaces</td>
                           <td style="vertical-align:top; text-align:left">One of <code>yes</code> or <code>no</code>. The default is
                              <code>yes</code>.</td>
                           <td style="vertical-align:top; text-align:left">If <code>on-no-match</code> is <code>shallow-copy</code>,
                              <code>shallow-copy-all</code>, or <code>deep-copy</code>, this attribute determines the
                              effective value of the <code>copy-namespaces</code> attribute on the implicit <code>xsl:copy</code>
                              or <code>xsl:copy-of</code> instruction in the built-in template rule 
                              (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>). In other cases it is ignored, apart from checking that
                              its value is valid.
                              </td>
                        </tr>
                        <tr>
                           <td style="vertical-align:top; text-align:left">visibility</td>
                           <td style="vertical-align:top; text-align:left">One of <code>public</code>, <code>private</code>, or
                              <code>final</code>. The default is <code>private</code>.</td>
                           <td style="vertical-align:top; text-align:left">See <a href="#visibility"><i>3.4.4.1 Visibility of Components</i></a>. If the mode is unnamed, that is, if the
                              <code>name</code> attribute is absent, then the
                              <code>visibility</code> attribute if present
                              <span class="verb">must</span> have the value
                              <code>private</code>.
                              
                              <table class="ednote" caption="Editorial note">
                                 <tr>
                                    <td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td>
                                    <td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td>
                                 </tr>
                                 <tr style="text-align: left; vertical-align: top;">
                                    <td colspan="2">See issue 270.</td>
                                 </tr>
                              </table>
                           </td>
                        </tr>
                     </tbody>
                  </table>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-streamable-mode" title="streamable mode"></a>A <b>streamable
                        mode</b> is a <a title="mode" class="termref" href="#dt-mode">mode</a> that is declared in
                     an <a href="#element-mode"><code>xsl:mode</code></a> declaration with the attribute
                        <code>streamable="yes"</code>.<span class="definition">]</span>
               </p>
                  <p>For any named <a title="mode" class="termref" href="#dt-mode">mode</a>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of each
                  attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has a
                  matching name in its <code>name</code> attribute, and that specifies an explicit
                  value for the required attribute. If there is
                     no such declaration, the default value of the attribute is used. If
                  there is more than one such declaration, the one with highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p>
                  <p>For the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                  of each attribute is taken from an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has
                  no <code>name</code> attribute, and that specifies an explicit value for the
                  required attribute. If there is no such declaration, the default value of the
                  attribute is used. If there is more than one such declaration, the one with
                  highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is
                  used.</p>
                  <p>
                  <a id="err-XTSE0545"><span class="error">[ERR XTSE0545] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if for any
                        named or unnamed <a title="mode" class="termref" href="#dt-mode">mode</a>, a package explicitly specifies two conflicting
                        values for the same attribute in different <a href="#element-mode"><code>xsl:mode</code></a>
                        declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                           precedence</a>, unless there is another definition of the same
                        attribute with higher import precedence. The attributes in question are the
                        attributes other than <code>name</code> on the <a href="#element-mode"><code>xsl:mode</code></a>
                           element.
               </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="using-modes"></a>6.7.2 <a href="#using-modes" style="text-decoration: none">Using Modes</a></h4>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-applicable" title="applicable"></a>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is <b>applicable</b> to one or more modes.
                     The modes to which it is applicable are defined by the <code>mode</code>
                     attribute of the <a href="#element-template"><code>xsl:template</code></a> element. If the attribute is
                     omitted, then the template rule is applicable to the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> 
                  specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing
                           element that has such an attribute, which in turn defaults to
                        the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. If the
                        <code>mode</code> attribute is present, then its value
                        <span class="verb">must</span> be a non-empty whitespace-separated list of tokens,
                     each of which defines a mode to which the template rule is
                     applicable.<span class="definition">]</span></p>
                  <p>Each token in the <code>mode</code> attribute <span class="verb">must</span> be one of
                  the following:</p>
                  <ul>
                     <li>
                        <p>An <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> to define the name of the mode</p>
                     </li>
                     <li>
                        <p>The token <code>#default</code>, to indicate that the template rule is
                        applicable to the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> that would apply if
                           the <code>mode</code> attribute were absent
                     </p>
                     </li>
                     <li>
                        <p>The token <code>#unnamed</code>, to indicate that the
                        template rule is applicable to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed
                           mode</a>
                     </p>
                     </li>
                     <li>
                        <p>The token <code>#all</code>, to indicate that the template rule is
                        applicable to all modes <span>other than <a title="enclosing mode" class="termref" href="#dt-enclosing-mode">enclosing modes</a></span>
                        (specifically, to the unnamed mode and to every mode that is named explicitly or implicitly in an
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction  anywhere in
                        the stylesheet).</p>
                        <p>More specifically, when a template rule specifies <code>mode="#all"</code> this makes the
                        template rule <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to:</p>
                        <ul>
                           <li>
                              <p>The unnamed mode.</p>
                           </li>
                           <li>
                              <p>Every mode, other than an <a title="enclosing mode" class="termref" href="#dt-enclosing-mode">enclosing mode</a>, that is declared using an
                              <a href="#element-mode"><code>xsl:mode</code></a> declaration within the containing <a title="package" class="termref" href="#dt-package">package</a>.</p>
                           </li>
                           <li>
                              <p>Every mode that is implicitly declared within the containing <a title="package" class="termref" href="#dt-package">package</a>
                              by virtue of being referenced in an <a href="#element-template"><code>xsl:template</code></a> or
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element.</p>
                           </li>
                        </ul>
                        <p>The value <code>mode="#all"</code>
                        cannot be used on a template rule declared within an
                        <a href="#element-override"><code>xsl:override</code></a> <span>or <a href="#element-mode"><code>xsl:mode</code></a></span> element.</p>
                     </li>
                  </ul>
                  <p>
                  <a id="err-XTSE0550"><span class="error">[ERR XTSE0550] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of
                        modes  is empty, if the same token is included more than once in the
                        list, if the list contains an invalid token, or if the token
                           <code>#all</code> appears together with any other value.
               </p>
                  <p>
                  <a id="err-XTSE3440"><span class="error">[ERR XTSE3440] </span></a>In the case of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> (that is, an
                           <a href="#element-template"><code>xsl:template</code></a> element having a <code>match</code>
                        attribute) appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, it is a
                           <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of
                        modes in the <code>mode</code> attribute contains <code>#all</code> or
                           <code>#unnamed</code>, or if it contains <code>#default</code> and the
                        <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, or if the
                           <code>mode</code> attribute is omitted when the default mode is the
                           <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.
               </p>
                  <p>The <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> element also has an optional
                     <code>mode</code> attribute. The value of this attribute
                     <span class="verb">must</span> be one of the following:</p>
                  <ul>
                     <li>
                        <p>an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> to define the name of a mode</p>
                     </li>
                     <li>
                        <p>the token <code>#default</code>, to indicate that the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> 
                        from the static context of the instruction is to be used</p>
                     </li>
                     <li>
                        <p>the token <code>#unnamed</code>, to indicate that the
                           <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a> is to be used</p>
                     </li>
                     <li>
                        <p>the token <code>#current</code>, to indicate that the <a title="current mode" class="termref" href="#dt-current-mode">current mode</a> is to be used</p>
                     </li>
                  </ul>
                  <p>If the attribute is omitted, the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> from
                        the static context of the instruction is used.</p>
                  <p>When searching for a template rule to process each item selected by the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  instruction, only those template rules that are applicable to the selected mode
                  are considered.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-current-mode" title="current mode"></a>At any point in the processing
                     of a stylesheet, there is a <b>current mode</b>. When the transformation
                     is initiated, the current mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                     instruction is evaluated, the current mode becomes the mode selected by this
                     instruction.<span class="definition">]</span> When a <a title="non-contextual function call" class="termref" href="#dt-non-contextual-function-call">non-contextual function call</a> is made, the current mode
                  is set to the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. While
                  evaluating global variables and parameters, and the sequence constructor contained
                  in <a href="#element-key"><code>xsl:key</code></a> or <a href="#element-sort"><code>xsl:sort</code></a>, the current mode is set
                  to the unnamed mode. No other instruction changes the current mode. The current
                  mode while evaluating an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>
                  is the same as the current mode of the caller. On completion of the
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, or on return from a
                  stylesheet function call, the current mode reverts to its previous value. The
                  current mode is used when an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction uses
                  the syntax <code>mode="#current"</code>; it is also used by the
                     <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a>
                  instructions (see <a href="#apply-imports"><i>6.9 Overriding Template Rules</i></a>).</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="apply-templates-function"></a>6.7.3 <a href="#apply-templates-function" style="text-decoration: none">The <code>apply-templates</code> Function</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-apply-templates">next</a> | <a href="#declaring-modes">previous</a>)</p>
                     <ol>
                        <li>
                           <p>A new function <code>fn:apply-templates</code> is introduced.<i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/2005">2005</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2038">2038</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2006">2006</a>&nbsp;16 May 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>Sometimes it is useful to be able to apply templates from within an XPath expression.
               A common example is when using XPath expressions to construct maps and arrays. For example,
               an array of maps might be constructed by the following code:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:array for-each select="*"&gt;
      &lt;xsl:map&gt;
        &lt;xsl:for-each select="@*"&gt;
          &lt;xsl:map-entry key="local-name()"&gt;
            &lt;xsl:apply-templates select="."/&gt;
          &lt;/xsl:map-entry&gt;
        &lt;/xsl:for-each&gt;
      &lt;/xsl:map&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
                  <p>Such code can become verbose, and it is difficult to read because the XML form of the instructions
                  bears literal relationship to the serialized form (typically JSON) of the result.
                  XSLT 4.0 offers the alternative of writing it like this:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:select&gt;
   array{ * ! map:build(@*, local-name#1, apply-templates#1) }
&lt;/xsl:select&gt;</pre>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Explanation: this constructs an array with one member for each element child <var>E</var> of
                  the context node. The member is a map constructed using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-map-build"><code>map:build</code></a> function.
                  The map has one entry for each attribute <var>A</var> of element <var>E</var>. The
                  key of this entry is the local name of the attribute, and the corresponding value is
                  obtained by applying templates to the attribute node.</p>
                  </div>
                  <p>To make this possible, a subset of the functionality of the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
               instruction is available via the (XSLT-only) <a href="#func-apply-templates"><code>apply-templates</code></a>
               function, whose specification follows.</p>
                  <div class="div4">
                     
                     <h5><a id="func-apply-templates"></a>6.7.3.1 <a href="#func-apply-templates" style="text-decoration: none">fn:apply-templates</a></h5>
                     <div class="changes">
                        <p class="changesHeading">
        Changes in 4.0
        (<a href="#xsl-mode-typed">next</a> | <a href="#apply-templates-function">previous</a>)</p>
                        <ol>
                           <li>
                              <p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2005">2005</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2006">2006</a>&nbsp;20 May 2025]</i></p>
                           </li>
                        </ol>
                     </div>
                     <dl>
                        <dt class="label">Summary</dt>
                        <dd>
                           <p>Applies template rules to selected items.</p>
                        </dd>
                        <dt class="label">Signature</dt>
                        <dd>
                           <div class="proto">
                              <table class="proto" border="0">
                                 <tr class="name">
                                    <td colspan="3"><code class="function">fn:apply-templates</code>(</td>
                                 </tr>
                                 <tr class="arg">
                                    <td><code>$select</code></td>
                                    <td><code class="as">as&nbsp;</code><code class="type">item()*</code>,</td>
                                    <td></td>
                                 </tr>
                                 <tr class="arg">
                                    <td><code>$options</code></td>
                                    <td><code class="as">as&nbsp;</code><code class="type">map(*)?</code></td>
                                    <td><code class="assign">:=&nbsp;</code><code>{}</code></td>
                                 </tr>
                                 <tr class="return-type">
                                    <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>item()*</code></td>
                                 </tr>
                              </table>
                           </div>
                        </dd>
                        <dt class="label">Properties</dt>
                        <dd>
                           <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                        </dd>
                        <dt class="label">Rules</dt>
                        <dd>
                           <p>The function call <code>apply-templates(<var>X</var>)</code>, used within an XPath 
            <a title="expression" class="termref" href="#dt-expression">expression</a>, returns 
            the same result as the instruction <code>&lt;xsl:apply-templates select="<var>X</var>"/&gt;</code></p>
                           <p>The entries that may appear in the <code>$options</code> map are as follows.
         The <a href="https://qt4cg.org/specifications/xpath-functions-40/#option-parameter-conventions">option parameter conventions</a><sup><small>FO</small></sup> apply.</p>
                           <div>
                              <div class="record">
                                 <table class="record" border="0">
                                    <tr>
                                       <td colspan="2"><code>record(</code></td>
                                    </tr>
                                    <tr class="arg">
                                       <td><code class="opt">params?</code></td>
                                       <td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code>,</td>
                                    </tr>
                                    <tr class="arg">
                                       <td><code class="opt">tunnel-params?</code></td>
                                       <td><code class="as">as&nbsp;</code><code>map(xs:QName, item()*)</code>,</td>
                                    </tr>
                                    <tr class="arg">
                                       <td><code class="opt">mode?</code></td>
                                       <td><code class="as">as&nbsp;</code><code>(xs:QName | enum("#current", "#unnamed"))</code></td>
                                    </tr>
                                    <tr>
                                       <td colspan="2"><code>)</code></td>
                                    </tr>
                                 </table>
                              </div>
                           </div>
                           <table class="fos-options">
                              <thead>
                                 <tr>
                                    <th style="text-align:left; vertical-align:top">Key</th>
                                    <th style="text-align:left; vertical-align:top">Value</th>
                                    <th style="text-align:left; vertical-align:top">Meaning</th>
                                 </tr>
                              </thead>
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <p><code>params?</code></p>
                                    </td>
                                    <td class="fos-thin" colspan="2">Supplies values for non-tunnel parameters. Each entry in the <code>params</code>
                                       map binds a parameter (identified by an <code>xs:QName</code> value) to a supplied value.
                                       
                                       <ul>
                                          <li>
                                             <p><b>Type: </b><code>map(xs:QName, item()*)</code></p>
                                          </li>
                                          <li>
                                             <p><b>Default: </b><code>{}</code></p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top">
                                       <p><code>tunnel-params?</code></p>
                                    </td>
                                    <td class="fos-thin" colspan="2">Supplies values for tunnel parameters. Each entry in the <code>tunnel-params</code>
                                       map binds a tunnel parameter (identified by an <code>xs:QName</code> value) to a supplied value.
                                       <ul>
                                          <li>
                                             <p><b>Type: </b><code>map(xs:QName, item()*)</code></p>
                                          </li>
                                          <li>
                                             <p><b>Default: </b><code>{}</code></p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" rowspan="4">
                                       <p><code>mode?</code></p>
                                    </td>
                                    <td class="fos-thick" colspan="2">Selects the mode to be used. The value may be set to an <code>xs:QName</code>
                                       that matches a declared mode in the stylesheet, or to one of the special values
                                       <code>#current</code> or <code>#unnamed</code>.
                                       <ul>
                                          <li>
                                             <p><b>Type: </b><code>(xs:QName | enum("#current", "#unnamed"))</code></p>
                                          </li>
                                          <li>
                                             <p><b>Default: </b><code>"#unnamed"</code></p>
                                          </li>
                                       </ul>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td class="fos-thin"><code>xs:QName</code></td>
                                    <td style="text-align:left; vertical-align:top">Selects a declared mode by name.</td>
                                 </tr>
                                 <tr>
                                    <td class="fos-thin"><code>#current</code></td>
                                    <td style="text-align:left; vertical-align:top">Selects the <a title="current mode" class="termref" href="#dt-current-mode">current mode</a>.</td>
                                 </tr>
                                 <tr>
                                    <td class="fos-thick"><code>#unnamed</code></td>
                                    <td style="text-align:left; vertical-align:top">Selects the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</td>
                                 </tr>
                              </tbody>
                           </table>
                           <p>For each item in the value of the <code>$select</code> argument, the function finds
         the best matching template rule in the selected mode and invokes that template rule with the supplied
         parameters (if any). The result of
         the function is the sequence concatenation of the results of performing this process for each
         item in the selected input, in turn.</p>
                        </dd>
                        <dt class="label">Error Conditions</dt>
                        <dd>
                           <p>Errors may arise in the same situations as for the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
         instruction: for example, if the <a href="#element-mode"><code>xsl:mode</code></a> declaration specifies 
         <code>on-no-match="fail"</code> and no matching template rule is found.</p>
                           <p><a id="err-XTDE0565"><span class="error">[ERR XTDE0565] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if a call
                        on the <a href="#func-apply-templates"><code>apply-templates</code></a> function selects a <a title="mode" class="termref" href="#dt-mode">mode</a>
                        that is not explicitly declared in the containing package, or accepted
                        from a used package, or whose visibility is <code>private</code>.
         </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Modes are private by default: for a mode to be available for reference by
         the <a href="#func-apply-templates"><code>apply-templates</code></a> function, it must be explicitly declared
         with <code>visibility="public"</code>.</p>
                           </div>
                        </dd>
                        <dt class="label">Notes</dt>
                        <dd>
                           <div class="note">
                              <p>Unlike the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction, the name of the required mode, and the
            names of the supplied parameters, can be evaluated dynamically.</p>
                              <p>If no mode is specified, the function uses the unnamed mode. It does not use the default mode
          (as defined by a containing <code>[xsl:]default-mode</code> attribute). This decision was made
         in order to avoid having to retain the default mode for each XPath expression at evaluation time,
         and to avoid complex rules for edge cases involving dynamic function calls.</p>
                              <p>See also the rules in <a href="#dynamic-component-references"><i>3.4.4.6 Dynamic References to Components</i></a>, which are relevant
         to resolution of the mode name.</p>
                           </div>
                        </dd>
                        <dt class="label">Examples</dt>
                        <dd>
                           <div class="example">
                              <table style="border:1px solid; padding:5px; width:100%" class="medium">
                                 <tbody>
                                    <tr>
                                       <td style="text-align:left; vertical-align:top" colspan="2">
                                          <p>The function call:</p>
                                       </td>
                                    </tr>
                                    <tr>
                                       <td style="text-align:left; vertical-align:top" colspan="2">
                                          <div class="exampleInner">
                                             <pre><code>apply-templates(*, {'mode': '#current', 'params': { #expand : false() } })</code></pre>
                                          </div>
                                       </td>
                                    </tr>
                                    <tr>
                                       <td style="text-align:left; vertical-align:top" colspan="2">
                                          <p>has the same effect as the instruction:</p>
                                       </td>
                                    </tr>
                                    <tr>
                                       <td style="text-align:left; vertical-align:top" colspan="2">
                                          <div class="exampleInner">
                                             <pre>&lt;xsl:apply-templates 
        select="*"
        mode="#current"&gt;
    &lt;xsl:with-param name="expand" select="false()"/&gt;
&lt;/xsl:apply-templates&gt;</pre>
                                          </div>
                                       </td>
                                    </tr>
                                 </tbody>
                              </table>
                           </div>
                        </dd>
                     </dl>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="xsl-mode-typed"></a>6.7.4 <a href="#xsl-mode-typed" style="text-decoration: none">Declaring the Type of Values Processed by a Mode</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#mode-result-type">next</a> | <a href="#func-apply-templates">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     <p>The <code>xsl:mode/@typed</code> attribute has been clarified and expanded
                  to provide better control over the handling of items other than XNodes.</p><i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2337">2337</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2736">2736</a>&nbsp;9 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>Typically the template rules in a particular <a title="mode" class="termref" href="#dt-mode">mode</a> will be
                  designed to process a specific kind of input document. The <code>typed</code>
                  attribute of <a href="#element-mode"><code>xsl:mode</code></a> gives the stylesheet author the opportunity
                  to provide information about this document to the processor. This information may
                  enable the processor to improve diagnostics or to optimize performance.</p>
                  <p>The allowed values of the attribute are as follows:</p>
                  <ul>
                     <li>
                        <p><code>yes</code>, <code>true</code>, <code>1</code>: the items processed
                  by this mode must be XNodes, and they must not have a type annotation
                  of <code>xs:untyped</code> or <code>xs:untypedAtomic</code>.</p>
                     </li>
                     <li>
                        <p><code>no</code>, <code>false</code>, <code>0</code>: the items processed
                  by this mode must be XNodes, and if they are elements or attributes then they must have a type annotation
                  of <code>xs:untyped</code> or <code>xs:untypedAtomic</code>.</p>
                     </li>
                     <li>
                        <p>The value <code>strict</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>
                        <ul>
                           <li>
                              <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, then:</p>
                              <ul>
                                 <li>
                                    <p>It is a static error if the in-scope schema declarations do
                                       not include a global element declaration for element name
                                          <var>E</var>
                                    </p>
                                 </li>
                                 <li>
                                    <p>When matching templates in this mode, the element name
                                          <var>E</var> appearing in this step is interpreted as
                                          <code>schema-element(E)</code>. (Informally, this means
                                       that it will only match an element if it has been validated
                                       against this element declaration). </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>Otherwise (the <code>NameTest</code> is a wildcard or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>), the
                              template matching proceeds as if the <code>typed</code> attribute were
                              absent. </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>The value <code>lax</code> is equivalent to <code>yes</code>, with the
                        additional provision that in the match pattern of any template rule that is
                           <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to this mode, any <code>NameTest</code>
                        used in the <code>ForwardStepP</code> of the first <code>StepExprP</code> of
                        a <code>RelativePathExprP</code> is interpreted as follows:</p>
                        <ul>
                           <li>
                              <p>If the <code>NameTest</code> is an <code>EQName</code>
                              <var>E</var>, and the principal node kind of the axis of this step is
                                 <code>Element</code>, and the in-scope schema declarations include
                              a global element declaration for element name <var>E</var>, then:</p>
                              <ul>
                                 <li>
                                    <p>When matching templates in this mode, the element name
                                          <var>E</var> appearing in this step is interpreted as
                                          <code>schema-element(E)</code>. (Informally, this means
                                       that it will only match an element if it has been validated
                                       against this element declaration). </p>
                                 </li>
                              </ul>
                           </li>
                           <li>
                              <p>Otherwise (the <code>NameTest</code> is a wildcard, or the principal
                              node kind is <code>Attribute</code> or <code>Namespace</code>, or
                              there is no element declaration for <var>E</var>), the template
                              matching proceeds as if the <code>typed</code> attribute were absent.
                           </p>
                           </li>
                        </ul>
                     </li>
                     <li>
                        <p>If the value is <code>~</code> followed by an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ItemType">ItemType</a><sup><small>XP</small></sup>,
                     for example <code>~xs:anyAtomicType</code> or <code>~jnode()</code> or <code>~map(*)</code>, this indicates
                     that all items to be processed using template rules in this mode must be
                     of the specified item type.</p>
                     </li>
                     <li>
                        <p>If the value is the string <code>"unspecified"</code>, or if it is omitted,
                     this is equivalent to specifying <code>~item()</code>, indicating that there
                     are no constraints.</p>
                     </li>
                  </ul>
                  <p>
                  <a id="err-XTTE3100"><span class="error">[ERR XTTE3100] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in a particular
                           <code>mode</code> selects an item that does not satisfy the constraints
                        imposed by the <code>@typed</code> attribute.
               </p>
                  <p>
                  <a id="err-XTSE3105"><span class="error">[ERR XTSE3105] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a template
                        rule applicable to a mode that is defined with <code>typed="strict"</code>
                        uses a match pattern that contains a <code>RelativePathExprP</code> whose
                        first <code>StepExprP</code> is an <code>AxisStepP</code> whose
                           <code>ForwardStepP</code> uses an axis whose principal node kind is
                           <code>Element</code> and whose <code>NodeTest</code> is an
                           <code>EQName</code> that does not correspond to the name of any global
                        element declaration in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>.
               </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="mode-result-type"></a>6.7.5 <a href="#mode-result-type" style="text-decoration: none">Declaring the Result Type of a Mode</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#enclosing-modes">next</a> | <a href="#xsl-mode-typed">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     The result type of a mode can be declared using an <code>as</code> attribute. The result type
                  of all template rules in this mode must be consistent with this, as must the values returned
                  by any built-in template rules for the mode.
                  <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/233">233</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/750">750</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/1382">1382</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/751">751</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1386">1386</a>&nbsp;18 October 2023]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>Traditionally, template rules have most commonly been used to construct XDM nodes, and the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
               instruction has been used to add nodes to a result tree. However, it is also possible to use template rules to produce
               other kinds of value, for example strings, booleans, or maps. For the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> 
               instruction to be useful, it will generally be the case that all template rules in a mode produce the same kind
               of value: for example, if one rule delivers a boolean, then the other rules will also deliver a boolean.</p>
                  <p>XSLT 4.0 therefore allows the result type of the template rules in a mode to be declared using the <code>as</code>
               attribute on the <a href="#element-mode"><code>xsl:mode</code></a> declaration. If this is absent, it defaults to <code>item()*</code>.
               The presence of an <code>as</code> attribute on a mode provides useful documentation and consistency checking,
               and enables the XSLT processor to infer a static type for an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction,
               which can be useful for optimization.</p>
                  <p>If a template rule <var>R</var> is <a title="applicable" class="termref" href="#dt-applicable">applicable</a> to a mode <var>M</var>, 
                  and <var>M</var> is declared with an <code>as</code> attribute whose value is the <code>SequenceType</code> 
                  <var>T</var>, then:</p>
                  <ul>
                     <li>
                        <p>If <var>R</var> has an <code>as</code> attribute, the <code>SequenceType</code> <var>S</var> declared
                     by <var>R</var> must be a subtype of <var>T</var>.</p>
                        <p><a id="err-XTSE4040"><span class="error">[ERR XTSE4040] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>
                        <var>R</var> has an <code>as</code> attribute <var>S</var>, 
                        and the template rule is <a title="applicable" class="termref" href="#dt-applicable">applicable</a>
                        to a <a title="mode" class="termref" href="#dt-mode">mode</a> <var>M</var> that is declared with an <code>as</code> attribute <var>T</var>,
                        and the sequence type <var>S</var> is not a subtype of the sequence type <var>T</var> as defined
                     by the relationship <code>subtype(S, T)</code> in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.</p>
                     </li>
                     <li>
                        <p>If <var>R</var> has no <code>as</code> attribute, then it is treated as if it had an <code>as</code>
                     attribute set to <var>T</var>. This means that a <a title="type error" class="termref" href="#dt-type-error">type error</a> 
                     <span class="error">[see <a href="#err-XTTE0505">ERR XTTE0505</a>]</span> is raised
                     if the result of the template rule cannot be coerced to a value of type <var>T</var>.</p>
                        <p>If <var>R</var> is applicable
                     to more than one mode, then it must meet the requirements of each one, which implies that these requirements
                     must be consistent with each other: for example, if one mode specifies <code>as="node()"</code> and another specifies
                        <code>as="map(*)"</code>, then a type error is inevitable if the template rule is actually evaluated, and
                        like other type errors this can be raised statically if detected statically. An
                     <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-implausible">implausibility</a><sup><small>XP</small></sup> <span class="verb">may</span> 
                        be reported if the only value that would satisfy both types is the empty sequence, map, or array.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>In practice the best way to satisfy this rule is to ensure 
                     that if a template rule is applicable to more than one mode (including
                  the case <code>mode="#all"</code>), then either (a) all those modes should have the same declared result type,
                  or (b) the template rule should declare an explicit result type that is compatible with each one of the relevant modes.</p>
                        </div>
                     </li>
                     <li>
                        <p>The requirement to return values of the correct type extends also to the built-in
                     template rule for the mode (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>). Since it is not possible to
                     determine statically whether the explicit template rules for a mode provide complete coverage
                     of all possible inputs, any failure of the built-in template rule to return a value 
                     that can be coerced to the expected type <span class="verb">must</span> be raised 
                     dynamically <span class="error">[see <a href="#err-XTTE0505">ERR XTTE0505</a>]</span>.</p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="enclosing-modes"></a>6.7.6 <a href="#enclosing-modes" style="text-decoration: none">Enclosing Modes</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#built-in-rule">next</a> | <a href="#mode-result-type">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     A mode (called an enclosing mode) can be defined in which all the relevant 
                     template rules are children of the <code>xsl:mode</code> element.
                     This is intended to allow a stylesheet design in which it is easier to
                     determine which rules might apply to a given <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                     call.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/82">82</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/542">542</a>&nbsp;20 June 2023]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-enclosing-mode" title="enclosing mode"></a>A mode declared by
                  an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has one or more contained <a href="#element-template"><code>xsl:template</code></a>
                  declarations is referred to as an <b>enclosing mode</b>.<span class="definition">]</span></p>
                  <p>An enclosing mode ensures that all the template rules for a mode are together in one place, which
               makes it easier for someone reading the stylesheet to establish what is going to happen when an
               <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in that mode is evaluated.</p>
                  <p>An enclosing mode <span class="verb">must</span> satisfy the following rules:</p>
                  <ol class="enumar">
                     <li>
                        <p>The mode must have a name.</p>
                     </li>
                     <li>
                        <p>Every contained <a href="#element-template"><code>xsl:template</code></a> element must have a <code>match</code>
                  attribute and no <code>name</code> attribute.</p>
                     </li>
                     <li>
                        <p>Every contained <a href="#element-template"><code>xsl:template</code></a> element must have no <code>mode</code>
                  attribute: the template is implicitly <a title="applicable" class="termref" href="#dt-applicable">applicable</a> only to the containing mode.</p>
                     </li>
                     <li>
                        <p>An <a href="#element-mode"><code>xsl:mode</code></a> declaration with one or more <a href="#element-template"><code>xsl:template</code></a>
                  children effectively has a <code>default-mode</code> attribute whose value is the mode’s name;
                     it must not have a <code>default-mode</code> attribute with any other value.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This means that <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions within the template
                  rules of the enclosing mode default to using the enclosing mode.</p>
                        </div>
                     </li>
                     <li>
                        <p>No <a href="#element-template"><code>xsl:template</code></a> that is in the same <span><a title="package" class="termref" href="#dt-package">package</a></span>
                     as the containing mode, but not declared within the containing mode, may be <a title="applicable" class="termref" href="#dt-applicable">applicable</a>
                  to the containing mode.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>Template rules in an enclosing mode may, however, be overridden within an 
                     <a href="#element-override"><code>xsl:override</code></a> element in a using <a title="package" class="termref" href="#dt-package">package</a>.</p>
                        </div>
                     </li>
                     <li>
                        <p>There must be no other <a href="#element-mode"><code>xsl:mode</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>
                  having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
                     </li>
                  </ol>
                  <p>These rules give rise to the following error conditions:</p>
                  <p><a id="err-XTSE4005"><span class="error">[ERR XTSE4005] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration with one or more <a href="#element-template"><code>xsl:template</code></a> children has no <code>name</code>
                     attribute.</p>
                  <p><a id="err-XTSE4010"><span class="error">[ERR XTSE4010] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration has a child <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute,
                     with a <code>mode</code> attribute, or with no <code>match</code> attribute.</p>
                  <p><a id="err-XTSE4015"><span class="error">[ERR XTSE4015] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code>
                     attribute whose value differs from its <code>name</code> attribute, or if any of those child <a href="#element-template"><code>xsl:template</code></a> 
                     elements has a <code>default-mode</code> attribute that differs from the <code>name</code> attribute
                     of the <a href="#element-mode"><code>xsl:mode</code></a> declaration.</p>
                  <p><a id="err-XTSE4020"><span class="error">[ERR XTSE4020] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                     <a title="package" class="termref" href="#dt-package">package</a> contains both (a) an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) 
                     an <a href="#element-template"><code>xsl:template</code></a> declaration that is not
                     one of those children but that references that <a href="#element-mode"><code>xsl:mode</code></a> declaration in its
                     <code>mode</code> attribute.</p>
                  <p><a id="err-XTSE4025"><span class="error">[ERR XTSE4025] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                     <a title="package" class="termref" href="#dt-package">package</a> contains (a) an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) 
                     a second <a href="#element-mode"><code>xsl:mode</code></a> declaration having the same name and the same
                     <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e23650"></a>Example: An Enclosing Mode</div>
                     <p>The following mode might be used for formatting of numbers appearing in text:</p>
                     <div class="exampleInner">
                        <pre>
&lt;xsl:mode name="numbers-in-text" as="xs:string" visibility="final"&gt;
  &lt;xsl:template match="type(xs:integer)[. gt 0 and . lt 21]"&gt;
    &lt;xsl:number value="." format="w"/&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="type(xs:integer)[. lt 10000]"&gt;
    &lt;xsl:number value="." format="1"/&gt;
  &lt;/xsl:template&gt;
  &lt;xsl:template match="type(xs:integer)"&gt;
    &lt;xsl:number value="." format="1" grouping-separator="," grouping-size="3"/&gt;
  &lt;/xsl:template&gt;  
&lt;/xsl:mode&gt;</pre>
                     </div>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="built-in-rule"></a>6.8 <a href="#built-in-rule" style="text-decoration: none">Built-in Template Rules</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#apply-imports">next</a> | <a href="#enclosing-modes">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  To allow recursive-descent transformation on a tree of maps and arrays, a new
                  set of built-in templates rules <code>shallow-copy-all</code> is introduced.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/570">570</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/718">718</a>&nbsp;26 September 2023]</i></p>
                     </li>
                  </ol>
               </div>
               <p>When an item is
               selected by <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and there is no user-specified
                  <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be used to process that item, then a built-in template rule is
               evaluated instead. </p>
               <p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rules</a> have lower
                  <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than all other
               template rules. Thus, the stylesheet author can override a built-in template rule by
               including an explicit template rule.</p>
               <p>There are <span>seven</span> sets of built-in template rules available. The set
               that is chosen is a property of the <a title="mode" class="termref" href="#dt-mode">mode</a> selected by
               the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. This property is set using the
                  <code>on-no-match</code> attribute of the <a href="#element-mode"><code>xsl:mode</code></a> declaration,
               which takes one of the values <code>deep-copy</code>, <code>shallow-copy</code>,
               <span><code>shallow-copy-all</code>,</span>
                  <code>deep-skip</code>, <code>shallow-skip</code>, 
               <code>text-only-copy</code>, or
                  <code>fail</code>, the default being <code>text-only-copy</code>. The effect of
               these <span>seven</span> sets of built-in template rules is explained in the following
               subsections.</p>
               <div class="div3">
                  
                  <h4><a id="built-in-templates-text-only-copy"></a>6.8.1 <a href="#built-in-templates-text-only-copy" style="text-decoration: none">Built-in Templates: Text-only Copy</a></h4>
                  <p>The effect of processing a
                     tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies
                        <code>on-no-match="text-only-copy"</code> is that the textual
                  content of the source document is retained while losing the markup, except where
                  explicit template rules dictate otherwise. When an element is encountered for
                  which there is no explicit <a title="template rule" class="termref" href="#dt-template-rule">template
                  rule</a>, the processing continues with the children of that element. Text
                  nodes are copied to the output.</p>
                  <p>The built-in rule for document nodes and element nodes is equivalent to calling
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with no <code>select</code> attribute, and
                  with the <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p>
                  <p>This is equivalent to the following in the case where
                  there are no parameters:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template
                     rule</a> for text and attribute nodes returns a text node containing the
                     <a title="string value" class="termref" href="#dt-string-value">string value</a> of the context node. It
                  is effectively:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="text()|@*" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This text node may have a string value that is zero-length.</p>
                  </div>
                  <p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template
                     rule</a> for atomic items returns a
                  text node containing the value. It is effectively:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match=".[. instance of xs:anyAtomicType]" mode="M"&gt;
  &lt;xsl:value-of select="string(.)"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This text node may have a string value that is zero-length.</p>
                  </div>
                  <p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template
                     rule</a> for processing instructions, comments, and namespace nodes does
                  nothing (it returns the empty sequence).</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template 
   match="processing-instruction()|comment()|namespace-node()" 
   mode="M"/&gt;</pre>
                  </div>
                  <p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template
                     rule</a> for functions (including
                     maps) does nothing (it returns the empty sequence).</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template 
   match=".[. instance of fn(*)]" 
   mode="M"/&gt;</pre>
                  </div>
                  <p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for
               arrays (see <a href="#arrays"><i>22 Arrays</i></a>) is to apply templates to the members of the array.
               It is equivalent to invoking <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with the <code>select</code>
               attribute set to <code>?*</code> (which selects the members of the array), and with the 
                  <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p>
                  <p>This is equivalent to the following in the case where
                  there are no parameters:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The following example illustrates the use of built-in template rules when there
                  are parameters.</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e23821"></a>Example: Using a Built-In Template Rule</div>
                     <p>Suppose the stylesheet contains the following instruction:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:apply-templates select="title" mode="M"&gt;
  &lt;xsl:with-param name="init" select="10"/&gt;
&lt;/xsl:apply-templates&gt;</pre>
                     </div>
                     <p>If there is no explicit template rule that matches the <code>title</code>
                     element, then the following implicit rule is used:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template match="title" mode="M"&gt;
  &lt;xsl:param name="init"/&gt;
  &lt;xsl:apply-templates mode="#current"&gt;
    &lt;xsl:with-param name="init" select="$init"/&gt;
  &lt;/xsl:apply-templates&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="built-in-templates-deep-copy"></a>6.8.2 <a href="#built-in-templates-deep-copy" style="text-decoration: none">Built-in Templates: Deep Copy</a></h4>
                  <p>The effect of processing a tree using a
                        <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies
                        <code>on-no-match="deep-copy"</code> is that an unmatched element
                  in the source tree is copied unchanged to the output, together with its entire
                  subtree. Other unmatched items are also copied unchanged. The subtree is copied
                  unconditionally, without attempting to match nodes in the subtree against template
                  rules.</p>
                  <p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic items, and functions, including maps and arrays) are processed
                  using a template rule that is equivalent to the following:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy-of select="." validation="preserve" copy-namespaces="CN"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>where <var>CN</var> is the value of the <code>copy-namespaces</code> attribute of the relevant
               <a href="#element-mode"><code>xsl:mode</code></a> declaration, defaulting to <code>yes</code>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="built-in-templates-shallow-copy"></a>6.8.3 <a href="#built-in-templates-shallow-copy" style="text-decoration: none">Built-in Templates: Shallow Copy</a></h4>
                  <p>The effect of processing a tree using a
                        <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies
                        <code>on-no-match="shallow-copy"</code> is that the source tree is
                  copied unchanged to the output, except for nodes where different processing is
                  specified using an explicit <a title="template rule" class="termref" href="#dt-template-rule">template
                     rule</a>.</p>
                  <p>When this default action is selected for a mode <var>M</var>, all items (nodes, atomic items, and functions, including maps and arrays) are processed
                  using a template rule that is equivalent to the following, except that all
                  parameters supplied in <a href="#element-with-param"><code>xsl:with-param</code></a> elements are passed on
                  implicitly to the called templates:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:copy validation="preserve" copy-namespaces="CN"&gt;
    &lt;xsl:apply-templates select="@*" mode="M"/&gt;
    &lt;xsl:apply-templates select="node()" mode="M"/&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>where <var>CN</var> is the value of the <code>copy-namespaces</code> attribute of the relevant
               <a href="#element-mode"><code>xsl:mode</code></a> declaration, defaulting to <code>yes</code>.</p>
                  <p>This rule is often referred to as the <em>identity template</em>, though it
                  should be noted that it does not preserve node identity.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This rule differs from the traditional identity template rule by using two
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instructions, one to process the
                     attributes and one to process the children. The only observable difference from
                     the traditional <code>select="node() | @*"</code> is that with two separate
                     instructions, the value of <code>position()</code> in the called templates
                     forms one sequence starting at 1 for the attributes, and a new sequence
                     starting at 1 for the children.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e23909"></a>Example: Modified Identity Transformation</div>
                     <p>The following stylesheet transforms an input document by deleting all elements
                     named <code>note</code>, together with their attributes and descendants:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="shallow-copy" streamable="true"/&gt;

&lt;xsl:template match="note"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="built-in-templates-shallow-copy-all"></a>6.8.4 <a href="#built-in-templates-shallow-copy-all" style="text-decoration: none">Built-in Templates: Shallow Copy All</a></h4>
                  <p>This processing mode is introduced in XSLT 4.0 as a variant of <code>shallow-copy</code>
               to enable recursive descent processing of trees involving maps and arrays, such as might result
               from parsing JSON input.
               </p>
                  <p>For all items other than maps and arrays, the effect of <code>shallow-copy-all</code>
               is exactly the same as <code>shallow-copy</code>.</p>
                  <p>For arrays, the processing is as follows. A new result array is created, and its content
                  is populated by decomposing the input array to a sequence of <b>value records</b>
               using the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-members"><code>array:members</code></a>. Each of these value records is processed
                  by a call on <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> (using the current mode, and passing
                  on the values of all template parameters); the result of the called template
                  is expected to be a value record.</p>
                  <p>That is, the template rule is equivalent to the following, except that this does not show
                  the propagation of template parameters:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array use="?value"&gt;
  &lt;xsl:apply-templates select="array:members(.)" mode="#current"/&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
                  <table class="ednote" caption="Editorial note">
                     <tr>
                        <td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td>
                        <td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td>
                     </tr>
                     <tr style="text-align: left; vertical-align: top;">
                        <td colspan="2">TODO: the use attribute is no more. Example need reworking.</td>
                     </tr>
                  </table>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>A <b>value record</b> is a single-entry map: it has a single key-value pair with the key <code>"value"</code>,
               the corresponding value being a member of the original array. The default processing for a value
               record, unless specified otherwise, is to apply templates to the value, as indicated by the rules
               that follow.</p>
                  </div>
                  <p>For maps, the processing is as follows:</p>
                  <ul>
                     <li>
                        <p>If the map contains two or more entries,
                     then a new result map is created, and its content is populated
                     by decomposing the input map using the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-map-entries"><code>map:entries</code></a> to 
                     produce a sequence of single-entry maps (each containing one key and one value), and then applying
                     templates to this sequence, using the current mode, and passing
                     on the values of all template parameters.</p>
                     </li>
                     <li>
                        <p>If the map contains a single entry <code>{ <var>K</var> : <var>V<sub>0</sub></var> }</code>, then a new single entry
                     map <code>{ <var>K</var>: <var>V<sub>1</sub></var> }</code> is constructed in which <var>V<sub>1</sub></var> is the
                     result of applying templates to <var>V<sub>0</sub></var> (using the current mode, and passing
                     on the values of all template parameters).</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This rule has the effect that if the input is a value record, the output will also
                     be a value record.</p>
                        </div>
                     </li>
                     <li>
                        <p>If the map is empty, the result is the empty map.</p>
                     </li>
                  </ul>
                  <p>In the first case, the template rule is equivalent to the following, except that this does not show
                  the propagation of template parameters:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:map&gt;
  &lt;xsl:apply-templates select="map:entries(.)" mode="#current"/&gt;
&lt;/xsl:map&gt;</pre>
                  </div>
                  <p>In the second case, the template rule is equivalent to the following, except that this does not show
                  the propagation of template parameters:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:map-entry key="map:keys(.)"&gt;
  &lt;xsl:apply-templates select="map:items(.)" mode="#current"/&gt;
&lt;/xsl:map-entry&gt;</pre>
                  </div>
                  <p>The reason there is a special rule for maps with one entry is to ensure that the process
               terminates.</p>
                  <p>The overall effect is best understood with an example.</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e23995"></a>Example: Modified Identity Transformation of a JSON Document</div>
                     <p>The following stylesheet transforms a supplied JSON document by deleting all properties
                     named <code>"Note"</code>, appearing at any level:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:stylesheet version="3.0"
     xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
				  
&lt;xsl:mode on-no-match="shallow-copy-all"/&gt;

&lt;xsl:template match="record(Note)"&gt;
  &lt;!-- no action --&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                     <p>Consider the following JSON input, converted to an array of maps by calling 
                     the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-json"><code>parse-json</code></a>:</p>
                     <div class="exampleInner">
                        <pre>[
  { "Title": "Computer Architecture",
    "Authors": [ "Enid Blyton", { "Note": "possibly misattributed" } ],
    "Category": "Computers",
    "Price": 42.60
  },
  { "Title": "Steppenwolf",
    "Authors": [ "Hermann Hesse" ],
    "Category": "Fiction",
    "Price": 12.00,
    "Note": "out of print"
  },
  { "Title": "How to Explore Outer Space with Binoculars",
    "Authors": [ "Bruce Betts", "Erica Colon" ],
    "Category": "Science",
    "Price": 10.40
  }
]</pre>
                     </div>
                     <p>The logic proceeds as follows:</p>
                     <ol class="enumar">
                        <li>
                           <p>The outermost array is processed by applying templates to a sequence of value records, 
                        the first being in the form:</p>
                           <div class="exampleInner">
                              <pre>{ "value": map: { "Title": ..., "Author": ..., ... }</pre>
                           </div>
                           <p>The result of applying templates to these value records is expected to comprise a new sequence
                        of value records, which is used to construct the final output array.</p>
                        </li>
                        <li>
                           <p>Each of the value records is processed using the rule for single-entry maps. This rule
                        produces a new value record by applying templates to the value, that is, to a map of the form
                        <code>map: { "Title": ..., "Author": ..., ... }</code> representing a book.</p>
                        </li>
                        <li>
                           <p>Each of these books, being represented by a map with more than two entries, is processed by
                     a template rule that splits the map into its multiple entries, each represented as a singleton
                     map (a map with one key and one value). One of these single-entry maps, for example, would be
                     <code>{"Title": "Steppenwolf"}</code>.</p>
                        </li>
                        <li>
                           <p>The default processing for a single-entry map of the form 
                        <code>{ "Title": "Steppenwolf" }</code> is to return the value unchanged.
                        This is achieved by applying templates to the string <code>"Steppenwolf"</code>;
                     the default template rule for strings returns the string unchanged.</p>
                        </li>
                        <li>
                           <p>When a single-entry map in the form <code>{ "Note": "out of print" }</code> is encountered, no output
                     is produced, meaning that entry in the parent map is effectively dropped. This is because there
                     is an explicit template rule with <code>match="record(Note)"</code> that matches such single-entry maps.</p>
                        </li>
                        <li>
                           <p>When a single-entry map in the form <code>"Authors": [ "Bruce Betts", "Erica Colon" ]</code> 
                        is encountered, a new single-entry map is produced; it has the same key (<code>"Authors"</code>),
                        and a value obtained by applying templates to the array <code>[ "Bruce Betts", "Erica Colon" ]</code>.
                        The default processing for an array, in which none of the constituents are matched by explicit
                        template rules, ends up delivering a copy of the array.</p>
                        </li>
                        <li>
                           <p>When the single-entry map <code>"Authors": [ "Enid Blyton", { "Note": "possibly misattributed" } ]</code>
                        is encountered, the recursive processing results in templates being applied to the map
                        <code>{ "Note": "possibly misattributed" }</code>. This matches the template rule having
                        <code>match="record(Note)"</code>, which returns no output, so the entry is effectively deleted.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The map entry is deleted, but the map itself remains, so the value becomes
                           <code>"Authors": [ "Enid Blyton", map: {} ]</code>.</p>
                           </div>
                        </li>
                     </ol>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="built-in-templates-deep-skip"></a>6.8.5 <a href="#built-in-templates-deep-skip" style="text-decoration: none">Built-in Templates: Deep Skip</a></h4>
                  <p>The effect of processing a tree using a <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies
                     <code>on-no-match="deep-skip"</code> is that where no explicit template rule is
                  specified for an element, that element and all its descendants are ignored, and
                  are not copied to the result tree.</p>
                  <p>The effect of choosing <code>on-no-match="deep-skip"</code> is as follows:</p>
                  <ul>
                     <li>
                        <p>The built-in rule for document nodes is equivalent to calling
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with no <code>select</code>
                        attribute, and with the <code>mode</code> attribute set to
                           <code>#current</code>. If the built-in rule was invoked with parameters,
                        those parameters are passed on in the implicit
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p>
                        <p>In the case where there are no parameters, this
                        is equivalent to the following rule:</p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:template match="document-node()" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</pre>
                        </div>
                     </li>
                     <li>
                        <p>The built-in rule for all items other than document nodes (that is, for all 
                        other kinds of node, as well as atomic
                           items and functions, including
                              maps and  and arrays) is to do nothing, that is, to return the empty
                        sequence (without applying templates to any children or ancestors).</p>
                        <p>This is equivalent to the following rule:</p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:template match="." mode="M"/&gt;</pre>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="built-in-templates-shallow-skip"></a>6.8.6 <a href="#built-in-templates-shallow-skip" style="text-decoration: none">Built-in Templates: Shallow Skip</a></h4>
                  <p>The effect of processing a tree using a
                        <a title="mode" class="termref" href="#dt-mode">mode</a> that specifies
                        <code>on-no-match="shallow-skip"</code> is to drop both the textual
                  content and the markup from the result document, except where there is an explicit
                  user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that dictates
                  otherwise.</p>
                  <p>The built-in rule for document nodes and element nodes  applies templates (in the current mode) first to the node’s
                     attributes and then to its children. If the built-in rule was invoked
                  with parameters, those parameters are passed on in the implicit
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  instructions.</p>
                  <p>In the case where there are no parameters, this is
                  equivalent to the following rule:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="document-node()|element()" mode="M"&gt;
  &lt;xsl:apply-templates select="@*" mode="#current"/&gt;
  &lt;xsl:apply-templates mode="#current"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The built-in template rule for all other kinds of node, and for atomic items and
                  functions (including maps, but not arrays) is empty:
                  that is, when the item is matched, the built-in template rule returns the empty
                  sequence.</p>
                  <p>This is equivalent to the following rule:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="." mode="M"/&gt;</pre>
                  </div>
                  <p>The built-in <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for
                  arrays (see <a href="#arrays"><i>22 Arrays</i></a>) is to apply templates to the members of the array.
                  It is equivalent to invoking <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> with the <code>select</code>
                  attribute set to <code>?*</code> (which selects the members of the array), and with the 
                  <code>mode</code> attribute set to <code>#current</code>. If the built-in
                  rule was invoked with parameters, those parameters are passed on in the implicit
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p>
                  <p>This is equivalent to the following in the case where
                  there are no parameters:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match=".[. instance of array(*)]" mode="M"&gt;
  &lt;xsl:apply-templates mode="#current" select="?*"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="built-in-templates-fail"></a>6.8.7 <a href="#built-in-templates-fail" style="text-decoration: none">Built-in Templates: Fail</a></h4>
                  <p>The effect of choosing <code>on-no-match="fail"</code> for a
                     <a title="mode" class="termref" href="#dt-mode">mode</a> is that every item selected in an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction
                  must be matched by an explicit user-written <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>.</p>
                  <p>The built-in template rule is effectively: </p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="." mode="M"&gt;
  &lt;xsl:message terminate="yes" error-code="err:XTDE0555"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>with an <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> message body.</p>
                  <p>
                  <a id="err-XTDE0555"><span class="error">[ERR XTDE0555] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
                        or <a href="#element-next-match"><code>xsl:next-match</code></a> is used to process 
                        <span>an item</span> using a mode
                        whose declaration specifies <code>on-no-match="fail"</code> when there is no
                           <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                        whose match pattern matches that <span>item</span>. 
               </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="apply-imports"></a>6.9 <a href="#apply-imports" style="text-decoration: none">Overriding Template Rules</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#for-each">next</a> | <a href="#built-in-rule">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a> instructions automatically
                  pass supplied parameters to the overridden template rule.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1861">1861</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1875">1875</a>&nbsp;25 March 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-apply-imports"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:apply-imports&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:apply-imports&gt;</code></p>
               <p class="element-syntax"><a id="element-next-match"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:next-match&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:next-match&gt;</code></p>
               <p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that is being used to
               override another template rule (see <a href="#conflict"><i>6.6 Conflict Resolution for Template Rules</i></a>) can use the
                  <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> instruction
               to invoke the overridden template rule. The <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
               instruction only considers template rules in imported stylesheet modules; the
                  <a href="#element-next-match"><code>xsl:next-match</code></a> instruction considers all template rules that
               have not already been used. Both instructions will invoke the built-in template rule for the
                  context item (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>) if no other template rule is found.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-current-template-rule" title="current template rule"></a>At any point in
                  the processing of a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there may
                  be a <b>current template rule</b>. Whenever a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is chosen as a result of
                  evaluating <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                     <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>, the
                  template rule becomes the current template rule for the evaluation of the rule’s
                  sequence constructor.<span class="definition">]</span>
             </p>
               <p>
               The <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is cleared (becomes <a title="absent" class="termref" href="#dt-absent">absent</a>)
                  by any instruction that evaluates an operand with changed focus. It is therefore cleared
                  when evaluating <a title="instruction" class="termref" href="#dt-instruction">instructions</a> contained within:
            </p>
               <ul>
                  <li>
                     <p><a href="#element-for-each"><code>xsl:for-each</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-for-each-group"><code>xsl:for-each-group</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-analyze-string"><code>xsl:analyze-string</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-iterate"><code>xsl:iterate</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-source-document"><code>xsl:source-document</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-merge"><code>xsl:merge</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-sort"><code>xsl:sort</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-key"><code>xsl:key</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-copy"><code>xsl:copy</code></a> if and only if there is a <code>select</code> attribute</p>
                  </li>
                  <li>
                     <p>A global <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-function"><code>xsl:function</code></a></p>
                  </li>
                  <li>
                     <p><a href="#element-template"><code>xsl:template</code></a> if and only if the called template specifies <code>&lt;xsl:context-item use="absent"/&gt;</code></p>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The current template rule is not affected by invoking named attribute sets (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), or named templates (see <a href="#named-templates"><i>10.1 Named Templates</i></a>) unless <code>&lt;xsl:context-item use="absent"/&gt;</code> is specified. 
                  While evaluating a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or the default value of a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> (see <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>) the current template rule is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
               </div>
               <p>These rules ensure that when <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or
                     <a href="#element-next-match"><code>xsl:next-match</code></a> is called, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is the same as when the current template rule was
                     invoked.</p>
               <p> Both <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a> search
               for a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> that matches the
                  <a title="context item" class="termref" href="#dt-context-item">context
                  item</a>, and that is applicable to the <a title="current mode" class="termref" href="#dt-current-mode">current mode</a> (see <a href="#modes"><i>6.7 Modes</i></a>). In
               choosing a template rule, they use the usual criteria such as the priority and
                  <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> of the template
               rules, but they consider as candidates only a subset of the template rules in the
                  <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This subset differs between the
               two instructions:</p>
               <ul>
                  <li>
                     <p>The <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction considers as candidates only
                     those template rules contained in <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet
                        levels</a> that are descendants in the <a title="import tree" class="termref" href="#dt-import-tree">import tree</a> of the <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet
                        level</a> that contains the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This is <em>not</em> the same as saying that the search considers all
                        template rules whose import precedence is lower than that of the current
                        template rule.</p>
                     </div>
                     <p><a id="err-XTSE3460"><span class="error">[ERR XTSE3460] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                              <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element appears in a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within an
                              <a href="#element-override"><code>xsl:override</code></a> element. (To invoke the template rule
                           that is being overridden, <a href="#element-next-match"><code>xsl:next-match</code></a> should
                           therefore be used.)</p>
                  </li>
                  <li>
                     <p>The <a href="#element-next-match"><code>xsl:next-match</code></a> instruction considers as candidates all
                     those template rules that come after the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> in the
                     ordering of template rules implied by the conflict resolution rules given in
                        <a href="#conflict"><i>6.6 Conflict Resolution for Template Rules</i></a>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Because a template rule declared as a child of <a href="#element-override"><code>xsl:override</code></a>
                        has higher precedence than any template rule declared in the used package
                        (see <a href="#modes-and-packages"><i>3.4.5 Overriding Template Rules from a Used Package</i></a>), the effect of
                           <a href="#element-next-match"><code>xsl:next-match</code></a> within such a template rule is to
                        consider as candidates first any other template rules for the same mode within the
                        same <a href="#element-use-package"><code>xsl:use-package</code></a> element (taking into account explicit and implicit
                        priority, and document order, in the usual way), and then all template rules in
                        the used package.</p>
                     </div>
                  </li>
               </ul>
               <p>If no matching template rule is found, both <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a>
            cause the built-in template rule for the mode to be invoked.</p>
               <p>If multiple matching template rules with the same explicit or implicit priority are found, 
               both <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a>
               respect the <code>on-multiple-match</code> and <code>warning-on-multiple-match</code> attributes of the 
               mode declaration.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>If is entirely possible for <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> to identify a template
               rule unambiguously, and for <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> 
               then to fail because there is no unambiguous second-choice template rule.</p>
               </div>
               <p>If a matching template rule <var>R</var> is found, then the result
               of the <a href="#element-next-match"><code>xsl:next-match</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction is the 
               result of invoking <var>R</var>. The parameters that are passed to <var>R</var> are as follows:</p>
               <ul>
                  <li>
                     <p>All parameters explicitly set using <a href="#element-with-param"><code>xsl:with-param</code></a>
                  child elements (see <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>).</p>
                  </li>
                  <li>
                     <p>If the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of the <a href="#element-next-match"><code>xsl:next-match</code></a> 
                     or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction is 4.0 or greater, then 
                     all non-tunnel parameters that were supplied in the invocation of the
                     current template rule, excluding any whose names match the names of
                     parameters appearing in child <a href="#element-with-param"><code>xsl:with-param</code></a> elements.</p>
                  </li>
                  <li>
                     <p>All <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> 
                     as described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>.</p>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The implicit passing of non-tunnel parameters is new in XSLT 4.0, and happens only if
                  <code>[xsl:]version</code> is set to 4.0 (or greater) on the instruction, or on some ancestor element
                  in the stylesheet. There may be cases where this
               change introduces a backward incompatibility: specifically, if the invoked template rule declares a default
               value for an optional parameter, it will now take the implicitly passed value rather than the
               default value. The 3.0 behavior can be therefore be retained by setting <code>version="3.0"</code>
               on the <a href="#element-next-match"><code>xsl:next-match</code></a> or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction.</p>
               </div>
               <p>The template rule <var>R</var> is evaluated with the same <a title="focus" class="termref" href="#dt-focus">focus</a> 
               as the <a href="#element-next-match"><code>xsl:next-match</code></a> 
               or <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> instruction. The <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a>
               changes to be <var>R</var>. The <a title="current mode" class="termref" href="#dt-current-mode">current mode</a> does not change. 
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In the case where the current template rule <var>T</var> is 
               declared within an <a href="#element-override"><code>xsl:override</code></a> element in a using package <var>P</var>, while 
               the selected rule <var>R</var> is declared within a different package <var>Q</var>, and where 
               the current mode is <var>M<sub>P</sub></var> (mode <var>M</var> in package <var>P</var>), the effect 
               is that the current mode for evaluation of <var>R</var> 
               remains <var>M<sub>P</sub></var> rather than reverting to its corresponding mode <var>M<sub>Q</sub></var> 
               (mode <var>M</var> in package <var>Q</var>). 
               If <var>R</var> contains an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction that uses
               <code>mode="#current"</code>, then the set of template rules considered by this instruction 
               will therefore include any overriding template rules declared in <var>P</var> as well as the original 
               rules declared in <var>Q</var>.
            </p>
               </div>
               <p>If no matching template rule is found that satisfies these criteria, the built-in
               template rule for the context item is used (see
                  <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>).</p>
               <p>
               <a id="err-XTDE0560"><span class="error">[ERR XTDE0560] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if
                        <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is
                     evaluated when the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template
                        rule</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>.
            </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e24610"></a>Example: Using <code>xsl:apply-imports</code>
                     </div>
                  <p>For example, suppose the stylesheet <code>doc.xsl</code> contains a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> for <code>example</code>
                  elements:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="example"&gt;
  &lt;pre&gt;&lt;xsl:apply-templates/&gt;&lt;/pre&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>Another stylesheet could import <code>doc.xsl</code> and modify the treatment of
                     <code>example</code> elements as follows:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:import href="doc.xsl"/&gt;

&lt;xsl:template match="example"&gt;
  &lt;div style="border: solid red"&gt;
     &lt;xsl:apply-imports/&gt;
  &lt;/div&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The combined effect would be to transform an <code>example</code> into an element
                  of the form:</p>
                  <div class="exampleInner">
                     <pre>&lt;div style="border: solid red"&gt;&lt;pre&gt;...&lt;/pre&gt;&lt;/div&gt;</pre>
                  </div>
               </div>
               <p>An <a href="#element-fallback"><code>xsl:fallback</code></a> instruction appearing as a child of an
                  <a href="#element-next-match"><code>xsl:next-match</code></a> instruction is ignored by an XSLT 2.0, 3.0, or 4.0 processor, 
               but can be used to define fallback
               behavior when the stylesheet is processed by an XSLT 1.0 processor with forwards
               compatible behavior.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e24651"></a>Example: Using <code>xsl:next-match</code></div>
                  <p>This example shows how an input element such as:</p>
                  <div class="exampleInner">
                     <pre>&lt;phrase upper-case="true" italic="true" bold="false" underscore="true"&gt;Hannover&lt;/phrase&gt;</pre>
                  </div>
                  <p>might be transformed into:</p>
                  <div class="exampleInner">
                     <pre>&lt;italic&gt;&lt;underscore&gt;HANNOVER&lt;/underscore&gt;&lt;/italic&gt;</pre>
                  </div>
                  <p>The following template rules achieve the required effect:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:template match="phrase" priority="10"&gt;
  &lt;xsl:next-match&gt;
     &lt;xsl:with-param name="upper-case" select="xs:boolean(@upper-case)"/&gt;
  &lt;/xsl:next-match&gt;
&lt;/xsl:template&gt;  

&lt;xsl:template match="phrase[xs:boolean(@italic)]" priority="8"&gt;
  &lt;italic&gt;
    &lt;xsl:next-match/&gt;
  &lt;/italic&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="phrase[xs:boolean(@bold)]" priority="6"&gt;
  &lt;bold&gt;
    &lt;xsl:next-match/&gt;
  &lt;/bold&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="phrase[xs:boolean(@underscore)]" priority="4"&gt;
  &lt;underscore&gt;
    &lt;xsl:next-match/&gt;
  &lt;/underscore&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="phrase" priority="2"&gt;
  &lt;xsl:param name="upper-case" as="xs:boolean?"/&gt;
  &lt;xsl:if test="$upper-case" then="upper-case(.)" else="string(.)"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>Note how the <code>$upper-case</code> parameter is passed implicitly through the chain of template rules.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="parameters-to-template-rules"></a>6.10 <a href="#parameters-to-template-rules" style="text-decoration: none">Passing Parameters to Template Rules</a></h3>
               <p>A template rule may have parameters. The parameters are declared in the body of the
               template using <a href="#element-param"><code>xsl:param</code></a> elements, as described in <a href="#parameters"><i>9.2 Parameters</i></a>.</p>
               <p>Values for these parameters may be supplied in the calling
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or
                  <a href="#element-next-match"><code>xsl:next-match</code></a> instruction by means of
                  <a href="#element-with-param"><code>xsl:with-param</code></a> elements appearing as children of the calling
               instruction. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>
               represented by the <code>name</code> attribute of the <a href="#element-with-param"><code>xsl:with-param</code></a>
               element must match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>
               represented by the <code>name</code> attribute of the corresponding
                  <a href="#element-param"><code>xsl:param</code></a> element. </p>
               <p>It is not an error for these instructions to supply a parameter that does not match
               any parameter declared in the template rule that is invoked; unneeded parameter
               values are simply ignored.</p>
               <p>A parameter may be declared as a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel
                  parameter</a> by specifying <code>tunnel="yes"</code> in the
                  <a href="#element-param"><code>xsl:param</code></a> declaration; in this case the caller must supply the
               value as a tunnel parameter by specifying <code>tunnel="yes"</code> in the
               corresponding <a href="#element-with-param"><code>xsl:with-param</code></a> element. Tunnel parameters differ from
               ordinary template parameters in that they are passed transparently through multiple
               template invocations. They are fully described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>.</p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="repetition"></a>7 <a href="#repetition" style="text-decoration: none">Repetition</a></h2>
            <p>XSLT offers two constructs for processing each <span>entry in a collection</span>:
               <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-iterate"><code>xsl:iterate</code></a>.</p>
            <p>Both instructions can be used to process the items in a sequence, the
         elements in an array, or the entries in a map. Arrays and maps are processed by reducing them
         to a sequence of items, so in what follows, the terms <b>item</b> and <b>sequence</b> 
         are used generically.</p>
            <p>The main difference between the two constructs is that with
               <a href="#element-for-each"><code>xsl:for-each</code></a>, the processing applied to each item in the sequence is
            independent of the processing applied to any other item; this means that the items may
            be processed in any order or in parallel, though the order of the output sequence is
            well defined and corresponds to the order of the input (sorted if so requested). By
            contrast, with <a href="#element-iterate"><code>xsl:iterate</code></a>, the processing is explicitly sequential:
            while one item is being processed, values may be computed which are then available for
            use while the next item is being processed. This makes <a href="#element-iterate"><code>xsl:iterate</code></a>
            suitable for tasks such as creating a running total over a sequence of financial
            transactions.</p>
            <p>A further difference is that <a href="#element-for-each"><code>xsl:for-each</code></a> permits
            sorting of the input sequence, while <a href="#element-iterate"><code>xsl:iterate</code></a> does not.</p>
            <div class="div2">
               
               <h3><a id="for-each"></a>7.1 <a href="#for-each" style="text-decoration: none">The <code>xsl:for-each</code> instruction</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#xsl-if">next</a> | <a href="#apply-imports">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  instructions acquire an attribute <code>separator</code> that can be
                  used to insert content between adjacent items. [This change was in the
                  editor's draft adopted as a baseline when the WG commenced work.]
               <i>&nbsp;&nbsp;[&nbsp;&nbsp;1 January 2022]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-for-each"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each&gt;</code></p>
               <p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction processes each  in a sequence of
               items, evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                  constructor</a> within the <a href="#element-for-each"><code>xsl:for-each</code></a> instruction once
               for each item in that sequence.</p>
               <p> The <code>select</code> attribute is <span class="verb">required</span>; it contains an
                  <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a
               sequence, called the input sequence. If there is an <a href="#element-sort"><code>xsl:sort</code></a> element
               present (see <a href="#sorting"><i>13 Sorting</i></a>) the input sequence is sorted to produce a
               sorted sequence. Otherwise, the sorted sequence is the same as the input
               sequence.</p>
               <p>The <a href="#element-for-each"><code>xsl:for-each</code></a> instruction contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is evaluated once for
               each item in the sorted sequence, with the <a title="focus" class="termref" href="#dt-focus">focus</a>
               set as follows:</p>
               <ul>
                  <li>
                     <p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the item being
                     processed. 
                  </p>
                  </li>
                  <li>
                     <p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the
                     position of this item in the sorted sequence.</p>
                  </li>
                  <li>
                     <p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is the size of the
                     sorted sequence (which is the same as the size of the input sequence).</p>
                  </li>
               </ul>
               <p> For each item in the input sequence, evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> produces a sequence
               of items (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>). These output sequences are
               concatenated; if item <var>Q</var> follows item <var>P</var> in the sorted sequence,
               then the result of evaluating the sequence constructor with <var>Q</var> as the
               context item is concatenated after the result of evaluating the sequence constructor
               with <var>P</var> as the context item. The result of the
                  <a href="#element-for-each"><code>xsl:for-each</code></a> instruction is the concatenated sequence of
               items.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e24856"></a>Example: Using <code>xsl:for-each</code> to process a sequence</div>
                  <p>For example, given an XML document with this structure</p>
                  <div class="exampleInner">
                     <pre>&lt;customers&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
  &lt;customer&gt;
    &lt;name&gt;...&lt;/name&gt;
    &lt;order&gt;...&lt;/order&gt;
    &lt;order&gt;...&lt;/order&gt;
  &lt;/customer&gt;
&lt;/customers&gt;</pre>
                  </div>
                  <p>the following would create an HTML document containing a table with a row for each
                     <code>customer</code> element</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="/"&gt;
  &lt;html&gt;
    &lt;head&gt;
      &lt;title&gt;Customers&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;
      &lt;table&gt;
	 &lt;tbody&gt;
	  &lt;xsl:for-each select="customers/customer"&gt;
	    &lt;tr&gt;
	      &lt;th&gt;
           &lt;xsl:apply-templates select="name"/&gt;
	      &lt;/th&gt;
	      &lt;xsl:for-each select="order"&gt;
           &lt;td&gt;
             &lt;xsl:apply-templates/&gt;
           &lt;/td&gt;
	      &lt;/xsl:for-each&gt;
	    &lt;/tr&gt;
	  &lt;/xsl:for-each&gt;
	&lt;/tbody&gt;
      &lt;/table&gt;
    &lt;/body&gt;
  &lt;/html&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e24871"></a>Example: Using <code>xsl:for-each</code> to process an array</div>
                  <p>Consider a JSON document of the form:</p>
                  <div class="exampleInner">
                     <pre>[
  { "city": "London", "latitude": 51.5099, "longitude": -0.1181 },
  { "city": "Paris",  "latitude": 48.8647, "longitude": 2.3488 },
  { "city": "Berlin", "latitude": 52.5200, "longitude": 13.4049 }                  
]</pre>
                  </div>
                  <p>The following code processes this array to produce an XML representation of the same information. The
               cities are sorted by name:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:for-each select="json-doc('input.json')?*"&gt;
   &lt;xsl:sort select="?city"/&gt;
   &lt;city number="{position()}" 
         name="{?city}" 
         latitude="{?latitude}" 
         longitude="{?longitude}"/&gt;
&lt;/xsl:for-each&gt;</pre>
                  </div>
                  <p>In this example it is possible to use the expression <code>$array?*</code> to convert an array to a sequence.
               This works because the members of the array are all single items. In the more general case (a member
               of the array might be the empty sequence, corresponding to the JSON value <code>null</code>, or it
               might be a sequence containing several items), <span>the function <code>array:members</code> can be
               used to deliver the contents of the array as a sequence of <em>value records</em>. This is 
               illustrated in the next example.</span></p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e24897"></a>Example: Using <code>xsl:for-each</code> to process an array containing nulls</div>
                  <p>Consider a JSON document of the form:</p>
                  <div class="exampleInner">
                     <pre>[
   { "city": "London", "data": [12.3, 15.6, null, 18.2] },
   { "city": "Paris",  "data": [7.9, 19.1, 23.0, null] },
   { "city": "Berlin", "data": [5.6, null, 14.6, 9.5] }                  
]</pre>
                  </div>
                  <p>The requirement is to convert this to the following XML:</p>
                  <div class="exampleInner">
                     <pre>&lt;cities&gt;
  &lt;city name="London" Q1="12.3" Q2="15.6" Q3="" Q4="18.2"/&gt;
  &lt;city name="Paris" Q1="7.9" Q2="19.1" Q3="23.0" Q4=""/&gt;
  &lt;city name="Berlin" Q1="5.6" Q2="" Q3="14.6" Q4="9.5"/&gt;
&lt;/cities&gt;</pre>
                  </div>
                  <p>The following code achieves this transformation:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:for-each select="json-doc('input.json')?*"&gt;
   &lt;city name="{?city}"&gt;
     &lt;xsl:for-each select="array:members(?data)"&gt;
       &lt;xsl:attribute name="Q{position()}" select="?value"/&gt;
     &lt;/xsl:for-each&gt;
   &lt;/city&gt;  
&lt;/xsl:for-each&gt;</pre>
                  </div>
                  <p>In this example the expression <code>$array?*</code> cannot be used on the inner arrays
                  because JSON nulls (which translate to the empty sequence in XDM) would be lost. Instead
                  the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-members"><code>array:members</code></a> is used to create a sequence of
                  value records: a non-null entry is represented by a value such as <code>{ 'value': 12.3 }</code>,
                  while a null entry would be <code>{ 'value': () }</code>.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e24925"></a>Example: Using <code>xsl:for-each</code> to process a map</div>
                  <p>Consider a JSON document of the form:</p>
                  <div class="exampleInner">
                     <pre>{
  "London": { "latitude": 51.5099, "longitude": -0.1181 },
  "Paris":  { "latitude": 48.8647, "longitude": 2.3488 },
  "Berlin": { "latitude": 52.5200, "longitude": 13.4049 }                  
}</pre>
                  </div>
                  <p>The following code processes this map to produce an XML representation of the same information. The
                  cities are sorted by name:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:for-each select="map:pairs(json-doc('input.json'))"&gt;
   &lt;xsl:sort select="?key"/&gt;
   &lt;city number="{position()}" 
         name="{?key}" 
         latitude="{?value?latitude}" 
         longitude="{?value?longitude}"/&gt;
&lt;/xsl:for-each&gt;</pre>
                  </div>
                  <p>In this example the map is decomposed to a sequence of key-value pairs, each represented as
               a map with two entries, <code>"key"</code> and <code>"value"</code>, which can be accessed using
               the lookup expressions <code>?key</code> and <code>?value</code>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="for-each-separator"></a>7.1.1 <a href="#for-each-separator" style="text-decoration: none">The <code>separator</code> attribute</a></h4>
                  <p>If the <code>separator</code> attribute is present, then its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
               is inserted, as a text node, into the output sequence, immediately after the results of processing each item in the sorted
               sequence other than the last.</p>
                  <p>For example, the following instruction:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:for-each select="6, 3, 9" separator="|"&gt;
   &lt;xsl:sort select="."/&gt;
   &lt;xsl:sequence select="., . + 1"/&gt;
&lt;/xsl:for-each&gt;</pre>
                  </div>
                  <p>produces a sequence comprising, in order: the integer 3, the integer 4, a text node with string value <code>"|"</code>,
               the integer 6, the integer 7, another text node with string value <code>"|"</code>,
            the integer 9, and the integer 10.</p>
                  <p>The node identity of any text nodes that are inserted is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. Specifically,
            it is not defined whether all the text nodes inserted in the course of one evaluation of the instruction are identical
            to each other, nor whether they are identical to the text nodes inserted in the course of another evaluation of this
            instruction, nor whether they are identical to any other parentless text nodes having the same string value.</p>
                  <p>If the separator is a zero-length string, then a zero-length text node is inserted into the sequence. (If the
            sequence is used for constructing the value of a node, then zero-length text nodes will be discarded: see
               <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a> and <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.)</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="iterate"></a>7.2 <a href="#iterate" style="text-decoration: none">The <code>xsl:iterate</code> Instruction</a></h3>
               <p>The <code>xsl:iterate</code> instruction processes the items in a sequence
            in order; unlike <code>xsl:for-each</code>, the result of processing one item can affect the way that
            subsequent items are processed.</p>
               <p class="element-syntax"><a id="element-iterate"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:iterate<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <a href="#element-on-completion">xsl:on-completion</a>?, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:iterate&gt;</code></p>
               <p class="element-syntax"><a id="element-next-iteration"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:next-iteration&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a>*) --&gt;<br>&lt;/xsl:next-iteration&gt;</code></p>
               <p class="element-syntax"><a id="element-break"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:break<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:break&gt;</code></p>
               <p class="element-syntax"><a id="element-on-completion"></a><code>&lt;xsl:on-completion<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-completion&gt;</code></p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e25027"></a>Example: Processing an array using <code>xsl:iterate</code></div>
                  <p>Consider the following JSON document representing transactions in a bank account:</p>
                  <div class="exampleInner">
                     <pre>[
  { "date": "2008-09-01", credit: 12.00 },
  { "date": "2008-09-01", credit: 8.00 },
  { "date": "2008-09-02", debit: 2.00 },
  { "date": "2008-09-02", credit: 12.00 }
]</pre>
                  </div>
                  <p>The following code converts this to an XML representation that includes a running balance:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:iterate select="json-doc('account.json') =&gt; array:members()"&gt;
   &lt;xsl:param name="balance" as="xs:decimal" select="0"/&gt;               
   &lt;xsl:variable name="delta" select="?value?credit otherwise -?value?debit"/&gt;               
   &lt;entry date="{ ?value?date }"
          amount="{ $delta }"
          balance="{ $balance + $delta }"/&gt;
   &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="balance" select="$balance + $delta"/&gt;
   &lt;/xsl:next-iteration&gt;   
&lt;/xsl:iterate&gt;</pre>
                  </div>
                  <p>Using <code>array:members()</code> in this way makes it possible to process any array, including one whose members
               are arbitrary sequences rather than single items. In this particular case, if it is known that the JSON array
               will not contain any <code>null</code> entries, or if any <code>null</code> entries are to be ignored,
                  it becomes possible to simplify the code as follows:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:iterate select="json-doc('account.json')?*"&gt;
   &lt;xsl:param name="balance" as="xs:decimal" select="0"/&gt;               
   &lt;xsl:variable name="delta" select="?credit otherwise -?debit"/&gt;               
   &lt;entry date="{ ?date }"
          amount="{ $delta }"
          balance="{ $balance + $delta }"/&gt;
   &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="balance" select="$balance + $delta"/&gt;
   &lt;/xsl:next-iteration&gt;   
&lt;/xsl:iterate&gt;</pre>
                  </div>
               </div>
               <p>The <code>select</code> attribute contains an
                  <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a
               sequence, called the input sequence.</p>
               <p>The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the
                  <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is evaluated once for each item in the
               input sequence, in order, or until the loop exits by evaluating an
                  <a href="#element-break"><code>xsl:break</code></a> instruction, whichever is earlier. Within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the body
               of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is set to each item from the value of the
                  <code>select</code> expression in turn; the <a title="context position" class="termref" href="#dt-context-position">context position</a> reflects the position of this item in the input
               sequence, and the <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number
               of items in the input sequence (which may be greater than the number of iterations,
               if the loop exits prematurely using <a href="#element-break"><code>xsl:break</code></a>).</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>If <a href="#element-iterate"><code>xsl:iterate</code></a> is used in conjunction with
                     <a href="#element-source-document"><code>xsl:source-document</code></a> to achieve streaming, calls on the function
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-last"><code>last</code></a> will be disallowed. </p>
               </div>
               <p>The <a href="#element-break"><code>xsl:break</code></a> and
                  <a href="#element-on-completion"><code>xsl:on-completion</code></a> elements may have either a <code>select</code>
               attribute or a non-empty contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> but not
               both. The effect of the element in both cases is obtained by evaluating the
                  <code>select</code> expression if present or the contained sequence constructor
               otherwise; if neither is present, the value is the empty sequence.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The <a href="#element-on-completion"><code>xsl:on-completion</code></a> element appears before other children
                  of <a href="#element-iterate"><code>xsl:iterate</code></a>
                  to ensure that variables declared in the sequence constructor are not in scope
                  within <a href="#element-on-completion"><code>xsl:on-completion</code></a>, since such variables do not have a
                  defined value within <a href="#element-on-completion"><code>xsl:on-completion</code></a> especially in the case
                  where the value of the <code>select</code> attribute is the empty sequence.</p>
               </div>
               <p>The effect of <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> is to cause the iteration to
               continue by processing the next item in the input sequence, potentially with
               different values for the iteration parameters. The effect of
                  <a href="#element-break"><code>xsl:break</code></a> is to cause the iteration to finish, whether or not all
               the items in the input sequence have been processed. In both cases the affected
               iteration is the one controlled by the innermost ancestor
                  <a href="#element-iterate"><code>xsl:iterate</code></a> element.</p>
               <p>The instructions <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> and <a href="#element-break"><code>xsl:break</code></a>
               are allowed only as descendants of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, and
               only in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of
               the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-tail-position" title="tail position"></a>An <a title="instruction" class="termref" href="#dt-instruction">instruction</a>
                  <var>J</var> is in a <b>tail position</b> within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
                  <var>SC</var> if it satisfies one of the following conditions:</p>
               <ul>
                  <li>
                     <p><var>J</var> is the last instruction in <var>SC</var>, ignoring any
                        <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p>
                  </li>
                  <li>
                     <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-if"><code>xsl:if</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p>
                  </li>
                  <li>
                     <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch of an
                        <a href="#element-choose"><code>xsl:choose</code></a> <span>or <a href="#element-switch"><code>xsl:switch</code></a></span> 
                     instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p>
                  </li>
                  <li>
                     <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var> (that
                     is, it is immediately followed by an <a href="#element-catch"><code>xsl:catch</code></a> element,
                     ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> elements).</p>
                  </li>
                  <li>
                     <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-catch"><code>xsl:catch</code></a> element within an <a href="#element-try"><code>xsl:try</code></a>
                     instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail
                        position</a> within <var>SC</var>.</p>
                  </li>
               </ul>
               <p>]</p>
               <p>
               <a id="err-XTSE3120"><span class="error">[ERR XTSE3120] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element
                     appears other than in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a> forming the body of an <a href="#element-iterate"><code>xsl:iterate</code></a>
                     instruction.
            </p>
               <p>
               <a id="err-XTSE3125"><span class="error">[ERR XTSE3125] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of <a href="#element-break"><code>xsl:break</code></a> or
                        <a href="#element-on-completion"><code>xsl:on-completion</code></a> is present and the instruction has
                     children.
            </p>
               <p>
               <a id="err-XTSE3130"><span class="error">[ERR XTSE3130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>name</code> attribute of an <a href="#element-with-param"><code>xsl:with-param</code></a> child of
                     an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element does not match the
                        <code>name</code> attribute of an <a href="#element-param"><code>xsl:param</code></a> child of the
                        innermost containing
                        <a href="#element-iterate"><code>xsl:iterate</code></a> instruction.
            </p>
               <p>Parameter names in <a href="#element-with-param"><code>xsl:with-param</code></a> must be unique: <span class="error">[see <a href="#err-XTSE0670">ERR XTSE0670</a>]</span>.</p>
               <p>The result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the concatenation of
               the sequences that result from the repeated evaluation of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, followed by the
               sequence that results from evaluating the <a href="#element-break"><code>xsl:break</code></a> or
                  <a href="#element-on-completion"><code>xsl:on-completion</code></a> element if any.</p>
               <p>Any <a href="#element-param"><code>xsl:param</code></a> element that appears as a child of
                  <a href="#element-iterate"><code>xsl:iterate</code></a> declares a parameter whose value may vary from one
               iteration to the next. The initial value of the parameter is the value obtained
               according to the rules given in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. The dynamic context
               for evaluating the initial value of an <a href="#element-param"><code>xsl:param</code></a> element is the same
               as the dynamic context for evaluating the <code>select</code> expression of the
                  <a href="#element-iterate"><code>xsl:iterate</code></a> instruction (the context item is thus
                  <em>not</em> the first item in the input sequence).</p>
               <p>On the first iteration a parameter always takes its initial value (which may depend
               on variables or other aspects of the dynamic context). Subsequently:</p>
               <ul>
                  <li>
                     <p>If an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction is evaluated, then
                     parameter values for processing the next item in the input sequence can be set
                     in the <a href="#element-with-param"><code>xsl:with-param</code></a> children of that instruction; in the
                     absence of an <a href="#element-with-param"><code>xsl:with-param</code></a> element that names a particular
                     parameter, that parameter will retain its value from the previous
                     iteration.</p>
                  </li>
                  <li>
                     <p>If an <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, no further items in
                     the input sequence are processed.</p>
                  </li>
                  <li>
                     <p>If neither an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> nor an
                        <a href="#element-break"><code>xsl:break</code></a> instruction is evaluated, then the next item in
                     the input sequence is processed using parameter values that are unchanged from
                     the previous iteration.</p>
                  </li>
               </ul>
               <p>The <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction contributes nothing to the result
               sequence (technically, it returns the empty sequence). The instruction supplies
               parameter values for the next iteration, which are evaluated according to the rules
               given in <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>; if there are no further items in the input
               sequence then it supplies parameter values for use while evaluating the body of the
                  <a href="#element-on-completion"><code>xsl:on-completion</code></a> element if any.</p>
               <p>The <a href="#element-break"><code>xsl:break</code></a> instruction indicates that the iteration should
               terminate without processing any remaining items from the input sequence. The <code>select</code> expression or  contained sequence
               constructor is evaluated using the same context item, position, and size as the
                  <a href="#element-break"><code>xsl:break</code></a> instruction itself, and the result is appended to the
               result of the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction as a whole.</p>
               <p>If neither an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> nor an <a href="#element-break"><code>xsl:break</code></a>
               instruction is evaluated, the next item in the input sequence is processed with
               parameter values unchanged from the previous iteration; if there are no further items
               in the input sequence, the iteration terminates.</p>
               <p>The optional <a href="#element-on-completion"><code>xsl:on-completion</code></a> element (which is not technically an
                  <a title="instruction" class="termref" href="#dt-instruction">instruction</a> and is not technically part of
               the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>) is evaluated when the input sequence is
               exhausted. It is not evaluated if the evaluation is terminated using
                  <a href="#element-break"><code>xsl:break</code></a>. During evaluation of its <code>select</code> expression or sequence constructor
               the context item, position, and size are <a title="absent" class="termref" href="#dt-absent">absent</a>
               (that is, any reference to these values is an error). However, the values of the
               parameters to <a href="#element-iterate"><code>xsl:iterate</code></a> are available, and take the values
               supplied by the <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction evaluated while
               processing the last item in the sequence.</p>
               <p>If the input sequence is empty, then the result of the
                  <a href="#element-iterate"><code>xsl:iterate</code></a> instruction is the result of evaluating the <code>select</code> attribute or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> forming the body of
               the <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, using the initial values of the
                  <a href="#element-param"><code>xsl:param</code></a> elements. If there is no
                  <a href="#element-on-completion"><code>xsl:on-completion</code></a> element, the result is the empty sequence.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Conceptually, <a href="#element-iterate"><code>xsl:iterate</code></a> behaves like a tail-recursive function.
                  The <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction then represents the recursive
                  call, supplying the tail of the input sequence as an implicit parameter. There are
                  two main reasons for providing the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction. One
                  is that many XSLT users find writing recursive functions to be a difficult skill,
                  and this construct promises to be easier to learn. The other is that recursive
                  function calls are difficult for an optimizer to analyze. Because
                     <a href="#element-iterate"><code>xsl:iterate</code></a> is more constrained than a general-purpose
                  head-tail recursive function, it should be more amenable to optimization. In
                  particular, when the instruction is used in conjunction with
                     <a href="#element-source-document"><code>xsl:source-document</code></a>, it is designed to make it easy for the
                  implementation to use streaming techniques, processing the nodes in an input
                  document sequentially as they are read, without building the entire document tree
                  in memory.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>One of the motivations for introducing the <a href="#element-iterate"><code>xsl:iterate</code></a> instruction
               was to enable information to be retained while processing a streamed sequence of
               sibling nodes. For examples illustrating this, see <a href="../xslt-streaming-40/#streaming-with-xsl-iterate">6 Streaming with</a><sup><small>SG</small></sup>.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="conditionals"></a>8 <a href="#conditionals" style="text-decoration: none">Conditional Processing</a></h2>
            <p>There are several instructions in XSLT that support conditional processing:
               <a href="#element-if"><code>xsl:if</code></a>, <a href="#element-choose"><code>xsl:choose</code></a><span>, and <a href="#element-switch"><code>xsl:switch</code></a></span>. 
            The <a href="#element-if"><code>xsl:if</code></a>
            instruction provides simple <span>if-then-else</span> conditionality; the <a href="#element-choose"><code>xsl:choose</code></a>
            instruction supports selection of one choice when there are several possibilities,
            <span>and <a href="#element-switch"><code>xsl:switch</code></a> allows a branch to be selected based on the value of a given
         expression.</span></p>
            <p>XSLT 3.0 also supports <a href="#element-try"><code>xsl:try</code></a> and
               <a href="#element-catch"><code>xsl:catch</code></a> which define conditional processing to handle <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a>.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>XSLT offers a number of ways of expressing conditional logic.</p>
               <p>XSLT 1.0 offered the <a href="#element-if"><code>xsl:if</code></a> instruction for cases where output was to be produced only if a condition was true,
         with <a href="#element-choose"><code>xsl:choose</code></a> available for multi-way branches where different output was to be produced under different
         input conditions. In addition, of course, XSLT 1.0 also offered the option of rule-based processing using templates and match patterns.</p>
               <p>XSLT 2.0 added the XPath conditional expression providing two-way branches for use at a finer-grained level where
            <a href="#element-choose"><code>xsl:choose</code></a> could be excessively verbose: it allowed constructs such as 
            <code>&lt;xsl:value-of select="if ($x) then 'red' else 'green'/&gt;</code> to be reduced from eight lines of code to one.</p>
               <p>XSLT 4.0 introduces the <code>then</code> and <code>else</code> attributes for <a href="#element-if"><code>xsl:if</code></a>,
            which are particularly useful in contexts such as the body of an <a href="#element-function"><code>xsl:function</code></a> declaration where
            the alternative results are conveniently evaluated using XPath expressions rather than XSLT instructions:
            for example a recursive function might have as its body the instruction 
               <code>&lt;xsl:if test="empty($seq)" then="1" else="head($seq) * my:f(tail($seq))"/&gt;</code>.
            The <code>select</code> attribute of <a href="#element-when"><code>xsl:when</code></a> and <a href="#element-otherwise"><code>xsl:otherwise</code></a>
               is introduced for similar reasons: XSLT instructions
            are most useful when contructing node trees, whereas XPath expressions are more convenient when computing
            atomic items. Again, the main contribution of these enhancements is to reduce visual clutter, making
            the code more concise and more easily readable.</p>
               <p>The <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced in XSLT 4.0 as an alternative to <a href="#element-choose"><code>xsl:choose</code></a>
            for the common use case where the conditions test for multiple different values of some common expression. By avoiding
            repetition of the common expression whose value is being tested, the logic becomes self-explanatory both to the human reader
            of the code and to an optimizing compiler, making it easier to generate efficient branching code.</p>
            </div>
            <div class="div2">
               
               <h3><a id="xsl-if"></a>8.1 <a href="#xsl-if" style="text-decoration: none">Conditional Processing with <code>xsl:if</code></a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#xsl-choose">next</a> | <a href="#for-each">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The <a href="#element-if"><code>xsl:if</code></a> instruction now allows <code>then</code> and <code>else</code>
                  attributes.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/167">167</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237</a>&nbsp;25 November 2022]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-if"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:if<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;then? = <var>expression</var><br>&nbsp;&nbsp;else? = <var>expression</var>〔()〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:if&gt;</code></p>
               <p>The <a href="#element-if"><code>xsl:if</code></a> element has a mandatory <code>test</code> attribute,
               whose value is an <a title="expression" class="termref" href="#dt-expression">expression</a>. The content is
               a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p>
               <p>If the <a href="#element-if"><code>xsl:if</code></a> element has a <code>then</code> attribute, then it
               <span class="verb">must</span> have no children. That is, the <code>then</code> attribute and the
               contained sequence constructor are mutually exclusive.</p>
               <p>The result of the <a href="#element-if"><code>xsl:if</code></a> instruction depends on the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of the expression in
               the <code>test</code> attribute. The rules for determining the effective boolean
               value of an expression are given in <a href="#xpath-40">[XPath 4.0]</a>: they are the same as
               the rules used for XPath conditional expressions.</p>
               <p>If the effective boolean value of the <a title="expression" class="termref" href="#dt-expression">expression</a> is <code>true</code>, then:</p>
               <ul>
                  <li>
                     <p>If there is a <code>then</code> attribute, the expression in the <code>then</code>
                  attribute is evaluated, and the resulting value is returned as the result of the 
                  <a href="#element-if"><code>xsl:if</code></a> instruction.</p>
                  </li>
                  <li>
                     <p>If there is a non-empty sequence constructor, it is evaluated and the
                  resulting value is returned as the result of the 
                  <a href="#element-if"><code>xsl:if</code></a> instruction.</p>
                  </li>
                  <li>
                     <p>Otherwise, the result of the 
                  <a href="#element-if"><code>xsl:if</code></a> instruction is the empty sequence.</p>
                  </li>
               </ul>
               <p>If the effective boolean value of the <code>test</code> <a title="expression" class="termref" href="#dt-expression">expression</a> is <code>false</code>, then:</p>
               <ul>
                  <li>
                     <p>If there is an <code>else</code> attribute, the expression in the <code>else</code>
                  attribute is evaluated, and the resulting value is returned as the result of the 
                  <a href="#element-if"><code>xsl:if</code></a> instruction.</p>
                  </li>
                  <li>
                     <p>Otherwise, the result of the 
                  <a href="#element-if"><code>xsl:if</code></a> instruction is the empty sequence.</p>
                  </li>
               </ul>
               <p>If the <code>test</code> expression has no effective boolean value (for example,
            if it is a sequence of several integers, or a map), then a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs. 
            (See <a href="https://www.w3.org/TR/xpath-functions/#ERRFORG0006" title="FORG0006"><span class="error">[ERR FORG0006] </span></a><sup><small>FO</small></sup>.)</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The semantics of the <a href="#element-if"><code>xsl:if</code></a> instruction are essentially equivalent to the semantics
               of the conditional expression in XPath: the construct <code>&lt;xsl:if test="C" then="X" else="Y"/&gt;</code>
                  can equivalently be written <code>&lt;xsl:sequence select="if (C) then X else Y"/&gt;</code>. The same
                  effect can also be achieved by writing 
                  <code>&lt;xsl:choose&gt;&lt;xsl:when test="C" select="X"/&gt;&lt;xsl:otherwise select="Y"/&gt;&lt;/xsl:choose&gt;.</code>
                  The choice of which of these constructs to use is a largely matter of personal style.
                  
               </p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e25673"></a>Example: Using <code>xsl:if</code> to insert separators</div>
                  <p>In the following example, the names in a group of names are formatted as a comma
                  separated list:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:apply-templates/&gt;
  &lt;xsl:if test="not(position()=last())"&gt;, &lt;/xsl:if&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>This adds a comma after every item except the last. This can also be
                  expressed as:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="namelist/name"&gt;
  &lt;xsl:if test="not(position()=1)"&gt;, &lt;/xsl:if&gt;
  &lt;xsl:apply-templates/&gt; 
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>which inserts a comma before every item except the first. (This formulation might
                  be more efficient, since determining whether an item is the last may involve look-ahead.)</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e25687"></a>Example: Using <code>xsl:if</code> as the body of a function</div>
                  <p>The following example shows the use of <a href="#element-if"><code>xsl:if</code></a> to
                  deliver the result of a recursive function:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="f:product" as="xs:double"&gt;
   &lt;xsl:param name="in" as="xs:double*"/&gt;
   &lt;xsl:if test="empty($in)" then="1e0" else="head($in) * f:product(tail($in))"/&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="xsl-choose"></a>8.2 <a href="#xsl-choose" style="text-decoration: none">Conditional Processing with <code>xsl:choose</code></a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#xsl-switch">next</a> | <a href="#xsl-if">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  In <a href="#element-choose"><code>xsl:choose</code></a>, the <a href="#element-when"><code>xsl:when</code></a> and
                  <code>xsl:otherwise</code> elements can take a <code>select</code> attribute
                  in place of a sequence constructor. 
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/167">167</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237</a>&nbsp;25 November 2022]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-choose"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:choose&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br>&lt;/xsl:choose&gt;</code></p>
               <p class="element-syntax"><a id="element-when"></a><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p>
               <p class="element-syntax"><a id="element-otherwise"></a><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p>
               <p>The <a href="#element-choose"><code>xsl:choose</code></a> element selects one among a number of possible
               alternatives. It consists of a sequence of one or more <a href="#element-when"><code>xsl:when</code></a>
               elements followed by an optional <a href="#element-otherwise"><code>xsl:otherwise</code></a> element. Each
               <a href="#element-when"><code>xsl:when</code></a> element has <span>an</span> attribute, <code>test</code>, which
               specifies an <a title="expression" class="termref" href="#dt-expression">expression</a> used as a condition.</p>
               <p>The effective value of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a>
               branch may be supplied using either a <code>select</code> attribute or a contained
               <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are
               mutually exclusive: if the <code>select</code> attribute is present then the
               sequence constructor must be empty, and if the sequence constructor is non-empty
               then the <code>select</code> attribute must be absent 
               <span><span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></span>. 
               If the <code>select</code>
               attribute is absent and the sequence constructor is empty, then the
               effective value is the empty sequence.</p>
               <p>When an <a href="#element-choose"><code>xsl:choose</code></a> element is processed, each of the
               <a href="#element-when"><code>xsl:when</code></a> elements is tested in turn (that is, in the order that
               the elements appear in the stylesheet), until one of the <a href="#element-when"><code>xsl:when</code></a>
               elements is satisfied. If none of the <a href="#element-when"><code>xsl:when</code></a> elements is
               satisfied, then the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is considered, as
               described below.</p>
               <p>An <a href="#element-when"><code>xsl:when</code></a> element is satisfied if the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of the <a title="expression" class="termref" href="#dt-expression">expression</a> in its <code>test</code> attribute is
               <code>true</code>. The rules for determining the effective boolean value of an
               expression are given in <a href="#xpath-40">[XPath 4.0]</a>: they are the same as the rules used
               for XPath conditional expressions.</p>
               <p>The  first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that
               is satisfied is evaluated, and the resulting sequence <span>(that is,
                  the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
                  as appropriate)</span> is returned as the result of
               the <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element
               is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated,
               and the resulting sequence is returned as the result of the
               <a href="#element-choose"><code>xsl:choose</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element
               is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of
               the <a href="#element-choose"><code>xsl:choose</code></a> instruction is the empty sequence.</p>
               <p><span>The <code>select</code> expressions and sequence constructors of  
               <a href="#element-when"><code>xsl:when</code></a> and
               <a href="#element-otherwise"><code>xsl:otherwise</code></a> instructions after the selected one are not evaluated.</span> 
               The <code>test</code>
               expressions for <a href="#element-when"><code>xsl:when</code></a> instructions after the selected one are not
               evaluated.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e25858"></a>Example: Using <code>xsl:choose</code> for formatting a numbered list
                     </div>
                  <p>The following example enumerates items in an ordered list using arabic numerals,
                  letters, or roman numerals depending on the depth to which the ordered lists are
                  nested.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test='$level=1'&gt;
          &lt;xsl:number format="i"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:when test='$level=2'&gt;
          &lt;xsl:number format="a"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:number format="1"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e25866"></a>Example: Using the <code>select</code> attribute of <code>xsl:when</code> and <code>xsl:otherwise</code></div>
                  <p>The following example is equivalent to the one above:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="orderedlist/listitem"&gt;
  &lt;fo:list-item indent-start='2pi'&gt;
    &lt;fo:list-item-label&gt;
      &lt;xsl:variable name="level"
                    select="count(ancestor::orderedlist) mod 3"/&gt;
      &lt;xsl:variable name="format" as="xs:string"&gt;
        &lt;xsl:choose&gt;
          &lt;xsl:when test='$level=1' select="'i'"/&gt;
          &lt;xsl:when test='$level=2' select="'a'"/&gt;
          &lt;xsl:otherwise select="'1'"/&gt;
        &lt;/xsl:choose&gt;
      &lt;/xsl:variable&gt;  
      &lt;xsl:number format="{ $format }"/&gt;
      &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;/fo:list-item-label&gt;
    &lt;fo:list-item-body&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/fo:list-item-body&gt;
  &lt;/fo:list-item&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="xsl-switch"></a>8.3 <a href="#xsl-switch" style="text-decoration: none">Conditional Processing with <code>xsl:switch</code></a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#try-catch">next</a> | <a href="#xsl-choose">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  A new <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/167">167</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237</a>&nbsp;25 November 2022]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-switch"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:switch<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:switch&gt;</code></p>
               <p class="element-syntax"><a id="element-when"></a><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p>
               <p class="element-syntax"><a id="element-otherwise"></a><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p>
               <p>The <a href="#element-switch"><code>xsl:switch</code></a> element selects one among a number of possible
               alternatives. The <code>select</code> attribute of the <a href="#element-switch"><code>xsl:switch</code></a> element
               is evaluated to obtain an atomic item, which is compared with the values given by the
               <code>test</code> attributes of the <a href="#element-when"><code>xsl:when</code></a> elements, in turn.</p>
               <p>The content of the <a href="#element-switch"><code>xsl:switch</code></a> element consists of a sequence of one or more <a href="#element-when"><code>xsl:when</code></a>
               elements followed by an optional <a href="#element-otherwise"><code>xsl:otherwise</code></a> element. Each
               <a href="#element-when"><code>xsl:when</code></a> element has <span>an</span> attribute, <code>test</code>, which
               contains an <a title="expression" class="termref" href="#dt-expression">expression</a>.</p>
               <p>The result of an <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a>
               branch may be supplied using either a <code>select</code> attribute or a contained
               <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. These are
               mutually exclusive: if the <code>select</code> attribute is present then the
               sequence constructor must be empty, and if the sequence constructor is non-empty
               then the <code>select</code> attribute must be absent. If the <code>select</code>
               attribute is absent and the sequence constructor is empty, then the
               result is the empty sequence.</p>
               <p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children are ignored by an XSLT 4.0 processor, but
               can be used to define the recovery action to be taken by a processor for an earlier version of XSLT when
               operating with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>.</p>
               <p>An <a href="#element-switch"><code>xsl:switch</code></a> element is processed as follows:</p>
               <ul>
                  <li>
                     <p>The <code>select</code> expression of the <a href="#element-switch"><code>xsl:switch</code></a>
                  element is evaluated.</p>
                  </li>
                  <li>
                     <p>The result of the evaluation is converted to a single atomic item
                  by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>; a type error occurs
                  if this conversion is not possible. This value is referred to below as the
                  <b>selector</b>.</p>
                  </li>
                  <li>
                     <p>Each of the
                  <a href="#element-when"><code>xsl:when</code></a> elements is tested in turn (that is, in the order that
                  the elements appear in the stylesheet), until one of the <a href="#element-when"><code>xsl:when</code></a>
                  elements is satisfied. If none of the <a href="#element-when"><code>xsl:when</code></a> elements is
                  satisfied, then the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is considered, as
                  described below.</p>
                     <p>An <a href="#element-when"><code>xsl:when</code></a> element is tested by first evaluating its <code>test</code>
                     expression and converting the result to a sequence of atomic items
                     by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>, and then
                     comparing this sequence of atomic items with the <code>selector</code> value. The
                     comparison is performed using the rules of the XPath <code>=</code> operator,
                     using the default collation that is in scope for the <a href="#element-switch"><code>xsl:switch</code></a>
                     instruction.</p>
                     <p>An <a href="#element-when"><code>xsl:when</code></a> element is satisfied if the result of this comparison is
                     <code>true</code>.</p>
                  </li>
                  <li>
                     <p>The first, and only the first, <a href="#element-when"><code>xsl:when</code></a> element that
                  is satisfied is evaluated, and the resulting sequence <span>(that is,
                     the result of evaluating its <code>select</code> attribute or contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
                     as appropriate)</span> is returned as the result of
                  the <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element
                  is satisfied, the content of the <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is evaluated,
                  and the resulting sequence is returned as the result of the
                  <a href="#element-switch"><code>xsl:switch</code></a> instruction. If no <a href="#element-when"><code>xsl:when</code></a> element
                  is satisfied, and no <a href="#element-otherwise"><code>xsl:otherwise</code></a> element is present, the result of
                  the <a href="#element-switch"><code>xsl:switch</code></a> instruction is the empty sequence.</p>
                  </li>
                  <li>
                     <p>The <code>select expressions</code> and sequence constructors of  
                  <a href="#element-when"><code>xsl:when</code></a> and
                  <a href="#element-otherwise"><code>xsl:otherwise</code></a> instructions after the selected one are not evaluated. 
                  The <code>test</code>
                  expressions for <a href="#element-when"><code>xsl:when</code></a> instructions after the selected one are not
                  evaluated.</p>
                  </li>
               </ul>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>There is no requirement that the values of <code>select</code> expressions
               should be literals, nor that the values should be distinct.</p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e26078"></a>Example: Using <code>xsl:switch</code> as a lookup table</div>
                  <p>The following example shows a simple function to convert a month number to a month name:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="f:month-name" as="xs:string"&gt;
    &lt;xsl:param name="month-number" as="xs:integer"/&gt;
    &lt;xsl:switch select="$month-number"&gt;
      &lt;xsl:when test="1" select="'January'"/&gt;
      &lt;xsl:when test="2" select="'February'"/&gt;
      &lt;xsl:when test="3" select="'March'"/&gt;
      &lt;xsl:when test="4" select="'April'"/&gt;
      &lt;xsl:when test="5" select="'May'"/&gt;
      &lt;xsl:when test="6" select="'June'"/&gt;
      &lt;xsl:when test="7" select="'July'"/&gt;
      &lt;xsl:when test="8" select="'August'"/&gt;
      &lt;xsl:when test="9" select="'September'"/&gt;
      &lt;xsl:when test="10" select="'October'"/&gt;
      &lt;xsl:when test="11" select="'November'"/&gt;
      &lt;xsl:when test="12" select="'December'"/&gt;
      &lt;xsl:otherwise select="error('Unknown month')"/&gt;
    &lt;/xsl:switch&gt;
  &lt;/xsl:function&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e26086"></a>Example: Using <code>xsl:switch</code> to return the number of days in the month</div>
                  <p>This function returns the number of days in a month, returning the empty sequence 
                  if the supplied month is invalid.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="f:days-in-month" as="xs:integer?"&gt;
    &lt;xsl:param name="month-number" as="xs:integer"/&gt;
    &lt;xsl:param name="leap-year" as="xs:boolean"/&gt;
    &lt;xsl:switch select="$month-number"&gt;
      &lt;xsl:when test="1, 3, 5, 7, 8, 10, 12" select="31"/&gt;
      &lt;xsl:when test="4, 6, 9, 11" select="30"/&gt;
      &lt;xsl:when test="2"&gt;
         &lt;xsl:if test="$leap-year" then="29" else="28"/&gt;
      &lt;/xsl:when&gt;
    &lt;/xsl:switch&gt;
  &lt;/xsl:function&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="try-catch"></a>8.4 <a href="#try-catch" style="text-decoration: none">Try/Catch</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#default-values-of-parameters">next</a> | <a href="#xsl-switch">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  New variables <code>err:stack-trace</code>, <code>err:additional</code>, 
                  and <code>err:map</code> are available within an <a href="#element-catch"><code>xsl:catch</code></a> clause.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1503">1503</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1505">1505</a>&nbsp;26 November 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p>The <a href="#element-try"><code>xsl:try</code></a> instruction can be used to trap
               dynamic errors occurring within the expression it wraps; the recovery action if such
               errors occur is defined using a child <a href="#element-catch"><code>xsl:catch</code></a> element.</p>
               <p class="element-syntax"><a id="element-try"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:try<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;rollback-output? = <var>boolean</var>〔'yes'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>sequence-constructor</var>, <a href="#element-catch">xsl:catch</a>, (<a href="#element-catch">xsl:catch</a> | <a href="#element-fallback">xsl:fallback</a>)*) --&gt;<br>&lt;/xsl:try&gt;</code></p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Because a sequence constructor may contain an <a href="#element-fallback"><code>xsl:fallback</code></a>
                  element, the effect of this content model is that an <a href="#element-fallback"><code>xsl:fallback</code></a>
                  instruction may appear as a child of <a href="#element-try"><code>xsl:try</code></a> in any position.</p>
               </div>
               <p class="element-syntax"><a id="element-catch"></a><code>&lt;xsl:catch<br>&nbsp;&nbsp;errors? = <var>tokens</var>〔'*'〕<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:catch&gt;</code></p>
               <p>An <a href="#element-try"><code>xsl:try</code></a> instruction evaluates either the expression contained in
               its <code>select</code> attribute, or its contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and returns the
               result of that evaluation if it succeeds without error. If a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during the evaluation, the
               processor evaluates the first <a href="#element-catch"><code>xsl:catch</code></a> child element applicable to
               the error, and returns that result instead.</p>
               <p>If the <a href="#element-try"><code>xsl:try</code></a> element has a <code>select</code> attribute, then it
                  <span class="verb">must</span> have no children other than <a href="#element-catch"><code>xsl:catch</code></a> and
                  <a href="#element-fallback"><code>xsl:fallback</code></a>. That is, the <code>select</code> attribute and the
               contained sequence constructor are mutually exclusive. If neither is present, the
               result of the <a href="#element-try"><code>xsl:try</code></a> is the empty sequence (no dynamic error can
               occur in this case).</p>
               <p>The <code>rollback-output</code> attribute is described in
                  <a href="#recovery"><i>8.4.1 Recovery of Result Trees</i></a>. The default value is <code>yes</code>.</p>
               <p>
               <a id="err-XTSE3140"><span class="error">[ERR XTSE3140] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-try"><code>xsl:try</code></a> element is
                     present and the element has children other than <a href="#element-catch"><code>xsl:catch</code></a> and
                        <a href="#element-fallback"><code>xsl:fallback</code></a> elements.
            </p>
               <p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children of the <a href="#element-try"><code>xsl:try</code></a> element
               are ignored by an XSLT 3.0 processor, but can be used to define the recovery action
               taken by an XSLT 1.0 or XSLT 2.0 processor operating with <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a>.</p>
               <p>The <a href="#element-catch"><code>xsl:catch</code></a> element has an optional <code>errors</code> attribute,
               which lists the error conditions that the <a href="#element-catch"><code>xsl:catch</code></a> element is
               designed to intercept. The default value is <code>errors="*"</code>, which catches
               all errors. The value is a whitespace-separated list of <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTests</a><sup><small>XP</small></sup>; an <a href="#element-catch"><code>xsl:catch</code></a> element
               catches an error condition if this list includes a <code>NameTest</code> that matches
               the error code associated with that error condition.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Error codes are QNames. Those defined in this specification and in related
                  specifications are all in the <a title="standard error namespace" class="termref" href="#dt-standard-error-namespace">standard
                     error namespace</a>, and may therefore be caught using an
                     <a href="#element-catch"><code>xsl:catch</code></a> element such as <code>&lt;xsl:catch
                     errors="err:FODC0001 err:FODC0005"&gt;</code> where the namespace prefix
                     <code>err</code> is bound to this namespace. Errors defined by implementers,
                  and errors raised by an explicit call of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function
                  or by use of the <a href="#element-message"><code>xsl:message</code></a>
                  or <a href="#element-assert"><code>xsl:assert</code></a> instruction, may
                  use error codes in other namespaces.</p>
               </div>
               <p>If more than one <a href="#element-catch"><code>xsl:catch</code></a> element matches an error, the error is
               processed using the first one that matches, in document order. If no
                  <a href="#element-catch"><code>xsl:catch</code></a> matches the error, then the error is not caught (that
               is, evaluation of the <a href="#element-try"><code>xsl:try</code></a> element fails with the dynamic
               error).</p>
               <p>An <a href="#element-catch"><code>xsl:catch</code></a> element may have either a <code>select</code>
               attribute, or a contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                  constructor</a>.</p>
               <p>
               <a id="err-XTSE3150"><span class="error">[ERR XTSE3150] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-catch"><code>xsl:catch</code></a> element is
                     present unless the element has empty content.
            </p>
               <p>The result of evaluating the <a href="#element-catch"><code>xsl:catch</code></a> element is the result of
               evaluating the XPath expression in its <code>select</code> attribute or the result of
               evaluating the contained sequence constructor; if neither is present, the result is
               the empty sequence. This result is delivered as the result of the <a href="#element-try"><code>xsl:try</code></a>
               instruction.</p>
               <p>If a dynamic error occurs during the evaluation of <a href="#element-catch"><code>xsl:catch</code></a>, it
               causes the containing <a href="#element-try"><code>xsl:try</code></a> to fail with this error. The error is
               not caught by other sibling <a href="#element-catch"><code>xsl:catch</code></a> elements within the same
                  <a href="#element-try"><code>xsl:try</code></a> instruction, but it may be caught by an
                  <a href="#element-try"><code>xsl:try</code></a> instruction at an outer level, or by an
                  <a href="#element-try"><code>xsl:try</code></a> instruction nested within the <a href="#element-catch"><code>xsl:catch</code></a>. </p>
               <p>Within the <code>select</code> expression, or within the sequence constructor
               contained by the <a href="#element-catch"><code>xsl:catch</code></a> element, a number of variables are
               implicitly declared, giving information about the error that occurred. These are
               lexically scoped to the <a href="#element-catch"><code>xsl:catch</code></a> element. These variables are all in
               the <a title="standard error namespace" class="termref" href="#dt-standard-error-namespace">standard error namespace</a>,
               and they are initialized as described in the following table:</p>
               <table class="data">
                  <caption>Variables Available within <code>xsl:catch</code></caption>
                  <thead>
                     <tr>
                        <th style="text-align:left; vertical-align:top">Variable</th>
                        <th style="text-align:left; vertical-align:top">Type</th>
                        <th style="text-align:left; vertical-align:top">Value</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:code</td>
                        <td style="text-align:left; vertical-align:top">xs:QName</td>
                        <td style="text-align:left; vertical-align:top">The error code</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:description</td>
                        <td style="text-align:left; vertical-align:top">xs:string?</td>
                        <td style="text-align:left; vertical-align:top">A description of the error condition; the empty sequence if no description is available
                           (for example, if
                           the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function was called with one
                           argument).</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:value</td>
                        <td style="text-align:left; vertical-align:top">item()*</td>
                        <td style="text-align:left; vertical-align:top">Value associated with the error. For an error raised by
                           calling the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function, this is the value of the
                           third argument (if supplied). For an error raised by evaluating
                           <a href="#element-message"><code>xsl:message</code></a> with <code>terminate="yes"</code>, or a failing <a href="#element-assert"><code>xsl:assert</code></a>, this
                           is the document node at the root of the tree containing the XML message
                           body.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:module</td>
                        <td style="text-align:left; vertical-align:top">xs:string?</td>
                        <td style="text-align:left; vertical-align:top">The URI (or system ID) of the stylesheet module containing the
                           instruction where the error occurred; the empty sequence if the information
                           is not available.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:line-number</td>
                        <td style="text-align:left; vertical-align:top">xs:integer?</td>
                        <td style="text-align:left; vertical-align:top">The line number within the stylesheet module of the
                           instruction where the error occurred; the empty sequence if the information
                           is not available. The value <span class="verb">may</span> be approximate.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:column-number</td>
                        <td style="text-align:left; vertical-align:top">xs:integer?</td>
                        <td style="text-align:left; vertical-align:top">The column number within the stylesheet module of the
                           instruction where the error occurred; the empty sequence if the information
                           is not available. The value <span class="verb">may</span> be approximate.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:stack-trace</td>
                        <td style="text-align:left; vertical-align:top">xs:string?</td>
                        <td style="text-align:left; vertical-align:top">An <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> 
                           string containing diagnostic
                           information about the state of execution at the point where the error occured, 
                           or the empty sequence if no stack trace is available.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:additional</td>
                        <td style="text-align:left; vertical-align:top">item()*</td>
                        <td style="text-align:left; vertical-align:top">Additional <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>
                           information about the error.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">err:map</td>
                        <td style="text-align:left; vertical-align:top">map(xs:string, item()*)</td>
                        <td style="text-align:left; vertical-align:top">A map with entries that are bound to the variables
                           above. The local names of the variables are assigned as keys. No map entries
                           are created for those values that are empty sequences. The variable can be
                           used to pass on all error information to another function.</td>
                     </tr>
                  </tbody>
               </table>
               <p>Variables declared within the sequence constructor of the <a href="#element-try"><code>xsl:try</code></a>
               element (and not within an <a href="#element-catch"><code>xsl:catch</code></a>) are not visible within the
                  <a href="#element-catch"><code>xsl:catch</code></a> element.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Within an <a href="#element-catch"><code>xsl:catch</code></a> it is possible to re-raise the error using
                  the function call <code>error($err:code, $err:description, $err:value)</code>.</p>
               </div>
               <p>The following additional rules apply to the catching of errors:</p>
               <ol class="enumar">
                  <li>
                     <p>All dynamic errors occurring during the evaluation of the
                        <a href="#element-try"><code>xsl:try</code></a> sequence constructor or <code>select</code>
                     expression are caught (provided they match one of the
                        <a href="#element-catch"><code>xsl:catch</code></a> elements). </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <ul>
                           <li>
                              <p>This includes errors occurring in functions or templates invoked in
                              the course of this evaluation, unless already caught by a nested
                                 <a href="#element-try"><code>xsl:try</code></a>.</p>
                           </li>
                           <li>
                              <p>It also includes (for
                                 example) errors caused by calling the
                                 <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-error"><code>error</code></a> function, or the
                                 <a href="#element-message"><code>xsl:message</code></a> instruction with
                                 <code>terminate="yes"</code>, or the 
                                 <a href="#element-assert"><code>xsl:assert</code></a> instruction, or the <code>xs:error</code> constructor
                                 function. </p>
                           </li>
                           <li>
                              <p>It does not include errors that occur while evaluating references to
                              variables whose declaration and initialization is outside the
                                 <a href="#element-try"><code>xsl:try</code></a>.</p>
                           </li>
                        </ul>
                     </div>
                  </li>
                  <li>
                     <p>The existence of an <a href="#element-try"><code>xsl:try</code></a> instruction does not affect the
                     obligation of the processor to raise certain errors as static errors, or its
                     right to choose whether to raise some errors (such as <a title="type error" class="termref" href="#dt-type-error">type errors</a>) statically or dynamically. Static
                     errors are never caught.</p>
                  </li>
                  <li>
                     <p>Some fatal errors arising in the processing environment, such as running out of
                     memory, may cause termination of the transformation despite the presence of an
                        <a href="#element-try"><code>xsl:try</code></a> instruction. This is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
                  </li>
                  <li>
                     <p>If the sequence constructor or <code>select</code> expression of the
                        <a href="#element-try"><code>xsl:try</code></a> causes execution of
                        <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-message"><code>xsl:message</code></a>, or <a href="#element-assert"><code>xsl:assert</code></a> instructions and
                     fails with a dynamic error that is caught, it is implementation-dependent
                     whether these instructions have any externally visible effect. The processor is
                        <span class="verb">not required</span> to roll back any changes made by these
                     instructions. The same applies to any side effects caused by extension
                     functions or extension instructions.</p>
                  </li>
                  <li>
                     <p>A serialization error that occurs during the serialization of
                     a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> produced
                     using <a href="#element-result-document"><code>xsl:result-document</code></a> is treated as a dynamic error in the
                     evaluation of the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, and may be
                     caught (for example by an <a href="#element-try"><code>xsl:try</code></a> instruction that contains
                     the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction). A serialization error
                     that occurs while serializing the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a>
                      is
                     treated as occurring after the transformation has finished, and cannot be
                     caught. </p>
                  </li>
                  <li>
                     <p>A validation error is treated as occurring in the instruction
                     that requested validation. For example, if the stylesheet is producing XHTML
                     output and requests validation of the entire result document by means of the
                     attribute <code>validation="strict"</code> on the instruction that creates the
                     outermost <code>html</code> element, then a validation failure can be caught
                     only at that level. Although the validation error might be detected, for
                     example, while writing a <code>p</code> element at a location where no
                        <code>p</code> element is allowed, it is not treated as an error in the
                     instruction that writes the <code>p</code> element and cannot be caught at that
                     level.</p>
                  </li>
                  <li>
                     <p>A type error may be caught if the processor raises it dynamically; this does
                     not affect the processor’s right to raise the error statically if it
                     chooses.</p>
                     <p>The following rules are provided to define which expression is considered to
                     fail when a type error occurs, and therefore where the error can be caught. The
                     general principle is that where the semantics of a construct <var>C</var> place
                     requirements on the type of some subexpression, a type error is an error in the
                     evaluation of <var>C</var>, not in the evaluation of the subexpression.</p>
                     <p>For example, consider the following construct:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:sequence select="$foo"/&gt;
&lt;/xsl:variable&gt;</pre>
                     </div>
                     <p>The expected type of the result of the sequence constructor is
                        <code>xs:integer</code>; if the value of variable <code>$foo</code> turns
                     out to be a string, then a type error will occur. It is not possible to catch
                     this by writing:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="v" as="xs:integer"&gt;
  &lt;xsl:try&gt;
    &lt;xsl:sequence select="$foo"/&gt;
    &lt;xsl:catch&gt;...&lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:variable&gt;</pre>
                     </div>
                     <p>This fails to catch the error because the <a href="#element-sequence"><code>xsl:sequence</code></a>
                     instruction is deemed to evaluate successfully; the failure only occurs when
                     the result of this instruction is bound to the variable.</p>
                     <p>A similar rule applies to functions: if the body of a function computes a
                     result which does not conform to the required type of the function result, it
                     is not possible to catch this error within the function body itself; it can
                     only be caught by the caller of the function. Similarly, if an expression used
                     to compute an argument to a function returns a value of the wrong type for the
                     function signature, this is not considered an error in this expression, but an
                     error in evaluating the function call as a whole.</p>
                     <p>A consequence of these rules is that when a type error occurs while
                     initializing a global variable (because the initializer returns a value of the
                     wrong type, given the declared type of the variable), then this error cannot be
                     caught.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Because processors are permitted to raise type errors during static
                        analysis, it is unwise to attempt to recover from type errors dynamically.
                        The best strategy is generally to prevent their occurrence. For example,
                        rather than writing <code>$p + 1</code> where <code>$p</code> is a parameter
                        of unknown type, and then catching the type error that occurs if
                           <code>$p</code> is not numeric, it is better first to test whether
                           <code>$p</code> is numeric, perhaps by means of an expression such as
                           <code>$p instance of my:numeric</code>, where <code>my:numeric</code> is
                        a union type with <code>xs:double</code>, <code>xs:float</code>, and
                           <code>xs:decimal</code> as its member types.</p>
                     </div>
                  </li>
                  <li>
                     <p>The fact that the application tries to catch errors does not prevent the
                     processor from organizing the evaluation in such a way as to prevent errors
                     occurring. For example <code>exists(//a[10 div . gt 5])</code> may still do an
                     “early exit”, rather than examining every item in the sequence just to see if
                     it triggers a divide-by-zero error.</p>
                  </li>
                  <li>
                     <p>Except as specified above, the optimizer must not rearrange the evaluation (at
                     compile time or at run time) so that expressions written to be subject to the
                     try/catch are evaluated outside its scope, or expressions written to be
                     external to the try/catch are evaluated within its scope. This does not prevent
                     expressions being rearranged, but any expression that is so rearranged must
                     carry its try/catch context with it.</p>
                  </li>
               </ol>
               <div class="div3">
                  
                  <h4><a id="recovery"></a>8.4.1 <a href="#recovery" style="text-decoration: none">Recovery of Result Trees</a></h4>
                  <p>The XSLT language is designed so that a processor that chooses to execute
                  instructions in document order will always append nodes to the result tree in
                  document order, and never needs to update a result tree in situ. As a result, it
                  is normal practice for XSLT processors to stream the result tree directly to its
                  final destination (for example, a serializer) without ever holding the tree in
                  memory. This applies whether or not the processor is streamable, and whether or
                  not source documents are streamed.</p>
                  <p>The language specification states (see <a href="#errors"><i>2.12 Error Handling</i></a>) that when a
                  transformation terminates with a dynamic error, the state of persistent resources
                  affected by the transformation (for example, serialized result documents) is
                     <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, so processors are not required to
                  take any special steps to recover such resources to their pre-transformation
                  state; at the same time, there is no guarantee that secondary result documents
                  produced before the failure occurs will be in a usable state.</p>
                  <p>The situation becomes more complicated when dynamic errors occur while writing to
                  a result tree, and the dynamic error is caught by an
                     <a href="#element-try"><code>xsl:try</code></a>/<a href="#element-catch"><code>xsl:catch</code></a> instruction. The semantics
                  of these instructions requires that when an error occurring during the evaluation
                  of <a href="#element-try"><code>xsl:try</code></a> is caught, the result of the <a href="#element-try"><code>xsl:try</code></a>
                  instruction is the result of the relevant <a href="#element-catch"><code>xsl:catch</code></a>. To achieve
                  this, any output written to the result tree during the execution of
                     <a href="#element-try"><code>xsl:try</code></a> until the point where the error occurs must
                  effectively be undone. There are two basic strategies for achieving this: either
                  the updates are not committed to persistent storage until the
                     <a href="#element-try"><code>xsl:try</code></a> instruction is completed, or the updates are written
                  in such a way that they can be rolled back in the event of a failure.</p>
                  <p>Both these strategies are potentially expensive, and both have an adverse effect
                  on streaming, in that they affect the amount of memory needed to transform large
                  amounts of data. XSLT 3.0 therefore provides an option to relax the requirement to
                  recover result trees when failures occur in the course of evaluating an
                     <a href="#element-try"><code>xsl:try</code></a> instruction. This option is invoked by specifying
                     <code>rollback-output="no"</code> on the <a href="#element-try"><code>xsl:try</code></a>
                  instruction.</p>
                  <p>The default value of the attribute is <code>rollback-output="yes"</code>.</p>
                  <p>The effect of specifying <code>rollback-output="no"</code> on
                     <a href="#element-try"><code>xsl:try</code></a> is as follows: if a dynamic error occurs in the course
                  of evaluating the <a href="#element-try"><code>xsl:try</code></a> instruction, and if the failing
                  construct is evaluated in <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a> while writing to
                  some result document, then it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>
                  whether an attempt to catch this error using <a href="#element-catch"><code>xsl:catch</code></a> will be
                  successful. If the attempt is successful, then the <a href="#element-try"><code>xsl:try</code></a>
                  instruction succeeds, delivering the result of evaluating the
                     <a href="#element-catch"><code>xsl:catch</code></a> clause, and the transformation proceeds as normal.
                  If the attempt is unsuccessful (typically, because non-recoverable updates have
                  already been made to the result tree), then the <a href="#element-try"><code>xsl:try</code></a>
                  instruction as a whole fails with a dynamic error. The state of this result
                  document will then be undefined, but the transformation can ignore the failure and
                  continue to produce other result documents, for example by wrapping the
                     <a href="#element-result-document"><code>xsl:result-document</code></a> instruction in an <a href="#element-try"><code>xsl:try</code></a>
                  instruction that catches the relevant error.</p>
                  <p>
                  <a id="err-XTDE3530"><span class="error">[ERR XTDE3530] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-try"><code>xsl:try</code></a>
                        instruction is unable to recover the state of a final result tree because
                        recovery has been disabled by use of the attribute
                           <code>rollback-output="no"</code>.
               </p>
                  <p>For example, consider the following:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:result-document href="out.xml"&gt;     
  &lt;xsl:try rollback-output="no"&gt;
    &lt;xsl:source-document streamable="yes" href="in.xml"&gt;
      &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:source-document&gt;
    &lt;xsl:catch errors="*"&gt;
       &lt;error code="{ $err:code }" message="{ $err:description }" file="in.xml"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;</pre>
                  </div>
                  <p>The most likely failure to occur here is a failure to read the streamed input file
                     <code>in.xml</code>. In the common case where this failure is detected
                  immediately, for example if the file does not exist or the network connection is
                  down, no output will have been written to the result document, and the attempt to
                  catch the error is likely to be successful. If however a failure is detected after
                  several megabytes of data have been copied to <code>out.xml</code>, for example an
                  XML well-formedness error in the input file, or a network failure that occurs
                  while reading the file, recovery of the output file may be impossible. In this
                  situation the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction will fail with a
                  dynamic error. It is possible to catch this error, but the state of the file
                     <code>out.xml</code> will be unpredictable.</p>
                  <p>Note that adding an <a href="#element-try"><code>xsl:try</code></a> instruction as a child of
                     <a href="#element-source-document"><code>xsl:source-document</code></a> does not help. Any error reading the input file
                  (such as a well-formedness error) is an error in the <a href="#element-source-document"><code>xsl:source-document</code></a>
                  instruction and can only be caught at that level.</p>
                  <p>When <code>rollback-output="no"</code> is specified, it is still possible to
                  ensure recovery of errors happens predictably by evaluating the
                  potentially failing code in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>: typically,
                  within an <a href="#element-variable"><code>xsl:variable</code></a>. In effect the variable acts as an
                  explicit buffer for temporary results, which is only copied to the final output if
                  evaluation succeeds.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>An application might wish to ensure that when a fatal error occurs while
                     reading an input stream, data written to persistent storage up to the point of
                     failure is available after the transformation terminates. Setting
                        <code>rollback-output="no"</code> does not guarantee this, but a processor
                     might choose to interpret this as the intent.</p>
                  </div>
                  <p>Changing the attribute to <code>rollback-output="yes"</code> makes the stylesheet
                  more robust and able to handle error conditions predictably, but the cost may be
                  substantial; for example it may be necessary to buffer the whole of the result
                  document in memory.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="try-catch-examples"></a>8.4.2 <a href="#try-catch-examples" style="text-decoration: none">Try/Catch Examples</a></h4>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e26741"></a>Example: Catching a Divide-by-Zero Error</div>
                     <p>The following example divides an employee’s salary by the number of
                     years they have served, catching the divide-by-zero error if the latter is
                     zero.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:try select="salary div length-of-service"&gt;
  &lt;xsl:catch errors="err:FOAR0001" select="()"/&gt;
&lt;/xsl:try&gt;</pre>
                     </div>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e26746"></a>Example: Catching an Error during Result-tree Validation</div>
                     <p>The following example generates a result tree and performs schema validation,
                     outputting a warning message and serializing the invalid tree if validation
                     fails.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:result-document href="out.xml"&gt;
  &lt;xsl:variable name="result"&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:try&gt;
    &lt;xsl:copy-of select="$result" validation="strict"/&gt;
    &lt;xsl:catch&gt;
      &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
      &lt;/xsl:message&gt;
      &lt;xsl:sequence select="$result"/&gt;
    &lt;/xsl:catch&gt;
  &lt;/xsl:try&gt;
&lt;/xsl:result-document&gt;</pre>
                     </div>
                     <p>The reason that the result tree is constructed in a variable in this example is
                     so that the unvalidated tree is available to be used within the
                        <a href="#element-catch"><code>xsl:catch</code></a> element. An alternative approach would be to
                     repeat the logic for constructing the tree:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:try&gt;
  &lt;xsl:result-document href="out.xml" validation="strict"&gt;  
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:catch&gt;
    &lt;xsl:message&gt;Warning: validation of result document failed:
          Error code: &lt;xsl:value-of select="$err:code"/&gt;
          Reason: &lt;xsl:value-of select="$err:description"/&gt;
    &lt;/xsl:message&gt;
    &lt;xsl:call-template name="construct-output"/&gt;
  &lt;/xsl:catch&gt;
&lt;/xsl:try&gt;</pre>
                     </div>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="conditional-content-construction"></a>8.5 <a href="#conditional-content-construction" style="text-decoration: none">Conditional Content Construction</a></h3>
               <p>The facilities described in this section are designed to make it easier to generate
               result trees conditionally depending on what is found in the input, without violating
               the rules for streamability. Although these facilities were 
               introduced to the language specifically to make streaming
               easier, they are available whether or not streaming
               is in use, and users have often found them convenient in non-streaming applications.</p>
               <p>The facilities are introduced first by example:</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e26761"></a>Example: Generating a Wrapper Element for a non-Empty Sequence</div>
                  <p>The following example generates an <code>events</code> element if and only if
                  there are one or more <code>event</code> elements. The code could be written like
                  this:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:if test="exists(event)"&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:if&gt;</pre>
                  </div>
                  <p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>,
                  because it processes the child <code>event</code> elements more than once. To make
                  it streamable, it can be rewritten as:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:where-populated&gt;
  &lt;events&gt;
    &lt;xsl:copy-of select="event"/&gt;
  &lt;/events&gt;
&lt;/xsl:where-populated&gt;</pre>
                  </div>
                  <p>The effect of the <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction, as explained
                  later, is to avoid outputting the <code>events</code> element if it would have no
                  children. A streaming implementation will typically hold the start tag of the
                     <code>events</code> element in a buffer, to be sent to the output destination
                  only if and when a child node is generated.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e26792"></a>Example: Generating a Header and Footer only if there is Content</div>
                  <p>The following example generates an <code>h3</code> element and a summary paragraph
                  only if a list of items is non-empty. The code could be written like this:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;h1&gt;Items for Sale&lt;/h1&gt;
&lt;/xsl:if&gt;  
&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="exists(item-for-sale)"&gt;
  &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
&lt;/xsl:if&gt;</pre>
                  </div>
                  <p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>,
                  because it processes the child <code>item-for-sale</code> elements more than once.
                  To make it streamable, it can be rewritten as:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:sequence&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;h1&gt;Items for Sale&lt;/h1&gt;
  &lt;/xsl:on-non-empty&gt;  
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-non-empty&gt;
    &lt;p&gt;Total value: {accumulator-before('total-value')}&lt;/p&gt;
  &lt;/xsl:on-non-empty&gt;  
&lt;/xsl:sequence&gt;</pre>
                  </div>
                  <p>The effect of the <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction, as explained
                  later, is to output the enclosed content only if the containing sequence
                  constructor also generates “ordinary” content, that is, if there is content
                  generated by instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and
                     <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e26818"></a>Example: Generating Substitute Text when there is no Content</div>
                  <p>The following example generates a summary paragraph only if a list of items is
                  empty. The code could be written like this:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:apply-templates select="item-for-sale"/&gt;
&lt;xsl:if test="empty(item-for-sale)"&gt;
  &lt;p&gt;There are no items for sale.&lt;/p&gt;
&lt;/xsl:if&gt;</pre>
                  </div>
                  <p>However, the above code would not be <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>,
                  because it processes the child <code>item-for-sale</code> elements more than once
                  (the fact that the list is empty is irrelevant, because streamability is
                  determined statically). To make the code streamable, it can be rewritten as:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:sequence&gt;
  &lt;xsl:apply-templates select="item-for-sale"/&gt;
  &lt;xsl:on-empty&gt;
    &lt;p&gt;There are no items for sale.&lt;/p&gt;
  &lt;/xsl:on-empty&gt;
&lt;/xsl:sequence&gt;</pre>
                  </div>
                  <p>The effect of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, as explained later,
                  is to output the enclosed content only if the containing sequence constructor
                  generates no “ordinary” content, that is, if there is no content generated by
                  instructions other than <a href="#element-on-empty"><code>xsl:on-empty</code></a> and
                     <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions.</p>
               </div>
               <p>For further examples showing the use of these instructions when streaming,
            see <a href="../xslt-streaming-40/#handling-empty-input">7 Handling Empty Input</a><sup><small>SG</small></sup>.</p>
               <div class="div3">
                  
                  <h4><a id="where-populated"></a>8.5.1 <a href="#where-populated" style="text-decoration: none">The <code>xsl:where-populated</code> instruction</a></h4>
                  <p class="element-syntax"><a id="element-where-populated"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:where-populated&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:where-populated&gt;</code></p>
                  <p>The <a href="#element-where-populated"><code>xsl:where-populated</code></a> instruction encloses a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The result of the instruction is established
                  as follows:</p>
                  <ol class="enumar">
                     <li>
                        <p>The sequence constructor is evaluated in the usual way (taking into account
                        any <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>
                        instructions) to produce a result <var>$R</var>.</p>
                     </li>
                     <li>
                        <p>The result of the instruction is the value of the expression
                           <code>$R[not(deemed-empty(.))]</code> where the function
                           <code>deemed-empty($item as item())</code> returns <code>true</code> if and only if
                           <code>$item</code> is one of the following:</p>
                        <ul>
                           <li>
                              <p>A document or element node that has no children.</p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>If an element has attributes or namespaces, these do not prevent
                                 the element being deemed empty.</p>
                                 <p>If a document or element node has children, the node is not deemed
                                 empty, even if the children are empty. For example, a document node
                                 created using an <a href="#element-variable"><code>xsl:variable</code></a> instruction in the
                                 form
                                    <code>&lt;xsl:variable name="temp"&gt;&lt;a/&gt;&lt;/xsl:variable&gt;</code>
                                 is not deemed empty, even though the contained &lt;a/&gt;
                                 element is empty.</p>
                              </div>
                           </li>
                           <li>
                              <p>A node, other than a document or element node, whose string value is
                              zero-length.</p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>A whitespace-only text node is not deemed empty.</p>
                              </div>
                           </li>
                           <li>
                              <p>An atomic item such that the result of casting the atomic item to a
                              string is zero-length.</p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>
                                 <p>This can happen only when the atomic item is of type
                                    <code>xs:string</code>, <code>xs:anyURI</code>,
                                    <code>xs:untypedAtomic</code>, <code>xs:hexBinary</code>, or
                                    <code>xs:base64Binary</code>.</p>
                              </div>
                           </li>
                           <li>
                              <p>A map whose size (number of key/value
                              pairs) is zero.</p>
                           </li>
                           <li>
                              <p>An array (see <a href="#arrays"><i>22 Arrays</i></a>) where the result 
                              of flattening the array using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function is 
                              either the empty sequence, or a sequence in which every item is deemed empty 
                              (applying these rules recursively).</p>
                           </li>
                        </ul>
                     </li>
                  </ol>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e26932"></a>Example: Generating an HTML list</div>
                     <p>The following example generates an HTML unnumbered list, if and only if the
                     list is non-empty. Note that the presence of the <code>class</code> attribute
                     does not make the list non-empty. The code is written to be streamable.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:where-populated expand-text="yes"&gt;
  &lt;ul class="my-list"&gt;
    &lt;xsl:for-each select="source-item"&gt;
       &lt;li&gt;{.}&lt;/li&gt;
    &lt;/xsl:for-each&gt;
  &lt;/ul&gt;
&lt;/xsl:where-populated&gt;</pre>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="on-empty"></a>8.5.2 <a href="#on-empty" style="text-decoration: none">The <code>xsl:on-empty</code> instruction</a></h4>
                  <p class="element-syntax"><a id="element-on-empty"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:on-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-empty&gt;</code></p>
                  <p>The <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction has the same content model as
                     <a href="#element-sequence"><code>xsl:sequence</code></a>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p>
                  <p>When an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction
                  appears in a sequence constructor, then:</p>
                  <ol class="enumar">
                     <li>
                        <p>It must be the only <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction in the
                        sequence constructor, and</p>
                     </li>
                     <li>
                        <p>It must not be followed in the sequence constructor by any other <a title="instruction" class="termref" href="#dt-instruction">instruction</a>, other than <a href="#element-fallback"><code>xsl:fallback</code></a>, or by a
                        significant text node (that is, a text node that has not been discarded
                        under the provisions of <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>), or by a
                           <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>. It may, however, be followed
                        by non-instructions such as <a href="#element-catch"><code>xsl:catch</code></a> where
                        appropriate.</p>
                     </li>
                  </ol>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-vacuous" title="vacuous"></a>An item is <b>vacuous</b> if
               it is one of the following: a zero-length text node; a document node with no children; an atomic item which, 
               on casting to <code>xs:string</code>, produces a zero-length string; or  an array 
                  which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either the empty sequence 
                  or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.<span class="definition">]</span></p>
                  <p>An <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered only if every 
                  preceding sibling instruction, text node, and literal result element in the same <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
                  returns either the empty sequence, or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.
               </p>
                  <p>If an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction is triggered, then the result 
                  of the containing <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the result of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This means that the (vacuous) results produced by other instructions in the 
                  sequence constructor are discarded. This is relevant mainly when the result of the sequence constructor 
                  is used for something other than constructing a node: for example if it forms the result of a function, 
                  or the value of a variable, and the function or variable specifies a required type.</p>
                     <p>When streaming, it may be necessary to buffer vacuous items in the result sequence until it is 
                     known whether the result will contain items that are non-vacuous. In many common situations, however
                     — in particular, when the sequence constructor is being used to create the content of a node — 
                     vacuous items can be discarded immediately because they do not affect the content of the node being constructed.
                  </p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In nearly all cases, the rules for <a href="#element-on-empty"><code>xsl:on-empty</code></a> are aligned 
                  with the rules for constructing complex content. If the sequence constructor within a literal result element 
                  or an <a href="#element-element"><code>xsl:element</code></a> instruction includes an <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction, 
                  then the content of the element will be the value delivered by the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction 
                  if and only if the content would otherwise be empty.</p>
                     <p>There is one minor exception to this rule: if the sequence constructor delivers multiple zero-length strings, 
                     then in the absence of the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction the new element would contain whitespace, 
                     made up of the separators between these zero-length strings; but <a href="#element-on-empty"><code>xsl:on-empty</code></a> takes no account 
                     of these separators.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Attribute and namespace nodes created by the sequence constructor 
                  are significant; the <a href="#element-on-empty"><code>xsl:on-empty</code></a> instruction will not be triggered if such nodes are present. 
                  If this is not the desired effect, it is possible to partition the sequence constructor to change the scope of 
                  <a href="#element-on-empty"><code>xsl:on-empty</code></a>, for example:</p>
                     <div class="exampleInner">
                        <pre>&lt;ol&gt;
  &lt;xsl:attribute name="class" select="numbered-list"/&gt;
  &lt;xsl:sequence&gt;
    &lt;xsl:value-of select="xyz"/&gt;
    &lt;xsl:on-empty select="'The list is empty'"/&gt;
  &lt;/xsl:sequence&gt;
&lt;/ol&gt;</pre>
                     </div>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Where the sequence constructor is a child of an instruction with
               an <code>[xsl:]use-attribute-sets</code> attribute, any attribute nodes created by expanding the referenced
               attribute set(s) are not part of the result of the sequence constructor and therefore play no role in determining
               whether an <a href="#element-on-empty"><code>xsl:on-empty</code></a> or <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is triggered. 
                  Equally, when the sequence constructor is a child
               of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, attribute nodes generated by expanding the attributes
               of the literal result element are not taken into account.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> is the only instruction in a sequence
                     constructor then it is always evaluated.</p>
                     <p>If <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> appear
                     in the same sequence constructor, then the rules ensure that only one of them
                     will be evaluated.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="on-non-empty"></a>8.5.3 <a href="#on-non-empty" style="text-decoration: none">The <code>xsl:on-non-empty</code> instruction</a></h4>
                  <p class="element-syntax"><a id="element-on-non-empty"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:on-non-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-non-empty&gt;</code></p>
                  <p>The <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction has the same content model as
                     <a href="#element-sequence"><code>xsl:sequence</code></a>, and when it is evaluated, the same rules apply.
                  In particular, the <code>select</code> attribute and the contained sequence
                  constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p>
                  <p>An <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is evaluated only 
                  if there is at least one sibling node in the same <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, 
                  excluding <a href="#element-on-empty"><code>xsl:on-empty</code></a> and <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions, 
                  whose evaluation yields a sequence containing an item that is not <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a>. 
                  If this condition applies, then all <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instructions in the 
                  containing sequence constructor are evaluated, and their results are included in the result 
                  of the containing sequence constructor in their proper positions.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a> instruction is typically used to generate headers or 
                     footers appearing before or after a list of items, where the header or footer is to be 
                     omitted if there are no items in the list.
              </p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Unlike <a href="#element-on-empty"><code>xsl:on-empty</code></a>, the <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>
                     instruction can appear anywhere in a sequence constructor, and can appear more
                     than once.</p>
                  </div>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="variables-and-parameters"></a>9 <a href="#variables-and-parameters" style="text-decoration: none">Variables and Parameters</a></h2>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-variable-binding-element" title="variable-binding element"></a>The two
               elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to
               as <b>variable-binding elements</b>.<span class="definition">]</span></p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-variable" title="variable"></a>The <a href="#element-variable"><code>xsl:variable</code></a> element
               declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local
                  variable</a>.<span class="definition">]</span>
         </p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-parameter" title="parameter"></a>The <a href="#element-param"><code>xsl:param</code></a> element
               declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a
                  <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that
               its value can be set by the caller.<span class="definition">]</span>
         </p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-value" title="value"></a>A variable is a binding between a name and a value.
               The <b>value</b> of a variable is any sequence (of nodes, atomic items,
                  and/or function items), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.<span class="definition">]</span>
         </p>
            <div class="div2">
               
               <h3><a id="variables"></a>9.1 <a href="#variables" style="text-decoration: none">Variables</a></h3>
               <p class="element-syntax"><a id="element-variable"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:variable<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;static? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:variable&gt;</code></p>
               <p>The <a href="#element-variable"><code>xsl:variable</code></a> element has a <span class="verb">required</span>
               <code>name</code> attribute, which specifies the name of the variable. The value of
               the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in
                  <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p>
               <p>The <a href="#element-variable"><code>xsl:variable</code></a> element has an optional <code>as</code> attribute,
               which specifies the <a title="required type" class="termref" href="#dt-required-type">required type</a> of the
               variable. The value of the <code>as</code> attribute is a 
               <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-supplied-value" title="supplied value"></a>The value of the variable is
                  computed using the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the
                     <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in
                     <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. This value is referred to as the
                     <b>supplied value</b> of the variable.<span class="definition">]</span> If the
                  <a href="#element-variable"><code>xsl:variable</code></a> element has a <code>select</code> attribute, then
               the sequence constructor <span class="verb">must</span> be empty.</p>
               <p>If the <code>as</code> attribute is specified, then the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is converted to
               the required type, using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
               <p>
               <a id="err-XTTE0570"><span class="error">[ERR XTTE0570] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a variable cannot be
                     converted to the required type.
            </p>
               <p>If the <code>as</code> attribute is omitted, the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is used directly, and no conversion
               takes place.</p>
               <p>For the effect of the <code>static</code> attribute, see <a href="#static-params"><i>9.6 Static Variables and Parameters</i></a>.</p>
               <p>The <code>visibility</code> attribute <span class="verb">must not</span>
               be specified for a <a title="local variable" class="termref" href="#dt-local-variable">local variable</a>: that is, it is allowed only when the parent
               element is <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, 
               <a href="#element-package"><code>xsl:package</code></a> or
                  <a href="#element-override"><code>xsl:override</code></a>.</p>
               <p>If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then the <code>select</code> attribute
                  <span class="verb">must</span> be absent and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
               <span class="verb">must</span> be empty. In this situation there is no <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>, and therefore the constraint
               that the supplied value is consistent with the required type does not apply.</p>
            </div>
            <div class="div2">
               
               <h3><a id="parameters"></a>9.2 <a href="#parameters" style="text-decoration: none">Parameters</a></h3>
               <p class="element-syntax"><a id="element-param"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;required? = <var>boolean</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;static? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:param&gt;</code></p>
               <p>The <a href="#element-param"><code>xsl:param</code></a> element may be used:</p>
               <ul>
                  <li>
                     <p>As a child of <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                     or <a href="#element-package"><code>xsl:package</code></a>, to
                     define a parameter to the transformation. <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">Stylesheet parameters</a> are set by the
                     calling application: see <a href="#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>. </p>
                  </li>
                  <li>
                     <p>As a child of <a href="#element-template"><code>xsl:template</code></a> to define a parameter to a
                     template, which may be supplied when the template is invoked using
                        <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                        <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>.
                        <a title="template parameter" class="termref" href="#dt-template-parameter">Template parameters</a> are set
                     by means of an <a href="#element-with-param"><code>xsl:with-param</code></a> child element of the invoking
                     instruction, as described in <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>.</p>
                  </li>
                  <li>
                     <p>As a child of <a href="#element-function"><code>xsl:function</code></a> to define a parameter to a
                     stylesheet function, which may be supplied when the function is called from an
                     XPath <a title="expression" class="termref" href="#dt-expression">expression</a>. 
                     <a title="function parameter" class="termref" href="#dt-function-parameter">Function parameters</a> are set
                     <span>either positionally or by keyword</span>
                     by means of the argument list in an XPath function call. </p>
                  </li>
                  <li>
                     <p>As a child of <a href="#element-iterate"><code>xsl:iterate</code></a> to define a parameter that can vary
                     from one iteration to the next. Iteration parameters always take their default
                     values for the first iteration, and in subsequent iterations are set using an
                        <a href="#element-with-param"><code>xsl:with-param</code></a> child of the
                        <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction.</p>
                  </li>
               </ul>
               <p>The attributes applicable to <a href="#element-param"><code>xsl:param</code></a>
               depend on its parent element in the stylesheet, as defined by the following
               table:</p>
               <table class="data">
                  <caption>Attributes of the <code>xsl:param</code> Element</caption>
                  <thead>
                     <tr>
                        <th style="text-align:left; vertical-align:top">Parent Element</th>
                        <th style="text-align:left; vertical-align:top">name</th>
                        <th style="text-align:left; vertical-align:top">select</th>
                        <th style="text-align:left; vertical-align:top">as</th>
                        <th style="text-align:left; vertical-align:top">required</th>
                        <th style="text-align:left; vertical-align:top">tunnel</th>
                        <th style="text-align:left; vertical-align:top">static</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <th style="text-align:left; vertical-align:top"><a href="#element-package"><code>xsl:package</code></a></th>
                        <td style="text-align:left; vertical-align:top">mandatory</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top">yes|<b>no</b></td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                        <td style="text-align:left; vertical-align:top">yes|<b>no</b></td>
                     </tr>
                     <tr>
                        <th style="text-align:left; vertical-align:top"><a href="#element-stylesheet"><code>xsl:stylesheet</code></a></th>
                        <td style="text-align:left; vertical-align:top">mandatory</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top">yes|<b>no</b></td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                        <td style="text-align:left; vertical-align:top">yes|<b>no</b></td>
                     </tr>
                     <tr>
                        <th style="text-align:left; vertical-align:top"><a href="#element-template"><code>xsl:template</code></a></th>
                        <td style="text-align:left; vertical-align:top">mandatory</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top">yes|<b>no</b></td>
                        <td style="text-align:left; vertical-align:top">yes|<b>no</b></td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                     </tr>
                     <tr>
                        <th style="text-align:left; vertical-align:top"><a href="#element-function"><code>xsl:function</code></a></th>
                        <td style="text-align:left; vertical-align:top">mandatory</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top"><b>yes</b>|no</td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                     </tr>
                     <tr>
                        <th style="text-align:left; vertical-align:top"><a href="#element-iterate"><code>xsl:iterate</code></a></th>
                        <td style="text-align:left; vertical-align:top">mandatory</td>
                        <td style="text-align:left; vertical-align:top">mandatory</td>
                        <td style="text-align:left; vertical-align:top">optional</td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                        <td style="text-align:left; vertical-align:top"><b>no</b></td>
                     </tr>
                  </tbody>
               </table>
               <p>In the table, the entries for the <code>name</code>,
                  <code>select</code>, and <code>as</code> attributes indicate whether the attribute
               must appear, is optional, or must be absent; the entries for the
                  <code>required</code>, <code>tunnel</code>, and <code>static</code> attributes
               indicate the values that are permitted if the attribute is present, with the default
               value shown in bold. (The value <code>yes</code> can also be written
                  <code>true</code> or <code>1</code>, while <code>no</code> can also be written
                  <code>false</code> or <code>0</code>.)</p>
               <p>The <code>name</code> attribute is mandatory: it specifies the name of the parameter.
               The value of the <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in
                  <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p>
               <p>
               <a id="err-XTSE0580"><span class="error">[ERR XTSE0580] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the values of
                     the <code>name</code> attribute of two sibling
                           <a href="#element-param"><code>xsl:param</code></a> elements represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.
            </p>
               <p>If the <a href="#element-param"><code>xsl:param</code></a> element has a <code>select</code> attribute, then
               the sequence constructor <span class="verb">must</span> be empty.</p>
               <p>The <code>static</code> attribute can take the value <code>yes</code> only on <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and is explained in
                  <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Local variables may <a title="shadows" class="termref" href="#dt-shadows">shadow</a> template parameters
                  and function parameters: see <a href="#scope-of-variables"><i>9.9 Scope of Variables</i></a>.</p>
               </div>
               <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The default is
                  <code>no</code>; the value <code>yes</code> may be specified only for <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>. Tunnel parameters are
               described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>
            </p>
               <div class="div3">
                  
                  <h4><a id="parameter-type"></a>9.2.1 <a href="#parameter-type" style="text-decoration: none">The Required Type of a Parameter</a></h4>
                  <p>The <a href="#element-param"><code>xsl:param</code></a> element has an optional <code>as</code> attribute,
                  which specifies the <a title="required type" class="termref" href="#dt-required-type">required type</a> of the parameter. The value
                  of the <code>as</code> attribute is a 
                  <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>. 
                  If the <code>as</code> attribute is omitted, then the
                  required type is <code>item()*</code>.</p>
                  <p>The <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the parameter is
                  the value supplied by the caller. If no value was supplied by the caller, and if
                  the parameter is not mandatory, then the default value is used as the supplied
                  value as described in <a href="#default-values-of-parameters"><i>9.2.2 Default Values of Parameters</i></a>.</p>
                  <p>The <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the parameter is
                  converted to the <a title="required type" class="termref" href="#dt-required-type">required type</a> using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                  <p>
                  <a id="err-XTTE0590"><span class="error">[ERR XTTE0590] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the conversion
                        of the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a
                        parameter, or of the context item, does not match the <a title="required type" class="termref" href="#dt-required-type">required type</a>,
                        after applying any permitted conversions.
               </p>
                  <p>For example, the following declares a parameter that requires the supplied
               value (after atomization) to be either a QName, or the string <code>"*"</code>, 
                  or the empty sequence:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:param name="n" as="(xs:QName | enum('*'))?"/&gt;</pre>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="default-values-of-parameters"></a>9.2.2 <a href="#default-values-of-parameters" style="text-decoration: none">Default Values of Parameters</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#variable-values">next</a> | <a href="#try-catch">previous</a>)</p>
                     <ol>
                        <li>
                           <p>Parameters on functions
                     declared using <a href="#element-function"><code>xsl:function</code></a> can now be defined as optional,
                     with a default value supplied.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/155">155</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159</a>&nbsp;30 September 2022]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>The optional <code>required</code> attribute of
                     <a href="#element-param"><code>xsl:param</code></a> may be used to indicate whether a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, 
                  <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a><span>, or <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a></span> is
                  mandatory or optional. The only value  permitted for
                  a parameter to <a href="#element-iterate"><code>xsl:iterate</code></a> is <code>no</code> (these are always
                  initialized to a default value).</p>
                  <p>The default value for a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a> is <code>required="yes"</code>; in all
               other cases it is <code>required="no"</code>.</p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-explicitly-mandatory" title="explicitly mandatory"></a>A parameter is
                        <b>explicitly mandatory</b> if it is a 
                  <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a> 
                  <span>with no <code>required</code> attribute</span>, or if the
                        <code>required</code> attribute is present and has the value
                        <code>yes</code>.<span class="definition">]</span> If a parameter is explicitly mandatory, then the
                     <a href="#element-param"><code>xsl:param</code></a> element <span class="verb">must</span> be empty and
                     <span class="verb">must not</span> have a <code>select</code> attribute.</p>
                  <p>The static context for evaluating the default value depends on where the
               relevant expression appears in the stylesheet, in the usual way. Note however that
               for <a href="#element-param"><code>xsl:param</code></a> elements defining <a title="function parameter" class="termref" href="#dt-function-parameter">function parameters</a>,
                  the static context does not include variables bound in preceding-sibling <a href="#element-param"><code>xsl:param</code></a> elements.</p>
                  <p>The dynamic context is different for different kinds of parameter:</p>
                  <ul>
                     <li>
                        <p>For <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, the 
                  context is the same as the context for evaluating global variables.</p>
                     </li>
                     <li>
                        <p>For <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>, the 
                     context is that of the called template. This means that the evaluation of the
                  default has access to the other parameters supplied in the call, provided they are declared
                  earlier. It also means, for example, that if the evaluation of the default value invokes
                  <a href="#element-next-match"><code>xsl:next-match</code></a>, the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template rule</a> is the called
                  template rather than the calling template.</p>
                     </li>
                     <li>
                        <p>For <a title="function parameter" class="termref" href="#dt-function-parameter">function parameters</a>, the dynamic
                     context for evaluating defaults is the dynamic context of the caller, except that no
                     local variables are in scope. This means that it is possible to declare a parameter
                     with <code>&lt;xsl:param name="dot" required="no" select="."/&gt;</code> to take its
                     default value from the context item of the caller.
                     
              </p>
                     </li>
                  </ul>
                  <p>If a parameter is not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a>, then it may have a
                  default value. The default value is obtained by evaluating the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the <code>select</code>
                  attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a>, as described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This specification does not dictate whether and when the default value of a
                     parameter is evaluated. For example, if the default is specified as
                        <code>&lt;xsl:param name="p"&gt;&lt;foo/&gt;&lt;/xsl:param&gt;</code>, then
                     it is not specified whether a distinct <code>foo</code> element node will be
                     created on each invocation of the template, or whether the same
                        <code>foo</code> element node will be used for each invocation. However, it
                     is permissible for the default value to depend on the values of other
                     parameters, or on the evaluation context, in which case the default must
                     effectively be evaluated on each invocation.</p>
                  </div>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-explicit-default" title="explicit default"></a>An <b>explicit
                        default</b> for a parameter is indicated by the presence of either a
                        <code>select</code> attribute or a non-empty sequence
                  constructor.<span class="definition">]</span></p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-implicit-default" title="implicit default"></a>If a parameter that is
                     not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> has no <a title="explicit default" class="termref" href="#dt-explicit-default">explicit default</a> value, then it has an <b>implicit
                        default</b> value, which is the empty sequence if there is an
                        <code>as</code> attribute, or a zero-length string if not.<span class="definition">]</span></p>
                  <p><span class="definition">[Definition:&nbsp;</span><a id="dt-implicitly-mandatory" title="implicitly mandatory"></a>If a parameter
                     has an <a title="implicit default" class="termref" href="#dt-implicit-default">implicit default</a> value which cannot be converted to
                     the <a title="required type" class="termref" href="#dt-required-type">required type</a> (that is, if it has an <code>as</code>
                     attribute which does not permit the empty sequence), then the parameter is
                        <b>implicitly mandatory</b>.<span class="definition">]</span></p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The effect of these rules is that specifying <code>&lt;xsl:param name="p"
                        as="xs:date" select="2"/&gt;</code> is an error, but if the default value of
                     the parameter is never used, then the processor has discretion whether or not
                     to raise the error. By contrast, <code>&lt;xsl:param name="p"
                        as="xs:date"/&gt;</code> is treated as if <code>required="yes"</code> had
                     been specified: the empty sequence is not a valid instance of
                        <code>xs:date</code>, so in effect there is no default value and the
                     parameter is therefore treated as being mandatory.</p>
                  </div>
                  <p>Various errors can arise with regard to mandatory parameters when no value is
                  supplied. In the rules below, <b>non-tunnel</b> means: not having a
                     <code>tunnel</code> attribute with the value <code>yes</code>.</p>
                  <ul>
                     <li>
                        <p>
                        <a id="err-XTSE3520"><span class="error">[ERR XTSE3520] </span></a>It is a static error if a parameter to <a href="#element-iterate"><code>xsl:iterate</code></a> is
                                 <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a>.
                     </p>
                     </li>
                     <li>
                        <p>
                        <a id="err-XTSE0690"><span class="error">[ERR XTSE0690] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                                 <a title="package" class="termref" href="#dt-package">package</a> contains both (a) a
                              named template named <var>T</var> that is not overridden by another
                              named template of higher import precedence and that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> non-tunnel parameter named
                                 <var>P</var>, and (b) an <a href="#element-call-template"><code>xsl:call-template</code></a>
                              instruction whose <code>name</code> attribute equals <var>T</var> and
                              that has no non-tunnel <a href="#element-with-param"><code>xsl:with-param</code></a> child element
                              whose <code>name</code> attribute equals <var>P</var>. (All names are
                              compared as QNames.)
                     </p>
                     </li>
                     <li>
                        <p>
                        <a id="err-XTDE0700"><span class="error">[ERR XTDE0700] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a template
                              that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a> parameter is invoked without
                              supplying a value for that parameter.
                     </p>
                        <p>This includes the following cases:</p>
                        <ul>
                           <li>
                              <p>The template is invoked using <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                                 <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or
                                 <a href="#element-next-match"><code>xsl:next-match</code></a> and there is no
                                 <a href="#element-with-param"><code>xsl:with-param</code></a> child whose <code>name</code> and
                                 <code>tunnel</code> attributes match the corresponding attributes
                              of the mandatory parameter.</p>
                           </li>
                           <li>
                              <p>The mandatory parameter is a tunnel parameter, and the template is
                              invoked using <a href="#element-call-template"><code>xsl:call-template</code></a>, and there is no
                                 <a href="#element-with-param"><code>xsl:with-param</code></a> child whose <code>name</code> and
                                 <code>tunnel</code> attributes match the corresponding attributes
                              of the mandatory parameter.</p>
                           </li>
                           <li>
                              <p>The template is invoked as the entry point to the transformation,
                              either by invoking an initial mode (<a href="#invoking-initial-mode"><i>2.3.3 Apply-Templates Invocation</i></a>) or by invoking an initial template
                                 (<a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a>) and no value is
                              supplied for the mandatory parameter by the calling application.</p>
                           </li>
                        </ul>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="variable-values"></a>9.3 <a href="#variable-values" style="text-decoration: none">Values of Variables and Parameters</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#global-variables">next</a> | <a href="#default-values-of-parameters">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  A variable-binding with no <code>as</code> or <code>select</code> attribute no longer
                  attempts to create an implicit document node if the sequence constructor contains
                  certain instructions (such as <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-array"><code>xsl:array</code></a>, 
                  <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>).
               <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/2009">2009</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2288">2288</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/2015">2015</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/2296">2296</a>&nbsp;20 May 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>A <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> may
               specify the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a <a title="variable" class="termref" href="#dt-variable">variable</a>
               or the default value of a
               <a title="parameter" class="termref" href="#dt-parameter">parameter</a> in four different ways.</p>
               <ul>
                  <li>
                     <p>If the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding
                        element</a> has a <code>select</code> attribute, then the value of the
                     attribute <span class="verb">must</span> be an <a title="expression" class="termref" href="#dt-expression">expression</a> and the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied
                        value</a> of the variable is the value that results from evaluating
                     the expression. In this case, the content of the variable-binding element
                        <span class="verb">must</span> be empty.</p>
                  </li>
                  <li>
                     <p>If the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding
                        element</a> has empty content and has neither a <code>select</code>
                     attribute nor an <code>as</code> attribute, then the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of the variable is a
                     zero-length string. Thus</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="x"/&gt;</pre>
                     </div>
                     <p>is equivalent to</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="x" select="''"/&gt;</pre>
                     </div>
                  </li>
                  <li>
                     <p>If a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding
                        element</a> satisfies all the following conditions:</p>
                     <ul>
                        <li>
                           <p>The element has no <code>select</code> attribute</p>
                        </li>
                        <li>
                           <p>The element has no <code>as</code> attribute</p>
                        </li>
                        <li>
                           <p>The element has non-empty content (that is, the variable-binding element 
                           has one or more child nodes)</p>
                        </li>
                        <li>
                           <p>There is no <a title="disqualifying element" class="termref" href="#dt-disqualifying-element">disqualifying element</a> among the element's 
                           children.</p>
                        </li>
                     </ul>
                     <p>then the content of the variable-binding
                     element specifies the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied
                     value</a>. The content of the variable-binding element is a 
                     <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>; a new document
                     is constructed with a document node having as its children the sequence of
                     nodes that results from evaluating the sequence constructor and then applying
                     the rules given in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. The value of
                     the variable is then a singleton sequence containing this document node. For
                     further details, see <a href="#temporary-trees"><i>9.4 Creating Implicit Document Nodes</i></a>. </p>
                  </li>
                  <li>
                     <p>Otherwise, the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> 
                     is the sequence that results from evaluating the
                     (possibly empty) <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a> contained within the variable-binding element (see
                        <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>). </p>
                  </li>
               </ul>
               <p>These combinations are summarized in the table below.</p>
               <table class="data">
                  <caption>Effect of Different Attribute Combinations on <code>xsl:variable</code></caption>
                  <col style="width:12%" span="1">
                  <col style="width:12%" span="1">
                  <col style="width:12%" span="1">
                  <col span="1">
                  <thead>
                     <tr>
                        <th style="text-align:left; vertical-align:top">select attribute</th>
                        <th style="text-align:left; vertical-align:top">as attribute</th>
                        <th style="text-align:left; vertical-align:top">content</th>
                        <th style="text-align:left; vertical-align:top">Effect</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">empty</td>
                        <td style="text-align:left; vertical-align:top">Value is obtained by evaluating the <code>select</code>
                           attribute</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">empty</td>
                        <td style="text-align:left; vertical-align:top">Value is obtained by evaluating the <code>select</code>
                           attribute, coerced to the type required by the <code>as</code>
                           attribute</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">Static error</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">Static error</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">empty</td>
                        <td style="text-align:left; vertical-align:top">Value is a zero-length string</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">empty</td>
                        <td style="text-align:left; vertical-align:top">Value is the empty sequence, provided the <code>as</code>
                           attribute permits the empty sequence</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">includes a <a title="disqualifying element" class="termref" href="#dt-disqualifying-element">disqualifying element</a></td>
                        <td style="text-align:left; vertical-align:top">Value is obtained by evaluating the sequence constructor</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">present and does not include a <a title="disqualifying element" class="termref" href="#dt-disqualifying-element">disqualifying element</a></td>
                        <td style="text-align:left; vertical-align:top">Value is a document node whose content is obtained by
                           evaluating the sequence constructor</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">absent</td>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">present</td>
                        <td style="text-align:left; vertical-align:top">Value is obtained by evaluating the sequence constructor,
                           coerced to the type required by the <code>as</code> attribute</td>
                     </tr>
                  </tbody>
               </table>
               <p>
               <a id="err-XTSE0620"><span class="error">[ERR XTSE0620] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a
                        <code>select</code> attribute and has non-empty content.
            </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e28274"></a>Example: Values of Variables</div>
                  <p>The value of the following variable is the sequence of integers (1, 2, 3):</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="i" as="xs:integer*" select="1 to 3"/&gt;</pre>
                  </div>
                  <p>The value of the following variable is an integer, assuming that the attribute
                     <code>@size</code> exists, and is annotated either as an integer, or as
                     <code>xs:untypedAtomic</code>:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="i" as="xs:integer" select="@size"/&gt;</pre>
                  </div>
                  <p>The value of the following variable is a zero-length string:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="z"/&gt;</pre>
                  </div>
                  <p>The value of the following variable is a document node containing an empty element
                  as a child:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="doc"&gt;&lt;c/&gt;&lt;/xsl:variable&gt;</pre>
                  </div>
                  <p>The value of the following variable is a sequence of integers (2, 4, 6):</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="seq" as="xs:integer*"&gt;
  &lt;xsl:for-each select="1 to 3"&gt;
    &lt;xsl:sequence select=".*2"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
                  <p>The value of the following variable is a sequence of parentless attribute
                  nodes:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="attset" as="attribute()+"&gt;
  &lt;xsl:attribute name="x"&gt;2&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="y"&gt;3&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="z"&gt;4&lt;/xsl:attribute&gt;    
&lt;/xsl:variable&gt;</pre>
                  </div>
                  <p>The value of the following variable is the empty sequence:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="empty" as="empty-sequence()"/&gt;</pre>
                  </div>
               </div>
               <p>The actual value of the variable depends on the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>, as described above, and the required type, which is
               determined by the value of the <code>as</code> attribute.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e28313"></a>Example: Pitfalls with Numeric Predicates</div>
                  <p>When a variable is used to select nodes by position, be careful not to do:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre>
                  </div>
                  <p>This will output the values of all the <code>td</code> elements, space-separated
                  (or with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0
                        behavior</a>, the value of the first <code>td</code>
                  element), because the variable <code>n</code> will be bound to a node, not a
                  number. Instead, do one of the following:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="n" select="2"/&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre>
                  </div>
                  <p>or</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="n"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[position()=$n]"/&gt;</pre>
                  </div>
                  <p>or</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="n" as="xs:integer"&gt;2&lt;/xsl:variable&gt;
...
&lt;xsl:value-of select="td[$n]"/&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="temporary-trees"></a>9.4 <a href="#temporary-trees" style="text-decoration: none">Creating Implicit Document Nodes</a></h3>
               <p>A document node is created implicitly when evaluating an
                  <a href="#element-variable"><code>xsl:variable</code></a>, <a href="#element-param"><code>xsl:param</code></a>, or
                  <a href="#element-with-param"><code>xsl:with-param</code></a> element that has non-empty content and that has no
                  <code>as</code> attribute, unless the children of this element include
               a <a title="disqualifying element" class="termref" href="#dt-disqualifying-element">disqualifying element</a>. 
               The value of the <a title="variable" class="termref" href="#dt-variable">variable</a> is this newly constructed
                  document node.
                The content of the
               document node is formed from the result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained within the
               variable-binding element, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. </p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-disqualifying-element" title="disqualifying element"></a>The <b>disqualifying elements</b>
            are <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, 
            <a href="#element-array-member"><code>xsl:array-member</code></a>, <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>. If a sequence
            constructor includes one of these elements, then construction of the implicit document node does
            not take place.<span class="definition">]</span></p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Most of the disqualifying elements return maps or arrays, and wrapping a map or array
            in a document node makes no sense. For <a href="#element-select"><code>xsl:select</code></a>, the justification is that
            this instruction should be as closely as possible an equivalent to the <code>select</code>
            attribute on the containing <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The construct:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="tree"&gt;
  &lt;a/&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
                  <p>can be regarded as a shorthand for:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="preserve"&gt;
    &lt;a/&gt;
  &lt;/xsl:document&gt;  
&lt;/xsl:variable&gt;</pre>
                  </div>
               </div>
               <p>The base URI of the document node is taken from the base URI of the variable binding
               element in the stylesheet. (See <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-base-uri">7.6.2 base-uri Accessor</a>)</p>
               <p>No document-level validation takes place (which means, for example, that there is no
               checking that ID values are unique). However, <a title="type annotation" class="termref" href="#dt-type-annotation">type
                  annotations</a> on nodes within the new tree are copied unchanged.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The base URI of other nodes in the tree is determined by the rules for
                  constructing complex content (see <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>).
                  The effect of these rules is that the base URI of a node in the temporary tree is
                  determined as if all the nodes in the temporary tree came from a single entity
                  whose URI was the base URI of the <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a>. Thus, the base URI of the document node
                  will be equal to the base URI of the variable-binding element, while an
                     <code>xml:base</code> attribute within the temporary tree will change the base
                  URI for its parent element and that element’s descendants, just as it would
                  within a document constructed by parsing.</p>
               </div>
               <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
               <p>A <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> is available for
               processing in exactly the same way as any source document. For example, its nodes are
               accessible using path expressions, and they can be processed using instructions such
               as <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-for-each"><code>xsl:for-each</code></a>. Also, the
                  <a href="#func-key"><code>key</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>id</code></a> functions can be used to
               find nodes within a temporary tree,  by supplying the
                  document node at the root of the tree as an argument to the function or by making
                  it the context node.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e28442"></a>Example: Two-Phase Transformation</div>
                  <p>The following stylesheet uses a temporary tree as the intermediate
                  result of a two-phase transformation, using different <a title="mode" class="termref" href="#dt-mode">modes</a> for the two phases (see <a href="#modes"><i>6.7 Modes</i></a>). Typically,
                  the template rules in module <code>phase1.xsl</code> will be declared with
                     <code>mode="phase1"</code>, while those in module <code>phase2.xsl</code> will
                  be declared with <code>mode="phase2"</code>: </p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;

&lt;xsl:import href="phase1.xsl"/&gt;
&lt;xsl:import href="phase2.xsl"/&gt;

&lt;xsl:variable name="intermediate"&gt;
  &lt;xsl:apply-templates select="/" mode="phase1"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:apply-templates select="$intermediate" mode="phase2"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                  </div>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The algorithm for matching nodes against template rules is exactly the same
                  regardless which tree the nodes come from. If different template rules are to be
                  used when processing different trees, then unless nodes from different trees can
                  be distinguished by means of <a title="pattern" class="termref" href="#dt-pattern">patterns</a>, it is a
                  good idea to use <a title="mode" class="termref" href="#dt-mode">modes</a> to ensure that each tree
                  is processed using the appropriate set of template rules.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="global-variables"></a>9.5 <a href="#global-variables" style="text-decoration: none">Global Variables and Parameters</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#invoking-templates-with-extension-instructions">next</a> | <a href="#variable-values">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  It is no longer an intrinsic error for a global variable to refer to itself; this
                  is now permitted, for example in cases where the value of the global variable is
                  a recursive inline function. Cases where self-reference would not make sense are
                  covered by the existing rules on circularities: see <a href="#circularity"><i>9.11 Circular Definitions</i></a>.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1540">1540</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1544">1544</a>&nbsp;12 November 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p>Both <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are allowed as
                  <a title="declaration" class="termref" href="#dt-declaration">declaration</a> elements: that is, they may
               appear as children of the <a href="#element-package"><code>xsl:package</code></a> or
               <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-global-variable" title="global variable"></a>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a> <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> declares a
                     <b>global variable</b> that is visible everywhere 
                  except within any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> 
                     by another variable binding.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-parameter" title="stylesheet parameter"></a>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a>
                     <a href="#element-param"><code>xsl:param</code></a> element declares a <b>stylesheet
                  parameter</b>. A stylesheet parameter is a global variable with the additional
                  property that its value can be supplied by the caller when a transformation is
                  initiated.<span class="definition">]</span> As described in <a href="#parameters"><i>9.2 Parameters</i></a>, a stylesheet
               parameter may be declared as being mandatory, or may have a default value specified
               for use when no value is supplied by the caller. The mechanism by which the caller
               supplies a value for a stylesheet parameter is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. An XSLT <a title="processor" class="termref" href="#dt-processor">processor</a>
               <span class="verb">must</span> provide such a mechanism.</p>
               <p>It is an error if no value is supplied for a mandatory stylesheet parameter <span class="error">[see <a href="#err-XTDE0050">ERR XTDE0050</a>]</span>.</p>
               <p>If a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> contains more than one binding
               for a global variable of a particular name, then the binding with the highest
                  <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p>
               <p>
               <a id="err-XTSE0630"><span class="error">[ERR XTSE0630] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more
                     than one non-hidden binding of a global
                     variable with the same name and same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                        precedence</a>, unless it also contains another binding with the same
                     name and higher import precedence.
            </p>
               <p>For a global variable or the default value of a stylesheet parameter, the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the variable value is evaluated with a
                  <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> as follows:</p>
               <ul>
                  <li>
                     <p>If the declaration appears within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>
                     (including within an <a href="#element-override"><code>xsl:override</code></a> element in the top-level
                     package), then the focus is based on the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if supplied, or <a title="absent" class="termref" href="#dt-absent">absent</a> otherwise.</p>
                  </li>
                  <li>
                     <p>If the declaration appears within a <a title="library package" class="termref" href="#dt-library-package">library package</a>, then the focus is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
                  </li>
               </ul>
               <p>An XPath error will be raised if the evaluation of a global variable or parameter
               references the context item, context position, or context size when the <a title="focus" class="termref" href="#dt-focus">focus</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>. The values of other components of
               the dynamic context are the initial values as defined in <a href="#xpath-dynamic-context"><i>5.3.3 Initializing the Dynamic Context</i></a> and <a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a>.</p>
               <p>The <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> is always (implicitly) <code>private</code> if the
               parameter is <code>static</code>, or <code>public</code> if the parameter is
               non-static.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This rule has the effect that after combining all the packages making up a
                  stylesheet, the non-static stylesheet parameters whose values are required
                  necessarily have distinct names, which simplifies the design of APIs.</p>
               </div>
               <p>For the effect of the <code>static</code> attribute, see <a href="#static-params"><i>9.6 Static Variables and Parameters</i></a>.</p>
               <p>The <code>visibility</code> attribute <span class="verb">must
                  not</span> be specified for a local variable: that is, it is allowed only when
               the parent element is <a href="#element-package"><code>xsl:package</code></a>, <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>,
                  <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a>.</p>
               <p>If the <code>visibility</code> attribute is present with the value
                  <code>abstract</code> then the <code>select</code> attribute
                  <span class="verb">must</span> be absent and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
               <span class="verb">must</span> be empty. In this situation there is no <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a>, and therefore the constraint
               that the supplied value is consistent with the required type does not apply.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e28668"></a>Example: A Stylesheet Parameter</div>
                  <p>The following example declares a global parameter <code>para-font-size</code>,
                  which is referenced in an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute
                     value template</a>.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:param name="para-font-size" as="xs:string"&gt;12pt&lt;/xsl:param&gt;

&lt;xsl:template match="para"&gt;
 &lt;fo:block font-size="{ $para-font-size }"&gt;
   &lt;xsl:apply-templates/&gt;
 &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The implementation must provide a mechanism allowing the user to supply a value
                  for the parameter <code>para-font-size</code> when invoking the stylesheet; the
                  value <code>12pt</code> acts as a default.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In XSLT 4.0, a global variable is in scope within its own definition. Trivial
               self-references such as <code>&lt;xsl:variable name="x" select="$x+1"/&gt;</code> are
               prevented by the general rules on circularities: see <a href="#circularity"><i>9.11 Circular Definitions</i></a>.
               However, there are other cases where self-reference makes perfect sense. The obvious
               example is where the value of the variable is a recursive inline function, such as:</p>
                  <div class="exampleInner">
                     <pre>
 &lt;xsl:variable name="max-depth" 
    select="fn($node as node()) {
              if (has-children($node)) 
              then 1 + max($node/* ! $max-depth(.))
              else 0}"/&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="static-params"></a>9.6 <a href="#static-params" style="text-decoration: none">Static Variables and Parameters</a></h3>
               <p>Static variables and parameters are global variables and can be used in the same way
               as other global variables. In addition, they can be used in
                  <code>[xsl:]use-when</code> expressions and in shadow attributes.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-static-variable" title="static variable"></a>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a>
                  <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a>
                  having the attribute <code>static="yes"</code> declares a <b>static
                     variable</b>: that is, a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> whose value is
                  known during static analysis of the stylesheet.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-static-parameter" title="static parameter"></a>A <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declared using an <a href="#element-param"><code>xsl:param</code></a> element
                  is referred to as a <b>static parameter</b>.<span class="definition">]</span>
            </p>
               <p>The <code>static</code> attribute <span class="verb">must not</span>
               take the value <code>yes</code> on an
                  <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element unless it is a
                  <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p>
               <p>When the <code>static</code> attribute is present with the value
                  <code>yes</code>, the <code>visibility</code> attribute <span class="verb">must
                  not</span> have a value other than <code>private</code>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This rule prevents static variables being overridden in another package. Since the
                  values of such variables may be used at compile time (for example, during
                  processing of <code>[xsl:]use-when</code> expressions), the rule is necessary to
                  ensure that packages can be independently compiled.</p>
                  <p>It is possible to make the value of a static variable
                  or parameter available in a using package by binding a non-static public variable
                  to its value, for example:</p>
                  <div class="exampleInner">
                     <pre>
     &lt;xsl:param name="DEBUG" static="yes" select="true()"/&gt;
     &lt;xsl:variable name="tracing" static="no" visibility="public" select="$DEBUG"/&gt;</pre>
                  </div>
               </div>
               <p>When the attribute <code>static="yes"</code> is specified, the
                  <a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> element
                  <span class="verb">must</span> have empty content. In the case of
                  <a href="#element-variable"><code>xsl:variable</code></a> the <code>select</code> attribute must be present to
               define the value of the variable <span class="error">[see <a href="#err-XTSE0010">ERR XTSE0010</a>]</span>.</p>
               <p>If the <code>select</code> attribute is present, then it is evaluated using the rules
               for <a title="static expression" class="termref" href="#dt-static-expression">static expressions</a>.</p>
               <p>The rules for the scope of static variables, and the
               handling of duplicate declarations, are similar to the rules for non-static
               variables, but with additional constraints designed to disallow forwards references.
               The reason for disallowing forwards references is to ensure that
                  <code>use-when</code> attributes can always be evaluated as early as possible, and
               in particular to ensure that the value of a <code>use-when</code> attribute never has
               circular dependencies. The additional constraints are as follows:</p>
               <ol class="enumar">
                  <li>
                     <p>The static context for evaluation of a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>
                     only contains those <a title="static variable" class="termref" href="#dt-static-variable">static
                        variables</a> visible within the containing package whose declarations
                     occur prior to the element containing the static expression in stylesheet tree
                     order. Stylesheet tree order is the order that results when all
                        <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a> declarations
                     are replaced by the declarations in the imported or included stylesheet module.
                     A static variable is not in scope within its own declaration.</p>
                  </li>
                  <li>
                     <p>If two static variables declared within the same package have the same name,
                     the one that has higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used (it is a
                     consequence of rules defined elsewhere that there cannot be more than one
                     declaration with highest import precedence). However, if the declaration with
                     higher import precedence occurs after the one with lower import precedence in
                     stylesheet tree order, then the two declarations must be consistent. For this
                     purpose two declarations are consistent if (a) they are either both
                        <a href="#element-variable"><code>xsl:variable</code></a> elements, or both <a href="#element-param"><code>xsl:param</code></a>
                     elements, and (b) if the variables are initialized (that is, if the elements
                     are <a href="#element-variable"><code>xsl:variable</code></a> elements, or if they are
                        <a href="#element-param"><code>xsl:param</code></a> elements and no value for the parameter is
                     externally supplied) then the values of both variables must be <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-identical">identical</a><sup><small>FO</small></sup>, and must not contain
                     function items.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This rule ensures that when a static variable reference is encountered, the
                        value of the most recently declared static variable with that name can be
                        used, knowing that this value cannot be overridden by a subsequent
                        declaration having higher import precedence.</p>
                     </div>
                     <p><a id="err-XTSE3450"><span class="error">[ERR XTSE3450] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                           variable declared with <code>static="yes"</code> is inconsistent with
                           another static variable of the same name that is declared earlier in
                           stylesheet tree order and that has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
                  </li>
               </ol>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>It is not an error to have two global variables or parameters with the same name, 
                  one static and one non-static, provided that they have different import precedence. 
                  If the static variable has higher precedence, then it will be used as the selected 
                  binding for all global variable references with this name, whether or not they appear 
                  in static expressions. If the non-static variable has higher precedence, then the 
                  static variable will be used as the selected binding for variable references appearing 
                  in static expressions, while the non-static variable will be used for variable 
                  references in non-static expressions. The two variables may have different values. 
                  In the case of global parameters, however, a transformation API may restrict 
                  them to have the same value.</p>
                  <p>If the two variable declarations have the same import precedence, and there is 
                     no declaration with higher import precedence, then error condition 
                     <span class="error">[see <a href="#err-XTSE0630">ERR XTSE0630</a>]</span> applies.
                  </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="static-expression"></a>9.7 <a href="#static-expression" style="text-decoration: none">Static Expressions</a></h3>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-static-expression" title="static expression"></a>A <b>static
                     expression</b> is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> whose value must
                  be computed during static analysis of the stylesheet.<span class="definition">]</span></p>
               <p>Static expressions appear in a number of contexts, in particular:</p>
               <ul>
                  <li>
                     <p>In <code>[xsl:]use-when</code> attributes (see <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>);</p>
                  </li>
                  <li>
                     <p>In the <code>select</code> attribute of <a title="static variable" class="termref" href="#dt-static-variable">static variable</a>
                     declarations (<a href="#element-variable"><code>xsl:variable</code></a> or <a href="#element-param"><code>xsl:param</code></a> with
                        <code>static="yes"</code>);</p>
                  </li>
                  <li>
                     <p>In shadow attributes (see <a href="#shadow-attributes"><i>3.11.4 Shadow Attributes</i></a>).</p>
                  </li>
               </ul>
               <p>There are no syntactic constraints on the XPath expression that can be used as a
                  <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>. However, there are severe constraints on
               the information provided in its evaluation context. These constraints are designed to
               ensure that the expression can be evaluated at the earliest possible stage of
               stylesheet processing, without any dependency on information contained in the
               stylesheet itself or in any source document.</p>
               <p>Specifically, the components of the static and dynamic context are defined by the
               following two tables:</p>
               <table class="def">
                  <caption>Static Context Components for Static Expressions</caption>
                  <col style="text-align:left; width:30%" span="1">
                  <col style="text-align:left" span="1">
                  <thead>
                     <tr>
                        <th style="text-align:left; vertical-align:top">Component</th>
                        <th style="text-align:left; vertical-align:top">Value</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td style="text-align:left; vertical-align:top">XPath 1.0 compatibility mode</td>
                        <td style="text-align:left; vertical-align:top">false</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Statically known namespaces</td>
                        <td style="text-align:left; vertical-align:top">the 
                           <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the containing element in the
                           stylesheet</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default namespace for elements and types</td>
                        <td style="text-align:left; vertical-align:top">determined by the <code>xpath-default-namespace</code> attribute if present
                           (see <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>); otherwise absent</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default function namespace</td>
                        <td style="text-align:left; vertical-align:top">the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a>.
                           </td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">In-scope schema types</td>
                        <td style="text-align:left; vertical-align:top">The type definitions that would be available in the absence of any
                           <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">In-scope element declarations</td>
                        <td style="text-align:left; vertical-align:top">None</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">In-scope attribute declarations</td>
                        <td style="text-align:left; vertical-align:top">None</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">In-scope variables</td>
                        <td style="text-align:left; vertical-align:top">The <a title="static variable" class="termref" href="#dt-static-variable">static
                              variables</a> visible within the containing package whose
                           declarations occur prior to the element containing the static expression in
                           stylesheet tree order. Stylesheet tree order is the order that results when
                           all <a href="#element-import"><code>xsl:import</code></a> and <a href="#element-include"><code>xsl:include</code></a>
                           declarations are replaced by the declarations in the imported or included
                           stylesheet module. A static variable is not in scope within its own
                           declaration, and it is in scope only within its
                           declaring package, not in any using packages. If two static
                           variables satisfying this rule have the same name and are both in scope, the
                           one that appears most recently in stylesheet tree order is used; as a
                           consequence of rules defined elsewhere this will always be consistent with
                           the declaration having highest import precedence.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Context item static type</td>
                        <td style="text-align:left; vertical-align:top"><a title="absent" class="termref" href="#dt-absent">Absent</a></td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">In-scope named item types</td>
                        <td style="text-align:left; vertical-align:top">None</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Statically known function
                           definitions</td>
                        <td style="text-align:left; vertical-align:top">The functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in the <code>fn</code>
                           <code>math</code>, <span><code>map</code>, and <code>array</code></span>  namespaces, together with:
                           
                           <ol class="enumar">
                              <li>
                                 <p>the functions
                              <a href="#func-element-available"><code>element-available</code></a>,
                              <a href="#func-function-available"><code>function-available</code></a>,
                              <a href="#func-type-available"><code>type-available</code></a>,
                              <a href="#func-available-system-properties"><code>available-system-properties</code></a>,
                              and
                              <a href="#func-system-property"><code>system-property</code></a> defined in this specification;</p>
                              </li>
                              <li>
                                 <p>functions that appear in both this specification and in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>
                           (for example, the functions in the <code>map</code> namespaces, and a few others such as <code>collation-key</code>
                           and <code>json-to-xml</code>);</p>
                              </li>
                              <li>
                                 <p>constructor functions for built-in types;</p>
                              </li>
                              <li>
                                 <p>the set of extension functions that are present in the static context of
                              every XPath expression (other than a static expression) within the content
                              of the element that contains the static expression. </p>
                              </li>
                           </ol>
                           
                           Note that <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> are
                           <em>not</em> included in the context, which means that the function
                           <a href="#func-function-available"><code>function-available</code></a> will return <code>false</code> in
                           respect of such functions, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> will
                           fail to find them. The effect of this rule is to ensure that
                           <a href="#func-function-available"><code>function-available</code></a> returns <code>true</code> in respect of
                           functions that can be called within the static expression. It also has the
                           effect that these extension functions will be recognized within the static
                           expression itself; however, the fact that a function is available in this
                           sense gives no guarantee that a call on the function will succeed.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Statically known collations</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default collation</td>
                        <td style="text-align:left; vertical-align:top">The Unicode Codepoint Collation</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Static Base URI</td>
                        <td style="text-align:left; vertical-align:top">The base URI of the containing element in the stylesheet document (see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-base-uri">7.6.2 base-uri Accessor</a>)</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Statically known documents</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Statically known collections</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Statically known default collection type</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Statically known decimal formats</td>
                        <td style="text-align:left; vertical-align:top">A single unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a>
                           equivalent to the decimal format that is created by an
                           <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declaration with no attributes.</td>
                     </tr>
                  </tbody>
               </table>
               <p>&nbsp;</p>
               <table class="def">
                  <caption>Dynamic Context Components for Static Expressions</caption>
                  <col style="text-align:left; width:30%" span="1">
                  <col style="text-align:left" span="1">
                  <thead>
                     <tr>
                        <th style="text-align:left; vertical-align:top">Component</th>
                        <th style="text-align:left; vertical-align:top">Value</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Context item, position, and size</td>
                        <td style="text-align:left; vertical-align:top"><a title="absent" class="termref" href="#dt-absent">Absent</a></td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Variable values</td>
                        <td style="text-align:left; vertical-align:top">A value for every variable present in the in-scope variables. For <a title="static parameter" class="termref" href="#dt-static-parameter">static parameters</a> where an external
                           value is supplied: the externally supplied value of the parameter. In all
                           other cases: the value of the variable as defined in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Dynamically known function definitions</td>
                        <td style="text-align:left; vertical-align:top">The same as the statically known function definitions</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Current dateTime</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Implicit timezone</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Executable Base URI</td>
                        <td style="text-align:left; vertical-align:top">The same as the Static Base URI</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default collation</td>
                        <td style="text-align:left; vertical-align:top">The Unicode Codepoint Collation</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default language</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default calendar</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default place</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Available documents</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Available text resources</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Available collections</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default collection</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Available URI collections</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Default URI collection</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Environment variables</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined</td>
                     </tr>
                  </tbody>
               </table>
               <p>Within a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, all static
               expressions are evaluated in a single <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO</small></sup>. This need not be the same execution scope as that
               used for static expressions in other stylesheet modules, or as that used when
               evaluating XPath expressions appearing elsewhere in the stylesheet module. This means
               that a function such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-date"><code>current-date</code></a> will return the same
               result when called in different <code>[xsl:]use-when</code> expressions within the
               same stylesheet module, but will not necessarily return the same result as the same
               call in an <code>[xsl:]use-when</code> expression within a different stylesheet
               module, or as a call on the same function executed during the transformation
               proper.</p>
               <p>If a <a title="static error" class="termref" href="#dt-static-error">static error</a> is present in a
                  <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>, it is treated in the same way as any other
               static error in the stylesheet module. If a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs
               during evaluation of a static expression, it is treated as a static error in the
               analysis of the stylesheet, while retaining its original error code.</p>
            </div>
            <div class="div2">
               
               <h3><a id="local-variables"></a>9.8 <a href="#local-variables" style="text-decoration: none">Local Variables and Parameters</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-local-variable" title="local variable"></a>As well as being allowed as a
                     <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, the
                     <a href="#element-variable"><code>xsl:variable</code></a> element is also allowed in <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a>. Such a variable
                  is known as a <b>local variable</b>.<span class="definition">]</span>
            </p>
               <p>An <a href="#element-param"><code>xsl:param</code></a> element may also be used to create a variable binding
               with local scope:</p>
               <ul>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-template-parameter" title="template parameter"></a> An
                           <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an
                           <a href="#element-template"><code>xsl:template</code></a> element, before any
                           non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
                        is known as a <b>template parameter</b>. A template parameter is a
                           <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the
                        additional property that its value can be set when the template is called,
                        using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>,
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>,
                        or <a href="#element-next-match"><code>xsl:next-match</code></a>.<span class="definition">]</span>
                  </p>
                  </li>
                  <li>
                     <p>
                     <span class="definition">[Definition:&nbsp;</span><a id="dt-function-parameter" title="function parameter"></a> An
                           <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an
                           <a href="#element-function"><code>xsl:function</code></a> element, before any
                           non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
                        is known as a <b>function parameter</b>. A function parameter is a
                           <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the
                        additional property that its value can be set when the function is called,
                        using a function call in an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.<span class="definition">]</span>
                  </p>
                  </li>
                  <li>
                     <p>An <a href="#element-param"><code>xsl:param</code></a> element may appear as a child
                     of an <a href="#element-iterate"><code>xsl:iterate</code></a> instruction, before any
                        non-<a href="#element-param"><code>xsl:param</code></a> children of that element. This defines a
                     parameter whose value may be initialized on entry to the iteration, and which
                     may be varied each time round the iteration by use of an
                        <a href="#element-with-param"><code>xsl:with-param</code></a> element in the
                        <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> instruction. </p>
                  </li>
               </ul>
               <p>The result of evaluating a local <a href="#element-variable"><code>xsl:variable</code></a> or
                  <a href="#element-param"><code>xsl:param</code></a> element (that is, the contribution it makes to the
               result of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> it is part of) is the empty
               sequence.</p>
            </div>
            <div class="div2">
               
               <h3><a id="scope-of-variables"></a>9.9 <a href="#scope-of-variables" style="text-decoration: none">Scope of Variables</a></h3>
               <p>For any <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding
               element</a>, there is a region (more specifically, a set of  nodes) of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> within which the binding is visible. The set of variable
               bindings in scope for an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>
               consists of those bindings that are visible at the point in the stylesheet where the
               expression occurs.</p>
               <p>A global <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding
                  element</a> is visible everywhere in the containing <a title="package" class="termref" href="#dt-package">package</a>
                   (including other <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a>) except within the <a href="#element-variable"><code>xsl:variable</code></a> or
                  <a href="#element-param"><code>xsl:param</code></a> element itself and any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding.
               (For rules regarding the visibility of the variable
               in other packages, see <a href="#visibility"><i>3.4.4.1 Visibility of Components</i></a>.)
            </p>
               <p>A local <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable binding element</a>
               is visible for all following siblings and their descendants, with the following exceptions:</p>
               <ol class="enumar">
                  <li>
                     <p>It is not visible in any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> by another variable binding.</p>
                  </li>
                  <li>
                     <p>It is not visible within the subtree rooted at an <a href="#element-fallback"><code>xsl:fallback</code></a>
                     instruction that is a sibling of the variable binding element.</p>
                  </li>
                  <li>
                     <p>It is not visible within the subtree rooted at an
                        <a href="#element-catch"><code>xsl:catch</code></a> instruction that is a sibling of the variable
                     binding element.</p>
                  </li>
                  <li>
                     <p>Within an <a href="#element-function"><code>xsl:function</code></a> declaration, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>
                     is not visible within sibling <a href="#element-param"><code>xsl:param</code></a> elements.</p>
                  </li>
               </ol>
               <p>The binding is not visible for the <a href="#element-variable"><code>xsl:variable</code></a> or
                  <a href="#element-param"><code>xsl:param</code></a> element itself.</p>
               <p>If a binding is visible for an element then it is visible for every
               attribute of that element and for every text node child of that element.</p>
               <p>An <a href="#element-param"><code>xsl:param</code></a> element specifying <code>tunnel="yes"</code>
            is also visible in the <code>test</code> attribute of the containing <a href="#element-template"><code>xsl:template</code></a>
            element.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-shadows" title="shadows"></a>Within a region of the 
               stylesheet where a binding <var>B</var>1 is visible, <var>B<sub>1</sub></var> shadows another 
               binding <var>B<sub>2</sub></var> having the same name as <var>B<sub>1</sub></var> if <var>B<sub>1</sub></var> occurs at 
               a point where <var>B<sub>2</sub></var> is visible.<span class="definition">]</span> </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e29434"></a>Example: Local Variable Shadowing a Global Variable</div>
                  <p>The following is allowed:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:param name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:variable name="x" select="2"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>It is also not an error if a binding established by a local
                  <a href="#element-variable"><code>xsl:variable</code></a> element <a title="shadows" class="termref" href="#dt-shadows">shadows</a>
               a binding established by another local <a href="#element-variable"><code>xsl:variable</code></a> or
                  <a href="#element-param"><code>xsl:param</code></a>.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e29451"></a>Example: Misuse of Variable Shadowing</div>
                  <p>The following is not an error, but the effect is probably not what was intended.
                  The template outputs <code>&lt;x value="1"/&gt;</code>, because the declaration of
                  the inner variable named <code>$x</code> has no effect on the value of the outer
                  variable named <code>$x</code>.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="x" select="1"/&gt;
&lt;xsl:template name="foo"&gt;
  &lt;xsl:for-each select="1 to 5"&gt;
    &lt;xsl:variable name="x" select="$x+1"/&gt;
  &lt;/xsl:for-each&gt;
  &lt;x value="{ $x }"/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Once a variable has been given a value, the value cannot subsequently be changed.
                  XSLT does not provide an equivalent to the assignment operator available in many
                  procedural programming languages. </p>
                  <p>This is because an assignment operator would make it harder to create an
                  implementation that processes a document other than in a batch-like way, starting
                  at the beginning and continuing through to the end.</p>
               </div>
               <p>As well as global variables and local variables, an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> may also declare range variables for use
               locally within an expression. For details, see <a href="#xpath-40">[XPath 4.0]</a>.</p>
               <p>Where a reference to a variable occurs in an XPath expression, it is resolved first
               by reference to range variables that are in scope, then by reference to local
               variables and parameters, and finally by reference to global variables and
               parameters. A range variable may shadow a local variable or a global variable. XPath
               also allows a range variable to shadow another range variable.</p>
            </div>
            <div class="div2">
               
               <h3><a id="with-param"></a>9.10 <a href="#with-param" style="text-decoration: none">Setting Parameter Values</a></h3>
               <p class="element-syntax"><a id="element-with-param"></a><code>&lt;xsl:with-param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:with-param&gt;</code></p>
               <p>Parameters are passed to templates using the <a href="#element-with-param"><code>xsl:with-param</code></a> element.
               The <span class="verb">required</span>
               <code>name</code> attribute specifies the name of the <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a> (the variable the value
               of whose binding is to be replaced). The value of the <code>name</code> attribute is
               an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>,
               which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p>
               <p>The <a href="#element-with-param"><code>xsl:with-param</code></a> element is also used
                  when passing parameters to an iteration of the <a href="#element-iterate"><code>xsl:iterate</code></a>
                  instruction, or to a dynamic invocation of an XPath expression using
                     <a href="#element-evaluate"><code>xsl:evaluate</code></a>. In consequence, 
               <a href="#element-with-param"><code>xsl:with-param</code></a> may appear within
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>,
                  <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-evaluate"><code>xsl:evaluate</code></a>, <a href="#element-next-iteration"><code>xsl:next-iteration</code></a>, 
               and <a href="#element-next-match"><code>xsl:next-match</code></a>. (Arguments to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>, however, are supplied
               as part of an XPath function call: see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>.) </p>
               <p>
               <a id="err-XTSE0670"><span class="error">[ERR XTSE0670] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>
                     if two or more sibling <a href="#element-with-param"><code>xsl:with-param</code></a> elements have
                        <code>name</code> attributes that represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.
            </p>
               <p>The value of the parameter is specified in the same way as for
                  <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> (see <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>), taking account of the values of the <code>select</code>
               and <code>as</code> attributes and the content of the <a href="#element-with-param"><code>xsl:with-param</code></a>
               element, if any.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>It is possible to have an <code>as</code> attribute on the
                     <a href="#element-with-param"><code>xsl:with-param</code></a> element that differs from the <code>as</code>
                  attribute on the corresponding <a href="#element-param"><code>xsl:param</code></a> element.</p>
                  <p>In this situation, the supplied value of the parameter will first be processed
                  according to the rules of the <code>as</code> attribute on the
                     <a href="#element-with-param"><code>xsl:with-param</code></a> element, and the resulting value will then be
                  further processed according to the rules of the <code>as</code> attribute on the
                     <a href="#element-param"><code>xsl:param</code></a> element.</p>
                  <p>For example, suppose the supplied value is a node with <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>
                  <code>xs:untypedAtomic</code>, and the <a href="#element-with-param"><code>xsl:with-param</code></a> element
                  specifies <code>as="xs:integer"</code>, while the <a href="#element-param"><code>xsl:param</code></a>
                  element specifies <code>as="xs:double"</code>. Then the node will first be
                  atomized and the resulting untyped atomic item will be cast to
                     <code>xs:integer</code>. If this succeeds, the <code>xs:integer</code> will
                  then be promoted to an <code>xs:double</code>.</p>
               </div>
               <p>The <a title="focus" class="termref" href="#dt-focus">focus</a> used for computing the value specified by
               the <a href="#element-with-param"><code>xsl:with-param</code></a> element is the same as that used for its parent <a title="instruction" class="termref" href="#dt-instruction">instruction</a>.</p>
               <p>The optional <code>tunnel</code> attribute may be used to indicate that a parameter
               is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The default is
                  <code>no</code>. Tunnel parameters are described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>. They are used only when passing parameters to templates: for an
                  <a href="#element-with-param"><code>xsl:with-param</code></a> element that is a child of
                  <a href="#element-evaluate"><code>xsl:evaluate</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> the
                  <code>tunnel</code> attribute <span class="verb">must</span> either be omitted or take
               the value <code>no</code>. </p>
               <p> In other cases it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the template that is
               invoked declares a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>
               with <code>required="yes"</code> and no value for this parameter is supplied by the
               calling instruction. <span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span>
            </p>
            </div>
            <div class="div2">
               
               <h3><a id="circularity"></a>9.11 <a href="#circularity" style="text-decoration: none">Circular Definitions</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-circularity" title="circularity"></a>A <b>circularity</b> is said to
                  exist if a construct such as a <a title="global variable" class="termref" href="#dt-global-variable">global
                     variable</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>,
                  or a <a title="key" class="termref" href="#dt-key">key</a>, cannot be evaluated without reference to its own value. For
                  example, if the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the
                  value of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>
                  <var>X</var> references a global variable <var>Y</var>, then the value for
                     <var>Y</var>
                  <span class="verb">must</span> be computed before the value of <var>X</var>. A
                  circularity exists if it is impossible to do this for all global variable
                  definitions.<span class="definition">]</span>
            </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e29722"></a>Example: Circular Variable Definitions</div>
                  <p>The following two declarations create a circularity:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="x" select="$y+1"/&gt;
&lt;xsl:variable name="y" select="$x+1"/&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e29727"></a>Example: Circularity involving Variables and Functions</div>
                  <p>The definition of a global variable can be circular even if no other variable is
                  involved. For example the following two declarations (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a> for an explanation of the
                     <a href="#element-function"><code>xsl:function</code></a> element) also create a circularity:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="x" select="my:f()"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:sequence select="$x"/&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e29737"></a>Example: Circularity involving Variables and Templates</div>
                  <p>The definition of a variable is also circular if the evaluation of the variable
                  invokes an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction and the variable is
                  referenced in the pattern used in the <code>match</code> attribute of any template
                  rule in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example the
                  following definition is circular:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="x"&gt;
  &lt;xsl:apply-templates select="//param[1]"/&gt;
&lt;/xsl:variable&gt;

&lt;xsl:template match="param[$x]"&gt;1&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e29751"></a>Example: Circularity involving Variables and Keys</div>
                  <p>Similarly, a variable definition is circular if it causes a call on the
                     <a href="#func-key"><code>key</code></a> function, and the definition of that <a title="key" class="termref" href="#dt-key">key</a> refers to that variable in its <code>match</code> or
                     <code>use</code> attributes. So the following definition is circular:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="x" select="my:f(10, /)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="arg1"/&gt;
  &lt;xsl:param name="top"/&gt;
  &lt;xsl:sequence select="key('k', $arg1, $top)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:key name="k" match="item[@code=$x]" use="@desc"/&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e29768"></a>Example: Circularity involving Attribute Sets</div>
                  <p>An attribute set is circular if its <code>use-attribute-sets</code> attribute
                  references itself, directly or indirectly. So the following definitions establish
                  a circularity:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:attribute-set name="a" use-attribute-sets="b"/&gt;
&lt;xsl:attribute-set name="b" use-attribute-sets="a"/&gt;</pre>
                  </div>
                  <p>Because attribute sets can invoke functions, global variables, or templates, and
                  can also include instructions such as literal result elements that themselves
                  invoke attribute sets, examples of circularity involving attribute sets can be
                  more complex than this simple example illustrates. It is also possible to
                  construct examples in which self-reference among attribute sets could be regarded
                  as (terminating or non-terminating) recursion. However, because such
                  self-references have no practical utility, any requirement to evaluate an
                  attribute set in the course of its own evaluation is considered an error.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In previous versions of this specification, self-reference among attribute sets
                     was defined as a static error. In XSLT 3.0 it is not always detectable
                     statically, because attribute sets can bind to each other across package
                     boundaries. Nevertheless, in cases where a processor can detect a static
                     circularity, it can raise this error during the analysis phase, under the
                     general provision for raising dynamic errors during stylesheet analysis if
                     execution can never succeed.</p>
                  </div>
               </div>
               <p>
               <a id="err-XTDE0640"><span class="error">[ERR XTDE0640] </span></a>In general, a <a title="circularity" class="termref" href="#dt-circularity">circularity</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">
                        dynamic error</a>. However, as with all other dynamic errors, an implementation will raise the
               error only if it actually executes the instructions and expressions that participate
               in the circularity. Because different implementations may optimize the execution of a
               stylesheet in different ways, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether a particular circularity will actually
               be raised.</p>
               <p>For example, in the following declarations, the function declares a local variable
                  <code>$b</code>, but it returns a result that does not require the variable to be
               evaluated. It is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether the value is actually evaluated, and
               it is therefore implementation-dependent whether the circularity is raised as an
               error:</p>
               <div class="exampleInner">
                  <pre>&lt;xsl:variable name="x" select="my:f(1)"/&gt;

&lt;xsl:function name="my:f"&gt;
  &lt;xsl:param name="a"/&gt;
  &lt;xsl:variable name="b" select="$x"/&gt;  
  &lt;xsl:sequence select="$a + 2"/&gt;
&lt;/xsl:function&gt;</pre>
               </div>
               <p>Although a circularity is detected as a dynamic error,
               there is no unique instruction whose evaluation triggers the error condition, and the
               result of any attempt to catch the error using an <a href="#element-try"><code>xsl:try</code></a>
               instruction is therefore <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
               <p>Circularities usually involve global variables or parameters, but they can also exist
               between <a title="key" class="termref" href="#dt-key">key</a> definitions (see <a href="#key"><i>20.2 Keys</i></a>),
               between named <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a> (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), or between any combination of these constructs. For
               example, a circularity exists if a key definition invokes a function that references
               an attribute set that calls the <a href="#func-key"><code>key</code></a> function, supplying the name
               of the original key definition as an argument.</p>
               <p>Circularity is not the same as recursion. Stylesheet functions (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>) and named templates (see <a href="#named-templates"><i>10.1 Named Templates</i></a>) may call other functions and named templates without
               restriction. With careless coding, recursion may be non-terminating. Implementations
               are <span class="verb">required</span> to raise circularity as a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>, but they are not
                  <span class="verb">required</span> to detect non-terminating recursion.</p>
               <p>Recursive functions can also be defined using global variable declarations. For example, the variable
            declaration <code>&lt;xsl:variable name="f" select="fn($n){if ($n=0) then 0 else $f($n - 1)}"/&gt;</code> does
            not constitute a circularity, because the variable can be evaluated (delivering a function) without knowing its
            own value.</p>
               <p>The requirement to report a circularity as a dynamic error
               overrides the rule that dynamic errors in evaluating <a title="pattern" class="termref" href="#dt-pattern">patterns</a> are normally masked (by treating the pattern as not
               matching).</p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="callable-components"></a>10 <a href="#callable-components" style="text-decoration: none">Callable Components</a></h2>
            <p>This section describes three constructs that can be used to provide subroutine-like
            functionality that can be invoked from anywhere in the stylesheet: named templates (see
               <a href="#named-templates"><i>10.1 Named Templates</i></a>), named attribute sets (see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>), and <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
               functions</a> (see <a href="#stylesheet-functions"><i>10.3 Stylesheet Functions</i></a>).</p>
            <p><span class="definition">[Definition:&nbsp;</span><a id="dt-invocation-construct" title="invocation construct"></a>The following 
               constructs are classified as <b>invocation constructs</b>: the
               instructions <a href="#element-call-template"><code>xsl:call-template</code></a>,
               <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and
                  <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic
               function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and
                  <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code>
               attribute. These all have the characteristic that they can cause evaluation of
               constructs that are not lexically contained within the calling
            construct.<span class="definition">]</span></p>
            <div class="div2">
               
               <h3><a id="named-templates"></a>10.1 <a href="#named-templates" style="text-decoration: none">Named Templates</a></h3>
               <div class="div3">
                  
                  <h4><a id="declaring-named-templates"></a>10.1.1 <a href="#declaring-named-templates" style="text-decoration: none">Declaring Named Templates</a></h4>
                  <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-named-template" title="named template"></a>Templates can be invoked by
                  name. An <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute
                  defines a <b>named template</b>.<span class="definition">]</span> The value of the
                  <code>name</code> attribute is an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as described in
                  <a href="#qname"><i>5.1.1 Qualified Names</i></a>. If an <a href="#element-template"><code>xsl:template</code></a> element has a
                  <code>name</code> attribute, it may, but need not, also have a <code>match</code>
               attribute. </p>
                  <p>The <code>match</code>, <code>mode</code> and <code>priority</code> attributes on an
                  <a href="#element-template"><code>xsl:template</code></a> element have no effect when the <a title="template" class="termref" href="#dt-template">template</a> is invoked by an
                  <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. Similarly, the <code>name</code>
                and <code>visibility</code> attributes on an
                  <a href="#element-template"><code>xsl:template</code></a> element have no effect when the template is invoked
               by an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p>
                  <p>
               <a id="err-XTSE0660"><span class="error">[ERR XTSE0660] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a 
                     
                        <a title="package" class="termref" href="#dt-package">package</a> contains more than one
                        non-hidden
                     <a title="template" class="termref" href="#dt-template">template</a> with the same name and the same
                        <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it
                     also contains a <a title="template" class="termref" href="#dt-template">template</a> with the same
                     name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import
                     precedence</a>.
            </p>
                  <p>The template name <code>xsl:initial-template</code> is specially
               recognized in that it provides a default entry point for stylesheet execution (see
                  <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>.) </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="invoking-named-templates"></a>10.1.2 <a href="#invoking-named-templates" style="text-decoration: none">Invoking Named Templates</a></h4>
                  <p class="element-syntax"><a id="element-call-template"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:call-template<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:call-template&gt;</code></p>
                  <p>An <a href="#element-call-template"><code>xsl:call-template</code></a> instruction invokes a template by
                  name; it has a <span class="verb">required</span>
                  <code>name</code> attribute that identifies the template to be invoked. Unlike
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, the <a href="#element-call-template"><code>xsl:call-template</code></a>
                  instruction does not change the <a title="focus" class="termref" href="#dt-focus">focus</a>.</p>
                  <p>
                  <a id="err-XTSE0650"><span class="error">[ERR XTSE0650] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains an
                        <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code>
                        attribute does not match the <code>name</code> attribute of any <a title="named template" class="termref" href="#dt-named-template">named template</a>
                        visible in the containing <a title="package" class="termref" href="#dt-package">package</a> (this
                        includes any template defined in this package, as well as templates accepted
                        from used packages whose visibility in this package is not
                        <code>hidden</code>). For more details of the process of binding the
                        called template, see <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>.
               </p>
                  <p>The target <a title="template" class="termref" href="#dt-template">template</a>
                  for an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is established using the
                  binding rules described in <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>. This will always
                  be a template whose <code>name</code> attribute matches the <code>name</code>
                  attribute of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. It may be a
                  template defined in the same package that has higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than any other template
                  with this name, or it may be a template accepted from a used package, or (if the
                  template is not defined as <code>private</code> or <code>final</code>) it may be
                  an overriding template in a package that uses the containing package. 
                  The result of evaluating an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is the
                  sequence produced by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a> contained in its target <a title="template" class="termref" href="#dt-template">template</a> (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>).</p>
                  <p>Parameters for a named template can be supplied using <a href="#element-with-param"><code>xsl:with-param</code></a> elements as children
              of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction: see <a href="#with-param"><i>9.10 Setting Parameter Values</i></a>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="invoking-templates-with-extension-instructions"></a>10.1.3 <a href="#invoking-templates-with-extension-instructions" style="text-decoration: none">Invoking Named Templates using Extension Instructions</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#stylesheet-functions">next</a> | <a href="#global-variables">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     It is possible to invoke a named template using an extension instruction, specifically,
                     an element whose name matches the name of the named template.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/168">168</a>&nbsp;&nbsp;30 September 2022]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>As an alternative to the use of <a href="#element-call-template"><code>xsl:call-template</code></a>, it is
               possible to invoke a named template using an instruction. For example, given
               the named template:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template name="log:message"&gt;
    &lt;xsl:param name="message" as="xs:string"/&gt;
    &lt;message&gt;{ $message }&lt;/message&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>a call on the template written as:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:call-template name="log:message"&gt;
    &lt;xsl:with-param name="message" select="'Good morning'"/&gt;
&lt;/xsl:call-template&gt;</pre>
                  </div>
                  <p>can be replaced with the instruction:</p>
                  <div class="exampleInner">
                     <pre>&lt;log:message message="Good morning"/&gt;</pre>
                  </div>
                  <p>For this to work, the name of the template must be in a non-null namespace, and
               this namespace must be designated as an extension element namespace using the
               attribute <code>[xsl:]extension-element-prefixes</code> on the instruction itself,
               or on some containing element (see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>).</p>
                  <p>The name of the instruction must match the name of the called template, and the
               names of its attributes (other than <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard attributes</a>)
                  are matched against the names of the template’s parameters. 
                  <a title="standard attributes" class="termref" href="#dt-standard-attributes">Standard attributes</a> are recognized
               (they must be in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) and have their standard meaning;
               for example <code>xsl:default-collation</code> affects the evaluation of any XPath expression
               used to compute a parameter value.</p>
                  <p>The way in which attribute values are handled depends on the type declaration
               of the template parameter:</p>
                  <ol class="enumar">
                     <li>
                        <p>If the declared type is <code>xs:boolean</code>, with no occurrence indicator,
                     then the attribute is treated
                     as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a> whose <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                     (after whitespace trimming) must be one of <code>yes</code>, <code>true</code>, or <code>1</code>,
                     or <code>no</code>, <code>false</code>, or <code>0</code>, in the same way as boolean
                     attributes on XSLT instructions. 
                  </p>
                     </li>
                     <li>
                        <p>If the declared type is any other atomic or union type, with no occurrence indicator, 
                     then the attribute is treated as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>,
                     and its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is treated as an <code>xs:untypedAtomic</code> item,
                     which forces conversion to the required type by applying the casting rules.</p>
                     </li>
                     <li>
                        <p>In all other cases (that is, if the type of the parameter is not declared, 
                     or if it is not atomic, or if there is an occurrence
                  indicator) the attribute is treated as an XPath expression and its value is converted
                  to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
                     </li>
                  </ol>
                  <p>If an instruction is recognized as an implicit call on a named template, then the static
                  and dynamic rules that apply are the same as if it were expanded into an 
                  <a href="#element-call-template"><code>xsl:call-template</code></a> instruction. The instruction</p>
                  <div class="exampleInner">
                     <pre>&lt;N A1="E1" A2="E2" A3="E3"/&gt;</pre>
                  </div>
                  <p>is essentially equivalent to:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:call-template name="N"&gt;
  &lt;xsl:with-param name="A1" select="E1"/&gt;
  &lt;xsl:with-param name="A2" select="E2"/&gt;
  &lt;xsl:with-param name="A3" select="E3"/&gt;
&lt;/xsl:call-template&gt;</pre>
                  </div>
                  <p>except that the interpretation of the parameter values <code>E1</code>, <code>E2</code>, and <code>E3</code>
               depends on the declared type as explained above.</p>
                  <p>Some of the implications of this equivalence are:</p>
                  <ul>
                     <li>
                        <p>The binding of the instruction to a specific named template (for example, if there
                     are overriding declarations in multiple packages) follows the binding rules in
                     <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>.</p>
                     </li>
                     <li>
                        <p>A value must be supplied for any parameter declared with <code>required="yes"</code>.</p>
                     </li>
                     <li>
                        <p>The context item for the evaluation of the extension instruction must satisfy any constraints
                  defined in an <a href="#element-context-item"><code>xsl:context-item</code></a> declaration in the called template.</p>
                     </li>
                     <li>
                        <p>It is an error if the instruction has attributes that do not correspond to the names
                  of parameters declared on the named template.</p>
                     </li>
                  </ul>
                  <p>It is not possible to supply values for 
                  <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a>, but existing
               tunnel parameters are passed through unchanged.</p>
                  <p>For backwards compatibility, if an external implementation of an extension instruction
               is available to the implementation, then that takes precedence over the existence of 
               a named template with a matching name.</p>
                  <p>The XSLT namespace cannot be designated as an extension element namespace, so the template
               names <code>xsl:initial-template</code> and <code>xsl:original</code> cannot be used as
               extension instructions.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="declaring-context-item"></a>10.1.4 <a href="#declaring-context-item" style="text-decoration: none">Declaring the Context Item for a Template</a></h4>
                  <p>The <a href="#element-context-item"><code>xsl:context-item</code></a> element is used as a child of
                     <a href="#element-template"><code>xsl:template</code></a>, to declare the required type of the context
                  item. It is intended particularly for use when the containing template is called
                  using an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction, but it also constrains
                  the context item if the same template is invoked using
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or
                     <a href="#element-next-match"><code>xsl:next-match</code></a>. </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The context item for a template must be either a single
               item, or absent. It cannot be an arbitrary value.</p>
                  </div>
                  <p class="element-syntax"><a id="element-context-item"></a><code>&lt;xsl:context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"〔'optional'〕&nbsp;/&gt;</code></p>
                  <p>If the <code>as</code> attribute is present then its value must be an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>. If the attribute is
                  omitted this is equivalent to specifying <code>as="item()"</code>.</p>
                  <p><a id="err-XTSE3088"><span class="error">[ERR XTSE3088] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is
                        present  when <code>use="absent"</code> is specified.</p>
                  <p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> is raised if the supplied
                  context item does not match its required type. No attempt is made to convert the
                  context item to the required type (using the coercion rules or
                  otherwise). The error code is the same as for <a href="#element-param"><code>xsl:param</code></a>:
                     <span class="error">[see <a href="#err-XTTE0590">ERR XTTE0590</a>]</span>.</p>
                  <p>If an <a href="#element-context-item"><code>xsl:context-item</code></a> element is present as
                  the first child element of <a href="#element-template"><code>xsl:template</code></a>, it defines whether the
                  template requires a context item to be supplied, and if so, what the type of the
                  context item must be. If this template is the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a>, then this has the effect of placing
                  constraints on the <a title="global context item" class="termref" href="#dt-global-context-item">global context
                     item</a> for the transformation as a whole.</p>
                  <p>The <code>use</code> attribute of
                     <a href="#element-context-item"><code>xsl:context-item</code></a> takes the value <code>required</code>,
                     <code>optional</code>, or <code>absent</code>.
                     The default is
                     <code>optional</code>.</p>
                  <p>If the containing <a href="#element-template"><code>xsl:template</code></a> element has no <code>name</code>
                  attribute then the only permitted value is <code>required</code>.</p>
                  <ul>
                     <li>
                        <p>If the value <code>required</code> is specified, then there must be a
                        context item. (This will automatically be the case if the template is
                        invoked using <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                           <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>,
                        but not if it is invoked using <a href="#element-call-template"><code>xsl:call-template</code></a>.) </p>
                     </li>
                     <li>
                        <p>If the value <code>optional</code> is specified, or if the attribute is
                        omitted, or if the <a href="#element-context-item"><code>xsl:context-item</code></a> element is omitted,
                        then there may or may not be a context item when the template is
                        invoked.</p>
                     </li>
                     <li>
                        <p>If the value <code>absent</code> is specified, then the contained sequence
                        constructor, and any <a href="#element-param"><code>xsl:param</code></a> elements, are evaluated with
                        an absent focus.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>It is not an error to call such a template with a non-absent focus; the
                           context item is simply treated as absent. This option is useful when
                           streaming, since an <a href="#element-call-template"><code>xsl:call-template</code></a> instruction may
                           become streamable if the referenced template is declared to make no use
                           of the context item.</p>
                        </div>
                     </li>
                  </ul>
                  <p> The processor <span class="verb">may</span>
                  raise a <a title="type error" class="termref" href="#dt-type-error">type error</a> statically if the
                  required context item type is incompatible with the <code>match</code> pattern,
                  that is, if no item that satisfies the match pattern can also satisfy the required
                  context item type.</p>
                  <p>The <a href="#element-context-item"><code>xsl:context-item</code></a> element plays no part in
                  deciding whether and when the template rule is invoked in response to an
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction. </p>
                  <p>
                  <a id="err-XTTE3090"><span class="error">[ERR XTTE3090] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                           <a href="#element-context-item"><code>xsl:context-item</code></a> child of <a href="#element-template"><code>xsl:template</code></a>
                        specifies that a context item is required and none is supplied by the
                        caller, that is, if the context item is absent at the point where
                           <a href="#element-call-template"><code>xsl:call-template</code></a> is evaluated.
               </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="call-template-params"></a>10.1.5 <a href="#call-template-params" style="text-decoration: none">Passing Parameters to Named Templates</a></h4>
                  <p>Parameters are passed to named templates using the <a href="#element-with-param"><code>xsl:with-param</code></a>
                  element as a child of the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction.</p>
                  <p>
                  <a id="err-XTSE0680"><span class="error">[ERR XTSE0680] </span></a>In the case of <a href="#element-call-template"><code>xsl:call-template</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to pass a non-tunnel
                        parameter named <var>x</var> to a template that does not have a non-tunnel
                        <a title="template parameter" class="termref" href="#dt-template-parameter">template
                           parameter</a> named <var>x</var>, unless the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is processed with
                              <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0
                           behavior</a>. This is not an error in the case of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                     <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and <a href="#element-next-match"><code>xsl:next-match</code></a>; in
                  these cases the parameter is simply ignored.</p>
                  <p>The optional <code>tunnel</code> attribute may be used to indicate that a
                  parameter is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a>. The
                  default is <code>no</code>. Tunnel parameters are described in <a href="#tunnel-params"><i>10.1.6 Tunnel Parameters</i></a>.
               </p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e30449"></a>Example: Calling a Named Template with a Parameter</div>
                     <p>This example defines a named template for a <code>numbered-block</code> with a
                     parameter to control the format of the number.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template name="numbered-block"&gt;
  &lt;xsl:param name="format"&gt;1. &lt;/xsl:param&gt;
  &lt;fo:block&gt;
    &lt;xsl:number format="{ $format }"/&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="ol//ol/li"&gt;
  &lt;xsl:call-template name="numbered-block"&gt;
    &lt;xsl:with-param name="format"&gt;a. &lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="tunnel-params"></a>10.1.6 <a href="#tunnel-params" style="text-decoration: none">Tunnel Parameters</a></h4>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-tunnel-parameter" title="tunnel parameter"></a>A parameter passed to a
                     template may be defined as a <b>tunnel parameter</b>. Tunnel parameters
                     have the property that they are automatically passed on by the called template
                     to any further templates that it calls, and so on recursively.<span class="definition">]</span> Tunnel
                  parameters thus allow values to be set that are accessible during an entire phase
                  of stylesheet processing, without the need for each template that is used during
                  that phase to be aware of the parameter.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Tunnel parameters are conceptually similar to the dynamically scoped variables found in
                     some functional programming languages (for example, early versions of LISP), where 
                     evaluating a variable reference involves searching down the dynamic call stack for
                     a matching variable name. There are two main use cases for the feature:</p>
                     <ol class="enumar">
                        <li>
                           <p>They provide a way to supply context information that might be needed by many
                     templates (for example, the fact that the output is to be localized for a particular language),
                     but which cannot be placed in a global variable because it might vary from one phase of processing
                     to another. Passing such information using conventional parameters is error-prone, because
                     a single <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or <a href="#element-call-template"><code>xsl:call-template</code></a> instruction
                     that neglects to pass the information on will lead to failures that are difficult to diagnose.</p>
                           <p>This style of processing is even more useful when handling JSON input,
                     because with maps and arrays, there is no ancestor axis to examine properties of nodes further
                     up the tree; with a recursive descent of the tree, all context information needs to be passed down
                     explicitly. One way of handling this is for each level of processing in the tree to bind a tunnel
                     parameter to the map or array encountered at that level, which then becomes available to all
                     template rules processing data further down the tree.</p>
                        </li>
                        <li>
                           <p>They are particularly useful when writing a customization layer for an existing stylesheet. For
                     example, if you want to override a template rule that displays chemical formulae, you might want the
                     new rule to be parameterized so you can apply the house-style of a particular scientific journal.
                     Tunnel parameters allow you to pass this information to the overriding template rule without
                     requiring modifications to all the intermediate template rules. Again, a global variable could be used,
                     but only if the same house-style is to be used for all chemical formulae processed during a single
                     transformation.</p>
                        </li>
                     </ol>
                  </div>
                  <p>A <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> is created by
                  using an <a href="#element-with-param"><code>xsl:with-param</code></a> element that specifies
                     <code>tunnel="yes"</code>. A template that requires access to the value of a
                  tunnel parameter must declare it using an <a href="#element-param"><code>xsl:param</code></a> element that
                  also specifies <code>tunnel="yes"</code>.</p>
                  <p>On any template call using an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                     <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or
                     <a href="#element-next-match"><code>xsl:next-match</code></a> instruction, a set of <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> is passed from the
                  calling template to the called template. This set consists of any parameters
                  explicitly created using <code>&lt;xsl:with-param tunnel="yes"&gt;</code>,
                  overlaid on a base set of tunnel parameters. If the
                     <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>,
                     <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>
                  instruction has an <a href="#element-template"><code>xsl:template</code></a> declaration as an ancestor
                  element in the stylesheet, then the base set consists of the tunnel parameters
                  that were passed to that template; otherwise (for example, if the instruction is
                  within a global variable declaration, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute
                     set</a> declaration, or a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>), the base set is empty. If a parameter created
                  using <code>&lt;xsl:with-param tunnel="yes"&gt;</code> has the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as a parameter in the base
                  set, then the parameter created using <a href="#element-with-param"><code>xsl:with-param</code></a> overrides
                  the parameter in the base set; otherwise, the parameter created using
                     <a href="#element-with-param"><code>xsl:with-param</code></a> is added to the base set.</p>
                  <p>When a template specifies <code>&lt;xsl:param tunnel="yes"&gt;</code>,
                  this declares the intention to make use of a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel
                     parameter</a>; it does not remove the parameter from the base set
                  of tunnel parameters that is passed on to any templates called by this
                  template.</p>
                  <p>Two sibling <a href="#element-with-param"><code>xsl:with-param</code></a> elements <span class="verb">must</span> have
                  distinct parameter names, even if one is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> and the other is not. Equally, two sibling
                     <a href="#element-param"><code>xsl:param</code></a> elements representing <a title="template parameter" class="termref" href="#dt-template-parameter">template parameters</a>
                  <span class="verb">must</span> have distinct parameter names, even if one is a <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameter</a> and the other is not.
                  However, the tunnel parameters that are implicitly passed in a template call
                     <span class="verb">may</span> have names that duplicate the names of non-tunnel
                  parameters that are explicitly passed on the same call.</p>
                  <p>
                  <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">Tunnel parameters</a> are not passed in
                  calls to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>.</p>
                  <p>All other options of <a href="#element-with-param"><code>xsl:with-param</code></a> and
                     <a href="#element-param"><code>xsl:param</code></a> are available with <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">tunnel parameters</a> just as with non-tunnel
                  parameters. For example, parameters may be declared as mandatory or optional, a
                  default value may be specified, and a required type may be specified. If any
                  conversion is required from the supplied value of a tunnel parameter to the
                  required type specified in <a href="#element-param"><code>xsl:param</code></a>, then the converted value is
                  used within the receiving template, but the value that is passed on in any further
                  template calls is the original supplied value before conversion. Equally, any
                  default value is local to the template: specifying a default value for a tunnel
                  parameter does not change the set of tunnel parameters that is passed on in
                  further template calls.</p>
                  <p>
                  <a title="tunnel parameter" class="termref" href="#dt-tunnel-parameter">Tunnel parameters</a> are passed
                  unchanged through a built-in template rule (see <a href="#built-in-rule"><i>6.8 Built-in Template Rules</i></a>).</p>
                  <p>If a tunnel parameter is declared in an
                     <a href="#element-param"><code>xsl:param</code></a> element with the attribute
                  <code>tunnel="yes"</code>, and if the
                  parameter is <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly</a>
                  or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly</a> mandatory,
                  then a  dynamic error occurs <span class="error">[see <a href="#err-XTDE0700">ERR XTDE0700</a>]</span> if the set of tunnel parameters passed to the template does not
                  include a parameter with a matching <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                     QName</a>.</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e30616"></a>Example: Using Tunnel Parameters</div>
                     <p>Suppose that the equations in a scientific paper are to be sequentially
                     numbered, but that the format of the number depends on the context in which the
                     equations appear. It is possible to reflect this using a rule of the form:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template match="equation"&gt;
  &lt;xsl:param name="equation-format" select="'(1)'" tunnel="yes"/&gt;
  &lt;xsl:number level="any" format="{ $equation-format }"/&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>At any level of processing above this level, it is possible to determine how
                     the equations will be numbered, for example:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template match="appendix"&gt;
  ...
  &lt;xsl:apply-templates&gt;
    &lt;xsl:with-param name="equation-format" select="'[i]'" tunnel="yes"/&gt;
  &lt;/xsl:apply-templates&gt;
  ...
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>The parameter value is passed transparently through all the intermediate layers
                     of template rules until it reaches the rule with <code>match="equation"</code>.
                     The effect is similar to using a global variable, except that the parameter can
                     take different values during different phases of the transformation.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="attribute-sets"></a>10.2 <a href="#attribute-sets" style="text-decoration: none">Named Attribute Sets</a></h3>
               <p class="element-syntax"><a id="element-attribute-set"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:attribute-set<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var>〔''〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"〔'private'〕<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>* --&gt;<br>&lt;/xsl:attribute-set&gt;</code></p>
               <p>Attribute sets generate named collections of attributes that can be used repeatedly on
               different constructed elements. The <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration is
               used to declare attribute sets. The <span class="verb">required</span>
               <code>name</code> attribute specifies the name of the attribute set. The value of the
                  <code>name</code> attribute is an <code>EQName</code>, which is expanded as
               described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-attribute-set" title="attribute set"></a>An <b>attribute set</b> is
                  defined as a set of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations in the same
                     <a title="package" class="termref" href="#dt-package">package</a> that share the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.<span class="definition">]</span>
            </p>
               <p>The content of the <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element consists of zero or
               more <a href="#element-attribute"><code>xsl:attribute</code></a> instructions that are evaluated to produce the
               attributes in the set.</p>
               <p>The effect of the <code>streamable</code> attribute is explained in 
            <a href="../xslt-streaming-40/#streamability-of-attribute-sets">9 Streamable Attribute Sets</a><sup><small>SG</small></sup>.</p>
               <div class="div3">
                  
                  <h4><a id="using-attribute-sets"></a>10.2.1 <a href="#using-attribute-sets" style="text-decoration: none">Using Attribute Sets</a></h4>
                  <p>
                  <a title="attribute set" class="termref" href="#dt-attribute-set">Attribute sets</a> are used by specifying a
                     <code>use-attribute-sets</code> attribute on the <a href="#element-element"><code>xsl:element</code></a>
                  or <a href="#element-copy"><code>xsl:copy</code></a> instruction, or by specifying an
                     <code>xsl:use-attribute-sets</code> attribute on a literal result element. An
                  attribute set may be defined in terms of other attribute sets by using the
                     <code>use-attribute-sets</code> attribute on the
                     <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element itself. The value of the
                     <code>[xsl:]use-attribute-sets</code> attribute is in each case a
                  whitespace-separated list of names of attribute sets. Each name is specified as an
                     <a title="EQName" class="termref" href="#dt-eqname">EQName</a>,
                  which is expanded as described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>.</p>
                  <p>
                  <a id="err-XTSE0710"><span class="error">[ERR XTSE0710] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value
                        of the <code>use-attribute-sets</code> attribute of an
                           <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, or
                           <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, or the
                           <code>xsl:use-attribute-sets</code> attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, is not
                        a whitespace-separated sequence of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>, or if it contains an
                        EQName that does not match the <code>name</code> attribute of any
                           <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>.
               </p>
                  <p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> may be considered
                  as comprising a sequence of instructions, each of which is either an
                     <a href="#element-attribute"><code>xsl:attribute</code></a> instruction or an <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a>. Starting with the declarations making up
                  an attribute set, this sequence of instructions can be generated by the following
                  rules: </p>
                  <ol class="enumar">
                     <li>
                        <p>The relevant attribute set <a title="declaration" class="termref" href="#dt-declaration">declarations</a> (that is, all declarations of attribute sets
                        within a package sharing the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>) are
                        considered in order: first in increasing order of <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, and within each precedence, in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>. </p>
                     </li>
                     <li>
                        <p>Each declaration is expanded to a sequence of instructions as follows.
                        First, one <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> is generated for
                        each EQName present in the <code>use-attribute-sets</code> attribute, if
                        present, retaining the order in which the EQNames appear. This is followed
                        by the sequence of contained <a href="#element-attribute"><code>xsl:attribute</code></a> instructions, in
                        order. </p>
                        <p><span class="definition">[Definition:&nbsp;</span><a id="dt-attribute-set-invocation" title="attribute set invocation"></a>An
                              <b>attribute set invocation</b> is a pseudo-instruction
                           corresponding to a single EQName appearing within an
                              <code>[xsl:]use-attribute-sets</code> attribute; the effect of the
                           pseudo-instruction is to cause the referenced <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to be evaluated.<span class="definition">]</span></p>
                     </li>
                  </ol>
                  <p>Similarly, an <code>[xsl:]use-attribute-sets</code>
                  attribute of an <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, or
                     <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, or of a literal result element, is
                  expanded to a sequence of <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set
                     invocations</a>, one for each EQName in order. </p>
                  <p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is a named
                     <a title="component" class="termref" href="#dt-component">component</a>, and the binding of QNames appearing in an
                     <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> to attribute set components
                  follows the rules in <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>. </p>
                  <p>The following two (mutually recursive) rules define how
                  an <code>[xsl:]use-attribute-set</code> attribute is expanded:</p>
                  <ol class="enumar">
                     <li>
                        <p>An <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is evaluated by evaluating each of the
                        contained <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set
                           invocations</a> and <a href="#element-attribute"><code>xsl:attribute</code></a> instructions in
                        order, to deliver a sequence of attribute nodes. </p>
                     </li>
                     <li>
                        <p>An <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> is evaluated by evaluating
                        the <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to which it is bound, as determined by
                        the rules in <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>. </p>
                     </li>
                  </ol>
                  <p>For rules regarding cycles in attribute set
                  declarations, see <a href="#circularity"><i>9.11 Circular Definitions</i></a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The effect of an <a title="attribute set invocation" class="termref" href="#dt-attribute-set-invocation">attribute set invocation</a> on the dynamic
                     context is the same as the effect of an <a href="#element-call-template"><code>xsl:call-template</code></a>
                     instruction. In particular, it does not change the <a title="focus" class="termref" href="#dt-focus">focus</a>.
                     Although attribute sets are often defined with fixed values, or with values
                     that depend only on global variables, it is possible to define an attribute set
                     in such a way that the values of the constructed attributes are dependent on
                     the context item.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In all cases the result of evaluating an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> is
                     subsequently used to create the attributes of an element node, using the rules
                     in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. The effect of those rules is
                     that when the result of evaluating the attribute set contains attributes with
                     duplicate names, the last duplicate wins. The optimization rules allow a
                     processor to avoid evaluating or validating an attribute if it is able to
                     determine that the attribute will subsequently be discarded as a duplicate.
                  </p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="visibility-of-attribute-sets"></a>10.2.2 <a href="#visibility-of-attribute-sets" style="text-decoration: none">Visibility of Attribute Sets</a></h4>
                  <p>The <code>visibility</code> attribute determines the
                  potential visibility of the attribute set in packages other than the containing
                  package. If the <code>visibility</code> attribute is present on any of the
                     <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations making up the definition of an
                     <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> (that is, all declarations within the same
                  package sharing the same name), then it <span class="verb">must</span> be present, with
                  the same value, on every <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration making up
                  the definition of that <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>.</p>
                  <p>If the <code>visibility</code> attribute is present with the
                  value <code>abstract</code> then there must be no <a href="#element-attribute"><code>xsl:attribute</code></a>
                  children and no <code>use-attribute-sets</code>
                     attribute.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="evaluating-attribute-sets"></a>10.2.3 <a href="#evaluating-attribute-sets" style="text-decoration: none">Evaluating Attribute Sets</a></h4>
                  <p>Attribute sets are evaluated as follows:</p>
                  <ul>
                     <li>
                        <p>The <a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-element"><code>xsl:element</code></a> instructions
                        have a <code>use-attribute-sets</code> attribute. The sequence of attribute
                        nodes produced by evaluating this attribute is prepended to the sequence
                        produced by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                           constructor</a> contained within the instruction.</p>
                     </li>
                     <li>
                        <p>
                        <a title="literal result element" class="termref" href="#dt-literal-result-element">Literal result elements</a>
                        allow an <code>xsl:use-attribute-sets</code> attribute, which is evaluated
                        in the same way as the <code>use-attribute-sets</code> attribute of
                           <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-copy"><code>xsl:copy</code></a>. The sequence
                        of attribute nodes produced by evaluating this attribute is prepended to the
                        sequence of attribute nodes produced by evaluating the attributes of the
                        literal result element, which in turn is prepended to the sequence produced
                        by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                           constructor</a> contained with the literal result element.</p>
                     </li>
                  </ul>
                  <p>The <a href="#element-attribute"><code>xsl:attribute</code></a> instructions are evaluated using the same
                     <a title="focus" class="termref" href="#dt-focus">focus</a> as is used for evaluating the 
                  <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained by the
                  element that is the parent of the <code>[xsl:]use-attribute-sets</code> attribute forming
                  the initial input to the algorithm. However, the static context for the evaluation
                  depends on the position of the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction in the
                  stylesheet: thus, only local variables declared within an
                     <a href="#element-attribute"><code>xsl:attribute</code></a> instruction, and global variables, are
                  visible.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The above rule means that for an <a href="#element-copy"><code>xsl:copy</code></a>
               element with a <code>select</code> attribute, the focus for evaluating any referenced attribute
               sets is the node selected by the <code>select</code> attribute, rather than the context item of 
                  the <a href="#element-copy"><code>xsl:copy</code></a> instruction.</p>
                  </div>
                  <p>The set of attribute nodes produced by expanding
                     <code>xsl:use-attribute-sets</code> may include several attributes with the
                  same name. When the attributes are added to an element node, only the last of the
                  duplicates will take effect.</p>
                  <p>The way in which each instruction uses the results of expanding the
                     <code>[xsl:]use-attribute-sets</code> attribute is described in the
                  specification for the relevant instruction: see <a href="#literal-result-element"><i>11.1 Literal Result Elements</i></a>, <a href="#xsl-element"><i>11.2 Creating Element Nodes Using xsl:element</i></a>, and <a href="#copying"><i>11.9 Copying Nodes</i></a>.</p>
                  <p>The result of evaluating an attribute set is a sequence of attribute nodes.
                  Evaluating the same attribute set more than once can produce different results,
                  because although an attribute set does not have parameters, it may contain
                  expressions or instructions whose value depends on the evaluation context.</p>
                  <p>Each attribute node produced by expanding an attribute set has a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> determined by the rules for the
                     <a href="#element-attribute"><code>xsl:attribute</code></a> instruction that created the attribute node: see
                     <a href="#annotation-for-constructed-attribute"><i>11.3.1 Setting the Type Annotation for a Constructed Attribute Node</i></a>. These type annotations
                  may be preserved, stripped, or replaced as determined by the rules for the
                  instruction that creates the element in which the attributes are used.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="attribute-sets-examples"></a>10.2.4 <a href="#attribute-sets-examples" style="text-decoration: none">Attribute Sets: Examples</a></h4>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e31000"></a>Example: A Simple Attribute Set</div>
                     <p>The following example creates a named <a title="attribute set" class="termref" href="#dt-attribute-set">attribute
                        set</a>
                     <code>title-style</code> and uses it in a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template match="chapter/heading"&gt;
  &lt;fo:block font-stretch="condensed" xsl:use-attribute-sets="title-style"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:attribute-set name="title-style"&gt;
  &lt;xsl:attribute name="font-size"&gt;12pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;</pre>
                     </div>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e31015"></a>Example: Overriding Attributes in an Attribute Set</div>
                     <p>The following example creates a named attribute set <code>base-style</code> and
                     uses it in a template rule with multiple specifications of the attributes:</p>
                     <dl>
                        <dt class="label">font-family</dt>
                        <dd>
                           <p>is specified only in the attribute set</p>
                        </dd>
                        <dt class="label">font-size</dt>
                        <dd>
                           <p>is specified in the attribute set, is specified on the literal result
                              element, and in an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction</p>
                        </dd>
                        <dt class="label">font-style</dt>
                        <dd>
                           <p>is specified in the attribute set, and on the literal result
                              element</p>
                        </dd>
                        <dt class="label">font-weight</dt>
                        <dd>
                           <p>is specified in the attribute set, and in an
                                 <a href="#element-attribute"><code>xsl:attribute</code></a> instruction</p>
                        </dd>
                     </dl>
                     <p>Stylesheet fragment:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:attribute-set name="base-style"&gt;
  &lt;xsl:attribute name="font-family"&gt;Univers&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-size"&gt;10pt&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-style"&gt;normal&lt;/xsl:attribute&gt;
  &lt;xsl:attribute name="font-weight"&gt;normal&lt;/xsl:attribute&gt;
&lt;/xsl:attribute-set&gt;

&lt;xsl:template match="o"&gt;
  &lt;fo:block xsl:use-attribute-sets="base-style"
            font-size="12pt"
            font-style="italic"&gt;
    &lt;xsl:attribute name="font-size"&gt;14pt&lt;/xsl:attribute&gt;
    &lt;xsl:attribute name="font-weight"&gt;bold&lt;/xsl:attribute&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>Result:</p>
                     <div class="exampleInner">
                        <pre>&lt;fo:block font-family="Univers"
          font-size="14pt"
          font-style="italic"
          font-weight="bold"&gt;
...
&lt;/fo:block&gt;</pre>
                     </div>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="stylesheet-functions"></a>10.3 <a href="#stylesheet-functions" style="text-decoration: none">Stylesheet Functions</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#xsl-function-name">next</a> | <a href="#invoking-templates-with-extension-instructions">previous</a>)</p>
                  <ol>
                     <li>
                        <p>Parameters on functions
               declared using <a href="#element-function"><code>xsl:function</code></a> can now be defined as optional,
               with a default value supplied.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/155">155</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159</a>&nbsp;30 September 2022]</i></p>
                     </li>
                     <li>
                        <p>User-defined functions can now have names that are in
               no namespace. An unprefixed name appearing in a function call is resolved
               to a no-namespace function with matching local name in preference to
               a function in the standard <code>fn</code> namespace.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/657">657</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2200">2200</a>&nbsp;23 September 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-stylesheet-function" title="stylesheet function"></a>An
                     <a href="#element-function"><code>xsl:function</code></a> declaration declares the name, parameters, and
                  implementation of a family of <b>stylesheet functions</b> that can be called from any
                  XPath <a title="expression" class="termref" href="#dt-expression">expression</a> within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                  (subject to visibility rules).<span class="definition">]</span>
            </p>
               <p class="element-syntax"><a id="element-function"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:function<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"〔'private'〕<br>&nbsp;&nbsp;streamability? = "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | <var>eqname</var>〔'unclassified'〕<br>&nbsp;&nbsp;override-extension-function? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;<span class="grayed">[override]?</span> = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;new-each-time? = "yes" | "true" | "1" | "no" | "false" | "0" | "maybe"<br>&nbsp;&nbsp;cache? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:function&gt;</code></p>
               <p>The effect of an <a href="#element-function"><code>xsl:function</code></a> declaration is to add a 
               <a title="function definition" class="termref" href="#dt-function-definition">function definition</a>
               to the static context for all XPath <a title="expression" class="termref" href="#dt-expression">expressions</a> 
               used in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> (including an XPath expression used
               within a predicate in a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>).</p>
               <p>The content of the <a href="#element-function"><code>xsl:function</code></a> element consists of zero or more
               <a href="#element-param"><code>xsl:param</code></a> elements that specify the formal parameters of the
               function, followed by a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                  constructor</a> that defines the value to be returned by the function.</p>
               <p>The children and attributes of the <a href="#element-function"><code>xsl:function</code></a> declaration translate directly
               into properties of the <a title="function definition" class="termref" href="#dt-function-definition">function definition</a>:</p>
               <ul>
                  <li>
                     <p>The <code>xsl:function/@name</code> attribute defines the function’s name.</p>
                  </li>
                  <li>
                     <p>The <code>xsl:param</code> children define the function’s parameters:</p>
                     <ul>
                        <li>
                           <p>The <code>xsl:param/@name</code> attribute defines the name of the parameter.</p>
                        </li>
                        <li>
                           <p>The <code>xsl:param/@required</code> attribute determines whether the parameter is mandatory or optional.</p>
                        </li>
                        <li>
                           <p>The <code>xsl:param/@as</code> attribute determines the required type of the parameter.</p>
                        </li>
                        <li>
                           <p>The <code>xsl:param/@select</code> attribute determines a default value for an optional parameter.</p>
                        </li>
                     </ul>
                  </li>
                  <li>
                     <p>The <code>xsl:function/@as</code> attribute defines the return type of the function.</p>
                  </li>
                  <li>
                     <p>The implementation of the function is defined by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> content
               of the <a href="#element-function"><code>xsl:function</code></a> element.</p>
                  </li>
               </ul>
               <p>An <a href="#element-function"><code>xsl:function</code></a> declaration can only appear as a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element in a stylesheet module.</p>
               <div class="div3">
                  
                  <h4><a id="xsl-function-name"></a>10.3.1 <a href="#xsl-function-name" style="text-decoration: none">Function Name and Arity</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#constructing-sequences">next</a> | <a href="#stylesheet-functions">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     Stylesheet functions may now be in no namespace, and may be invoked without
                     use of a namespace prefix, provided they are private to a package.
                  <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/657">657</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2235">2235</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/2200">2200</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/2236">2236</a>&nbsp;7 October 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>The name of the function is given by the <code>name</code>
                  attribute.</p>
                  <p>
                  <a id="err-XTSE0740"><span class="error">[ERR XTSE0740] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> has a name
                        that is in no namespace, unless the <a title="visibility" class="termref" href="#dt-visibility">visibility</a>
                     of the function is <code>private</code>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>XSLT 4.0 allows the function name to be unprefixed, provided that its
                  <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is <code>private</code>. This represents a QName
               in no namespace. A function call using an unprefixed function name is resolved to
               a no-namespace function name in preference to a function in the default function namespace,
               which for XSLT is always the <code>fn</code> namespace.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>To prevent the namespace URI used for the function name appearing in
                     the result document, use the <code>exclude-result-prefixes</code> attribute on
                     the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element: see <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>.</p>
                     <p>The name of the function must not be in a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>: <span class="error">[see <a href="#err-XTSE0080">ERR XTSE0080</a>]</span>
                  </p>
                  </div>
                  <p>The function parameters are defined by child <a href="#element-param"><code>xsl:param</code></a> elements. The parameters must have distinct names.
                  The list of parameters must contain zero or more required parameters, followed by zero or more optional parameters.
                  A parameter is optional if it has the attribute <code>required="no"</code>; otherwise, it is required.</p>
                  <p>The default value for an optional parameter can be defined using the <code>select</code> attribute or the 
               contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the <a href="#element-param"><code>xsl:param</code></a> element. These must be absent
               for a required parameter. If an optional parameter has no <code>select</code> attribute and the contained sequence
               constructor is empty, then the default value will be the empty sequence. This will lead to a type error if the
               required type of the parameter does not permit the empty sequence.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>When considering function overriding, dynamic function calls,
                  and details such as the <code>function-lookup</code> function, it is useful to think
                  of an <a href="#element-function"><code>xsl:function</code></a> declaration with optional parameters as a syntactic 
                  short-cut for a set of <a href="#element-function"><code>xsl:function</code></a> declarations of varying arity, each
                  of which calls the function with next-higher arity, supplying the default value of the parameter
                  explicitly in the function call.</p>
                     <p>This is not an exact equivalence, however, because of the rules allowing default values
                     of function parameters to be context-dependent.</p>
                  </div>
                  <p>The <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> derived from the 
                  <a href="#element-function"><code>xsl:function</code></a> declaration has an <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                  from <var>M</var> to <var>M</var>+<var>N</var>, where <var>M</var> is the number of required parameters
                  and <var>N</var> is the number of optional parameters. The arity range constrains the number of arguments
               that may appear in a call to this function.</p>
                  <p>For example, the following <a href="#element-function"><code>xsl:function</code></a> declaration
               declares a function, named <code>f:compare</code>, with an arity range of (2 to 3). 
                  The effect of calling <code>f:compare($a, $b)</code> is the same as the effect
               of calling <code>f:compare($a, $b, { "order": "ascending" })</code>.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:function name="f:compare" as="xs:boolean"&gt;
  &lt;xsl:param name="arg1" as="xs:double"/&gt;
  &lt;xsl:param name="arg2" as="xs:double"/&gt;
  &lt;xsl:param name="options" as="map(*)" 
             required="no" 
             select="{ 'order': 'ascending' }"/&gt;
  &lt;xsl:if test="$options?order = 'descending'" 
          then="$arg1 gt $arg2" 
          else="$arg2 gt $arg1"/&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Functions are not polymorphic. Although the XPath function call mechanism
                     allows two functions to have the same name and 
                     <span>non-overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a></span>, 
                     it does not allow them to be distinguished
                     by the types of their arguments.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="function-arguments"></a>10.3.2 <a href="#function-arguments" style="text-decoration: none">Parameters</a></h4>
                  <p>The <a href="#element-param"><code>xsl:param</code></a> elements define the formal parameters to the
                  function. In a static function call, these are referenced either positionally or by name.
                  The rules for associating arguments in a static function call with parameter definitions
                  in the function declaration are given in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-eval-static-function-call">4.6.1.2 Evaluating Static Function Calls</a>.</p>
                  <p>
                  <a id="err-XTSE0760"><span class="error">[ERR XTSE0760] </span></a>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of
                        an <a href="#element-function"><code>xsl:function</code></a> element has either a <code>select</code>
                        attribute or non-empty content<span>, unless it
                        specifies <code>required="no"</code>.</span>
               </p>
                  <p>
                  <a id="err-XTSE0761"><span class="error">[ERR XTSE0761] </span></a>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of
                        an <a href="#element-function"><code>xsl:function</code></a> element specifies
                     <code>required="no"</code>, unless all following-sibling
                        <a href="#element-param"><code>xsl:param</code></a> elements also specify <code>required="no"</code>.
               </p>
                  <p>The <code>as</code> attribute of the <a href="#element-param"><code>xsl:param</code></a> element defines
                  the required type of the parameter. The rules for converting the values of the
                  actual arguments supplied in the function call to the types required by each
                     <a href="#element-param"><code>xsl:param</code></a> element, and the
                     errors that can occur, are defined in <a href="#xpath-40">[XPath 4.0]</a>. The
                  rules that apply are those for the case where <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is set to <code>false</code>.</p>
                  <p>If the <code>as</code> attribute is omitted, no conversion takes place and any
                  value is accepted.</p>
                  <p>The default value for an optional parameter 
                  (one with <code>required="no"</code>) will often be supplied using a 
                  simple literal or constant expression, for example
                  <code>&lt;xsl:param name="married" as="xs:boolean" select="false()"/&gt;</code>,
                  or <code>&lt;xsl:param name="options" as="map(*)" select="{}"/&gt;</code>. 
                  However, to allow greater flexibility,
                  the default value can also be context-dependent. For example, 
                  <code>&lt;xsl:param name="node" as="node()" select="."/&gt;</code> declares a parameter whose
                  default value is the context item from the dynamic context of the caller, while 
                  <code>&lt;xsl:param name="collation" as="xs:string" select="default-collation()"/&gt;</code>
                  declares a parameter whose default value is the default collation from the dynamic context of the caller.
                  The detailed rules are as follows. In these rules, the term <b>caller</b> means the function call or function reference
                  that invokes the function being defined.</p>
                  <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup> for the 
                  initializing expression of an optional parameter of an <a href="#element-function"><code>xsl:function</code></a> declaration
                  is the same as the static context for a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>.</p>
                  <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-context">dynamic context</a><sup><small>XP</small></sup> for the initializing 
                  expression of an optional parameter 
                  is the same as the dynamic context for the evaluation of a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>, 
                  with the following exceptions:</p>
                  <ul>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup>, <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-position">context position</a><sup><small>XP</small></sup>,
                     and <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-size">context size</a><sup><small>XP</small></sup> are taken from the dynamic context of the caller.</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-def-collation">default collation</a><sup><small>XP</small></sup> and <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-executable-base-uri">Executable Base URI</a><sup><small>XP</small></sup>
                  are taken from the dynamic context of the caller.</p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The effect of these rules is that the <code>select</code> expression for an optional parameter
               is evaluated in the same way as a static expression, except that it may contain context-dependent
               subexpressions such as <code>.</code>, <code>position()</code>, <code>last()</code>,
               <code>static-base-uri()</code>, and <code>default-collation()</code> to access the
               dynamic context of the caller. It may also contain expressions such as <code>name()</code>
               or <code>@x = "abc"</code> that have an implicit dependency on the dynamic context of the caller.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="function-result"></a>10.3.3 <a href="#function-result" style="text-decoration: none">Function Result</a></h4>
                  <p>The result of the function<span>, if all arguments are supplied,</span> 
                  is the result of evaluating the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p>
                  <p>If a reduced-arity form of the function is invoked by omitting optional arguments, then
               the result of the function is obtained by evaluating the sequence constructor after binding the
               omitted arguments to their default values, which are obtained by evaluating the <code>select</code>
               attribute or sequence constructor of the relevant <a href="#element-param"><code>xsl:param</code></a> element, as
               described in <a href="#default-values-of-parameters"><i>9.2.2 Default Values of Parameters</i></a>.</p>
                  <p>Within the sequence constructor, the <a title="focus" class="termref" href="#dt-focus">focus</a> is
                  initially <a title="absent" class="termref" href="#dt-absent">absent</a>; this means that any attempt
                  to reference the context item, context position, or context size is a 
                  <a title="type error" class="termref" href="#dt-type-error">type error</a>. (See <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.)</p>
                  <p>It is not possible within the body of the <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> to access the values of local variables that
                  were in scope in the place where the function call was written. Global variables,
                  however, remain available.</p>
                  <p>The optional <code>as</code> attribute indicates the <a title="required type" class="termref" href="#dt-required-type">required type</a> of the result of the function.
                  The value of the <code>as</code> attribute is a
                  <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a>.</p>
                  <p>
                  <a id="err-XTTE0780"><span class="error">[ERR XTTE0780] </span></a>If the <code>as</code> attribute  is specified, then the result evaluated by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see
                           <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>) is converted to the required
                        type, using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. It is a <a title="type error" class="termref" href="#dt-type-error">type
                           error</a> if this conversion fails. If the <code>as</code> attribute is omitted, the calculated result is
                  used as supplied, and no conversion takes place.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Using the <a href="#element-value-of"><code>xsl:value-of</code></a> instruction to deliver the function
               result is generally a mistake, except in the rare case where the function is actually
               intended to return a text node. For functions that return atomic items such as strings,
               numbers, or booleans, using <a href="#element-sequence"><code>xsl:sequence</code></a> or <a href="#element-select"><code>xsl:select</code></a>
               is generally better because it avoids wrapping the value in a text node and then immediately
               unwrapping it again, with possible loss of type information.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="function-visibility-and-overriding"></a>10.3.4 <a href="#function-visibility-and-overriding" style="text-decoration: none">Visibility and Overriding of Functions</a></h4>
                  <p>It is possible to have multiple function declarations sharing the same function name and arity:</p>
                  <ul>
                     <li>
                        <p>Multiple <a href="#element-function"><code>xsl:function</code></a> declarations 
                     are allowed within a single <a title="package" class="termref" href="#dt-package">package</a> if they have different
                     <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
                     </li>
                     <li>
                        <p>A function declared using <a href="#element-function"><code>xsl:function</code></a>
                  may have the same name and arity as an <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>.</p>
                     </li>
                     <li>
                        <p>A function declared within one package may be overridden
                  (using <a href="#element-override"><code>xsl:override</code></a>) in another package.</p>
                     </li>
                  </ul>
                  <p>The rules governing these three scenarios are given in the sections that follow.</p>
                  <div class="div4">
                     
                     <h5><a id="function-overriding-within-package"></a>10.3.4.1 <a href="#function-overriding-within-package" style="text-decoration: none">Overriding Functions within a Package</a></h5>
                     <p>Two stylesheet functions with the same name may appear in a package if their
                  <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a> do not overlap. Neither overrides the other;
                  the function that is selected is determined by the arity of the function call or function reference.</p>
                     <p>In addition, a stylesheet function may be overridden by another stylesheet function with the same name that
                     has higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. Such overriding is only allowed, however, if the 
                     <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> of the overriding function
                     includes the totality of the arity range of the overridden function.</p>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-eclipsed" title="eclipsed"></a>An <a href="#element-function"><code>xsl:function</code></a> declaration
                     <var>F</var> is said to be <b>eclipsed</b> if the containing package includes 
                     an <a href="#element-function"><code>xsl:function</code></a> declaration
                     <var>G</var> such that <var>F</var> and <var>G</var> have the same name, <var>F</var> has lower
                     <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                     of <var>G</var> includes the totality of the arity range of <var>F</var>.<span class="definition">]</span></p>
                     <p>
                     <a id="err-XTSE0769"><span class="error">[ERR XTSE0769] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to
                           contain an <a href="#element-function"><code>xsl:function</code></a>
                           declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration
                           <var>G</var> such that <var>F</var> and <var>G</var> have the same 
                           <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, <var>F</var> has lower
                           <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the 
                           <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                           of <var>G</var> includes part but not all of the arity range of <var>F</var>,
                           unless <var>G</var> is itself <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another 
                           <a href="#element-function"><code>xsl:function</code></a> declaration.
                  </p>
                     <p>
                     <a id="err-XTSE0770"><span class="error">[ERR XTSE0770] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to
                           contain an <a href="#element-function"><code>xsl:function</code></a>
                           declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration
                           <var>G</var> such that <var>F</var> and <var>G</var> have the same 
                           <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same
                           <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, if the 
                           <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a>
                           of <var>F</var> and <var>G</var> overlap in whole or in part, 
                           unless <var>F</var> and <var>G</var> are both <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another 
                           <a href="#element-function"><code>xsl:function</code></a> declaration.
                  </p>
                     <p>Similarly it is a static error
                     <span class="error">[see <a href="#err-XTDE0770">ERR XTDE0770</a>]</span> for 
                           a <a title="package" class="termref" href="#dt-package">package</a> to
                           contain an <a href="#element-function"><code>xsl:function</code></a>
                     declaration <var>F</var> that is not <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another 
                     <a href="#element-function"><code>xsl:function</code></a> declaration, if its name and arity range conflict
                           with a constructor function in the static context. There will be a constructor
                  function (with arity 1) in the static context for every atomic type or plain union type
                  in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>.
                  </p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="overriding-extension-functions"></a>10.3.4.2 <a href="#overriding-extension-functions" style="text-decoration: none">Overriding Extension Functions</a></h5>
                     <p>The optional <code>override-extension-function</code> attribute defines what
                     happens if an <a href="#element-function"><code>xsl:function</code></a> declaration has the same name and 
                     overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> 
                     as a function provided by the implementer or made available in
                     the static context using an implementation-defined mechanism. If the <code>override-extension-function</code> attribute
                     has the value <code>yes</code>, then this function is used in preference; if it
                     has the value <code>no</code>, then the other function is used in preference. The
                     default value is <code>yes</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Specifying <code>override-extension-function="yes"</code> ensures
                        interoperable behavior: the same code will execute with all processors.
                        Specifying <code>override-extension-function="no"</code> is useful when
                        writing a fallback implementation of a function that is available with some
                        processors but not others: it allows the vendor’s implementation of the
                        function (or a user’s implementation written as an extension function)
                        to be used in preference to the stylesheet implementation, which is useful when
                        the extension function is more efficient.</p>
                        <p>The <code>override-extension-function</code> attribute does <em>not</em>
                        affect the rules for deciding which of several <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> with the same
                        name and overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> takes precedence.</p>
                     </div>
                     <p>The <code>override</code> attribute is a <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a> synonym of <code>override-extension-function</code>,
                     retained for compatibility with XSLT 2.0. If both attributes are present then they
                     <span class="verb">must</span> have the same value.</p>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="overriding-functions-in-used-packages"></a>10.3.4.3 <a href="#overriding-functions-in-used-packages" style="text-decoration: none">Overriding Functions in a Used Package</a></h5>
                     <p>When a package is referenced in <a href="#element-use-package"><code>xsl:use-package</code></a>, functions
               declared in the used package become available in the using package, conditional
               on their declared <a title="visibility" class="termref" href="#dt-visibility">visibility</a>, as described 
                  in <a href="#packages"><i>3.4 Packages</i></a>.</p>
                     <p>If the <code>visibility</code> attribute of <a href="#element-function"><code>xsl:function</code></a> is present with the
                  value <code>abstract</code> then the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
                  defining the function body <span class="verb">must</span> be empty.</p>
                     <p>The XPath specification states that the function that is executed as the result of
                  a function call is identified by looking in the static context for a 
                  <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> whose name and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                  match the name and number of arguments in the function call. In XSLT 3.0, final determination of the function to be called cannot be
                     made until all packages have been assembled: see <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>XSLT 4.0 allows a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> to be in no namespace,
                  provided that its <a title="visibility" class="termref" href="#dt-visibility">visibility</a> is local to a package.
                  A static function call or named function reference using an unprefixed lexical QName
                  is resolved first by looking for no-namespace functions,
                  then for functions in the standard namespace <code>http://www.w3.org/2005/xpath-functions</code>.
                  A no-namespace function might be a private <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>
                  declared within the same package, or it might be (for example) a constructor function
                  for a user-defined atomic type in an imported no-namespace schema; it will never, however,
                  be a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> imported or overridden from a different package,
                  so the rules for referencing functions across packages do not come into play.</p>
                     </div>
                     <p>An <a href="#element-function"><code>xsl:function</code></a> declaration defines a
                  <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> which forms a
                     <a title="component" class="termref" href="#dt-component">component</a> in its containing <a title="package" class="termref" href="#dt-package">package</a>,
                  unless </p>
                     <ul>
                        <li>
                           <p>it is <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a>, or</p>
                        </li>
                        <li>
                           <p>the <code>override-extension-function</code> or <code>override</code>
                        attribute has the value <code>no</code> and there is already a 
                        <a title="function definition" class="termref" href="#dt-function-definition">function definition</a> 
                        with the same name and an overlapping <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                         in the static context.</p>
                        </li>
                     </ul>
                     <p>The optional <code>override-extension-function</code> attribute defines what
                  happens if this function has the same name and an 
                  <span><a title="arity range" class="termref" href="#dt-arity-range">arity range</a> that conflicts 
                  with a function</span> provided by the implementer or made available in
                  the static context using an implementation-defined mechanism. If the <code>override-extension-function</code> attribute
                  has the value <code>yes</code>, then this function is used in preference; if it
                  has the value <code>no</code>, then the other function is used in preference. The
                  default value is <code>yes</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>Specifying <code>override-extension-function="yes"</code> ensures
                     interoperable behavior: the same code will execute with all processors.
                     Specifying <code>override-extension-function="no"</code> is useful when
                     writing a fallback implementation of a function that is available with some
                     processors but not others: it allows the vendor’s implementation of the
                     function (or a user’s implementation written as an extension function)
                     to be used in preference to the stylesheet implementation, which is useful when
                     the extension function is more efficient.</p>
                        <p>The <code>override-extension-function</code> attribute does <em>not</em>
                     affect the rules for deciding which of several 
                     <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> with the same
                     name and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> takes precedence.</p>
                     </div>
                     <p>The <code>override</code> attribute is a <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a> synonym of <code>override-extension-function</code>,
                  retained for compatibility with XSLT 2.0. If both attributes are present then they
                     <span class="verb">must</span> have the same value.</p>
                     <p>When the <a href="#element-function"><code>xsl:function</code></a> declaration appears as a
                  child of <a href="#element-override"><code>xsl:override</code></a>, there <span class="verb">must</span> be a
                  <a title="compatible" class="termref" href="#dt-compatible">compatible</a> stylesheet function in the 
                  <a title="package" class="termref" href="#dt-package">package</a> referenced by the containing
                     <a href="#element-use-package"><code>xsl:use-package</code></a> element; the <a title="visibility" class="termref" href="#dt-visibility">visibility</a> 
                  of that function must be <code>public</code> or
                  <code>abstract</code> (See also <a href="#package-overriding-components"><i>3.4.4.3 Overriding Components from a Used Package</i></a>.)</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="function-lookup"></a>10.3.5 <a href="#function-lookup" style="text-decoration: none">Dynamic Access to Functions</a></h4>
                  <p>If a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                     function</a> with a particular <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                     QName</a> and <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> exists in the
                  stylesheet, then a call to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> function
                  <span>will return the function as a value if it supplies that name and an arity within that range</span>. This applies
                  only if the static context for the call on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>
                  includes the stylesheet function, which implies that the function is visible in
                  the containing package.</p>
                  <p>The <a href="#func-function-available"><code>function-available</code></a> function, when
                  called with a particular <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>
                  and arity, returns <code>true</code> if and only if a call on
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> with the same arguments, in the same
                  static context, would return a function item.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>For legacy reasons there is also a single-argument version of
                        <a href="#func-function-available"><code>function-available</code></a>, which returns <code>true</code> if there is a
                     function with the given name regardless of arity.</p>
                  </div>
                  <p>The standard rules for
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> require that if the supplied name and
                  arity identify a context-dependent function such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-name"><code>name#0</code></a>
                  or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-lang"><code>lang#1</code></a> (call it <var>F</var>), then the returned
                  function value includes in its closure a copy of the static and dynamic context of
                  the call to <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>, and the context item for a
                  subsequent dynamic call of <var>F</var> is taken from this saved context. In the
                  case where the context item is a node in a streamed input document, saving the
                  node is not possible. In this case, therefore, the context is saved with an absent
                  focus, so the call on <var>F</var> will fail with a dynamic error saying that
                  there is no context item available.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="function-determinism"></a>10.3.6 <a href="#function-determinism" style="text-decoration: none">Determinism of Functions</a></h4>
                  <p>Stylesheet functions have been designed to be largely deterministic: unless a
                  stylesheet function calls some <a title="extension function" class="termref" href="#dt-extension-function">extension
                     function</a> which is itself nondeterministic, the function will return
                  results that depend only on the supplied arguments. This property (coupled with
                  the fact that the effect of calling extension functions is entirely <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>) enables a processor to implement various
                  optimizations, such as removing invariant function calls from the body of a loop,
                  or combining common subexpressions.</p>
                  <p>One exception to the intrinsic determinism of stylesheet functions arises because
                  constructed nodes have distinct identity. This means that when a function that
                  creates a new node is called, two calls on the function will return nodes that can
                  be distinguished: for example, with such a function, <code>f:make-node() is
                     f:make-node()</code> will return <code>false</code>.</p>
                  <p>Three classes of functions can be identified:</p>
                  <ol class="enumar">
                     <li>
                        <p><a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">Deterministic</a><sup><small>FO</small></sup>
                        functions: as the term is defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>,
                        these offer a guarantee that when a function is called repeatedly with the
                        same arguments, it returns the same results. A classic example is the
                           <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function, which offers the guarantee that
                           <code>doc($X) is doc($X)</code>: that is, two calls supplying the same
                        URI return the same node.</p>
                     </li>
                     <li>
                        <p>Proactive functions: these offer the guarantee that each invocation of the
                        function causes a single execution of the function body, or behaves exactly
                        as if it did so. In particular this means that when the function creates new
                        nodes, it creates new nodes on each invocation. By default, <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> are
                        proactive.</p>
                     </li>
                     <li>
                        <p>Elidable functions: these offer no guarantee of determinism, and no
                        guarantee of proactive evaluation. If the function creates new nodes, then
                        two calls on the function with the same arguments may or may not return the
                        same nodes, at the implementation’s discretion. Examples of elidable functions include
                        the <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> functions
                           <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a> and
                           <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-json-to-xml"><code>json-to-xml</code></a>.</p>
                     </li>
                  </ol>
                  <p>The <code>new-each-time</code> attribute of <a href="#element-function"><code>xsl:function</code></a> allows a
                  stylesheet function to be assigned to one of these three categories. The value
                     <code>new-each-time="no"</code> means the function is deterministic; the value
                     <code>new-each-time="yes"</code> means it is proactive; and the value
                     <code>new-each-time="maybe"</code> means it is elidable.</p>
                  <p>The definition of <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">determinism</a><sup><small>FO</small></sup> 
                  requires a definition of what it means for a function
                  to be called twice with “the same” arguments and to return “the same” result. This
                  is defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>, specifically by the definition
                  of the term <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-identical">identical</a><sup><small>FO</small></sup>.</p>
                  <p>Processors have considerable freedom to optimize execution of stylesheets, and of
                  function calls in particular, but the strategies that are adopted must respect the
                  specification as to whether functions are deterministic, proactive, or elidable.
                  For example, consider a function call that appears within an
                     <a href="#element-for-each"><code>xsl:for-each</code></a> instruction, where the supplied arguments to the
                  function do not depend on the context item or on any variables declared within the
                     <a href="#element-for-each"><code>xsl:for-each</code></a> instruction. A possible optimization is to
                  execute the function call only once, rather than executing it repeatedly each time
                  round the loop (this is sometimes called loop-lifting). This optimization is safe
                  when the function is deterministic or elidable, but it requires great care if the
                  function is proactive; it is permitted only if the processor is able to determine
                  that the results of stylesheet execution are equivalent to the results that would
                  be obtained if the optimization had not been performed. Declaring a function call
                  to be elidable (by writing <code>new-each-time="maybe"</code>) makes it more
                  likely that an implementation will be able to apply this optimization, as well as
                  other optimizations such as caching or memoization.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="memoization"></a>10.3.7 <a href="#memoization" style="text-decoration: none">Memoization</a></h4>
                  <p>The <code>cache</code> attribute is an optimization hint which the processor can
                  use or ignore at its discretion; however it <span class="verb">should</span> be taken
                  seriously, because it may make a difference to whether execution of a stylesheet
                  is practically feasible or not.</p>
                  <p>The default value is <code>cache="no".</code></p>
                  <p>The value <code>cache="yes"</code> encourages the processor to retain memory of
                     previous calls of this function
                  during the same transformation and to reuse results from this memory whenever
                  possible. The default value <code>cache="no"</code> encourages the
                  processor not to retain memory of previous calls.</p>
                  <p>In all cases the results must respect the semantics. If a function is proactive
                     (<code>new-each-time="yes"</code>) then caching of results may be infeasible,
                  especially if the function result can include nodes; but it is not an error to
                  request it, since some implementations may be able to provide caching, or
                  analogous optimizations, even for proactive functions. (One possible strategy is
                  to return a copy of the cached result, thus creating the illusion that the
                  function has been evaluated anew.)</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Memoization is essentially a trade-off between time and space; a memoized
                     function can be expected to use more memory to deliver faster execution.
                     Achieving an optimum balance may require configuring the size of the cache that
                     is used; implementations <span class="verb">may</span> use additional <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a> or other
                     mechanisms to provide finer control of this kind.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Memoization of a function generally involves creating an associative table (for
                     example, a hash map) that maps argument values to function results. To get this
                     right, it is vital that the key for this table should correctly reflect what it
                     means for two function calls to have “the same arguments”. Does it matter, for
                     example, that one call passes the <code>xs:string</code> value <code>"Paris"</code>, while
                     another passes the <code>xs:untypedAtomic</code> item <code>"Paris"</code>? If the function
                     is declared with <code>new-each-time="maybe"</code>, then the rules say that
                     these cannot be treated as “the same arguments”: the definition of 
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-identical">identical</a><sup><small>FO</small></sup> requires them to have the same type
                     as well as being equal. However, an implementation that is able to determine
                     that all references to the argument within the function body only make use of
                     its string value might be able to take advantage of this fact, and thus perform
                     more efficient caching.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="function-examples"></a>10.3.8 <a href="#function-examples" style="text-decoration: none">Examples of Stylesheet Functions</a></h4>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e32166"></a>Example: A Stylesheet Function</div>
                     <p>The following example creates a recursive <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> named <code>str:reverse</code> that reverses
                     the words in a supplied sentence, and then invokes this function from within a
                        <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>. </p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:transform 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:str="http://example.com/namespace"
  version="3.0"
  expand-text="yes"
  exclude-result-prefixes="str"&gt; 

&lt;xsl:function name="str:reverse" as="string"&gt;
  &lt;xsl:param name="sentence" as="string"/&gt;
  &lt;xsl:if test="contains($sentence, ' ')"
             then="str:reverse(substring-after($sentence, ' ')) ||
                         ' ' || substring-before($sentence, ' ')"
             else="$sentence"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:template match="/"&gt;
  &lt;output&gt;{str:reverse('DOG BITES MAN')}&lt;/output&gt;
&lt;/xsl:template&gt;

&lt;/xsl:transform&gt;</pre>
                     </div>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e32181"></a>Example: Declaring the Return Type of a Function</div>
                     <p>The following example illustrates the use of the <code>as</code> attribute in a
                     function definition. It returns a string containing the representation of its
                     integer argument, expressed as a roman numeral. For example, the function call
                        <code>num:roman(7)</code> will return the string <code>"vii"</code>. This
                     example uses the <a href="#element-number"><code>xsl:number</code></a> instruction, described in 
                     <a href="#number"><i>12 Numbering</i></a>. The <a href="#element-number"><code>xsl:number</code></a> instruction returns a text
                     node, and the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> are invoked to convert this text node to the type declared
                     in the <a href="#element-function"><code>xsl:function</code></a> element, namely <code>xs:string</code>. So
                     the text node is <a title="atomize" class="termref" href="#dt-atomization">atomized</a> to a
                     string.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="num:roman" as="xs:string"&gt;
  &lt;xsl:param name="value" as="xs:integer"/&gt;
  &lt;xsl:number value="$value" format="i"/&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e32213"></a>Example: A Higher-Order Function</div>
                     <p>XPath 3.0 introduces the ability to pass function items as arguments to a
                     function. A function that takes function items as arguments is known as a
                     higher-order function.</p>
                     <p>The following example is a higher-order function that operates on any
                     tree-structured data, for example an organization chart. Given as input a
                     function that finds the direct subordinates of a node in this tree structure
                     (for example, the direct reports of a manager, or the geographical subdivisions
                     of an administrative area), it determines whether one object is present in the
                     subtree rooted at another object (for example, whether one person is among the
                     staff managed directly or indirectly by a manager, or whether one parcel of
                     land is contained directly or indirectly within another parcel). The function
                     does not check for cycles in the data.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="f:is-subordinate" as="xs:boolean"&gt;
    &lt;xsl:param name="superior" 
               as="node()"/&gt;
    &lt;xsl:param name="subordinate" 
               as="node()"/&gt;
    &lt;xsl:param name="get-direct-children" 
               as="fn(node()) as node()*"/&gt;
    &lt;xsl:select&gt;
               some $sub in $get-direct-children($superior) satisfies
                 ($sub is $subordinate or
                  f:is-subordinate($sub, $subordinate, 
                                      $get-direct-children))
    &lt;/xsl:select&gt;                                   
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>(This example is written to use the <a href="#element-select"><code>xsl:select</code></a> instruction,
                  newly introduced in XSLT 4.0, to compute the function result.)</p>
                     <p>Given source data representing an organization chart in the form of elements
                     such as:</p>
                     <div class="exampleInner">
                        <pre>&lt;employee id="P57832" manager="P68951"/&gt;</pre>
                     </div>
                     <p>the following function can be defined to get the direct reports of a
                     manager:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="f:direct-reports" 
               as="element(employee)*"&gt;
    &lt;xsl:param name="manager" as="element(employee)"/&gt;
    &lt;xsl:sequence select="$manager/../employee
                               [@manager = $manager/@id]"/&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>It is then possible to test whether one employee <code>$E</code> reports
                     directly or indirectly to another employee <code>$M</code> by means of the
                     function call:</p>
                     <div class="exampleInner">
                        <pre>f:is-subordinate($M, $E, f:direct-reports#1)</pre>
                     </div>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="static-xpath-evaluation"></a>10.4 <a href="#static-xpath-evaluation" style="text-decoration: none">Static XPath Evaluation</a></h3>
               <p>The two instructions described in this section, <code>xsl:sequence</code>
            and <code>xsl:select</code>, can be used to evaluate XPath expressions that
            are statically known: that is, the XPath expressions are statically processed
            during the static processing of the stylesheet, and are dynamically evaluated
            during the dynamic evaluation of the stylesheet. The <a href="#element-sequence"><code>xsl:sequence</code></a>
            instruction can also be used to evaluate a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p>
               <div class="div3">
                  
                  <h4><a id="constructing-sequences"></a>10.4.1 <a href="#constructing-sequences" style="text-decoration: none">The <code>xsl:sequence</code> Instruction</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#select-instruction">next</a> | <a href="#xsl-function-name">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                  An <code>as</code> attribute is available on the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/46">46</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1306">1306</a>&nbsp;27 June 2024]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-sequence"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:sequence<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sequence&gt;</code></p>
                  <p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction may be used within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> to construct a
               sequence of nodes, atomic items, and/or function
                  items. This sequence is returned as the result of the instruction. Unlike
               most other instructions, <a href="#element-sequence"><code>xsl:sequence</code></a> can return a sequence
               containing existing nodes, rather than constructing new nodes. When
                  <a href="#element-sequence"><code>xsl:sequence</code></a> is used to select atomic items or function items, the effect is very similar to the
                  <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction.</p>
                  <p>The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
               are mutually exclusive; if the instruction
               has a <code>select</code> attribute, then it <span class="verb">must</span> have no children
               other than <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. If there is no
               <code>select</code> attribute and no contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, 
               the result is the empty sequence. 
            </p>
                  <p>The effect of the instruction is as follows:</p>
                  <ol class="enumar">
                     <li>
                        <p>Evaluate the expression in the <code>select</code> attribute if present, 
                  or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> otherwise. Call the result <var>T</var>.</p>
                     </li>
                     <li>
                        <p>Use the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert <var>T</var> to the sequence
               type appearing in the <code>as</code> attribute, defaulting to <code>item()*</code>.
               The converted result is the value returned by the <a href="#element-sequence"><code>xsl:sequence</code></a>
               instruction.</p>
                     </li>
                  </ol>
                  <p>
               <a id="err-XTSE3185"><span class="error">[ERR XTSE3185] </span></a>For the elements <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-on-empty"><code>xsl:on-empty</code></a>,
                     <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>, <a href="#element-when"><code>xsl:when</code></a>,
                     <a href="#element-otherwise"><code>xsl:otherwise</code></a>, <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>,
                     <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>, <a href="#element-map"><code>xsl:map</code></a>,
                     <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-array-member"><code>xsl:array-member</code></a>,
                     and <a href="#element-result-document"><code>xsl:result-document</code></a>,
                     it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute is present
                     and the instruction has children other than <a href="#element-fallback"><code>xsl:fallback</code></a>.
            </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction was first introduced in XSLT 2.0, so the <code>xsl:fallback</code>
               instruction is relevant only to an XSLT 1.0 processor operating in forwards compatibility mode.</p>
                     <p>An XSLT 2.0 or 3.0 processor operating in forwards compatibility mode will ignore the <code>@as</code>
               attribute.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <a href="#element-sequence"><code>xsl:sequence</code></a> instruction is most commonly used as the final instruction
            in the body of <a href="#element-function"><code>xsl:function</code></a>, to compute the result of the function. If the result
            is a single item, consider writing <code>&lt;xsl:sequence select="..." as="item()"/&gt;</code> to
            make this clear to the reader.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The main use case for allowing <a href="#element-sequence"><code>xsl:sequence</code></a> to contain a sequence
                  constructor is to allow the instructions within an <a href="#element-fork"><code>xsl:fork</code></a>
                  element to be divided into groups.</p>
                     <p>It can also be used to limit the scope of local variables or of standard
                  attributes such as <code>[xsl:]default-collation</code>.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e32412"></a>Example: Constructing a Sequence of Integers</div>
                     <p>The following code:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="values" as="xs:integer*"&gt;
    &lt;xsl:sequence select="(1,2,3,4)"/&gt;
    &lt;xsl:sequence select="(8,9,10)"/&gt;
&lt;/xsl:variable&gt;
&lt;xsl:value-of select="sum($values)"/&gt;</pre>
                     </div>
                     <p>produces the output: <code>37</code>
               </p>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e32422"></a>Example: Using <code>xsl:for-each</code> to Construct a Sequence</div>
                     <p>The following code constructs a sequence containing the value of the
                     <code>@price</code> attribute for selected elements, 
                  or a computed price for those elements that
                  have no <code>@price</code> attribute:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:variable name="prices" as="xs:decimal*"&gt;
   &lt;xsl:for-each select="//product"&gt;
      &lt;xsl:sequence select="@price otherwise @cost * 1.5" as="xs:decimal"/&gt;
   &lt;/xsl:for-each&gt;
&lt;/xsl:variable&gt;</pre>
                     </div>
                     <p>Note that the existing <code>@price</code> attributes could equally have been
                  added to the <code>$prices</code> sequence using <a href="#element-copy-of"><code>xsl:copy-of</code></a> or
                     <a href="#element-value-of"><code>xsl:value-of</code></a>. However, <a href="#element-copy-of"><code>xsl:copy-of</code></a> would
                  create a copy of the attribute node, which is not needed in this situation, while
                     <a href="#element-value-of"><code>xsl:value-of</code></a> would create a new text node, which then has to
                  be converted to an <code>xs:decimal</code>. Using <a href="#element-sequence"><code>xsl:sequence</code></a>,
                  which in this case atomizes the existing attribute node and adds an
                     <code>xs:decimal</code> atomic item to the result sequence, is a more direct
                  way of achieving the same result.</p>
                     <p>This example could alternatively be solved at the XPath level:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:sequence select="//product/(+@price otherwise @cost*1.5))"/&gt;</pre>
                     </div>
                     <p>or, in XSLT 4.0:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:select&gt;//product/(+@price otherwise @cost*1.5))&lt;/xsl:select&gt;</pre>
                     </div>
                     <p>The apparently redundant <code>+</code> operator is there to atomize the attribute
                  value: the expression on the right hand side of the <code>/</code> operator must
                  not return a  sequence containing both nodes and
                     non-nodes (atomic items or function items).</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="select-instruction"></a>10.4.2 <a href="#select-instruction" style="text-decoration: none">The <code>xsl:select</code> Instruction</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#dynamic-xpath">next</a> | <a href="#constructing-sequences">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                  The <a href="#element-select"><code>xsl:select</code></a> instruction is new in 4.0.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2004">2004</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2008">2008</a>&nbsp;20 May 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-select"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:select<br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-fallback">xsl:fallback</a>*#PCDATA) --&gt;<br>&lt;/xsl:select&gt;</code></p>
                  <p>The <a href="#element-select"><code>xsl:select</code></a> instruction evaluates an XPath expression contained as a child node
            of the instruction. For example, the instruction:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:select as="map(*)"&gt;
   {  "title"  : $title,
      "author" : $author
   }
&lt;/xsl:select&gt;</pre>
                  </div>
                  <p>evaluates the contained XPath expression, in the current static and dynamic context,
            and returns (in this example) a map with two entries.</p>
                  <p>While the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction (with a <code>select</code> 
               attribute) can also be used to evaluate
            an arbitrary XPath expression and return its result, the <a href="#element-select"><code>xsl:select</code></a>
            instruction offers some potential advantages:</p>
                  <ul>
                     <li>
                        <p>An XPath expression written within an XML attribute is subjected by the
               XML parser to attribute value normalization, which changes the arrangement
               of whitespace within the value. While this will rarely affect the actual meaning
               of the expression, it can mean that formatting is lost. Multi-line attribute
               values are therefore best avoided. The loss of formatting also makes it difficult
               for an XSLT processor to provide precise error locations.</p>
                     </li>
                     <li>
                        <p>When an XPath expression appears in an attribute value, then one of the
               characters <span class="unicode-codepoint">U+0022</span> (<span class="unicode-name">QUOTATION MARK</span>, <code>"</code>)  or <span class="unicode-codepoint">U+0027</span> (<span class="unicode-name">APOSTROPHE</span>, <code>'</code>)  becomes unavailable for use
               with the expression, unless written as <code>&amp;quot;</code> or <code>&amp;apos;</code>
               respectively. When an expression is written within a text node, this problem does not
               arise, and both characters can be used without escaping.</p>
                     </li>
                     <li>
                        <p>The content of the <a href="#element-select"><code>xsl:select</code></a> instruction can be written
               as a CDATA section, allowing operators such as <code>&lt;</code> and <code>&lt;=</code>
               to be written without escaping.</p>
                     </li>
                     <li>
                        <p>The instruction name <a href="#element-sequence"><code>xsl:sequence</code></a> can easily
               confuse people reading the code in cases where the intent is to return a single
               item.</p>
                     </li>
                  </ul>
                  <p>With the increasing richness of the XPath language, expressions of ten or twenty lines
            become increasingly common, and this instruction makes such expressions more manageable.
            This often arises when constructing maps and arrays designed to be serialized as JSON.
            For example, a function might be defined that takes an element node as input and constructs
            a map containing selected information:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="f:book-to-json" as="map(*)"&gt;
   &lt;xsl:param name="book" as="element(book)"/            
   &lt;xsl:select&gt;
      {  "title"  : string($book/title),
         "isbn"   : string($book/isbn),
         "price"  : number($book/@price),
         "author" : array { $book/author ! string() },
         "date"   : current-date()"
      }
   &lt;/xsl:select&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
                  <p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> child instructions will be ignored by an 
            XSLT 4.0 processor, but will be evaluated by an XSLT 3.0 or earlier processor running
            in forwards compatible mode. An <a href="#element-fallback"><code>xsl:fallback</code></a> instruction may be preceded
            by a text node consisting entirely of whitespace, but must not be preceded by a text node
            containing non-whitespace characters. The XPath expression to be evaluated is therefore
            contained in the last text node child. (XML comments, processing instructions, and 
            <a href="#element-note"><code>xsl:note</code></a> elements will already have been removed.)</p>
                  <p>The effect of the <a href="#element-select"><code>xsl:select</code></a> instruction is as follows:</p>
                  <ol class="enumar">
                     <li>
                        <p>Let <var>E</var> be the string value of the last text node child of the
               instruction, if any.</p>
                     </li>
                     <li>
                        <p>If <var>E</var> is absent, zero-length, or consists entirely of whitespace,
               then let <var>V</var> be the empty sequence.</p>
                     </li>
                     <li>
                        <p>Otherwise, let <var>V</var> be the result of evaluating <var>E</var> as an XPath
                  expression in the current static and dynamic context.</p>
                     </li>
                     <li>
                        <p>The result of the <a href="#element-select"><code>xsl:select</code></a>
               instruction is the result of using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a> to convert <var>V</var>
                  to the type appearing in the <code>as</code> attribute, 
                  defaulting to <code>item()*</code>.</p>
                     </li>
                  </ol>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The text node cannot contain text value templates.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <a href="#element-select"><code>xsl:select</code></a> instruction requires the XPath expression to
            be known statically (though it can refer to variables whose value is dynamic). The 
            <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction, by contrast, can be used to evaluate
            XPath expressions that are constructed dynamically or read from an external document.
            The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is described in the next section.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Many instructions take their input either from an XPath expression
            contained in a <code>select</code> attribute, or from a sequence constructor
            forming the content of the instruction, the two options being mutually exclusive. 
            Instructions that follow this pattern
            include <a href="#element-break"><code>xsl:break</code></a>, <a href="#element-on-completion"><code>xsl:on-completion</code></a>, <a href="#element-catch"><code>xsl:catch</code></a>,
            <a href="#element-on-empty"><code>xsl:on-empty</code></a>, <a href="#element-when"><code>xsl:when</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
            and many others. In most of these cases, writing an XPath expression within
            a child <a href="#element-select"><code>xsl:select</code></a> element is equivalent to writing the same expression
            with a <code>select</code> attribute. However, there are a few subtle differences,
            for example in the case of <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-text"><code>xsl:text</code></a>, and <a href="#element-value-of"><code>xsl:value-of</code></a>,
            the default separator is different (a single space when a <code>select</code> attribute is used, a zero-length
            string for a sequence constructor comprising an <a href="#element-select"><code>xsl:select</code></a> instruction).</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="dynamic-xpath"></a>10.5 <a href="#dynamic-xpath" style="text-decoration: none">Dynamic XPath Evaluation</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#creating-text-nodes">next</a> | <a href="#select-instruction">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  A new attribute <code>trusted=yes|no</code> is added to <a href="#element-evaluate"><code>xsl:evaluate</code></a>
                  to indicate whether the XPath expression to be evaluated is trusted to access
                  external resources. The default value is <code>no</code>, which may cause backwards
                  incompatibility. Dynamic evaluation using <a href="#element-evaluate"><code>xsl:evaluate</code></a> is no longer
                  an optional feature of the XSLT language.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2047">2047</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213</a>&nbsp;23 October 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-evaluate"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:evaluate<br>&nbsp;&nbsp;<b>xpath</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;base-uri? = { <var>uri</var> }<br>&nbsp;&nbsp;with-params? = <var>expression</var><br>&nbsp;&nbsp;context-item? = <var>expression</var><br>&nbsp;&nbsp;namespace-context? = <var>expression</var><br>&nbsp;&nbsp;schema-aware? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;trusted? = { <var>boolean</var> }〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:evaluate&gt;</code></p>
               <p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction constructs an XPath expression in the
               form of a string, evaluates the expression in a specified context, and returns the
               result of the evaluation.</p>
               <p>The expression given as the value of the <code>xpath</code> attribute is evaluated
               and the result is converted to a string using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-target-expression" title="target expression"></a>The string that results
                  from evaluating the expression in the <code>xpath</code> attribute is referred to
                  as the <b>target expression</b>.<span class="definition">]</span></p>
               <p><a id="err-XTDE3160"><span class="error">[ERR XTDE3160] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a>
                      is
                     not a valid <a title="expression" class="termref" href="#dt-expression">expression</a> (that is, if a static error occurs when analyzing the string
                     according to the rules of the XPath specification).</p>
               <p>The <code>as</code> attribute, if present, indicates the required type of the result.
               If the attribute is absent, the required type is <code>item()*</code>, which allows
               any result. The result of evaluating the <a title="target expression" class="termref" href="#dt-target-expression">target
                  expression</a> is converted to the required type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. This may
               cause a <a title="type error" class="termref" href="#dt-type-error">type error</a> if conversion is not
               possible. The result after conversion is returned as the result of the
                  <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p>
               <p>The target expression may contain variable references; the values
               of such variables may be supplied using an <a href="#element-with-param"><code>xsl:with-param</code></a> child
               instruction if the names of the variables are known statically, or using a map
               supplied as the value of the expression in the <code>with-params</code> attribute if
               the names are only known dynamically. If the <code>with-params</code> attribute is
               present then it must contain an expression whose value, when evaluated, is of type
                  <code>map(xs:QName, item()*)</code> (see <a href="#map"><i>21 Maps</i></a> for details of
               maps).</p>
               <p>
               <a id="err-XTTE3165"><span class="error">[ERR XTTE3165] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                     result of evaluating the expression in the <code>with-params</code>
                     attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is
                     anything other than a single map of type
                     <code>map(xs:QName, item()*)</code>.
            </p>
               <div class="div3">
                  
                  <h4><a id="evaluate-static-context"></a>10.5.1 <a href="#evaluate-static-context" style="text-decoration: none">Static context for the target expression</a></h4>
                  <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-static-context">static context</a><sup><small>XP</small></sup> for
                  the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a> is as
                  follows:</p>
                  <ul>
                     <li>
                        <p>XPath 1.0 compatibility mode is <code>false</code>.</p>
                     </li>
                     <li>
                        <p>Trust level: the <a href="../xquery-40/xpath-40.html#">trust level</a><sup><small>XP</small></sup>
                     of the target expression is determined by the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                     of the <code>trusted</code> attribute. If the value is <code>yes</code>,
                     the target expression has the same level of trust, and may therefore access
                     the same external resources, as the calling stylesheet. If the value is 
                        <code>no</code>, the target expression has no access to external resources,
                     other than any resources made explicitly available via some secure
                     <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanism.</p>
                     </li>
                     <li>
                        <p>Statically known namespaces and default namespaces for 
                        elements and for types:</p>
                        <ul>
                           <li>
                              <p>if the <code>namespace-context</code> attribute is present, then its
                              value is an <a title="expression" class="termref" href="#dt-expression">expression</a> whose
                              required type is a single node. The expression is evaluated, and the
                              in-scope namespaces of the resulting node are used as the statically
                              known namespaces for the target expression. The binding for the
                              default namespace in the in-scope namespaces is used as the default
                              namespace for <span>both</span>
                              elements and types in the target expression.</p>
                              <p>
                              <a id="err-XTTE3170"><span class="error">[ERR XTTE3170] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                                    result of evaluating the <code>namespace-context</code>
                                    attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is
                                    anything other than a single node.
                           </p>
                           </li>
                           <li>
                              <p>if the <code>namespace-context</code> attribute is absent, then the
                              <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction
                              (with the exception of any binding for the default namespace) are used
                              as the statically known namespaces for the target expression, and the
                              value of the attribute <code>[xsl:]xpath-default-namespace</code>,
                              if present, is used to establish the default namespace for elements and
                              types in the target expression, as described in <a href="#unprefixed-qnames"><i>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</i></a>.</p>
                           </li>
                        </ul>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>XPath 3.0 allows expanded names to be written in a context-independent
                           way using the syntax <code>Q{namespace-uri}local-name</code></p>
                        </div>
                     </li>
                     <li>
                        <p>Default function namespace: the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function
                           namespace</a>.</p>
                     </li>
                     <li>
                        <p>In-scope schema definitions: if the <code>schema-aware</code> attribute is
                        present and has the <a title="effective value" class="termref" href="#dt-effective-value">effective
                           value</a>
                        <code>yes</code>, then the in-scope schema definitions from the stylesheet
                        context of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction (that is, 
                        the schema definitions imported using
                           <a href="#element-import-schema"><code>xsl:import-schema</code></a>, taking into account any <code>[xsl:]schema-role</code>
                        on the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction or on any of its ancestors). 
                        Otherwise, the built-in types (see
                           <a href="#built-in-types"><i>3.12 Built-in Types</i></a>).</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>If the containing stylesheet does not import a schema, then the in-scope schema definitions
                        for the target expression will contain only the built-in schema types, regardless of the value
                        of the <code>schema-aware</code> attribute.</p>
                        </div>
                     </li>
                     <li>
                        <p>In-scope variables: the names of the in-scope variables
                        are the union of the names appearing in the <code>name</code> attribute of
                        the contained <a href="#element-with-param"><code>xsl:with-param</code></a> elements, and the names
                        present as keys in the map obtained by evaluating the
                           <code>with-params</code> attribute, if present. The corresponding type is
                           <code>item()*</code> in the case of a name found as a key in the
                           <code>with-params</code> map, or the type named in the <code>as</code>
                        attribute of <a href="#element-with-param"><code>xsl:with-param</code></a> child (defaulting to
                           <code>item()*</code>) otherwise.</p>
                        <p>If a variable name is present both the static
                           <a href="#element-with-param"><code>xsl:with-param</code></a> children and also in the dynamic
                           <code>with-params</code> map, the value from the latter takes
                        precedence.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>Variables declared in the stylesheet in <a href="#element-variable"><code>xsl:variable</code></a> or
                              <a href="#element-param"><code>xsl:param</code></a> elements are <em>not</em> in-scope
                           within the target expression.</p>
                        </div>
                     </li>
                     <li>
                        <p>Function signatures:</p>
                        <ul>
                           <li>
                              <p>All functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> in the
                           <code>fn</code>, <code>math</code>, <code>map</code>, and <code>array</code> namespaces;</p>
                           </li>
                           <li>
                              <p>Constructor functions for named simple types included in the in-scope schema definitions;</p>
                           </li>
                           <li>
                              <p>All user-defined functions present in the containing package provided their visibility is
                           not <code>hidden</code> or <code>private</code>;</p>
                           </li>
                           <li>
                              <p>An <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of
                           <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>.</p>
                           </li>
                        </ul>
                        <p>Note that this set deliberately excludes XSLT-defined functions in the
                           <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function
                           namespace</a> including for example, <a href="#func-key"><code>key</code></a>,
                           <a href="#func-current-group"><code>current-group</code></a>, and
                           <a href="#func-system-property"><code>system-property</code></a>. A list of these functions is in
                           <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>.</p>
                     </li>
                     <li>
                        <p>Statically known collations: the same as the collations available at this
                        point in the stylesheet.</p>
                     </li>
                     <li>
                        <p>Default collation: the same as the default collation defined at this point
                        in the stylesheet (for example, by use of the
                           <code>[xsl:]default-collation</code> attribute)</p>
                     </li>
                     <li>
                        <p>Base URI: if the <code>base-uri</code> attribute is present, then its
                           <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>; otherwise,
                        the base URI of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.</p>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="evaluate-dynamic-context"></a>10.5.2 <a href="#evaluate-dynamic-context" style="text-decoration: none">Dynamic context for the target expression</a></h4>
                  <p>The dynamic context for evaluation of the target expression is
                  as follows:</p>
                  <ul>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup> depends on the result of evaluating the
                        expression in the <code>context-item</code> attribute. If this attribute is
                        absent then the context value,
                        position, and size for evaluation of the target expression are all <a title="absent" class="termref" href="#dt-absent">absent</a>. 
                        If the attribute is present then the result of evaluating the expression
                        is used as the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-context-value">context value</a><sup><small>XP</small></sup>, and the <a title="context position" class="termref" href="#dt-context-position">context position</a>
                        and <a title="context size" class="termref" href="#dt-context-size">context size</a> are both set to 1 (one).</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The attribute name <code>context-item</code> is a misnomer; it reflects the fact
                     that in XSLT 3.0, the supplied expression was required to return a single item, rather than
                     an arbitrary sequence.</p>
                        </div>
                     </li>
                     <li>
                        <p>The <b>variable values</b> consists of the values
                        bound to parameters defined either in the contained
                           <a href="#element-with-param"><code>xsl:with-param</code></a> elements, which are evaluated as
                        described in <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>, or in the map that results
                        from evaluation of the expression in the <code>with-params</code> attribute;
                        if the same QName is bound in both, the value in the
                           <code>with-params</code> map takes precedence.</p>
                     </li>
                     <li>
                        <p>The XSLT-specific aspects of the dynamic context described in <a href="#additional-dynamic-context"><i>5.3.4 Additional Dynamic Context Components used by XSLT</i></a> are all <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
                     </li>
                     <li>
                        <p>The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamically-known-function-definitions">dynamically known function definitions</a><sup><small>XP</small></sup>
                        (representing the functions accessible using <a href="#func-function-available"><code>function-available</code></a> or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>)
                        include all the functions available in the static context, and may also include an additional 
                        <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> set of functions that are available dynamically but not statically.
                     </p>
                     </li>
                     <li>
                        <p>All other aspects of the dynamic context are the same as the dynamic context
                        for the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction itself, except that an implementation <code>may</code> restrict
                           the availability of external resources (for example, available documents)
                           or provide options to restrict their availability, for security
                           reasons.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>For example, a processor may disallow access using the
                              <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions
                           to documents in local filestore.</p>
                        </div>
                     </li>
                  </ul>
               </div>
               <div class="div3">
                  
                  <h4><a id="evaluate-effect"></a>10.5.3 <a href="#evaluate-effect" style="text-decoration: none">The effect of the <code>xsl:evaluate</code> instruction</a></h4>
                  <p>The XPath expression is evaluated in the same <a href="https://qt4cg.org/specifications/xpath-functions-40/#execution-scope">execution scope</a><sup><small>FO</small></sup> as the calling XSLT transformation; this
                  means that the results of <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup> functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> or
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-current-dateTime"><code>current-dateTime</code></a> will be consistent between the calling
                  stylesheet and the called XPath expression.</p>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if evaluation of the
                  XPath expression fails with a dynamic error. The XPath-defined error code is used
                  unchanged.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Implementations wanting to avoid the cost of repeated compilation of the same
                     XPath expression should cache the compiled form internally.</p>
                  </div>
                  <p>Stylesheet authors need to be aware of the security risks
                  associated with the use of <a href="#element-evaluate"><code>xsl:evaluate</code></a>. The instruction should
                  not be used to execute code from an untrusted source. To avoid the risk of code
                  injection, user-supplied data should never be inserted into the expression using
                  string concatenation, but should always be referenced by use of parameters.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="evaluation-as-optional-feature"></a>10.5.4 <a href="#evaluation-as-optional-feature" style="text-decoration: none">Disabling <code>xsl:evaluate</code></a></h4>
                  <p>A processor <span class="verb">may</span> allow users, via some
                  <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> mechanism, to disable
                  the use of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.
                  It may either be <b>statically
                     disabled</b>, or <b>dynamically
                     disabled</b>.</p>
                  <p>If the feature is statically disabled, then:</p>
                  <ul>
                     <li>
                        <p>A call to <code>element-available('xsl:evaluate')</code> returns <code>false</code>,
                        wherever it appears;</p>
                     </li>
                     <li>
                        <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        returns the string <code>"no"</code>, wherever it appears;</p>
                     </li>
                     <li>
                        <p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction has an
                           <a href="#element-fallback"><code>xsl:fallback</code></a> child, fallback processing takes place;</p>
                     </li>
                     <li>
                        <p>No static error is raised if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is
                        present in the stylesheet (an error occurs only if it is actually
                        evaluated).</p>
                     </li>
                  </ul>
                  <p>If the feature is dynamically disabled, then:</p>
                  <ul>
                     <li>
                        <p>A call to <code>element-available('xsl:evaluate')</code> appearing in a
                           <a title="static expression" class="termref" href="#dt-static-expression">static expression</a> (for
                        example, in an <code>[xsl:]use-when</code> attribute) returns <code>true</code>;</p>
                     </li>
                     <li>
                        <p>A call to <code>element-available('xsl:evaluate')</code> appearing anywhere
                        else returns <code>false</code>;</p>
                     </li>
                     <li>
                        <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        appearing in a <a title="static expression" class="termref" href="#dt-static-expression">static
                           expression</a> (for example, in an <code>[xsl:]use-when</code>
                        attribute) returns the string <code>"yes"</code>;</p>
                     </li>
                     <li>
                        <p>A call to <code>system-property('xsl:supports-dynamic-evaluation')</code>
                        appearing anywhere else returns the string <code>"no"</code>;</p>
                     </li>
                     <li>
                        <p>If an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction has an
                           <a href="#element-fallback"><code>xsl:fallback</code></a> child, fallback processing takes place;</p>
                     </li>
                     <li>
                        <p>In the absence of an <a href="#element-fallback"><code>xsl:fallback</code></a> child, a dynamic error is
                        raised if an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated. The
                        dynamic error may be caught using <a href="#element-try"><code>xsl:try</code></a> and
                           <a href="#element-catch"><code>xsl:catch</code></a>.</p>
                     </li>
                  </ul>
                  <p><a id="err-XTDE3175"><span class="error">[ERR XTDE3175] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an
                           <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated when use of
                           <a href="#element-evaluate"><code>xsl:evaluate</code></a> has been statically or dynamically
                        disabled. </p>
                  <p>In consequence of these rules, the recommended approach for stylesheet authors to
                  write code that works whether or not <a href="#element-evaluate"><code>xsl:evaluate</code></a> is enabled is
                  to use an <a href="#element-fallback"><code>xsl:fallback</code></a> child instruction. For example:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="isValid" as="xs:boolean"&gt;
  &lt;xsl:evaluate xpath="$validityCondition"&gt;
     &lt;xsl:fallback&gt;&lt;xsl:sequence select="true()"/&gt;&lt;/xsl:fallback&gt;
  &lt;/xsl:evaluate&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>There may be circumstances where may be inappropriate to allow use of
                        <a href="#element-evaluate"><code>xsl:evaluate</code></a>. For example:</p>
                     <ul>
                        <li>
                           <p>There may be security risks associated with the ability to execute code
                           from an untrusted source, which cannot be inspected during static
                           analysis. This risk is reduced in XSLT 4.0, because a processor
                           is <span class="verb">required</span> to offer the option <code>trusted="no"</code>,
                           which disables access to external resources. However, some risk remains
                           because untrusted code may still consume unbounded CPU or memory resource.</p>
                        </li>
                        <li>
                           <p>There may be environments where the available computing resources are
                           sufficient to enable pre-compiled stylesheets to be executed, but not to
                           enable XPath expressions to be compiled into executable code.</p>
                        </li>
                     </ul>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="evaluate-examples"></a>10.5.5 <a href="#evaluate-examples" style="text-decoration: none">Examples of <code>xsl:evaluate</code></a></h4>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e33287"></a>Example: Using a Dynamic Sort Key</div>
                     <p>A common requirement is to sort a table on the value of an expression which is
                     selected at run-time, perhaps by supplying the expression as a string-valued
                     parameter to the stylesheet. Suppose that such an expression is supplied to the
                     parameter:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:param name="sortkey" as="xs:string" select="'@name'"/&gt;</pre>
                     </div>
                     <p>Then the data may be sorted as follows:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:sort&gt;
   &lt;xsl:evaluate xpath="$sortkey" as="xs:string" context-item="."/&gt;
&lt;/xsl:sort&gt;</pre>
                     </div>
                     <p>Note the importance in this use case of caching the compiled expression, since
                     it is evaluated repeatedly, once for each item in the list being sorted.</p>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e33296"></a>Example: Getting a Function if it Exists</div>
                     <p>If the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> function were not available
                     in the standard library, then a very similar function could be implemented like this:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:function name="f:function-lookup"&gt;
  &lt;xsl:param name="name" as="xs:QName"/&gt;
  &lt;xsl:param name="arity" as="xs:integer"/&gt;
  &lt;xsl:try&gt;
    &lt;xsl:evaluate xpath="'Q{' || namespace-uri-from-QName($name) || '}' 
                || local-name-from-QName($name) || '#' || $arity"&gt;
      &lt;xsl:with-param name="name" as="xs:QName" select="$name"/&gt;
      &lt;xsl:with-param name="arity" as="xs:integer" select="$arity"/&gt;
    &lt;/xsl:evaluate&gt;
    &lt;xsl:catch errors="err:XTDE3160" select="()"/&gt;
  &lt;/xsl:try&gt;  
&lt;/xsl:function&gt;</pre>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The main difference between this function and the standard <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>
                     function is that there are differences in the functions that are visible: for example <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>
                  gives access to user-defined functions with private visibility, whereas <a href="#element-evaluate"><code>xsl:evaluate</code></a> does not.</p>
                     </div>
                     <p>The <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction uses the supplied QName and arity
                     to construct an expression of the form
                     <code>Q{namespace-uri}local#arity</code>, which is then evaluated to return a
                     function item representing the requested function.</p>
                  </div>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="creating-new-nodes"></a>11 <a href="#creating-new-nodes" style="text-decoration: none">Creating Nodes</a></h2>
            <p>This section describes instructions that directly create new nodes.</p>
            <div class="div2">
               
               <h3><a id="literal-result-element"></a>11.1 <a href="#literal-result-element" style="text-decoration: none">Literal Result Elements</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-literal-result-element" title="literal result element"></a>In a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an element in the
                     <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that does not belong to the
                     <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> and that is not an
                     <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see
                     <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>) is classified as a <b>literal result
                     element</b>.<span class="definition">]</span> A literal result element is evaluated to construct a
               new element node with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                  QName</a> (that is, the same namespace URI, local name, and namespace
               prefix). The result of evaluating a literal result element is a node sequence
               containing one element, the newly constructed element node.</p>
               <p>The content of the element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                  constructor</a> (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>). The sequence
               obtained by evaluating this sequence constructor, after prepending any attribute
               nodes produced as described in <a href="#attributes-for-lres"><i>11.1.2 Attribute Nodes for Literal Result Elements</i></a> and namespace
               nodes produced as described in <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>, is used to construct
               the content of the element, following the rules in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>
            </p>
               <p>The base URI of the new element is copied from the base URI of the literal result
               element in the stylesheet, unless the content of the new element includes an
                  <code>xml:base</code> attribute, in which case the base URI of the new element is
               the value of that attribute, resolved (if it is a relative URI reference) against the base URI of the literal result element in
               the stylesheet. (Note, however, that this is only relevant when creating a parentless
               element. When the literal result element is copied to form a child of an element or
               document node, the base URI of the new copy is taken from that of its new
               parent.)</p>
               <div class="div3">
                  
                  <h4><a id="setting-annotation-for-lre"></a>11.1.1 <a href="#setting-annotation-for-lre" style="text-decoration: none">Setting the Type Annotation for Literal Result Elements</a></h4>
                  <p>The attributes <code>xsl:type</code> and <code>xsl:validation</code> may be used
                  on a literal result element to invoke validation of the contents of the element
                  against a type definition or element declaration in a schema, and to determine the
                     <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new element node will carry. These
                  attributes also affect the type annotation carried by any elements and attributes
                  that have the new element node as an ancestor. These two attributes are both
                  optional, and if one is specified then the other <span class="verb">must</span> be
                  omitted.</p>
                  <p>The value of the <code>xsl:validation</code> attribute, if present, must be one of
                  the values <code>strict</code>, <code>lax</code>, <code>preserve</code>, or
                     <code>strip</code>. The value of the <code>xsl:type</code> attribute, if
                  present, must be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> identifying a type definition that is present in
                  the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema
                     components</a> for the stylesheet. Neither attribute may be specified as
                  an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template.</a>
                  The effect of these attributes is described in <a href="#validation"><i>25.4 Validation</i></a>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="attributes-for-lres"></a>11.1.2 <a href="#attributes-for-lres" style="text-decoration: none">Attribute Nodes for Literal Result Elements</a></h4>
                  <p>Attribute nodes for a literal result element may be created by including
                     <a href="#element-attribute"><code>xsl:attribute</code></a> instructions within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. Additionally,
                  attribute nodes are created corresponding to the attributes of the literal result
                  element in the stylesheet, and as a result of expanding the
                     <code>xsl:use-attribute-sets</code> attribute of the literal result element, if
                  present.</p>
                  <p>The sequence that is used to construct the content of the literal result element
                  (as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>) is the
                  concatenation of the following four sequences, in order:</p>
                  <ol class="enumar">
                     <li>
                        <p>The sequence of namespace nodes produced as described in <a href="#lre-namespaces"><i>11.1.3 Namespace Nodes for Literal Result Elements</i></a>.</p>
                     </li>
                     <li>
                        <p>The sequence of attribute nodes produced by expanding the
                           <code>xsl:use-attribute-sets</code> attribute (if present) following the
                        rules given in <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>
                     </p>
                     </li>
                     <li>
                        <p>The attributes produced by processing the attributes of the literal result
                        element itself, other than attributes in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>. The way these are
                        processed is described below.</p>
                     </li>
                     <li>
                        <p>The sequence produced by evaluating the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, if the
                        element is not empty.</p>
                     </li>
                  </ol>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The significance of this order is that an attribute produced by an
                        <a href="#element-attribute"><code>xsl:attribute</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, or
                        <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction in the content of the literal
                     result element takes precedence over an attribute produced by expanding an
                     attribute of the literal result element itself, which in turn takes precedence
                     over an attribute produced by expanding the <code>xsl:use-attribute-sets</code>
                     attribute. This is because of the rules in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>, which specify that when two or more
                     attributes in the sequence have the same name, all but the last of the
                     duplicates are discarded.</p>
                     <p>Although the above rules place namespace nodes before attributes, this is not
                     strictly necessary, because the rules in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a> allow the namespaces and attributes to
                     appear in any order so long as both come before other kinds of node. The order
                     of namespace nodes and attribute nodes in the sequence has no effect on the
                     relative position of the nodes in document order once they are added to a
                     tree.</p>
                  </div>
                  <p>Each attribute of the literal result element, other than an attribute in the
                     <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, is processed to
                  produce an attribute for the element in the <a title="result tree" class="termref" href="#dt-result-tree">result
                     tree</a>.</p>
                  <p>The value of such an attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>: it can
                  therefore contain <a title="expression" class="termref" href="#dt-expression">expressions</a> contained in
                  curly brackets (<code>{}</code>). The new attribute node will have the same
                     <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (that is, the same
                  namespace URI, local name, and namespace prefix) as the attribute in the
                  stylesheet tree, and its <a title="string value" class="termref" href="#dt-string-value">string value</a>
                  will be the same as the <a title="effective value" class="termref" href="#dt-effective-value">effective
                     value</a> of the attribute in the stylesheet tree. The <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> on the attribute will
                  initially be <code>xs:untypedAtomic</code>, and the <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of the attribute node will be the same as its <a title="string value" class="termref" href="#dt-string-value">string value</a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The eventual <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the attribute in the
                        <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> depends on the
                        <code>xsl:validation</code> and <code>xsl:type</code> attributes of the
                     parent literal result element, and on the instructions used to create its
                     ancestor elements. If the <code>xsl:validation</code> attribute is set to
                        <code>preserve</code> or <code>strip</code>, the type annotation will be
                        <code>xs:untypedAtomic</code>, and the <a title="typed value" class="termref" href="#dt-typed-value">typed
                        value</a> of the attribute node will be the same as its <a title="string value" class="termref" href="#dt-string-value">string value</a>. If the
                        <code>xsl:validation</code> attribute is set to <code>strict</code> or
                        <code>lax</code>, or if the <code>xsl:type</code> attribute is used, the
                     type annotation on the attribute will be set as a result of the schema
                     validation process applied to the parent element. If neither attribute is
                     present, the type annotation on the attribute will be
                        <code>xs:untypedAtomic</code>.</p>
                  </div>
                  <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
                  perform attribute value normalization by effectively applying the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-normalize-space"><code>normalize-space</code></a> function to the value of the attribute,
                  and the resulting attribute node must be given the <code>is-id</code>
                  property.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p> If the attribute name is <code>xml:space</code>, it is <em>not</em> an
                     error when the value is something other than <code>default</code> or
                        <code>preserve</code>. Although the XML specification states that other
                     values are erroneous, a document containing such values is well-formed; if
                     erroneous values are to be rejected, schema validation should be used. </p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <code>xml:base</code>, <code>xml:lang</code>, <code>xml:space</code>, and
                        <code>xml:id</code> attributes have two effects in XSLT. They behave as
                     standard XSLT attributes, which means for example that if they appear on a
                     literal result element, they will be copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> in the same way as any other
                     attribute. In addition, they have their standard meaning as defined in the core
                     XML specifications. Thus, an <code>xml:base</code> attribute in the stylesheet
                     affects the base URI of the element on which it appears, and an
                        <code>xml:space</code> attribute affects the interpretation of <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> within that
                     element. One consequence of this is that it is inadvisable to write these
                     attributes as attribute value templates: although an XSLT processor will
                     understand this notation, the XML parser will not. See also <a href="#namespace-aliasing"><i>11.1.4 Namespace Aliasing</i></a> which describes how to use
                        <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> with these attributes.</p>
                     <p>The same is true of the schema-defined attributes <code>xsi:type</code>,
                        <code>xsi:nil</code>, <code>xsi:noNamespaceSchemaLocation</code>, and
                        <code>xsi:schemaLocation</code>. If the stylesheet is processed by a schema
                     processor, these attributes will be recognized and interpreted by the schema
                     processor, but in addition the XSLT processor treats them like any other
                     attribute on a literal result element: that is, their <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> (after expanding <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>) is
                     copied to the result tree in the same way as any other attribute. If the
                        <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is validated, the copied
                     attributes will again be recognized and interpreted by the schema
                     processor.</p>
                     <p>None of these attributes will be generated in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> unless the stylesheet writes them to the result tree
                     explicitly, in the same way as any other attribute.</p>
                  </div>
                  <p>
                  <a id="err-XTSE0805"><span class="error">[ERR XTSE0805] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        attribute on a literal result element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, unless it is one of the
                        attributes explicitly defined in this specification.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If there is a need to create attributes in the XSLT namespace, this can be
                     achieved using <a href="#element-attribute"><code>xsl:attribute</code></a>, or by means of the
                        <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="lre-namespaces"></a>11.1.3 <a href="#lre-namespaces" style="text-decoration: none">Namespace Nodes for Literal Result Elements</a></h4>
                  <p>The created element node will have a copy of the namespace nodes that were present
                  on the element node in the stylesheet tree with the exception of any namespace
                  node whose <a title="string value" class="termref" href="#dt-string-value">string value</a> is designated as
                  an <b>excluded namespace</b>. Special considerations apply to aliased
                  namespaces: see <a href="#namespace-aliasing"><i>11.1.4 Namespace Aliasing</i></a>.
               </p>
                  <p>The following namespaces are designated as excluded namespaces:</p>
                  <ul>
                     <li>
                        <p>The <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> URI
                           (<code>http://www.w3.org/1999/XSL/Transform</code>)</p>
                     </li>
                     <li>
                        <p>A namespace URI declared as an extension namespace (see <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>)</p>
                     </li>
                     <li>
                        <p>A namespace URI designated by using an
                           <code>[xsl:]exclude-result-prefixes</code> attribute either on the
                        literal result element itself or on an ancestor element. The attribute
                           <span class="verb">must</span> be in the XSLT namespace only if its parent
                        element is <em>not</em> in the XSLT namespace.</p>
                        <p>The value of the attribute is either <code>#all</code>, or a
                        whitespace-separated list of tokens, each of which is either a namespace
                        prefix or <code>#default</code>. The namespace bound to each of the prefixes
                        is designated as an excluded namespace.</p>
                        <p>
                        <a id="err-XTSE0808"><span class="error">[ERR XTSE0808] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                              namespace prefix is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and there is
                              no namespace binding in scope for that prefix.
                     </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The prefix must be declared in a 
                        <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace binding</a>,
                        not in a <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace binding</a>.</p>
                        </div>
                        <p>The default namespace of the parent element of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute (see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#ElementNode">7.5.2 Element nodes</a>) may be designated as an excluded
                        namespace by including <code>#default</code> in the list of namespace
                        prefixes.</p>
                        <p>
                        <a id="err-XTSE0809"><span class="error">[ERR XTSE0809] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                              value <code>#default</code> is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and the parent
                              element of the <code>[xsl:]exclude-result-prefixes</code> attribute
                              has no default namespace.
                     </p>
                        <p>The value <code>#all</code> indicates that all namespaces that are in scope
                        for the stylesheet element that is the parent of the
                           <code>[xsl:]exclude-result-prefixes</code> attribute are designated as
                        excluded namespaces.</p>
                        <p>The designation of a namespace as an excluded namespace is effective within
                        the subtree of the stylesheet module rooted at the element bearing the
                           <code>[xsl:]exclude-result-prefixes</code> attribute; a subtree rooted at
                        an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element does not include any stylesheet
                        modules imported or included by children of that
                           <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
                     </li>
                  </ul>
                  <p>The excluded namespaces, as described above, <em>only</em> affect namespace
                  nodes copied from the stylesheet when processing a literal result element. There
                  is no guarantee that an excluded namespace will not appear on the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> for some other reason. Namespace
                  nodes are also written to the result tree as part of the process of namespace
                  fixup (see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>), or as the result of instructions
                  such as <a href="#element-copy"><code>xsl:copy</code></a> and <a href="#element-element"><code>xsl:element</code></a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>When a stylesheet uses a namespace declaration only for the purposes of
                     addressing a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>, specifying
                     the prefix in the <code>[xsl:]exclude-result-prefixes</code> attribute will
                     avoid superfluous namespace declarations in the serialized <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. The attribute is also useful to
                     prevent namespaces used solely for the naming of stylesheet functions or
                     extension functions from appearing in the serialized result tree.</p>
                     <p>In XSLT 4.0, a simpler approach is to declare such namespaces in a <code>fixed-namespaces</code>
                  attribute on the <code>xsl:stylesheet</code> element: see <a href="#fixed-namespaces"><i>3.6.1 The fixed-namespaces Attribute</i></a>.
                     Namespace prefixes declared in that way are not eligible to be used in the names
                     of literal result elements and their attributes, and they are not copied into the 
                     result tree.
                  </p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e33815"></a>Example: Excluding Namespaces from the Result Tree</div>
                     <p>Consider the following stylesheet:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:stylesheet version="1.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:a="a.uri"
  xmlns:b="b.uri"
  exclude-result-prefixes="#all"&gt;
  
&lt;xsl:template match="/"&gt;
  &lt;foo xmlns:c="c.uri" xmlns:d="d.uri" xmlns:a2="a.uri" 
       xsl:exclude-result-prefixes="c"/&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                     <p>The result of this stylesheet will be:</p>
                     <div class="exampleInner">
                        <pre>&lt;foo xmlns:d="d.uri"/&gt;</pre>
                     </div>
                     <p>The namespaces <code>a.uri</code> and <code>b.uri</code> are excluded by virtue
                     of the <code>exclude-result-prefixes</code> attribute on the
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element, and the namespace
                        <code>c.uri</code> is excluded by virtue of the
                        <code>xsl:exclude-result-prefixes</code> attribute on the <code>foo</code>
                     element. The setting <code>#all</code> does not affect the namespace
                        <code>d.uri</code> because <code>d.uri</code> is not an in-scope namespace
                     for the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element. The element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> does not have a namespace node
                     corresponding to <code>xmlns:a2="a.uri"</code> because the effect of
                        <code>exclude-result-prefixes</code> is to designate the namespace URI
                        <code>a.uri</code> as an excluded namespace, irrespective of how many
                     prefixes are bound to this namespace URI.</p>
                     <p>If the stylesheet is changed so that the literal result element has an
                     attribute <code>b:bar="3"</code>, then the element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> will typically have a namespace
                     declaration <code>xmlns:b="b.uri"</code> (the processor may choose a different
                     namespace prefix if this is necessary to avoid conflicts). The
                        <code>exclude-result-prefixes</code> attribute makes <code>b.uri</code> an
                     excluded namespace, so the namespace node is not automatically copied from the
                     stylesheet, but the presence of an attribute whose name is in the namespace
                        <code>b.uri</code> forces the namespace fixup process (see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>) to introduce a namespace node for this
                     namespace.</p>
                  </div>
                  <p>A literal result element may have an optional <code>xsl:inherit-namespaces</code>
                  attribute, with the value <code>yes</code> or <code>no</code>. The default value
                  is <code>yes</code>. If the value is set to <code>yes</code>, or is omitted, then
                  the namespace nodes created for the newly constructed element are copied to the
                  children and descendants of the newly constructed element, as described in
                     <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. If the value is set to
                     <code>no</code>, then these namespace nodes are not automatically copied to the
                  children. This may result in namespace undeclarations (such as
                     <code>xmlns=""</code> or, in the case of XML 1.1, <code>xmlns:p=""</code>)
                  appearing on the child elements when they are serialized.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="namespace-aliasing"></a>11.1.4 <a href="#namespace-aliasing" style="text-decoration: none">Namespace Aliasing</a></h4>
                  <p>When a stylesheet is used to define a transformation whose output is itself a
                  stylesheet module, or in certain other cases where the result document uses
                  namespaces that it would be inconvenient to use in the stylesheet, namespace
                  aliasing can be used to declare a mapping between a namespace URI used in the
                  stylesheet and the corresponding namespace URI to be used in the result
                  document.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-literal-namespace-uri" title="literal namespace URI"></a>A namespace
                     URI in the stylesheet tree that is being used to specify a namespace URI in the
                        <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is called a
                        <b>literal namespace URI</b>.<span class="definition">]</span>
               </p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-target-namespace-uri" title="target namespace URI"></a>The namespace
                     URI that is to be used in the <a title="result tree" class="termref" href="#dt-result-tree">result
                        tree</a> as a substitute for a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is called the <b>target namespace
                        URI</b>.<span class="definition">]</span>
               </p>
                  <p>Either of the <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace
                     URI</a> or the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace
                     URI</a> can be <em>null</em>: this is treated as a reference to the
                  set of names that are in no namespace.</p>
                  <p class="element-syntax"><a id="element-namespace-alias"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:namespace-alias<br>&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | "#default"<br>&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> | "#default"&nbsp;/&gt;</code></p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-alias" title="alias"></a>A stylesheet can use the
                        <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is being used
                     as an <b>alias</b> for a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target
                        namespace URI</a>.<span class="definition">]</span>
               </p>
                  <p>The effect is that when names in the namespace identified by the <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> are copied to
                  the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>, the namespace URI in the
                  result tree will be the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace
                     URI</a>, instead of the literal namespace URI. This applies to:</p>
                  <ul>
                     <li>
                        <p>the namespace URI in the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> of a literal result element in the stylesheet</p>
                     </li>
                     <li>
                        <p>the namespace URI in the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> of an attribute specified on a literal result element in
                        the stylesheet</p>
                     </li>
                  </ul>
                  <p>The effect of an <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>
                  declaration is local to the <a title="package" class="termref" href="#dt-package">package</a> in which
                  it appears: that is, it only affects the result of <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a> within the
                  same package.</p>
                  <p>Where namespace aliasing changes the namespace URI part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> containing the name of an
                  element or attribute node, the namespace prefix in that expanded QName is replaced
                  by the prefix indicated by the <code>result-prefix</code> attribute of the
                     <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration.</p>
                  <p>The <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element declares that the namespace URI
                  bound to the prefix specified by the <code>stylesheet-prefix</code> is the
                     <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a>, and
                  the namespace URI bound to the prefix specified by the <code>result-prefix</code>
                  attribute is the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace
                     URI</a>. Thus, the <code>stylesheet-prefix</code> attribute specifies the
                  namespace URI that will appear in the stylesheet, and the
                     <code>result-prefix</code> attribute specifies the corresponding namespace URI
                  that will appear in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>It is the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a> that apply,
                  not the <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a>. More specifically: if a prefix <code>p</code>
               appears in the <code>stylesheet-prefix</code> or <code>result-prefix</code> attribute,
               there must be an in-scope namespace declaration of the form <code>xmlns:p="...."</code>;
               it is not sufficient to declare the namespace in the <code>fixed-namespaces</code>
               attribute of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
                  </div>
                  <p>The default namespace (as declared by <code>xmlns</code>) may be specified by
                  using <code>#default</code> instead of a prefix. If no default namespace is in
                  force, specifying <code>#default</code> denotes the null namespace URI. This
                  allows elements that are in no namespace in the stylesheet to acquire a namespace
                  in the result document, or vice versa. <span>
                     Defining an alias for the null namespace URI does not affect no-namespace attributes; 
                     these remain in no namespace. However, where <code>result-prefix="#default"</code> is specified and 
                     no default namespace is in force, attributes whose namespace matches the literal namespace 
                     URI are renamed to be in no namespace.
                  </span></p>
                  <p>If a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is
                  declared to be an alias for multiple different <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">target namespace URIs</a>, then the
                  declaration with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import
                     precedence</a> is used.</p>
                  <p>
                  <a id="err-XTSE0810"><span class="error">[ERR XTSE0810] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within a <a title="package" class="termref" href="#dt-package">package</a> there is more than one such declaration
                            with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and the
                        same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and
                        different values for the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target
                           namespace URI</a>, unless there is also an
                           <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and a
                        higher import precedence. 
               </p>
                  <p>No error occurs if there is more than one such
                     <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration having the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and the same
                     <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, even if
                  the <code>result-prefix</code> differs; in this case the
                     <code>result-prefix</code> used is the one that appears last in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration order</a>. </p>
                  <p>
                  <a id="err-XTSE0812"><span class="error">[ERR XTSE0812] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a value
                        other than <code>#default</code> is specified for either the
                           <code>stylesheet-prefix</code> or the <code>result-prefix</code>
                        attributes of the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element when there is
                        no in-scope binding for that namespace prefix.
               </p>
                  <p>When a literal result element is processed, its namespace nodes are handled as
                  follows:</p>
                  <ul>
                     <li>
                        <p>A namespace node whose string value is a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is not
                        copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p>
                     </li>
                     <li>
                        <p>A namespace node whose string value is a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a> is copied to
                        the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>, whether or not the
                        URI identifies an excluded namespace.</p>
                     </li>
                  </ul>
                  <p>In the event that the same URI is used as a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, the second of
                  these rules takes precedence.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>These rules achieve the effect that the element generated from the literal
                     result element will have an in-scope namespace node that binds the
                        <code>result-prefix</code> to the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target namespace URI</a>, provided that the namespace declaration
                     associating this prefix with this URI is in scope for both the
                        <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> instruction and for the literal result
                     element. Conversely, the <code>stylesheet-prefix</code> and the <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> will not
                     normally appear in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e34231"></a>Example: Using <code>xsl:namespace-alias</code> to Generate a Stylesheet</div>
                     <p>When literal result elements are being used to create element, attribute, or
                     namespace nodes that use the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT
                        namespace</a> URI, the stylesheet may use an alias. </p>
                     <p>For example, the stylesheet</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
  xmlns:fo="http://www.w3.org/1999/XSL/Format"
  xmlns:axsl="file://namespace.alias"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axsl" result-prefix="xsl"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;axsl:stylesheet version="3.0"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/axsl:stylesheet&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="elements"&gt;
  &lt;axsl:template match="/"&gt;
     &lt;axsl:comment select="system-property('xsl:version')"/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="block"&gt;
  &lt;axsl:template match="{.}"&gt;
     &lt;fo:block&gt;&lt;axsl:apply-templates/&gt;&lt;/fo:block&gt;
  &lt;/axsl:template&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                     <p>will generate an XSLT stylesheet from a document of the form:</p>
                     <div class="exampleInner">
                        <pre>&lt;elements&gt;
&lt;block&gt;p&lt;/block&gt;
&lt;block&gt;h1&lt;/block&gt;
&lt;block&gt;h2&lt;/block&gt;
&lt;block&gt;h3&lt;/block&gt;
&lt;block&gt;h4&lt;/block&gt;
&lt;/elements&gt;</pre>
                     </div>
                     <p>The output of the transformation will be a stylesheet such as the following.
                     Whitespace has been added for clarity. Note that an implementation may output
                     different namespace prefixes from those appearing in this example; however, the
                     rules guarantee that there will be a namespace node that binds the prefix
                        <code>xsl</code> to the URI
                        <code>http://www.w3.org/1999/XSL/Transform</code>, which makes it safe to
                     use the QName <code>xsl:version</code> in the content of the generated
                     stylesheet.</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:stylesheet
  version="3.0"
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format"&gt;

&lt;xsl:template match="/"&gt;
  &lt;xsl:comment select="system-property('xsl:version')"/&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="p"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h1"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h2"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h3"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="h4"&gt;
  &lt;fo:block&gt;&lt;xsl:apply-templates/&gt;&lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>It may be necessary also to use aliases for namespaces other than the XSLT
                     namespace URI. For example, it can be useful to define an alias for the
                     namespace <code>http://www.w3.org/2001/XMLSchema-instance</code>, so that the
                     stylesheet can use the attributes <code>xsi:type</code>, <code>xsi:nil</code>,
                     and <code>xsi:schemaLocation</code> on a literal result element, without
                     running the risk that a schema processor will interpret these as applying to
                     the stylesheet itself. Equally, literal result elements belonging to a
                     namespace dealing with digital signatures might cause XSLT stylesheets to be
                     mishandled by general-purpose security software; using an alias for the
                     namespace would avoid the possibility of such mishandling.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e34275"></a>Example: Aliasing the XML Namespace</div>
                     <p>It is possible to define an alias for the XML namespace.</p>
                     <div class="exampleInner">
                        <pre>
&lt;xsl:stylesheet xmlns:axml="http://www.example.com/alias-xml"
                xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
                version="3.0"&gt;

&lt;xsl:namespace-alias stylesheet-prefix="axml" result-prefix="xml"/&gt;

&lt;xsl:template match="/"&gt;
  &lt;name axml:space="preserve"&gt;
    &lt;first&gt;James&lt;/first&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;last&gt;Clark&lt;/last&gt;
  &lt;/name&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                     </div>
                     <p>produces the output:</p>
                     <div class="exampleInner">
                        <pre>&lt;name xml:space="preserve"&gt;&lt;first&gt;James&lt;/first&gt; &lt;last&gt;Clark&lt;/last&gt;&lt;/name&gt;</pre>
                     </div>
                     <p>This allows an <code>xml:space</code> attribute to be generated in the output
                     without affecting the way the stylesheet is parsed. The same technique can be
                     used for other attributes such as <code>xml:lang</code>, <code>xml:base</code>,
                     and <code>xml:id</code>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Namespace aliasing is only necessary when literal result elements are used. The
                     problem of reserved namespaces does not arise when using
                        <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-attribute"><code>xsl:attribute</code></a> to construct
                     the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. Therefore, as an
                     alternative to using <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>, it is always
                     possible to achieve the desired effect by replacing literal result elements
                     with <a href="#element-element"><code>xsl:element</code></a> and <a href="#element-attribute"><code>xsl:attribute</code></a>
                     instructions.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="xsl-element"></a>11.2 <a href="#xsl-element" style="text-decoration: none">Creating Element Nodes Using <code>xsl:element</code>
                     </a></h3>
               <p class="element-syntax"><a id="element-element"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:element<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var>〔''〕<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:element&gt;</code></p>
               <p>The <a href="#element-element"><code>xsl:element</code></a> instruction allows an element to be created with a
               computed name. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the
               element to be created is specified by a <span class="verb">required</span>
               <code>name</code> attribute and an optional <code>namespace</code> attribute.</p>
               <p>The result of evaluating the <a href="#element-element"><code>xsl:element</code></a> instruction, in usual circumstances, is the newly constructed
               element node.</p>
               <div class="div3">
                  
                  <h4><a id="xsl-element-content"></a>11.2.1 <a href="#xsl-element-content" style="text-decoration: none">The Content of the Constructed Element Node</a></h4>
                  <p>The content of the <a href="#element-element"><code>xsl:element</code></a> instruction is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> for the children,
                  attributes, and namespaces of the created element. The sequence obtained by
                  evaluating this sequence constructor (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>)
                  is used to construct the content of the element, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p>
                  <p>The <a href="#element-element"><code>xsl:element</code></a> element may have a
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations. If this attribute is present,
                  it is expanded as described in <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a> to produce a
                  sequence of attribute nodes. This sequence is prepended to the sequence produced
                  as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as
                  described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="xsl-element-name"></a>11.2.2 <a href="#xsl-element-name" style="text-decoration: none">The Name of the Constructed Element Node</a></h4>
                  <p>The <code>name</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, whose
                     <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                  <span class="verb">must</span> be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                     QName</a>.</p>
                  <p>
                  <a id="err-XTDE0820"><span class="error">[ERR XTDE0820] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                           <code>name</code> attribute  is not a
                           <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>. 
               </p>
                  <p>
                  <a id="err-XTDE0830"><span class="error">[ERR XTDE0830] </span></a>In the case of an <a href="#element-element"><code>xsl:element</code></a> instruction with no
                           <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                           error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective
                           value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not
                        declared in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the
                           <a href="#element-element"><code>xsl:element</code></a> instruction.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If a <code>fixed-namespaces</code> attribute is present on the containing <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or
               <a href="#element-package"><code>xsl:package</code></a> element, then the prefix must be declared in that attribute, not in a
               <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace binding</a>.</p>
                  </div>
                  <p>If the <code>namespace</code> attribute is not present then the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace
                  declarations in effect for the <a href="#element-element"><code>xsl:element</code></a> element, including any
                  default namespace declaration.</p>
                  <p>If the <code>namespace</code> attribute is present, then it too is interpreted as
                  an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>.
                  The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                  <span class="verb">must</span> be in the lexical space of the <code>xs:anyURI</code>
                  type. If the string is zero-length, then the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element has a null namespace URI. Otherwise,
                  the string is used as the namespace URI of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element to be created. The local part of the
                     <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> specified by the
                     <code>name</code> attribute is used as the local part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the element to be
                  created.</p>
                  <p>
                  <a id="err-XTDE0835"><span class="error">[ERR XTDE0835] </span></a> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                           <code>namespace</code> attribute  is not in the
                        lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                           <code>http://www.w3.org/2000/xmlns/</code>.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The XDM data model requires the name of a node to be an instance of
                        <code>xs:QName</code>, and XML Schema defines the namespace part of an
                        <code>xs:QName</code> to be an instance of <code>xs:anyURI</code>. However,
                     the schema specification, and the specifications that it refers to, give
                     implementations some flexibility in how strictly they enforce these
                     constraints.</p>
                  </div>
                  <p>The prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>
                  specified in the <code>name</code> attribute (or the absence of a prefix) is
                  copied to the prefix part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                     QName</a> representing the name of the new element node. In the event of
                  a conflict a prefix may subsequently be added, changed, or removed during the
                  namespace fixup process (see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>). The term <em>conflict</em>
                  here means any violation of the constraints defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>, for example the use of the same prefix to refer to
                  two different namespaces in the element and in one of its attributes, the use of
                  the prefix <code>xml</code> to refer to a namespace other than the XML namespace,
                  or any use of the prefix
                  <code>xmlns</code>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="xsl-element-properties"></a>11.2.3 <a href="#xsl-element-properties" style="text-decoration: none">Other Properties of the Constructed Element Node</a></h4>
                  <p>The <a href="#element-element"><code>xsl:element</code></a> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. If the value is set to
                     <code>yes</code>, or is omitted, then the namespace nodes created for the newly
                  constructed element (whether these were copied from those of the source node, or
                  generated as a result of namespace fixup) are copied to the children and
                  descendants of the newly constructed element, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. If the value is set to <code>no</code>,
                  then these namespace nodes are not automatically copied to the children. This may
                  result in namespace undeclarations (such as <code>xmlns=""</code> or, in the case
                  of XML Namespaces 1.1, <code>xmlns:p=""</code>) appearing on the child elements
                  when 
                  the element is serialized.</p>
                  <p>The base URI of the new element is copied from the base URI of the
                     <a href="#element-element"><code>xsl:element</code></a> instruction in the stylesheet, unless the content
                  of the new element includes an <code>xml:base</code> attribute, in which case the
                  base URI of the new element is the value of that attribute, resolved (if it is a
                  relative URI) against the base URI of the <a href="#element-element"><code>xsl:element</code></a> instruction
                  in the stylesheet. (Note, however, that this is only relevant when creating
                  parentless elements. When the new element is copied to form a child of an element
                  or document node, the base URI of the new copy is taken from that of its new
                  parent.)</p>
                  <p>The values of the <code>nilled</code>,
                     <code>is-id</code>, and <code>is-idrefs</code> properties of the new element
                  depend on the <code>type</code> and <code>validation</code> attributes of the
                     <a href="#element-element"><code>xsl:element</code></a> instruction, as explained in <a href="#validation"><i>25.4 Validation</i></a>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="annotation-for-constructed-element"></a>11.2.4 <a href="#annotation-for-constructed-element" style="text-decoration: none">The Type Annotation of the Constructed Element Node</a></h4>
                  <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <a href="#element-element"><code>xsl:element</code></a> instruction to invoke validation of the
                  contents of the element against a type definition or element declaration in a
                  schema, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type
                     annotation</a> that the new element node will carry. These attributes
                  also affect the type annotation carried by any elements and attributes that have
                  the new element node as an ancestor. These two attributes are both optional, and
                  if one is specified then the other <span class="verb">must</span> be omitted. The
                  permitted values of these attributes and their semantics are described in <a href="#validation"><i>25.4 Validation</i></a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The final type annotation of the element in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> also depends on the <code>type</code> and
                        <code>validation</code> attributes of the instructions used to create the
                     ancestors of the element.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="creating-attributes"></a>11.3 <a href="#creating-attributes" style="text-decoration: none">Creating Attribute Nodes Using <code>xsl:attribute</code>
                     </a></h3>
               <p class="element-syntax"><a id="element-attribute"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:attribute<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:attribute&gt;</code></p>
               <p>The <a href="#element-attribute"><code>xsl:attribute</code></a> element can be used to add attributes to result
               elements whether created by literal result elements in the stylesheet or by
               instructions such as <a href="#element-element"><code>xsl:element</code></a> or <a href="#element-copy"><code>xsl:copy</code></a>. The
                  <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of the attribute to be
               created is specified by a <span class="verb">required</span>
               <code>name</code> attribute and an optional <code>namespace</code> attribute. Except
               in error cases, the result of evaluating an <a href="#element-attribute"><code>xsl:attribute</code></a>
               instruction is the newly constructed attribute node.</p>
               <p>The string value of the new attribute node may be defined either by using the
                  <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the
                  <a href="#element-attribute"><code>xsl:attribute</code></a> element. These are
                  mutually exclusive: if the <code>select</code> attribute is present then the
                  sequence constructor must be empty, and if the sequence constructor is non-empty
                  then the <code>select</code> attribute must be absent. If the <code>select</code>
                  attribute is absent and the sequence constructor is empty, then the
               string value of the new attribute node will be a zero-length string. The way in which
               the value is constructed is specified in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
               <p>
               <a id="err-XTSE0840"><span class="error">[ERR XTSE0840] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-attribute"><code>xsl:attribute</code></a> element
                     is present unless the element has empty content.
            </p>
               <p>If the <code>separator</code> attribute is present, then the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of this attribute is used to
               separate adjacent items in the result sequence, as described in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>. In the absence of this attribute, the default
               separator is <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>)  when the content is specified using the
                  <code>select</code> attribute, or a zero-length string when the content is
               specified using a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                  constructor</a>.</p>
               <p>The <code>name</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, whose
                  <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
               <span class="verb">must</span> be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
               QName</a>.</p>
               <p>
               <a id="err-XTDE0850"><span class="error">[ERR XTDE0850] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> 
                     of the <code>name</code>
                     attribute  is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                        QName</a>.
            </p>
               <p>
               <a id="err-XTDE0855"><span class="error">[ERR XTDE0855] </span></a>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no
                        <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                        error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective
                        value</a> of the <code>name</code> attribute is the string
                        <code>xmlns</code>.
            </p>
               <p>
               <a id="err-XTDE0860"><span class="error">[ERR XTDE0860] </span></a>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no
                        <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                        error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective
                        value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared
                     in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> 
                     for the <a href="#element-attribute"><code>xsl:attribute</code></a>
                     instruction.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>If a <code>fixed-namespaces</code> attribute is present on the containing <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or
               <a href="#element-package"><code>xsl:package</code></a> element, then the prefix must be declared in that attribute, not in a
               <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace binding</a>.</p>
               </div>
               <p>If the <code>namespace</code> attribute is not present, then the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations
               in effect for the <a href="#element-attribute"><code>xsl:attribute</code></a> element, <em>not</em> including
               any default namespace declaration.</p>
               <p>If the <code>namespace</code> attribute is present, then it too is interpreted as an
                  <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. The
                  <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
               <span class="verb">must</span> be in the lexical space of the <code>xs:anyURI</code> type.
               If the string is zero-length, then the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                  QName</a> of the attribute has a null namespace URI. Otherwise, the string
               is used as the namespace URI of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                  QName</a> of the attribute to be created. The local part of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> specified by the <code>name</code>
               attribute is used as the local part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                  QName</a> of the attribute to be created.</p>
               <p>
               <a id="err-XTDE0865"><span class="error">[ERR XTDE0865] </span></a> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                        <code>namespace</code> attribute  is not in the
                     lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The same considerations apply as for elements: <span class="error">[see <a href="#err-XTDE0835">ERR XTDE0835</a>]</span> in <a href="#xsl-element"><i>11.2 Creating Element Nodes Using xsl:element</i></a>.</p>
               </div>
               <p>The prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> specified
               in the <code>name</code> attribute (or the absence of a prefix) is copied to the
               prefix part of the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>
               representing the name of the new attribute node. In the event of a conflict this
               prefix may subsequently be added, changed, or removed during the namespace fixup
               process (see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>). If the attribute is in a non-null
               namespace and no prefix is specified, then the namespace fixup process will invent a
               prefix. The term <em>conflict</em> here means any violation of the constraints
               defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>, for example the use of the same prefix
               to refer to two different namespaces in the element and in one of its attributes, the
               use of the prefix <code>xml</code> to refer to a namespace other than the XML
               namespace, or any use of the prefix <code>xmlns</code>.</p>
               <p>If the name of a constructed attribute is <code>xml:id</code>, the processor must
               perform attribute value normalization by effectively applying the
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-normalize-space"><code>normalize-space</code></a> function to the value of the attribute, and
               the resulting attribute node must be given the <code>is-id</code> property. This
               applies whether the attribute is constructed using the <a href="#element-attribute"><code>xsl:attribute</code></a>
               instruction or whether it is constructed using an attribute of a literal result
               element. This does not imply any constraints on the value of the attribute, or on its
               uniqueness, and it does not affect the <a title="type annotation" class="termref" href="#dt-type-annotation">type
                  annotation</a> of the attribute, unless the containing document is
               validated.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The effect of setting the <code>is-id</code> property is that the parent element
                  can be located within the containing document by use of the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>id</code></a> function. In effect, XSLT when constructing a
                  document performs some of the functions of an <code>xml:id</code> processor, as
                  defined in <a href="#xml-id">[xml:id]</a>; the other aspects of <code>xml:id</code>
                  processing are performed during validation.</p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e35027"></a>Example: Creating a List-Valued Attribute</div>
                  <p>The following instruction creates the attribute <code>colors="red green
                     blue"</code>:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:attribute name="colors" select="'red', 'green', 'blue'"/&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e35036"></a>Example: Namespaces are not Attributes</div>
                  <p>It is not an error to write:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:attribute name="xmlns:xsl" 
   namespace="file://some.namespace"
   select="'http://www.w3.org/1999/XSL/Transform'"/&gt;</pre>
                  </div>
                  <p>However, this will not result in the namespace declaration
                     <code>xmlns:xsl="http://www.w3.org/1999/XSL/Transform"</code> being output.
                  Instead, it will produce an attribute node with local name <code>xsl</code>, and
                  with a system-allocated namespace prefix mapped to the namespace URI
                     <code>file://some.namespace</code>. This is because the namespace fixup process
                  is not allowed to use <code>xmlns</code> as the name of a namespace node.</p>
               </div>
               <p>As described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>, in a sequence that is
               used to construct the content of an element, any attribute nodes
                  <span class="verb">must</span> appear in the sequence before any element, text, comment,
               or processing instruction nodes. Where the sequence contains two or more attribute
               nodes with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, the
               one that comes last is the only one that takes effect.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>If a collection of attributes is generated repeatedly, this can be done
                  conveniently by using named attribute sets: see <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a>
               </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="annotation-for-constructed-attribute"></a>11.3.1 <a href="#annotation-for-constructed-attribute" style="text-decoration: none">Setting the Type Annotation for a Constructed Attribute Node</a></h4>
                  <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <a href="#element-attribute"><code>xsl:attribute</code></a> instruction to invoke validation of the
                  contents of the attribute against a type definition or attribute declaration in a
                  schema, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type
                     annotation</a> that the new attribute node will carry. These two
                  attributes are both optional, and if one is specified then the other
                     <span class="verb">must</span> be omitted. The permitted values of these attributes
                  and their semantics are described in <a href="#validation"><i>25.4 Validation</i></a>.</p>
                  <p>The process of validation also determines the values of
                  the <code>is-id</code> and <code>is-idrefs</code> properties on the new attribute
                  node.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The final <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the attribute in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the attribute.</p>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="creating-text-nodes"></a>11.4 <a href="#creating-text-nodes" style="text-decoration: none">Creating Text Nodes</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#xsl-text">next</a> | <a href="#dynamic-xpath">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The <a href="#element-text"><code>xsl:text</code></a> instruction can now have a <code>select</code> attribute,
                  and it can take a sequence constructor as its content. The only remaining distinction
                  between the <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions
                  is that whitespace text node children of <a href="#element-text"><code>xsl:text</code></a> are treated
                  as significant, rather than being stripped during stylesheet preprocessing.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/323">323</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2251">2251</a>&nbsp;14 October 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>This section describes three different ways of creating text nodes: by means of
               literal text nodes in the stylesheet, or by using the <a href="#element-text"><code>xsl:text</code></a> and
                  <a href="#element-value-of"><code>xsl:value-of</code></a> instructions. It is also possible to create text
               nodes using the <a href="#element-number"><code>xsl:number</code></a> instruction described in <a href="#number"><i>12 Numbering</i></a>.</p>
               <p>If and when the sequence that results from evaluating a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is used to form the
               content of a node, as described in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a> and
                  <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>, adjacent text nodes in the sequence
               are merged. Within the sequence itself, however, they exist as distinct nodes.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e35147"></a>Example: A Sequence of Text Nodes</div>
                  <p>The following function returns a sequence of three text nodes:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="f:wrap"&gt;
  &lt;xsl:param name="s"/&gt;
  &lt;xsl:text&gt;(&lt;/xsl:text&gt;
  &lt;xsl:value-of select="$s"/&gt;
  &lt;xsl:text&gt;)&lt;/xsl:text&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
                  <p>When this function is called as follows:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:value-of select="f:wrap('---')"/&gt;</pre>
                  </div>
                  <p>the result is:</p>
                  <div class="exampleInner">
                     <pre>(---)</pre>
                  </div>
                  <p>No additional spaces are inserted, because the calling
                     <a href="#element-value-of"><code>xsl:value-of</code></a> instruction merges adjacent text nodes before
                  atomizing the sequence. However, the result of the instruction:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:value-of select="data(f:wrap('---'))"/&gt;</pre>
                  </div>
                  <p>is:</p>
                  <div class="exampleInner">
                     <pre>( --- )</pre>
                  </div>
                  <p>because in this case the three text nodes are atomized to form three strings, and
                  spaces are inserted between adjacent strings.</p>
                  <p>This example reflects the traditional usage of <a href="#element-text"><code>xsl:text</code></a> to output
               constant text and <a href="#element-value-of"><code>xsl:value-of</code></a> to output variable text. In XSLT 4.0,
               however, either instruction can be used for either purpose, and in the example above
               either instruction could be replaced by the other.</p>
               </div>
               <p>It is possible to construct text nodes whose string value is zero-length. A
               zero-length text node, when atomized, produces a zero-length string. However,
               zero-length text nodes are ignored when they appear in a sequence that is used to
               form the content of a node, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a> and <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
               <div class="div3">
                  
                  <h4><a id="literal-text-nodes"></a>11.4.1 <a href="#literal-text-nodes" style="text-decoration: none">Literal Text Nodes</a></h4>
                  <p>A <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> can contain text nodes. Each text node
                  in a sequence constructor remaining after <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text nodes</a> have been stripped as specified in <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a> will construct a new text node with the same
                     <a title="string value" class="termref" href="#dt-string-value">string value</a>. The resulting text node
                  is added to the result of the containing sequence constructor.</p>
                  <p>Text is processed at the tree level. Thus, markup of <code>&amp;lt;</code> in a
                  template will be represented in the stylesheet tree by a text node that includes
                  the character <code>&lt;</code>. This will create a text node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that contains a <code>&lt;</code>
                  character, which will be represented by the markup <code>&amp;lt;</code> (or an
                  equivalent character reference) when the result tree is serialized as an XML
                  document, unless otherwise specified using <a title="character map" class="termref" href="#dt-character-map">character maps</a> (see <a href="#character-maps"><i>26.3 Character Maps</i></a>) or
                     <code>disable-output-escaping</code> (see <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a>).</p>
                  <p>A non-whitespace text node in the stylesheet that is not contained within an <a href="#element-text"><code>xsl:text</code></a> or
               <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is equivalent to wrapping the text node in
               <a href="#element-text"><code>xsl:text</code></a>. For example:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:if test="$debug"&gt;Here I am&lt;/xsl:if&gt;</pre>
                  </div>
                  <p>is equivalent to:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:if test="$debug"&gt;&lt;xsl:text&gt;Here I am&lt;/xsl:text&gt;&lt;/xsl:if&gt;</pre>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="xsl-text"></a>11.4.2 <a href="#xsl-text" style="text-decoration: none">The <code>xsl:text</code> and <code>xsl:value-of</code> instructions</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#generating-cdata">next</a> | <a href="#creating-text-nodes">previous</a>)</p>
                     <ol>
                        <li>
                           <p>The rules for <a href="#element-text"><code>xsl:text</code></a>
                  and <a href="#element-value-of"><code>xsl:value-of</code></a> are integrated, allowing <a href="#element-text"><code>xsl:text</code></a>
                  to be used to construct all text nodes, whether the content is fixed or variable.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/323">323</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2251">2251</a>&nbsp;31 October 2025]</i></p>
                        </li>
                        <li>
                           <p>The attribute <code>cdata</code> is added to <a href="#element-text"><code>xsl:text</code></a>
                  and <a href="#element-value-of"><code>xsl:value-of</code></a> to request serialization of a text node as a CDATA
                  section.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2198">2198</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2301">2301</a>&nbsp;19 November 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-text"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:text<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;cdata? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:text&gt;</code></p>
                  <p class="element-syntax"><a id="element-value-of"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:value-of<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;cdata? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:value-of&gt;</code></p>
                  <p>The <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a>element 
                  have identical content models. The only differences between them are:</p>
                  <ol class="enumar">
                     <li>
                        <p>The <a href="#element-text"><code>xsl:text</code></a> element is treated specially
                     during whitespace-stripping, as described in <a href="#stylesheet-stripping"><i>3.11.1 Stripping Whitespace and Commentary from the Stylesheet</i></a>.
                     Specifically, whitespace text nodes that are children of <a href="#element-text"><code>xsl:text</code></a>
                     are preserved, whereas whitespace text nodes that are children of <a href="#element-value-of"><code>xsl:value-of</code></a>
                     are discarded.</p>
                     </li>
                     <li>
                        <p>Special rules apply to <a href="#element-value-of"><code>xsl:value-of</code></a> 
                     when the instruction is processed
                     with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>.
                     Specifically, if no <code>separator</code> attribute is present, 
                     and if the <code>select</code> attribute is present, then all items in the 
                     <a title="atomize" class="termref" href="#dt-atomization">atomized</a> result sequence 
                     other than the first are ignored.</p>
                     </li>
                  </ol>
                  <p>The <a href="#element-text"><code>xsl:text</code></a> or 
                  <a href="#element-value-of"><code>xsl:value-of</code></a> instruction is evaluated to construct a new text
                  node; the result of the instruction is the newly constructed text node.</p>
                  <p>The string value of the new text node may be defined either by using the
                     <code>select</code> attribute, or by the 
                  <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
                  (see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>)
                  that forms the content of the <a href="#element-text"><code>xsl:text</code></a> or 
                  <a href="#element-value-of"><code>xsl:value-of</code></a> element. 
                  These are mutually exclusive: if the <code>select</code>
                     attribute is present then the sequence constructor must be empty, and if the
                     sequence constructor is non-empty then the <code>select</code> attribute must
                     be absent. If the <code>select</code> attribute is absent and the sequence
                     constructor is empty, then the result of the instruction is a text node whose
                     string value is zero-length. The way in which the value is constructed
                  is specified in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
                  <p>
                  <a id="err-XTSE0870"><span class="error">[ERR XTSE0870] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           <code>select</code> attribute of the <a href="#element-text"><code>xsl:text</code></a> or 
                        <a href="#element-value-of"><code>xsl:value-of</code></a>
                        element is present when the content of the element is non-empty.
               </p>
                  <p>If the <code>separator</code> attribute is present, then the 
                  <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of this attribute is used to
                  separate adjacent items in the result sequence, as described in 
                  <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>. In the absence of this attribute, the
                  default separator is <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>)  when the content is specified using the
                     <code>select</code> attribute, or a zero-length string when the content is
                  specified using a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a>.</p>
                  <p>If the element or one of its ancestors has an
                     <code>[xsl:]expand-text</code> attribute, and the nearest ancestor with such an
                  attribute has the value <code>yes</code>, then any unescaped curly brackets in the
                  value of the element indicate the presence of <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>, which are expanded
                  as described in <a href="#text-value-templates"><i>5.6.2 Text Value Templates</i></a>.</p>
                  <p>In the absence of such an attribute, or if the
                  <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is <code>no</code>, the content of the
                     <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a>
                  instruction may comprise a single text node whose value forms the
                     <a title="string value" class="termref" href="#dt-string-value">string value</a> of the constructed text node. An
                     <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a> element 
                  may also be empty, in which case the result of
                  evaluating the instruction is a text node whose string value is the zero-length
                  string.</p>
                  <p>For the effect of the <code>cdata</code> attribute, see <a href="#generating-cdata"><i>11.4.3 Generating CDATA Sections</i></a>.</p>
                  <p>For the effect of the <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a>
                  <code>disable-output-escaping</code> attribute, see <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a>
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>It is not always necessary to use the <a href="#element-text"><code>xsl:text</code></a> 
                     or <a href="#element-value-of"><code>xsl:value-of</code></a> instruction to
                     write text nodes to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>.
                     Literal text can be written to the result tree by including it anywhere in a
                        <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. The principal reason for
                     using <a href="#element-text"><code>xsl:text</code></a> is that it offers improved control over
                     whitespace handling.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Historically, <a href="#element-value-of"><code>xsl:value-of</code></a> was used to construct
                  variable content, while <a href="#element-text"><code>xsl:text</code></a> was used to copy fixed
                  text from the stylesheet to the result document. In 4.0, that distinction
                  is no longer relevant. Stylesheet authors should consider using 
                   <a href="#element-text"><code>xsl:text</code></a> whenever there is a need to construct
                     text nodes, as the intent is more clearly expressed. 
                     The <a href="#element-value-of"><code>xsl:value-of</code></a> instruction has often been misunderstood; 
                  it is a common mistake to use it where <a href="#element-sequence"><code>xsl:sequence</code></a> or
                  <a href="#element-copy-of"><code>xsl:copy-of</code></a> is more appropriate.</p>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e35473"></a>Example: Generating a List with Separators</div>
                     <p>The instruction:</p>
                     <div class="exampleInner">
                        <pre>&lt;x&gt;&lt;xsl:text select="1 to 4" separator="|"/&gt;&lt;/x&gt;</pre>
                     </div>
                     <p>produces the output:</p>
                     <div class="exampleInner">
                        <pre>&lt;x&gt;1|2|3|4&lt;/x&gt;</pre>
                     </div>
                  </div>
                  <p>&nbsp;</p>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e35481"></a>Example: Generating Whitespace using <code>xsl:text</code></div>
                     <p>The instruction:</p>
                     <div class="exampleInner">
                        <pre>&lt;a&gt;&lt;xsl:text&gt;  &lt;x/&gt;  &lt;/xsl:text&gt;&lt;/a&gt;</pre>
                     </div>
                     <p>produces the output:</p>
                     <div class="exampleInner">
                        <pre>&lt;a&gt;  &lt;x/&gt;  &lt;/a&gt;</pre>
                     </div>
                     <p>This illustrates that all whitespace text node children of <a href="#element-text"><code>xsl:text</code></a> are preserved,
                  even if they have non-whitespace siblings.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="generating-cdata"></a>11.4.3 <a href="#generating-cdata" style="text-decoration: none">Generating CDATA Sections</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#comparing-sort-keys">next</a> | <a href="#xsl-text">previous</a>)</p>
                     <ol>
                        <li>
                           <p>The attribute <code>cdata</code> is added to <a href="#element-text"><code>xsl:text</code></a>
                  and <a href="#element-value-of"><code>xsl:value-of</code></a> to request serialization of a text node as a CDATA
                  section.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2198">2198</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2301">2301</a>&nbsp;19 November 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>The XDM data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>) does not recognize CDATA sections as a special kind
               of node; CDATA is regarded simply as one way of serializing a text node. The elements
               <code>&lt;e&gt;x &amp;lt; y&lt;/e&gt;</code> and <code>&lt;e&gt;&lt;![CDATA[x &lt; y]]&gt;&lt;/e&gt;</code> have
               exactly the same representation in XDM: an element node with a text node child, the string value
               of the text node being <code>"x &lt; y"</code>.</p>
                  <p>It is however possible to request that a text node should be serialized as a CDATA section. If all elements
               with a given name are to be serialized as CDATA, this can be achieved using the serialization parameter
               <code>cdata-section-elements</code> (available, for example, as an attribute on <a href="#element-output"><code>xsl:output</code></a>
               and <a href="#element-result-document"><code>xsl:result-document</code></a>). If CDATA serialization is to be used more selectively than this, 
               it can also be requested using the <code>cdata</code> attribute on the <a href="#element-text"><code>xsl:text</code></a> and
               <a href="#element-value-of"><code>xsl:value-of</code></a> instructions.</p>
                  <p>The <code>cdata</code> attribute, if its effective value is <code>yes</code>,
               is a request to the processor to serialize the text node as a CDATA section.
               For example, the text node produced by the instruction <code>&lt;xsl:text cdata="yes"&gt;&gt;&gt;&gt;&lt;/xsl:text&gt;</code>
               might be serialized as <code>&lt;![CDATA[&gt;&gt;&gt;]]&gt;</code>. Honoring this request
               requires close coupling between the processor and the serializer, and
               processors <span class="verb">may</span> therefore ignore the request. In particular, it is
               likely that a processor will ignore the request unless the result of the transformation
               is passed directly to the serializer, bypassing the construction of an in-memory
               result tree.</p>
                  <p>It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances, the
               <code>cdata</code> attribute of the <a href="#element-text"><code>xsl:text</code></a> and
               <a href="#element-value-of"><code>xsl:value-of</code></a> instructions has any effect on the serialized output.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>A processor delivering output in the form of an in-memory tree using a data model
               (such as the DOM model) that includes CDATA nodes <span class="verb">may</span> take account of
               the <code>cdata</code> attribute to generate such nodes.</p>
                  </div>
                  <p>If the <code>cdata</code> attribute is present, regardless of its <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>,
               then the <code>disable-output-escaping</code> attribute is ignored.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The attribute is likely to have effect only in the following circumstances:</p>
                     <ul>
                        <li>
                           <p>The output of the transformation is sent directly to a serializer (or to
                           another destination, such as a DOM, that recognizes CDATA).</p>
                        </li>
                        <li>
                           <p>The serialization method is <code>xml</code> or <code>xhtml</code> (perhaps
                     invoked indirectly via the <code>html</code> or <code>adaptive</code> output methods).</p>
                        </li>
                        <li>
                           <p>The text node is not bound to a variable.</p>
                        </li>
                        <li>
                           <p>The parent element of the text node is not listed in the <code>cdata-section-elements</code>
                            serialization parameter (in this case every text node child of the element
                            should be serialized as a CDATA section, regardless of any <code>cdata</code>
                            attributes).</p>
                        </li>
                        <li>
                           <p>The text node is not used as input to the process of constructing
                        an attribute, comment, processing instruction, or another text node: 
                        see <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
                        </li>
                        <li>
                           <p>The text node is not used as input to the process of constructing
                        a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a>.</p>
                        </li>
                     </ul>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The <code>cdata</code> attribute is an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>, so the
               value can be made conditional on the actual content of the text. For example,
               the instruction:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:value-of select="$s" cdata="{matches($s, '[&amp;lt;&amp;amp;]')}"/&gt;</pre>
                     </div>
                     <p>will request serialization as a CDATA section if the text contains either of the
               characters <code>&lt;</code> or <code>&amp;</code>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Whether or not the output of an <a href="#element-text"><code>xsl:text</code></a> or <a href="#element-value-of"><code>xsl:value-of</code></a>
               instruction is “sent directly to a serializer” is essentially implementation-defined.
               There may be cases that vary between processors, for example an instruction that returns
               the result of a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>.</p>
                  </div>
                  <p>The effect of setting <code>cdata="yes"</code> (in cases where it has any effect at all)
                  is as if the text node were wrapped in a containing element
                  whose name is listed in the <code>cdata-section-elements</code> parameter,
                  with the start and end tags of that element then being stripped from the serialized output.</p>
                  <p>This implies:</p>
                  <ul>
                     <li>
                        <p>If the text node includes the character sequence <code>]]&gt;</code>, then the CDATA section
                  must be closed, and a new CDATA section opened, after the <code>]]</code>.</p>
                     </li>
                     <li>
                        <p>Similarly, if the text node includes a codepoint that cannot be represented
                        using the selected encoding, then the CDATA section
                  must be closed, and a new CDATA section opened, after the escaped representation of that codepoint.</p>
                     </li>
                     <li>
                        <p>Unicode normalization does not operate across the boundary between a CDATA
                        and a non-CDATA text node.</p>
                     </li>
                     <li>
                        <p>Character mapping (as defined by the <code>use-character-maps</code> parameter)
                        does not take place within a CDATA text node.</p>
                     </li>
                     <li>
                        <p>Special characters such as <code>&amp;</code> and <code>&lt;</code>
                        in a CDATA text node are not escaped.</p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="creating-document-nodes"></a>11.5 <a href="#creating-document-nodes" style="text-decoration: none">Creating Document Nodes</a></h3>
               <p class="element-syntax"><a id="element-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:document<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:document&gt;</code></p>
               <p>The <a href="#element-document"><code>xsl:document</code></a> instruction is used to create a new document node.
               The content of the <a href="#element-document"><code>xsl:document</code></a> element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> for the children of
               the new document node. A document node is created, and the sequence obtained by
               evaluating the sequence constructor is used to construct the content of the document,
               as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. </p>
               <p>Except in error situations, the result of evaluating the
                  <a href="#element-document"><code>xsl:document</code></a> instruction is a single node, the newly constructed
               document node.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The new document is not serialized. To construct a document that is to form a
                  final result rather than an intermediate result, use the
                     <a href="#element-result-document"><code>xsl:result-document</code></a> instruction described in <a href="#creating-result-trees"><i>25.1 Creating Secondary Results</i></a>.</p>
               </div>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <a href="#element-document"><code>xsl:document</code></a> instruction to validate the contents of the new
               document, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that elements and
               attributes within the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> will carry.
               The permitted values and their semantics are described in <a href="#validating-document-nodes"><i>25.4.2 Validating Document Nodes</i></a>.</p>
               <p>The base URI of the new document node is taken from the base URI of the
                  <a href="#element-document"><code>xsl:document</code></a> instruction.</p>
               <p>The <code>document-uri</code> and <code>unparsed-entities</code> properties of the
               new document node are set to empty.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e35756"></a>Example: Checking Uniqueness Constraints in a Temporary Tree</div>
                  <p>The following example creates a temporary tree held in a variable. The use of an
                  enclosed <a href="#element-document"><code>xsl:document</code></a> instruction ensures that uniqueness
                  constraints defined in the schema for the relevant elements are checked.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="tree" as="document-node()"&gt;
  &lt;xsl:document validation="strict"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/xsl:document&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="creating-processing-instructions"></a>11.6 <a href="#creating-processing-instructions" style="text-decoration: none">Creating Processing Instructions</a></h3>
               <p class="element-syntax"><a id="element-processing-instruction"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:processing-instruction<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:processing-instruction&gt;</code></p>
               <p>The <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is evaluated to create a
               processing instruction node.</p>
               <p>The <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element has a
                  <span class="verb">required</span>
               <code>name</code> attribute that specifies the name of the processing instruction
               node. The value of the <code>name</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>.</p>
               <p>The string value of the new processing instruction node may be defined either by
               using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the
               content of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element. These are mutually exclusive: if the <code>select</code>
                  attribute is present then the sequence constructor must be empty, and if the
                  sequence constructor is non-empty then the <code>select</code> attribute must be
                  absent. If the <code>select</code> attribute is absent and the sequence
                  constructor is empty, then the string value of the new
               processing instruction node will be a zero-length string. The way in which the value
               is constructed is specified in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
               <p>
               <a id="err-XTSE0880"><span class="error">[ERR XTSE0880] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the
                        <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is present unless the
                     element has empty content.
            </p>
               <p>Except in error situations, the result of evaluating the
                  <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> instruction is a single node, the
               newly constructed processing instruction node.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e35835"></a>Example: Creating a Processing Instruction</div>
                  <p>This instruction:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:processing-instruction name="xml-stylesheet"
  select="('href=&amp;quot;book.css&amp;quot;', 'type=&amp;quot;text/css&amp;quot;')"/&gt;</pre>
                  </div>
                  <p>creates the processing instruction</p>
                  <div class="exampleInner">
                     <pre>&lt;?xml-stylesheet href="book.css" type="text/css"?&gt;</pre>
                  </div>
                  <p>Note that the <code>xml-stylesheet</code> processing instruction contains
                     <em>pseudo-attributes</em> in the form <code>name="value"</code>. Although
                  these have the same textual form as attributes in an element start tag, they are
                  not represented as XDM attribute nodes, and cannot therefore be constructed using
                     <a href="#element-attribute"><code>xsl:attribute</code></a> instructions.</p>
               </div>
               <p>
               <a id="err-XTDE0890"><span class="error">[ERR XTDE0890] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code>
                     attribute  is not both an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup> and a <a href="https://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Because these rules disallow the name <code>xml</code>, the
                     <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> cannot be used to output an XML
                  declaration. The <a href="#element-output"><code>xsl:output</code></a> declaration should be used to control
                  this instead (see <a href="#serialization"><i>26 Serialization</i></a>).</p>
               </div>
               <p>If the result of evaluating the content of the
                  <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> contains the string
               <code>?&gt;</code>, this string is modified by inserting a space between the
                  <code>?</code> and <code>&gt;</code> characters.</p>
               <p>The base URI of the new processing instruction is copied from the base URI of the
                  <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element in the stylesheet. (Note,
               however, that this is only relevant when creating a parentless processing
               instruction. When the new processing instruction is copied to form a child of an
               element or document node, the base URI of the new copy is taken from that of its new
               parent.)</p>
            </div>
            <div class="div2">
               
               <h3><a id="creating-namespace-nodes"></a>11.7 <a href="#creating-namespace-nodes" style="text-decoration: none">Creating Namespace Nodes</a></h3>
               <p class="element-syntax"><a id="element-namespace"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:namespace<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:namespace&gt;</code></p>
               <p>The <a href="#element-namespace"><code>xsl:namespace</code></a> element is evaluated to create a namespace node.
               Except in error situations, the result of evaluating the
                  <a href="#element-namespace"><code>xsl:namespace</code></a> instruction is a single node, the newly constructed
               namespace node.</p>
               <p>The <a href="#element-namespace"><code>xsl:namespace</code></a> element has a <span class="verb">required</span>
               <code>name</code> attribute that specifies the name of the namespace node (that is,
               the namespace prefix). The value of the <code>name</code> attribute is interpreted as
               an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. If
               the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                  <code>name</code> attribute is a zero-length string, a namespace node is added for
               the default namespace.</p>
               <p>The string value of the new namespace node (that is, the namespace URI) may be
               defined either by using the <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the
               content of the <a href="#element-namespace"><code>xsl:namespace</code></a> element. These are mutually exclusive: if the <code>select</code> attribute is present
                  then the sequence constructor must be empty, and if the sequence constructor is
                  non-empty then the <code>select</code> attribute must be absent. Since
               the string value of a namespace node cannot be a zero-length string, either a <code>select</code> attribute or a non-empty sequence
                  constructor <span class="verb">must</span> be present. The way in which the
               value is constructed is specified in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
               <p>
               <a id="err-XTDE0905"><span class="error">[ERR XTDE0905] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the string value of
                     the new namespace node is not valid in the lexical space of the datatype
                        <code>xs:anyURI</code>, or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.
            </p>
               <p>
               <a id="err-XTSE0910"><span class="error">[ERR XTSE0910] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-namespace"><code>xsl:namespace</code></a> element
                     is present when the element has content other than one or more
                        <a href="#element-fallback"><code>xsl:fallback</code></a> instructions, or if the <code>select</code>
                     attribute is absent when the element has empty content.
            </p>
               <p>Note the restrictions described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a> for
               the position of a namespace node relative to other nodes in the node sequence
               returned by a sequence constructor.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e36014"></a>Example: Constructing a QName-Valued Attribute</div>
                  <p>This literal result element:</p>
                  <div class="exampleInner">
                     <pre>&lt;data xsi:type="xs:integer" 
             xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;
  &lt;xsl:namespace name="xs" 
                 select="'http://www.w3.org/2001/XMLSchema'"/&gt;
  &lt;xsl:text&gt;42&lt;/xsl:text&gt;
&lt;/data&gt;</pre>
                  </div>
                  <p>would typically cause the output document to contain the element:</p>
                  <div class="exampleInner">
                     <pre>&lt;data xsi:type="xs:integer"
     xmlns:xs="http://www.w3.org/2001/XMLSchema"
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt;42&lt;/data&gt;</pre>
                  </div>
                  <p>In this case, the element is constructed using a literal result element, and the
                  namespace <code>xmlns:xs="http://www.w3.org/2001/XMLSchema"</code> could therefore
                  have been added to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> simply
                  by declaring it as one of the in-scope namespaces in the stylesheet. In practice,
                  the <a href="#element-namespace"><code>xsl:namespace</code></a> instruction is more likely to be useful in
                  situations where the element is constructed using an <a href="#element-element"><code>xsl:element</code></a>
                  instruction, which does not copy all the in-scope namespaces from the
                  stylesheet.</p>
               </div>
               <p>
               <a id="err-XTDE0920"><span class="error">[ERR XTDE0920] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code>
                     attribute  is neither a zero-length string nor an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, or if it is <code>xmlns</code>.
                  
            </p>
               <p>
               <a id="err-XTDE0925"><span class="error">[ERR XTDE0925] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the
                        <a href="#element-namespace"><code>xsl:namespace</code></a> instruction generates a namespace node whose
                     name is <code>xml</code> and whose string value is not
                        <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose
                     string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose
                     name is not <code>xml</code>.
            </p>
               <p>
               <a id="err-XTDE0930"><span class="error">[ERR XTDE0930] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if evaluating the
                        <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of an <a href="#element-namespace"><code>xsl:namespace</code></a>
                     instruction results in a zero-length string. 
            </p>
               <p>For details of other error conditions that may arise, see <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>It is rarely necessary to use <a href="#element-namespace"><code>xsl:namespace</code></a> to create a namespace
                  node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>; in most
                  circumstances, the required namespace nodes will be created automatically, as a
                  side-effect of writing elements or attributes that use the namespace. An example
                  where <a href="#element-namespace"><code>xsl:namespace</code></a> is needed is a situation where the required
                  namespace is used only within attribute values in the result document, not in
                  element or attribute names; especially where the required namespace prefix or
                  namespace URI is computed at run-time and is not present in either the source
                  document or the stylesheet.</p>
                  <p>Adding a namespace node to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>
                  will never change the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of
                  any element or attribute node in the result tree: that is, it will never change
                  the namespace URI of an element or attribute. It might, however, constrain the
                  choice of prefixes when namespace fixup is performed.</p>
                  <p>Namespace prefixes for element and attribute names are initially established by
                  the rules of the instruction that creates the element or attribute node, and in
                  the event of conflicts, they may be changed by the namespace fixup process
                  described in <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>. The fixup process ensures that an
                  element has in-scope namespace nodes for the namespace URIs used in the element
                  name and in its attribute names, and the serializer will typically use these
                  namespace nodes to determine the prefix to use in the serialized output. The fixup
                  process cannot generate namespace nodes that are inconsistent with those already
                  present in the tree. This means that it is not possible for the processor to
                  decide the prefix to use for an element or for any of its attributes until all the
                  namespace nodes for the element have been added.</p>
                  <p>If a namespace prefix is mapped to a particular namespace URI using the
                     <a href="#element-namespace"><code>xsl:namespace</code></a> instruction, or by using
                     <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> to copy a namespace
                  node, this prevents the namespace fixup process (and hence the serializer) from
                  using the same prefix for a different namespace URI on the same element.</p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e36136"></a>Example: Conflicting Namespace Prefixes</div>
                  <p>Given the instruction:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:element name="p:item" 
                 xmlns:p="http://www.example.com/p"&gt;
  &lt;xsl:namespace name="p"&gt;http://www.example.com/q&lt;/xsl:namespace&gt;
&lt;/xsl:element&gt;</pre>
                  </div>
                  <p>a possible serialization of the <a title="result tree" class="termref" href="#dt-result-tree">result
                     tree</a> is:</p>
                  <div class="exampleInner">
                     <pre>&lt;ns0:item 
    xmlns:ns0="http://www.example.com/p" 
    xmlns:p="http://www.example.com/q"/&gt;</pre>
                  </div>
                  <p>The processor must invent a namespace prefix for the URI <code>p.uri</code>; it
                  cannot use the prefix <code>p</code> because that prefix has been explicitly
                  associated with a different URI.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The <a href="#element-namespace"><code>xsl:namespace</code></a> instruction cannot be used to generate a
                     <b>namespace undeclaration</b> of the form <code>xmlns=""</code> (nor the
                  new forms of namespace undeclaration permitted in <a href="#xml-names11">[Namespaces in XML 1.1]</a>).
                  Namespace undeclarations are generated automatically by the serializer if
                     <code>undeclare-prefixes="yes"</code> is specified on
                     <a href="#element-output"><code>xsl:output</code></a>, whenever a parent element has a namespace node for
                  the default namespace prefix, and a child element has no namespace node for that
                  prefix.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="creating-comments"></a>11.8 <a href="#creating-comments" style="text-decoration: none">Creating Comments</a></h3>
               <p class="element-syntax"><a id="element-comment"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:comment<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:comment&gt;</code></p>
               <p>The <a href="#element-comment"><code>xsl:comment</code></a> element is evaluated to construct a new comment
               node. Except in error cases, the result of evaluating the
                  <a href="#element-comment"><code>xsl:comment</code></a> instruction is a single node, the newly constructed
               comment node.</p>
               <p>The string value of the new comment node may be defined either by using the
                  <code>select</code> attribute, or by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the
                  <a href="#element-comment"><code>xsl:comment</code></a> element. These are mutually
                  exclusive: if the <code>select</code> attribute is present then the sequence
                  constructor must be empty, and if the sequence constructor is non-empty then the
                     <code>select</code> attribute must be absent. If the <code>select</code>
                  attribute is absent and the sequence constructor is empty, then the
               string value of the new comment node will be a zero-length string. The way in which
               the value is constructed is specified in <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>.</p>
               <p>
               <a id="err-XTSE0940"><span class="error">[ERR XTSE0940] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-comment"><code>xsl:comment</code></a> element is
                     present unless the element has empty content.
            </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e36225"></a>Example: Generating a Comment Node</div>
                  <p>For example, this</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:comment&gt;This file is automatically generated. Do not edit!&lt;/xsl:comment&gt;</pre>
                  </div>
                  <p>would create the comment</p>
                  <div class="exampleInner">
                     <pre>&lt;!--This file is automatically generated. Do not edit!--&gt;</pre>
                  </div>
               </div>
               <p>In the generated comment node, the processor <span class="verb">must</span> insert a space
               after any occurrence of <code>x2D</code> (hyphen) that is followed by another occurrence of <code>x2D</code> (hyphen) or
               that ends the comment.</p>
            </div>
            <div class="div2">
               
               <h3><a id="copying"></a>11.9 <a href="#copying" style="text-decoration: none">Copying Nodes</a></h3>
               <div class="div3">
                  
                  <h4><a id="shallow-copy"></a>11.9.1 <a href="#shallow-copy" style="text-decoration: none">Shallow Copy</a></h4>
                  <p class="element-syntax"><a id="element-copy"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:copy<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var>〔''〕<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:copy&gt;</code></p>
                  <p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction provides a way of copying a selected item. The selected item is the item selected by
                     evaluating the expression in the <code>select</code> attribute if present, or
                     the <a title="context item" class="termref" href="#dt-context-item">context item</a> otherwise.
                  If the selected item is a node, evaluating the <a href="#element-copy"><code>xsl:copy</code></a>
                  instruction constructs a copy of the selected node, and the result of the
                     <a href="#element-copy"><code>xsl:copy</code></a> instruction is this newly constructed node. By
                  default, the namespace nodes of the context node are automatically copied as well,
                  but the attributes and children of the node are not automatically copied.</p>
                  <p>
                  <a id="err-XTTE0945"><span class="error">[ERR XTTE0945] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the
                           <a href="#element-copy"><code>xsl:copy</code></a> instruction with no <code>select</code>
                        attribute when the context item is absent. 
               </p>
                  <p>If the <code>select</code> expression returns the empty sequence,
                  the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns the empty sequence, and the
                  contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated.</p>
                  <p><a id="err-XTTE3180"><span class="error">[ERR XTTE3180] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                        evaluating the <code>select</code> expression  is a sequence of more
                        than one item.</p>
                  <p>When the selected item is an atomic item
                     or function item, the
                     <a href="#element-copy"><code>xsl:copy</code></a> instruction returns this value. The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated.
                     </p>
                  <p>When the selected item is an attribute node,
                  text node, comment node, processing instruction node, or namespace node, the
                     <a href="#element-copy"><code>xsl:copy</code></a> instruction returns a new node that is a copy of the
                  context node. The new node will have the same node kind, name, and string value as
                  the context node. In the case of an attribute node, it will also have the same
                  values for the <code>is-id</code> and <code>is-idrefs</code> properties. The
                     <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is not evaluated. </p>
                  <p>When the selected item is a document node or
                  element node, the <a href="#element-copy"><code>xsl:copy</code></a> instruction returns a new node that
                  has the same node kind and name as the selected
                  node. The content of the new node is formed by evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the
                     <a href="#element-copy"><code>xsl:copy</code></a> instruction. If the
                        <code>select</code> attribute is present then the sequence constructor is
                     evaluated with the selected item as the <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a>; otherwise it is evaluated using the context of
                     the <a href="#element-copy"><code>xsl:copy</code></a> instruction unchanged. The sequence
                  obtained by evaluating this sequence constructor is used (after prepending any
                  attribute nodes or namespace nodes as described in the following paragraphs) to
                  construct the content of the document or element node, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p>
                  <p>When the selected item is a document node, the
                     <code>unparsed-entities</code> property of the existing document node is copied
                  to the new document node.</p>
                  <p>When the selected item is an element or attribute node,
                  the values of the <code>is-id</code>, <code>is-idrefs</code>, and
                     <code>nilled</code> properties of the new element or attribute depend on the
                  values of the <code>validation</code> and <code>type</code> attributes, as defined
                  in <a href="#validation"><i>25.4 Validation</i></a>.</p>
                  <p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional
                     <code>use-attribute-sets</code> attribute, whose value is a
                  whitespace-separated list of QNames that identify
                     <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations. This attribute is used only
                  when copying element nodes. This list is expanded as described in <a href="#attribute-sets"><i>10.2 Named Attribute Sets</i></a> to produce a sequence of attribute nodes. This sequence
                  is prepended to the sequence produced as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p>
                  <p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional
                     <code>copy-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then all the namespace nodes of the source element are copied as
                  namespace nodes for the result element. These copied namespace nodes are prepended
                  to the sequence produced as a result of evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (it is immaterial
                  whether they come before or after any attribute nodes produced by expanding the
                     <code>use-attribute-sets</code> attribute). If the value is set to
                     <code>no</code>, then the namespace nodes are not copied. However, namespace
                  nodes will still be added to the result element as <span class="verb">required</span> by
                  the namespace fixup process: see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>.</p>
                  <p>The <a href="#element-copy"><code>xsl:copy</code></a> instruction has an optional
                     <code>inherit-namespaces</code> attribute, with the value <code>yes</code> or
                     <code>no</code>. The default value is <code>yes</code>. The attribute is used
                  only when copying element nodes. If the value is set to <code>yes</code>, or is
                  omitted, then the namespace nodes created for the newly constructed element
                  (whether these were copied from those of the source node, or generated as a result
                  of namespace fixup) are copied to the children and descendants of the newly
                  constructed element, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>. If the value is set to <code>no</code>, then these namespace nodes are not
                  automatically copied to the children. This may result in namespace undeclarations
                  (such as <code>xmlns=""</code> or, in the case of XML Namespaces 1.1,
                     <code>xmlns:p=""</code>) appearing on the child elements when a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is serialized.</p>
                  <p>
                  <a id="err-XTTE0950"><span class="error">[ERR XTTE0950] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the
                           <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to
                        copy a node that has namespace-sensitive content if the
                           <code>copy-namespaces</code> attribute has the value <code>no</code> and
                        its explicit or implicit <code>validation</code> attribute has the value
                           <code>preserve</code>. It is also a type error if either of these
                        instructions (with <code>validation="preserve"</code>) is used to copy an
                        attribute having namespace-sensitive content, unless the parent element is
                        also copied. A node has namespace-sensitive content if its typed value
                        contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                        or a type derived therefrom. The reason this is an error is because the
                        validity of the content depends on the namespace context being
                        preserved.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>When attribute nodes are copied, whether with <a href="#element-copy"><code>xsl:copy</code></a> or with
                        <a href="#element-copy-of"><code>xsl:copy-of</code></a>, the processor does not automatically copy any
                     associated namespace information. The namespace used in the attribute name
                     itself will be declared by virtue of the namespace fixup process (see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>) when the attribute is added to an element in the
                        <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>, but if namespace
                     prefixes are used in the content of the attribute (for example, if the value of
                     the attribute is an XPath expression) then it is the responsibility of the
                     stylesheet author to ensure that suitable namespace nodes are added to the
                        <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. This can be achieved by
                     copying the namespace nodes using <a href="#element-copy"><code>xsl:copy</code></a>, or by generating
                     them using <a href="#element-namespace"><code>xsl:namespace</code></a>.</p>
                  </div>
                  <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <a href="#element-copy"><code>xsl:copy</code></a> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema, and thus to determine the
                     <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new copy of an element or
                  attribute node will carry. These attributes are ignored when copying an item that
                  is not an element, attribute or document node. When the node being copied is an
                  element or document node, these attributes also affect the type annotation carried
                  by any elements and attributes that have the copied element or document node as an
                  ancestor. These two attributes are both optional, and if one is specified then the
                  other <span class="verb">must</span> be omitted. The permitted values of these attributes
                  and their semantics are described in <a href="#validation"><i>25.4 Validation</i></a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The final <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of the node in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> also depends on the
                        <code>type</code> and <code>validation</code> attributes of the instructions
                     used to create the ancestors of the node.</p>
                  </div>
                  <p>When a node is copied, its base URI is copied, except
                  when the result of the <a href="#element-copy"><code>xsl:copy</code></a> instruction is an element node
                  having an <code>xml:base</code> attribute, in which case the base URI of the new
                  node is taken as the value of its <code>xml:base</code> attribute, resolved if it
                  is relative against the base URI of the <a href="#element-copy"><code>xsl:copy</code></a> instruction. </p>
                  <p>When an <code>xml:id</code> attribute is copied, using either the
                     <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction, it is
                     <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether the value of the attribute
                  is subjected to attribute value normalization (that is, effectively applying the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-normalize-space"><code>normalize-space</code></a> function).</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In most cases the value will already have been subjected to attribute value
                     normalization on the source tree, but if this processing has not been performed
                     on the source tree, it is not an error for it to be performed on the result
                     tree.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="copy-of"></a>11.9.2 <a href="#copy-of" style="text-decoration: none">Deep Copy</a></h4>
                  <p class="element-syntax"><a id="element-copy-of"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:copy-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;copy-accumulators? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;/&gt;</code></p>
                  <p>The <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction can be used to construct a copy of a
                  sequence of nodes, atomic items, and/or function
                     items with each new node containing copies of all the children,
                  attributes, and (by default) namespaces of the original node, recursively. The
                  result of evaluating the instruction is a sequence of items corresponding
                  one-to-one with the supplied sequence, and retaining its order.</p>
                  <p>The <span class="verb">required</span>
                  <code>select</code> attribute contains an <a title="expression" class="termref" href="#dt-expression">expression</a>, whose value may be any sequence of nodes, atomic items,
                     and/or function items. The items in this
                  sequence are processed as follows:</p>
                  <ul>
                     <li>
                        <p>If the item is an element node, a new element is constructed and appended to
                        the result sequence. The new element will have the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as the original, and it
                        will have deep copies of the attribute nodes and children of the element
                        node.</p>
                        <p>The new element will also have namespace nodes copied from the original
                        element node, unless they are excluded by specifying
                           <code>copy-namespaces="no"</code>. If this attribute is omitted, or takes
                        the value <code>yes</code>, then all the namespace nodes of the original
                        element are copied to the new element. If it takes the value
                        <code>no</code>, then none of the namespace nodes are copied: however,
                        namespace nodes will still be created in the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> as <span class="verb">required</span> by the namespace
                        fixup process: see <a href="#namespace-fixup"><i>5.7.3 Namespace Fixup</i></a>. This attribute affects
                        all elements copied by this instruction: both elements selected directly by
                        the <code>select</code>
                        <a title="expression" class="termref" href="#dt-expression">expression</a>, and elements that are
                        descendants of nodes selected by the <code>select</code> expression. </p>
                        <p>The values of the <code>is-id</code>,
                           <code>is-idrefs</code>, and <code>nilled</code> properties of the new
                        element depend on the values of the <code>validation</code> and
                           <code>type</code> attributes, as defined in <a href="#validation"><i>25.4 Validation</i></a>.</p>
                     </li>
                     <li>
                        <p>If the item is a document node, the instruction adds a new document node to
                        the result sequence; the children of this document node will be one-to-one
                        copies of the children of the original document node (each copied according
                        to the rules for its own node kind). The
                              <code>unparsed-entities</code> property of the original document node
                           is copied to the new document node.</p>
                     </li>
                     <li>
                        <p>If the item is an attribute or namespace node, or a text node, a comment, or
                        a processing instruction, the same rules apply as with
                           <a href="#element-copy"><code>xsl:copy</code></a> (see <a href="#shallow-copy"><i>11.9.1 Shallow Copy</i></a>).</p>
                     </li>
                     <li>
                        <p>If the item is an atomic item or a function
                           item, the value is appended to the result sequence, as with
                           <a href="#element-sequence"><code>xsl:sequence</code></a>.</p>
                     </li>
                  </ul>
                  <p>The optional attributes <code>type</code> and <code>validation</code> may be used
                  on the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to validate the contents of an
                  element, attribute or document node against a type definition, element
                  declaration, or attribute declaration in a schema and thus to determine the
                     <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> that the new copy of an element or
                  attribute node will carry. These attributes are applied individually to each
                  element, attribute, and document node that is selected by the expression in the
                     <code>select</code> attribute. These attributes are ignored when copying an
                  item that is not an element, attribute or document node.</p>
                  <p>The specified <code>type</code> and <code>validation</code> apply directly only to
                  elements, attributes and document nodes created as copies of nodes actually
                  selected by the <code>select</code> expression, they do not apply to nodes that
                  are implicitly copied because they have selected nodes as an ancestor. However,
                  these attributes do indirectly affect the <a title="type annotation" class="termref" href="#dt-type-annotation">type
                     annotation</a> carried by such implicitly copied nodes, as a consequence
                  of the validation process.</p>
                  <p>These two attributes are both optional, and if one is specified then the other
                     <span class="verb">must</span> be omitted. The permitted values of these attributes
                  and their semantics are described in <a href="#validation"><i>25.4 Validation</i></a>.</p>
                  <p>Errors may occur when copying namespace-sensitive elements or attributes using
                     <code>validation="preserve"</code>. <span class="error">[see <a href="#err-XTTE0950">ERR XTTE0950</a>]</span>.</p>
                  <p>If removal of namespaces is requested using
                     <code>copy-namespaces="no"</code>, then any validation that is requested is
                  applied to the tree that remains after the relevant namespaces have been removed.
                  This will cause validation to fail if there is namespace-sensitive content that
                  depends on the presence of the removed namespaces.</p>
                  <p>
                  For any node <var>N</var> that is explicitly selected by the evaluation of the 
                  <code>select</code> expression, the base URI of the new copy is as follows:</p>
                  <ul>
                     <li>
                        <p>If <var>N</var> is an element node having an <code>xml:base</code> attribute, 
                     the base URI of the new node is taken as the value of the <code>xml:base</code> attribute, 
                     resolved if it is relative against the static base URI of the <code>xsl:copy-of</code> instruction.
                  </p>
                     </li>
                     <li>
                        <p>Otherwise, the base URI of the new copy is the same as the base URI of <var>N</var>.
                  </p>
                     </li>
                  </ul>
                  <p>For any element or processing instruction node that has <var>N</var> as an ancestor, 
                     the base URI of the new copy is set to be the same as that of its new parent, 
                     with the following exception: if a copied element has an <code>xml:base</code> 
                     attribute, then its base URI is set to the value of that attribute, 
                     resolved if it is relative against the base URI of the new parent node.
                  </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If two elements in a subtree have different base URIs for some reason 
                     unconnected with <code>xml:base</code> attributes (for example, if they originated in different 
                     external entities), then these differences are lost when the subtree is copied.
                  </p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>As a consequence of rules specified elsewhere (see <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>), 
                        if a node created using the <code>xsl:copy-of</code> instruction is subsequently attached 
                        as a child to a new element or document node, the final copy of the node inherits 
                        its base URI from its new parent node, unless this is overridden using an <code>xml:base</code> attribute.
                     </p>
                  </div>
                  <p>The effect of the <code>copy-accumulators</code> attribute is described in
                  <a href="#applicability-of-accumulators"><i>19.2 Applicability of Accumulators</i></a>.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="number"></a>12 <a href="#number" style="text-decoration: none">Numbering</a></h2>
            <p class="element-syntax"><a id="element-number"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:number<br>&nbsp;&nbsp;value? = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;level? = "single" | "multiple" | "any"〔'single'〕<br>&nbsp;&nbsp;count? = <var>pattern</var><br>&nbsp;&nbsp;from? = <var>pattern</var><br>&nbsp;&nbsp;format? = { <var>string</var> }〔'1'〕<br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;letter-value? = { "alphabetic" | "traditional" }<br>&nbsp;&nbsp;ordinal? = { <var>string</var> }〔'no'〕<br>&nbsp;&nbsp;start-at? = { <var>string</var> }<br>&nbsp;&nbsp;grouping-separator? = { <var>char</var> }<br>&nbsp;&nbsp;grouping-size? = { <var>integer</var> }&nbsp;/&gt;</code></p>
            <p>The <a href="#element-number"><code>xsl:number</code></a> instruction is used to create a formatted number. The
            result of the instruction is a newly constructed text node containing the formatted
            number as its <a title="string value" class="termref" href="#dt-string-value">string value</a>.</p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-place-marker" title="place marker"></a>The <a href="#element-number"><code>xsl:number</code></a>
               instruction performs two tasks: firstly, determining a <b>place marker</b>
               (this is a sequence of integers, to allow for hierarchic numbering schemes such as
                  <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place
               marker for output as a text node in the result sequence.<span class="definition">]</span> The place marker
            to be formatted can either be supplied directly, in the <code>value</code> attribute, or
            it can be computed based on the position of a selected node within the tree that
            contains it.</p>
            <p>
            <a id="err-XTSE0975"><span class="error">[ERR XTSE0975] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> is present unless
                  the <code>select</code>, <code>level</code>, <code>count</code>, and
                     <code>from</code> attributes are all absent.
         </p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>The facilities described in this section are specifically designed to enable the
               calculation and formatting of section numbers, paragraph numbers, and the like. For
               formatting of other numeric quantities, the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a>
               function may be more suitable.</p>
               <p>Furthermore, formatting of integers where there is no requirement to calculate the
               position of a node in the document can now be accomplished using the
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-integer"><code>format-integer</code></a> function, which borrows many concepts from
               the <a href="#element-number"><code>xsl:number</code></a> specification.</p>
            </div>
            <div class="div2">
               
               <h3><a id="start-at"></a>12.1 <a href="#start-at" style="text-decoration: none">The <code>start-at</code> Attribute</a></h3>
               <p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                  <code>start-at</code> attribute <span class="verb">must</span> be a string representing a
               whitespace-separated sequence of one or more integers, each one optionally preceded
               by a minus sign, separated by whitespace. More specifically, the value must be a
               string matching the regular expression <code>-?[0-9]+(\s+-?[0-9]+)*</code>. This
               sequence of integers is used to <b>re-base</b> the sequence of integers being
               formatted. Specifically if <var>$S</var> is the sequence of integers represented by
               the <code>start-at</code> attribute, and <var>$V</var> is the sequence of integers to
               be formatted, then the following transformation is applied to <var>$V</var>:</p>
               <div class="exampleInner">
                  <pre>
for $i in 1 to count($V)
return if ($i le count($S))
  then $V[$i] + $S[$i] - 1
  else $V[$i] + $S[last()] - 1</pre>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This means that if there are <var>N</var> integers in the <code>start-at</code>
                  attribute, then these are used to re-base the first <var>N</var> numbers, while
                  numbers after the <var>Nth</var> are re-based using the last (<var>Nth</var>)
                  integer in the <code>start-at</code> attribute. If the <code>start-at</code>
                  attribute contains more integers than are required, the surplus is ignored.</p>
               </div>
               <p>For example, if the attribute is given as
                  <code>start-at="3 0 0"</code>, and the number sequence to be formatted is
                  <code>(1, 1, 1, 1)</code>, then the re-based sequence is <code>3, 0, 0,
               0</code>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="formatting-supplied-number"></a>12.2 <a href="#formatting-supplied-number" style="text-decoration: none">Formatting a Supplied Number</a></h3>
               <p>The <a title="place marker" class="termref" href="#dt-place-marker">place marker</a> to be formatted may be
               specified by an expression. The <code>value</code> attribute contains the <a title="expression" class="termref" href="#dt-expression">expression</a>. 
               The value of this expression is 
               <a title="atomize" class="termref" href="#dt-atomization">atomized</a> using the procedure defined in <a href="#xpath-40">[XPath 4.0]</a>, 
               and each value <var>$V</var> in the atomized sequence is then
               converted to the integer value returned by the XPath expression
                  <code>xs:integer(round(number($V)))</code>. If
                  the <code>start-at</code> attribute is present, this sequence is then re-based as
                  described in <a href="#start-at"><i>12.1 The start-at Attribute</i></a>. The resulting sequence of
               integers is used as the place marker to be formatted.</p>
               <p>If the instruction is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a>, then:</p>
               <ul>
                  <li>
                     <p>All items in the <a title="atomize" class="termref" href="#dt-atomization">atomized</a> sequence
                     after the first are discarded;</p>
                  </li>
                  <li>
                     <p>If the atomized sequence is empty, it is replaced by a sequence containing the
                        <code>xs:double</code> value <code>NaN</code> as its only item;</p>
                  </li>
                  <li>
                     <p>If any value in the sequence cannot be converted to an integer (this includes
                     the case where the sequence contains a <code>NaN</code> value) then the string
                        <code>NaN</code> is inserted into the formatted result string in its proper
                     position. The error described in the following paragraph does not apply in this
                     case.</p>
                  </li>
               </ul>
               <p>
               <a id="err-XTDE0980"><span class="error">[ERR XTDE0980] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if any undiscarded item
                     in the atomized sequence supplied as the value of the <code>value</code>
                     attribute of <a href="#element-number"><code>xsl:number</code></a> cannot be converted to an integer, or
                     if the resulting integer is less than 0 (zero). 
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The value zero does not arise when numbering nodes in a source document, but it
                  can arise in other numbering sequences. It is permitted specifically because the
                  rules of the <a href="#element-number"><code>xsl:number</code></a> instruction are also invoked by functions
                  such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-time"><code>format-time</code></a>: the minutes and seconds component of a
                  time value can legitimately be zero.</p>
               </div>
               <p>The resulting sequence is formatted as a string using the <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> of the attributes specified in
                  <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a>; each of these attributes is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. After
               conversion, the <a href="#element-number"><code>xsl:number</code></a> element constructs a new text node
               containing the resulting string, and returns this node.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e37071"></a>Example: Numbering a Sorted List</div>
                  <p>The following example numbers a sorted list:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="items"&gt;
  &lt;xsl:for-each select="item"&gt;
    &lt;xsl:sort select="."/&gt;
    &lt;p&gt;
      &lt;xsl:number value="position()" format="1. "/&gt;
      &lt;xsl:value-of select="."/&gt;
    &lt;/p&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="numbering-based-on-position"></a>12.3 <a href="#numbering-based-on-position" style="text-decoration: none">Numbering based on Position in a Document </a></h3>
               <p>If no <code>value</code> attribute is specified, then the <a href="#element-number"><code>xsl:number</code></a>
               instruction returns a new text node containing a formatted <a title="place marker" class="termref" href="#dt-place-marker">place marker</a> that is based on the position of a
               selected node within its containing document. If the <code>select</code> attribute is
               present, then the expression contained in the <code>select</code> attribute is
               evaluated to determine the selected node. If the <code>select</code> attribute is
               omitted, then the selected node is the <a title="context node" class="termref" href="#dt-context-node">context
                  node</a>.</p>
               <p>
               <a id="err-XTTE0990"><span class="error">[ERR XTTE0990] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                        <a href="#element-number"><code>xsl:number</code></a> instruction is evaluated, with no
                        <code>value</code> or <code>select</code> attribute, when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. 
            </p>
               <p>
               <a id="err-XTTE1000"><span class="error">[ERR XTTE1000] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                     evaluating the <code>select</code> attribute of the <a href="#element-number"><code>xsl:number</code></a>
                     instruction is anything other than a single node.
            </p>
               <p> The following attributes control how the selected node is to be numbered:</p>
               <ul>
                  <li>
                     <p>The <code>level</code> attribute specifies rules for selecting the nodes that
                     are taken into account in allocating a number; it has the values
                        <code>single</code>, <code>multiple</code> or <code>any</code>. The default
                     is <code>single</code>.</p>
                  </li>
                  <li>
                     <p>The <code>count</code> attribute is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that specifies which nodes are to be counted at those
                     levels. If <code>count</code> attribute is not specified, then it defaults to
                     the pattern that matches any node with the same node kind as the selected node
                     and, if the selected node has an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                        QName</a>, with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                        QName</a> as the selected node.</p>
                  </li>
                  <li>
                     <p>The <code>from</code> attribute is a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that specifies where counting starts.</p>
                  </li>
               </ul>
               <p>In addition, the attributes specified in <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a> are used for number
               to string conversion, as in the case when the <code>value</code> attribute is
               specified.</p>
               <p>The <a href="#element-number"><code>xsl:number</code></a> element first constructs a sequence of positive
               integers using the <code>level</code>, <code>count</code> and <code>from</code>
               attributes. Where <code>level</code> is <code>single</code> or <code>any</code>, this
               sequence will either be empty or contain a single number; where <code>level</code> is
                  <code>multiple</code>, the sequence may be of any length. The sequence is
               constructed as follows:</p>
               <p>Let <code>matches-count($node)</code> be a function that returns <code>true</code> if and only if
               the given node <code>$node</code> matches the pattern given in the <code>count</code>
               attribute, or the implied pattern (according to the rules given above) if the
                  <code>count</code> attribute is omitted.</p>
               <p>Let <code>matches-from($node)</code> be a function that returns <code>true</code> if and only if
               the given node <code>$node</code> matches the pattern given in the <code>from</code>
               attribute, or if <code>$node</code> is the root node of a tree. If the
                  <code>from</code> attribute is omitted, then the function returns <code>true</code> if and only
               if <code>$node</code> is the root node of a tree.</p>
               <p>Let <code>$S</code> be the selected node.</p>
               <p>When <code>level="single"</code>: </p>
               <ul>
                  <li>
                     <p>Let <code>$A</code> be the node sequence selected by the following
                     expression:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-count(.)][1]</code>
                  </p>
                     <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>count</code> pattern)</p>
                  </li>
                  <li>
                     <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                     <p>(this selects the innermost ancestor-or-self node that matches the
                        <code>from</code> pattern)</p>
                  </li>
                  <li>
                     <p>Let <code>$AF</code> be the value of:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                     <p>(this selects $A if it is in the subtree rooted at $F, or the empty sequence
                     otherwise)</p>
                  </li>
                  <li>
                     <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
                  </li>
                  <li>
                     <p>Otherwise return the value of:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;1 + count($AF/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                     <p>(the number of preceding siblings of the counted node that match the
                        <code>count</code> pattern, plus one).</p>
                  </li>
               </ul>
               <p>When <code>level="multiple"</code>: </p>
               <ul>
                  <li>
                     <p>Let <code>$A</code> be the node sequence selected by the expression:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-count(.)]</code>
                  </p>
                     <p>(the set of ancestor-or-self nodes that match the <code>count</code>
                     pattern)</p>
                  </li>
                  <li>
                     <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$S/ancestor-or-self::node()[matches-from(.)][1]</code>
                  </p>
                     <p>(the innermost ancestor-or-self node that matches the <code>from</code>
                     pattern)</p>
                  </li>
                  <li>
                     <p>Let <code>$AF</code> be the value of:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$A[ancestor-or-self::node()[. is $F]]</code>
                  </p>
                     <p>(the nodes selected in the first step that are in the subtree rooted at the
                     node selected in the second step)</p>
                  </li>
                  <li>
                     <p>Return the result of the expression:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;for $af in $AF return
                        1+count($af/preceding-sibling::node()[matches-count(.)])</code>
                  </p>
                     <p>(a sequence of integers containing, for each of these nodes, one plus the
                     number of preceding siblings that match the <code>count</code> pattern)</p>
                  </li>
               </ul>
               <p>When <code>level="any"</code>: </p>
               <ul>
                  <li>
                     <p>Let <code>$A</code> be the node sequence selected by the expression:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$S/(preceding::node()|ancestor-or-self::node())[matches-count(.)]</code>
                  </p>
                     <p>(the set of nodes consisting of the selected node together with all nodes,
                     other than attributes and namespaces, that precede the selected node in
                     document order, provided that they match the <code>count</code> pattern)</p>
                  </li>
                  <li>
                     <p>Let <code>$F</code> be the node sequence selected by the expression:</p>
                     <p>
                     <code>&nbsp;&nbsp;&nbsp;$S/(preceding::node()|ancestor-or-self::node())[matches-from(.)][last()]</code>
                  </p>
                     <p>(the last node in document order that matches the <code>from</code> pattern and
                     that precedes the selected node, using the same definition)</p>
                  </li>
                  <li>
                     <p>Let <code>$AF</code> be the node sequence <code>$A[. is $F or . &gt;&gt;
                        $F]</code></p>
                     <p>(the nodes selected in the first step, excluding those that precede the node
                     selected in the second step)</p>
                  </li>
                  <li>
                     <p>If <code>$AF</code> is empty, return the empty sequence, <code>()</code>
                  </p>
                  </li>
                  <li>
                     <p>Otherwise return the value of the expression <code>count($AF)</code>
                  </p>
                  </li>
               </ul>
               <p>The resulting sequence of numbers is referred to as the <a title="place marker" class="termref" href="#dt-place-marker">place marker</a>.</p>
               <p>If the <code>start-at</code> attribute is present, then the
                  <a title="place marker" class="termref" href="#dt-place-marker">place marker</a> is re-based as described in <a href="#start-at"><i>12.1 The start-at Attribute</i></a>.</p>
               <p>The sequence of numbers is then converted into a string using the <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> of the attributes specified in
                  <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a>; each of these attributes is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>. After
               conversion, the resulting string is used to create a text node, which forms the
               result of the <a href="#element-number"><code>xsl:number</code></a> instruction.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e37490"></a>Example: Numbering the Items in an Ordered List</div>
                  <p>The following will number the items in an ordered list:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="ol/item"&gt;
  &lt;fo:block&gt;
    &lt;xsl:number/&gt;
    &lt;xsl:text&gt;. &lt;/xsl:text&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e37495"></a>Example: Multi-Level Numbering</div>
                  <p>The following two rules will number <code>title</code> elements. This is intended
                  for a document that contains a sequence of chapters followed by a sequence of
                  appendices, where both chapters and appendices contain sections, which in turn
                  contain subsections. Chapters are numbered 1, 2, 3; appendices are numbered A, B,
                  C; sections in chapters are numbered 1.1, 1.2, 1.3; sections in appendices are
                  numbered A.1, A.2, A.3. Subsections within a chapter are numbered 1.1.1, 1.1.2,
                  1.1.3; subsections within an appendix are numbered A.1.1, A.1.2, A.1.3.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="title"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="chapter|section|subsection"
                 format="1.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="appendix//title" priority="1"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="multiple"
                 count="appendix|section|subsection"
                 format="A.1 "/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e37505"></a>Example: Numbering Notes within a Chapter</div>
                  <p>This example numbers notes sequentially within a chapter, starting from the number 100: :</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="note"&gt;
  &lt;fo:block&gt;
     &lt;xsl:number level="any" from="chapter" format="(1) " start-at="100"/&gt;
     &lt;xsl:apply-templates/&gt;
  &lt;/fo:block&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="convert"></a>12.4 <a href="#convert" style="text-decoration: none">Number to String Conversion Attributes</a></h3>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This specification is aligned with that of the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-integer"><code>format-integer</code></a> function, but there are differences; for
                  example grouping separators are part of the primary format token in
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-integer"><code>format-integer</code></a>, but are indicated by separate attributes
                  in <a href="#element-number"><code>xsl:number</code></a>.</p>
               </div>
               <p>The following attributes are used to control conversion of a sequence of numbers into
               a string. The numbers are integers greater than or equal to 0 (zero). The attributes
               are all optional.</p>
               <p>The main attribute is <code>format</code>. The default value for the
                  <code>format</code> attribute is <code>1</code>. The <code>format</code> attribute
               is split into a sequence of tokens where each token is a maximal sequence of
               alphanumeric characters or a maximal sequence of non-alphanumeric characters.
                  <em>Alphanumeric</em> means any character that has a Unicode category of Nd,
               Nl, No, Lu, Ll, Lt, Lm or Lo (see <a href="#UNICODE">[UNICODE]</a>). The alphanumeric tokens (<em>format tokens</em>)
               indicate the format to be used for each number in the sequence; in most cases the
               format token is the same as the required representation of the number 1 (one).</p>
               <p>Each non-alphanumeric token is either a prefix, a separator, or a suffix. If there is
               a non-alphanumeric token but no format token, then the single non-alphanumeric token
               is used as both the prefix and the suffix. The prefix, if it exists, is the
               non-alphanumeric token that precedes the first format token: the prefix always
               appears exactly once in the constructed string, at the start. The suffix, if it
               exists, is the non-alphanumeric token that follows the last format token: the suffix
               always appears exactly once in the constructed string, at the end. All other
               non-alphanumeric tokens (those that occur between two format tokens) are
                  <em>separator tokens</em> and are used to separate numbers in the
               sequence.</p>
               <p>The <var>n</var>th format token is used to format the <var>n</var>th number in the
               sequence. If there are more numbers than format tokens, then the last format token is
               used to format remaining numbers. If there are no format tokens, then a format token
               of <code>1</code> is used to format all numbers. Each number after the first is
               separated from the preceding number by the separator token preceding the format token
               used to format that number, or, if that is the first format token, then by
                  <code>.</code> (dot).</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e37559"></a>Example: Formatting a List of Numbers</div>
                  <p>Given the sequence of numbers <code>5, 13, 7</code> and the format token
                     <code>A-001(i)</code>, the output will be the string <code>E-013(vii)</code>
               </p>
               </div>
               <p>Format tokens are interpreted as follows:</p>
               <ul>
                  <li>
                     <p>Any token where the last character has a decimal digit value of 1 (as specified
                     in the Unicode character property database, see <a href="#UNICODE">[UNICODE]</a>), and the Unicode
                     value of preceding characters is one less than the Unicode value of the last
                     character generates a decimal representation of the number where each number is
                     at least as long as the format token. The digits used in the decimal
                     representation are the set of digits containing the digit character used in the
                     format token. Thus, a format token <code>1</code> generates the sequence
                        <code>0 1 2 ... 10 11 12 ...</code>, and a format token <code>01</code>
                     generates the sequence <code>00 01 02 ... 09 10 11 12 ... 99 100 101</code>. A
                     format token of <span class="unicode-codepoint">U+0661</span> (<span class="unicode-name">ARABIC-INDIC DIGIT ONE</span>, <code>١</code>)  generates the
                     sequence <code>١</code> then <code>٢</code> then
                        <code>٣</code> ...</p>
                  </li>
                  <li>
                     <p>A format token <code>A</code> generates the sequence <code>A B C ... Z AA AB
                        AC...</code>.</p>
                  </li>
                  <li>
                     <p>A format token <code>a</code> generates the sequence <code>a b c ... z aa ab
                        ac...</code>.</p>
                  </li>
                  <li>
                     <p>A format token <code>i</code> generates the sequence <code>i ii iii iv v vi vii
                        viii ix x ...</code>.</p>
                  </li>
                  <li>
                     <p>A format token <code>I</code> generates the sequence <code>I II III IV V VI VII
                        VIII IX X ...</code>.</p>
                  </li>
                  <li>
                     <p>A format token <code>w</code> generates numbers written as lower-case words,
                     for example in English, <code>one two three four ...</code>.
                  </p>
                  </li>
                  <li>
                     <p>A format token <code>W</code> generates numbers written as upper-case words,
                     for example in English, <code>ONE TWO THREE FOUR ...</code>.
                  </p>
                  </li>
                  <li>
                     <p>A format token <code>Ww</code> generates numbers written as title-case words,
                     for example in English, <code>One Two Three Four ...</code>.
                  </p>
                  </li>
                  <li>
                     <p>Any other format token indicates a numbering sequence in which that token
                     represents the number 1 (one) (but see the note below).
                     
                     It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> which numbering sequences,
                     additional to those listed above, are supported. If an implementation does not
                     support a numbering sequence represented by the given token, it
                        <span class="verb">must</span> use a format token of <code>1</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>In some traditional numbering sequences additional signs are added to denote
                        that the letters should be interpreted as numbers; these are not included in
                        the format token. An example, see also the example below, is classical Greek
                        where a <em>dexia keraia</em> and sometimes an <em>aristeri
                           keraia</em> is added.</p>
                     </div>
                  </li>
               </ul>
               <p>For all format tokens other than the first kind above (one that consists of decimal
               digits), there <span class="verb">may</span> be <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> lower and upper bounds on the range of numbers
               that can be formatted using this format token; indeed, for some numbering sequences
               there may be intrinsic limits. For example, the format
                  token <span class="unicode-codepoint">U+2460</span> (<span class="unicode-name">CIRCLED DIGIT ONE</span>, <code>①</code>)  has a range imposed
                  by the Unicode character repertoire (zero to 20 in Unicode versions prior to 3.2,
                  or zero to 50 in subsequent versions). For the numbering sequences
               described above any upper bound imposed by the implementation <span class="verb">must
                  not</span> be less than 1000 (one thousand) and any lower bound must not be
               greater than 1. Numbers that fall outside this range <span class="verb">must</span> be
               formatted using the format token <code>1</code>. The numbering sequence associated
               with the format token <code>1</code> has a lower bound of 0 (zero).</p>
               <p>The above expansions of numbering sequences for format tokens such as <code>a</code>
               and <code>i</code> are indicative but not prescriptive. There are various conventions
               in use for how alphabetic sequences continue when the alphabet is exhausted, and
               differing conventions for how roman numerals are written (for example,
                  <code>IV</code> versus <code>IIII</code> as the representation of the number 4).
               Sometimes alphabetic sequences are used that omit letters such as <code>i</code> and
                  <code>o</code>. This specification does not prescribe the detail of any sequence
               other than those sequences consisting entirely of decimal digits.</p>
               <p>Many numbering sequences are language-sensitive. This applies especially to the
               sequence selected by the tokens <code>w</code>, <code>W</code> and <code>Ww</code>.
               It also applies to other sequences, for example different languages using the
               Cyrillic alphabet use different sequences of characters, each starting with the
               letter #x410 (Cyrillic capital letter A). In such cases, the <code>lang</code>
               attribute specifies which language’s conventions are to be used; its <a title="effective value" class="termref" href="#dt-effective-value">effective
                     value</a>
                  <span class="verb">must</span> either be a string in the value space of
                     <code>xs:language</code>, or a zero-length string. If no
                  <code>lang</code> value is specified, or if the
                  value is a zero-length string, the language that is used is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The set of
               languages for which numbering is supported is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. If a language is
               requested that is not supported, the processor <span class="verb">may</span> use a fallback language identified by removing
                  successive hyphen-separated suffixes from the supplied value until a supported
                  language code is obtained; failing this, the processor  uses the language
               that it would use if the <code>lang</code> attribute were omitted.</p>
               <p>The optional <code>ordinal</code> attribute is used to
               indicate whether cardinal or ordinal numbers are required, and to select other
               options relating to the grammatical context of the number to be formatted. The
               allowed set of values is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. If the attribute
               is absent, or if its value is zero-length, or if its value is <code>no</code> or
                  <code>0</code> or <code>false</code>, then cardinal numbers appropriate to the
               selected language are output. If the value is <code>yes</code> or <code>1</code> or
                  <code>true</code>, then ordinal numbers appropriate to the target language are
               output. Other values are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
               <p>For example, in English, the value <code>ordinal="yes"</code> when used with the
               format token <code>1</code> outputs the sequence <code>1st 2nd 3rd 4th ...</code>,
               and when used with the format token <code>w</code> outputs the sequence <code>first
                  second third fourth ...</code>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In some languages, the form of numbers (especially ordinal numbers) varies
                  depending on the grammatical context: they may have different genders and may
                  decline with the noun that they qualify. In such cases the value of the
                     <code>ordinal</code> attribute may be used to indicate the variation of the
                  cardinal or ordinal number required, in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. </p>
                  <p>The way in which the variation is indicated will depend on the conventions of the
                  language.</p>
                  <p>For inflected languages that vary the ending of the word, the approach recommended
                  in the previous version of this specification was to indicate the required ending,
                  preceded by a hyphen: for example in German, appropriate values might be
                     <code>ordinal="-e"</code>, <code>ordinal="-er"</code>,
                     <code>ordinal="-es"</code>, <code>ordinal="-en"</code>. </p>
                  <p>Another approach, which might usefully be adopted by an implementation based on
                  the open-source ICU localization library <a href="#ICU">[ICU]</a>, or any other library
                  making use of the Unicode Common Locale Data Repository <a href="#CLDR">[Unicode CLDR]</a>, is
                  to allow the value of the attribute to be the name of a registered numbering rule
                  set for the language in question, conventionally prefixed with a percent sign: for
                  example, <code>ordinal="%spellout-ordinal-masculine"</code>, or
                     <code>ordinal="%spellout-cardinal-year"</code>. (The attribute name
                     <code>ordinal</code> in this case is a misnomer, but serves the purpose.) </p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e37859"></a>Example: Ordinal Numbering in Italian</div>
                  <p>The specification <code>format="1" ordinal="-º" lang="it"</code>, if supported,
                  should produce the sequence:</p>
                  <div class="exampleInner">
                     <pre>1º 2º 3º 4º ...</pre>
                  </div>
                  <p>The specification <code>format="Ww" ordinal="-o" lang="it"</code>, if supported,
                  should produce the sequence:</p>
                  <div class="exampleInner">
                     <pre>Primo Secondo Terzo Quarto Quinto ...</pre>
                  </div>
               </div>
               <p>The <code>letter-value</code> attribute disambiguates between numbering sequences
               that use letters. In many languages there are two commonly used numbering sequences
               that use letters. One numbering sequence assigns numeric values to letters in
               alphabetic sequence, and the other assigns numeric values to each letter in some
               other manner traditional in that language. In English, these would correspond to the
               numbering sequences specified by the format tokens <code>a</code> and <code>i</code>.
               In some languages, the first member of each sequence is the same, and so the format
               token alone would be ambiguous. A value of <code>alphabetic</code> specifies the
               alphabetic sequence; a value of <code>traditional</code> specifies the other
               sequence. If the <code>letter-value</code> attribute is not specified, then it is
                  <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> how
               any ambiguity is resolved.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Implementations may use <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension
                     attributes</a> on <a href="#element-number"><code>xsl:number</code></a> to provide additional
                  control over the way in which numbers are formatted.</p>
               </div>
               <p>The <code>grouping-separator</code> attribute gives the separator used as a grouping
               (for example, thousands) separator in decimal numbering sequences, and the optional
                  <code>grouping-size</code> specifies the size (normally 3) of the grouping. For
               example, <code>grouping-separator=","</code> and <code>grouping-size="3"</code> would
               produce numbers of the form <code>1,000,000</code> while
                  <code>grouping-separator="."</code> and <code>grouping-size="2"</code> would
               produce numbers of the form <code>1.00.00.00</code>. If only one of the
                  <code>grouping-separator</code> and <code>grouping-size</code> attributes is
               specified, then it is ignored.</p>
               <p>The <a title="effective value" class="termref" href="#dt-effective-value">effective
                  value</a> of the <code>grouping-separator</code> attribute
                  <span class="verb">may</span> be any string, including a zero-length string. </p>
               <p>The <a title="effective value" class="termref" href="#dt-effective-value">effective
                  value</a> of the <code>grouping-size</code> attribute
                  <span class="verb">must</span> be a string in the lexical space of
                  <code>xs:integer</code>. If the resulting integer is positive then it defines the
               number of digits between adjacent grouping separators; it if is zero or negative,
               then no grouping separators are inserted. </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e37964"></a>Example: Format Tokens and the Resulting Sequences</div>
                  <p>These examples use non-Latin characters which might not display correctly in all
                  browsers, depending on the system configuration.</p>
                  <table class="data">
                     <caption>Format tokens for use with xsl:number</caption>
                     <thead>
                        <tr>
                           <th style="text-align:left; vertical-align:top">Description</th>
                           <th style="text-align:left; vertical-align:top">Format Token</th>
                           <th style="text-align:left; vertical-align:top">Sequence</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align:left; vertical-align:top">French cardinal words</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="Ww" lang="fr"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">Un, Deux, Trois, Quatre</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">German ordinal words</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="w" ordinal="-e" lang="de"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">erste, zweite, dritte, vierte</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">Katakana numbering</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="&amp;#x30A2;"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">ア, イ, ウ, エ, オ, カ, キ,
                              ク, ケ, コ, サ, シ, ス, セ,
                              ソ, タ, チ, ツ, テ, ト, ナ,
                              ニ, ヌ, ネ, ノ, ハ, ヒ, フ,
                              ヘ, ホ, マ, ミ, ム, メ, モ,
                              ヤ, ユ, ヨ, ラ, リ, ル, レ,
                              ロ, ワ, ヰ, ヱ, ヲ, ン</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">Katakana numbering in iroha order</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="&amp;#x30A4;"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">イ, ロ, ハ, ニ, ホ, ヘ, ト,
                              チ, リ, ヌ, ル, ヲ, ワ, カ,
                              ヨ, タ, レ, ソ, ツ, ネ, ナ,
                              ラ, ム, ウ, ヰ, ノ, オ, ク,
                              ヤ, マ, ケ, フ, コ, エ, テ,
                              ア, サ, キ, ユ, メ, ミ, シ,
                              ヱ, ヒ, モ, セ, ス</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">Thai numbering</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="&amp;#x0E51;"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">๑, ๒, ๓, ๔, ๕, ๖, ๗, ๘,
                              ๙, ๑๐, ๑๑, ๑๒, ๑๓,
                              ๑๔, ๑๕, ๑๖, ๑๗,
                              ๑๘, ๑๙, ๒๐</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">Traditional Hebrew numbering</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="&amp;#x05D0;" letter-value="traditional"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">א, ב, ג, ד, ה, ו, ז, ח,
                              ט, י, יא, יב, יג,
                              יד, טו, טז, יז,
                              יח, יט, כ</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">Traditional Georgian numbering</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="&amp;#x10D0;" letter-value="traditional"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">ა, ბ, გ, დ, ე, ვ, ზ,
                              ჱ, თ, ი, ია, იბ,
                              იგ, იდ, იე, ივ,
                              იზ, იჱ, ით, კ </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">Classical Greek numbering (see note)</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="&amp;#x03B1;" letter-value="traditional"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top"> αʹ, βʹ, γʹ, δʹ,
                              εʹ, ϛʹ, ζʹ, ηʹ,
                              θʹ, ιʹ, ιαʹ,
                              ιβʹ, ιγʹ, ιδʹ,
                              ιεʹ, ιϛʹ, ιζʹ,
                              ιηʹ, ιθʹ, κʹ</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top">Old Slavic numbering</td>
                           <td style="text-align:left; vertical-align:top">
                              <code>format="&amp;#x0430;" letter-value="traditional"</code>
                              </td>
                           <td style="text-align:left; vertical-align:top">А, В, Г, Д, Е, Ѕ, З, И,
                              Ѳ, Ӏ, АӀ, ВӀ, ГӀ,
                              ДӀ, ЕӀ, ЅӀ, ЗӀ,
                              ИӀ, ѲӀ, К</td>
                        </tr>
                     </tbody>
                  </table>
                  <p>Note that Classical Greek is an example where the format token is not the same as
                  the representation of the number 1.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="sorting"></a>13 <a href="#sorting" style="text-decoration: none">Sorting</a></h2>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-specification" title="sort key specification"></a>A <b>sort key
                  specification</b> is a sequence of one or more adjacent
                  <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules for sorting the
               items in an input sequence to form a sorted sequence.<span class="definition">]</span>
         </p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-component" title="sort key component"></a>Within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>, each
                  <a href="#element-sort"><code>xsl:sort</code></a> element defines one <b>sort key
               component</b>.<span class="definition">]</span> The first <a href="#element-sort"><code>xsl:sort</code></a> element specifies the
            primary component of the sort key specification, the second <a href="#element-sort"><code>xsl:sort</code></a>
            element specifies the secondary component of the sort key specification, and so on.</p>
            <p>A sort key specification may occur immediately within an
               <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>,
               <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, or <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
            element.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>When used within <a href="#element-for-each"><code>xsl:for-each</code></a>, <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>,
               or <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>, <a href="#element-sort"><code>xsl:sort</code></a> elements must occur
               before any other children.</p>
            </div>
            <div class="div2">
               
               <h3><a id="xsl-sort"></a>13.1 <a href="#xsl-sort" style="text-decoration: none">The <code>xsl:sort</code> Element</a></h3>
               <p class="element-syntax"><a id="element-sort"></a><code>&lt;xsl:sort<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }〔'ascending'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;stable? = { <var>boolean</var> }〔'yes'〕<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sort&gt;</code></p>
               <p>The <a href="#element-sort"><code>xsl:sort</code></a> element defines a <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>. A sort key component specifies how a <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a> is to be computed for each item
               in the sequence being sorted, and also how two sort key values are to be
               compared.</p>
               <p>The value of a <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a> is
               determined either by its <code>select</code> attribute or by the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. If neither is
               present, the default is <code>select="."</code>, which has the effect of sorting on
               the actual value of the item if it is an atomic item, or on the typed-value of the
               item if it is a node. If a <code>select</code> attribute is present, its value
                  <span class="verb">must</span> be an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p>
               <p>
               <a id="err-XTSE1015"><span class="error">[ERR XTSE1015] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-sort"><code>xsl:sort</code></a> element with a <code>select</code> attribute has
                     non-empty content.
            </p>
               <p>Those attributes of the <a href="#element-sort"><code>xsl:sort</code></a> elements whose values are <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a> are
               evaluated using the same <a title="focus" class="termref" href="#dt-focus">focus</a> as is used to
               evaluate the <code>select</code> attribute of the containing instruction
               (specifically, <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-for-each"><code>xsl:for-each</code></a>,
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, or <a href="#element-perform-sort"><code>xsl:perform-sort</code></a>).</p>
               <p>The <code>stable</code> attribute is permitted only on the first
                  <a href="#element-sort"><code>xsl:sort</code></a> element within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>.
            </p>
               <p>
               <a id="err-XTSE1017"><span class="error">[ERR XTSE1017] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-sort"><code>xsl:sort</code></a> element other than the first in a sequence of
                     sibling <a href="#element-sort"><code>xsl:sort</code></a> elements has a <code>stable</code>
                     attribute.
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-stable" title="stable"></a>A <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort
                     key specification</a> is said to be <b>stable</b> if its first
                     <a href="#element-sort"><code>xsl:sort</code></a> element has no <code>stable</code> attribute, or has
                  a <code>stable</code> attribute whose <a title="effective value" class="termref" href="#dt-effective-value">effective
                     value</a> is <code>yes</code>.<span class="definition">]</span>
            </p>
               <div class="div3">
                  
                  <h4><a id="sorting-process"></a>13.1.1 <a href="#sorting-process" style="text-decoration: none">The Sorting Process</a></h4>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-initial-sequence" title="initial sequence"></a>The sequence to be
                     sorted is referred to as the <b>initial sequence</b>.<span class="definition">]</span>
               </p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-sorted-sequence" title="sorted sequence"></a>The sequence after sorting
                     as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements is referred to as the
                        <b>sorted sequence</b>.<span class="definition">]</span>
               </p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-sort-key-value" title="sort key value"></a> For each item in the
                        <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, a value is
                     computed for each <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key
                        component</a> within the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort
                        key specification</a>. The value computed for an item by using the
                        <var>N</var>th sort key component is referred to as the <var>N</var>th
                        <b>sort key value</b> of that item.<span class="definition">]</span>
               </p>
                  <p>The items in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> are
                  ordered into a <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> by
                  comparing their <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a>. The
                  relative position of two items <var>A</var> and <var>B</var> in the sorted
                  sequence is determined as follows. The first sort key value of <var>A</var> is
                  compared with the first sort key value of <var>B</var>, according to the rules of
                  the first <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>. If,
                  under these rules, <var>A</var> is less than <var>B</var>, then <var>A</var> will
                  precede <var>B</var> in the sorted sequence, unless the <code>order</code>
                  attribute of this <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key
                     component</a> specifies <code>descending</code>, in which case
                     <var>B</var> will precede <var>A</var> in the sorted sequence. If, however, the
                  relevant sort key values compare equal, then the second sort key value of
                     <var>A</var> is compared with the second sort key value of <var>B</var>,
                  according to the rules of the second <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key
                     component</a>. This continues until two sort key values are found that
                  compare unequal. If all the sort key values compare equal, and the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is <a title="stable" class="termref" href="#dt-stable">stable</a>, then <var>A</var> will precede <var>B</var>
                  in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> if and only if
                     <var>A</var> preceded <var>B</var> in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>. If all the sort key values compare equal, and the
                     <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is
                  not <a title="stable" class="termref" href="#dt-stable">stable</a>, then the relative order of
                     <var>A</var> and <var>B</var> in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
                     sequence</a> is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>If two items have equal <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key
                        values</a>, and the sort is <a title="stable" class="termref" href="#dt-stable">stable</a>,
                     then their order in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
                        sequence</a> will be the same as their order in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, regardless of whether
                        <code>order="descending"</code> was specified on any or all of the <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key components</a>.</p>
                  </div>
                  <p>The <var>N</var>th sort key value is computed by evaluating either the
                     <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of the
                     <var>N</var>th <a href="#element-sort"><code>xsl:sort</code></a> element, or the expression
                     <code>.</code> (dot) if neither is present. This evaluation is done with the
                     <a title="focus" class="termref" href="#dt-focus">focus</a> set as follows:</p>
                  <ul>
                     <li>
                        <p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the item in the
                           <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> whose
                           <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a> is being
                        computed.</p>
                     </li>
                     <li>
                        <p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the
                        position of that item in the initial sequence.</p>
                     </li>
                     <li>
                        <p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is the size of the
                        initial sequence.</p>
                     </li>
                  </ul>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>As in any other XPath expression, the <a href="#func-current"><code>current</code></a> function may
                     be used within the <code>select</code> expression of <a href="#element-sort"><code>xsl:sort</code></a>
                     to refer to the item that is the context item for the expression as a whole;
                     that is, the item whose <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key
                        value</a> is being computed.</p>
                  </div>
                  <p>The <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> are <a title="atomize" class="termref" href="#dt-atomization">atomized</a>, and are then compared. The way they
                  are compared depends on their datatype, as described in the next section.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="comparing-sort-keys"></a>13.1.2 <a href="#comparing-sort-keys" style="text-decoration: none">Comparing Sort Key Values</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#grouping">next</a> | <a href="#generating-cdata">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     Numeric values of type <code>xs:decimal</code> are compared
                     as decimals, without first converting to <code>xs:double</code>.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/98">98</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218</a>&nbsp;7 October 2025]</i></p>
                        </li>
                        <li>
                           <p>
                     Composite sort keys are allowed in <a href="#element-sort"><code>xsl:sort</code></a>.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1662">1662</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1674">1674</a>&nbsp;7 January 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>It is possible to force the system to compare <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> using the rules for a particular datatype by
                  including a cast as part of the <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key
                     component</a>. For example, <code>&lt;xsl:sort
                     select="xs:date(@dob)"/&gt;</code> will force the attributes to be compared as
                  dates. In the absence of such a cast, the sort key values are compared using the
                  rules appropriate to their datatype. Any values of type
                     <code>xs:untypedAtomic</code> are cast to <code>xs:string</code>.</p>
                  <p>For backwards compatibility with XSLT 1.0, the <code>data-type</code> attribute
                  remains available. If this has the <a title="effective value" class="termref" href="#dt-effective-value">effective
                     value</a>
                  <code>text</code>, the atomized <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key
                     values</a> are converted to strings before being compared. If it has the
                  <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>number</code>, the atomized sort key values are converted to
                  doubles before being compared. The conversion is done by using the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-string"><code>string</code></a> or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-number"><code>number</code></a> function as
                  appropriate. If the <code>data-type</code> attribute has
                     any other <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>, then
                     this value <span class="verb">must</span> be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> denoting an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                        QName</a> with a non-absent namespace, and the effect of the
                  attribute is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. 
               <span>If the attribute is omitted, no conversion
               takes place.</span></p>
                  <p>
                  If the <a href="#element-sort"><code>xsl:sort</code></a> element is processed with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0
                              behavior</a>,
                  then if any <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a>, after
                           <a title="atomize" class="termref" href="#dt-atomization">atomization</a> and any type
                        conversion <span class="verb">required</span> by the <code>data-type</code>
                        attribute, is a sequence containing more than one item, then the effective
                        sort key value is the first item in the sequence.</p>
                  <p>In general the <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> (after any
                  conversion) are sequences of atomic items. Two sequences of atomic items
                  <var>S<sub>1</sub></var> and <var>S<sub>2</sub></var> are compared as follows:</p>
                  <ol class="enumar">
                     <li>
                        <p>If both <var>S<sub>1</sub></var> and <var>S<sub>2</sub></var> are empty sequences,
                     then they compare equal.</p>
                     </li>
                     <li>
                        <p>A sequence that is empty is considered to be less than
                        a sequence that is not empty.</p>
                     </li>
                     <li>
                        <p>If neither sequence is empty, then
                        <code>head(<var>S<sub>1</sub></var>)</code> and 
                        <code>head(<var>S<sub>2</sub></var>)</code> are compared
                        according to the rules below.</p>
                        <ol class="enumla">
                           <li>
                              <p>If they compare equal, the result is obtained
                        by comparing <code>tail(<var>S<sub>1</sub></var>)</code> to 
                        <code>tail(<var>S<sub>2</sub></var>)</code>.</p>
                           </li>
                           <li>
                              <p>Otherwise, the result of comparing these two
                        items is used as the result of the sequence comparison.</p>
                           </li>
                        </ol>
                     </li>
                  </ol>
                  <p>For example:</p>
                  <ul>
                     <li>
                        <p><code>(1, 2, 3)</code> precedes <code>(1, 2, 4)</code>.</p>
                     </li>
                     <li>
                        <p><code>(1, 2)</code> precedes <code>(1, 2, 3)</code></p>
                     </li>
                     <li>
                        <p><code>()</code> precedes <code>(1, 2)</code></p>
                     </li>
                  </ul>
                  <p>Individual atomic items are compared by calling the function 
               <code>fn:compare(<var>A<sub>1</sub></var>, <var>A<sub>2</sub></var>, <var>C</var>)</code>,
               where <var>C</var> is the appropriate collation,
                  as described in the next section.
               This will raise an error if the values are
                  not comparable (for example, if one is an <code>xs:integer</code> and the other is
                  an <code>xs:date</code>).</p>
                  <p>
                  <a id="err-XTDE1030"><span class="error">[ERR XTDE1030] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if, for any <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>, the set of
                           <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> evaluated for
                        all the items in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial
                           sequence</a>, after any type conversion requested, contains a pair
                        of atomic items that are not comparable using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a>. If the processor is
                           able to detect the error statically, it <span class="verb">may</span> optionally
                           raise it as a <a title="static error" class="termref" href="#dt-static-error">static
                           error</a>.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The above error condition may occur if the
                     sequence is heterogeneous (for example, if it contains both strings and
                     numbers). The error can generally be prevented by invoking a cast or
                     constructor function within the sort key component.</p>
                     <p>The error condition is subject to the usual caveat that a processor is not
                     required to evaluate any expression solely in order to determine whether it
                     raises an error. For example, if there are several sort key components, then a
                     processor is not required to evaluate or compare minor sort key values unless
                     the corresponding major sort key values are equal.</p>
                     <p>In XSLT 4.0 the error can no longer occur if the items in the sequence
                  all have the same data type. An order relation is now defined for all
                  atomic types (including, for example, <code>xs:duration</code>).</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="collating-sequences"></a>13.1.3 <a href="#collating-sequences" style="text-decoration: none">Sorting Using Collations</a></h4>
                  <p>The rules given in this section apply when comparing values whose type is
                     <code>xs:string</code> or a type derived by restriction from
                     <code>xs:string</code>, or whose type is <code>xs:anyURI</code> or a type
                  derived by restriction from <code>xs:anyURI</code>.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-collation" title="collation"></a>Facilities in XSLT 3.0 and XPath 3.0 that
                     require strings to be ordered rely on the concept of a named
                        <b>collation</b>. A collation is a set of rules that determine whether
                     two strings are equal, and if not, which of them is to be sorted before the
                     other.<span class="definition">]</span> A collation is identified by a URI, but the manner in which
                  this URI is associated with an actual rule or algorithm is largely <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
                  <p>For more information about collations, see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#string-compare">5.3 Comparison of strings</a> in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. Some
                  specifications, for example <a href="#UNICODE-TR10">[UNICODE TR10]</a>, use the term “collation”
                  to describe rules that can be tailored or parameterized for various purposes. In
                  this specification, a collation URI refers to a collation in which all such
                  parameters have already been fixed. Therefore, if a collation URI is specified,
                  other attributes such as <code>case-order</code> and <code>lang</code> are
                  ignored. </p>
                  <p>Every implementation <span class="verb">must</span>
                     recognize the collation URI 
                  <code>http://www.w3.org/2005/xpath-functions/collation/codepoint</code>, which
                  provides the ability to compare strings based on the Unicode codepoint values of
                  the characters in the string.</p>
                  <p>Furthermore, every implementation must recognize collation URIs
                  representing tailorings of the Unicode Collation Algorithm (UCA), as described in
                     <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#uca-collations">5.3.4 The Unicode Collation Algorithm</a>. Although this form of collation URI must be
                  recognized, implementations are not required to support every possible
                  tailoring.</p>
                  <p>If the <a href="#element-sort"><code>xsl:sort</code></a> element has a <code>collation</code> attribute,
                  then the strings are compared according to the rules for the named <a title="collation" class="termref" href="#dt-collation">collation</a>: that is, they are compared using the
                  XPath function call <code>compare($a, $b, $collation)</code>.</p>
                  <p>If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                     <code>collation</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> is a relative
                  URI, then it is resolved against the base URI of the <a href="#element-sort"><code>xsl:sort</code></a>
                  element.</p>
                  <p>
                  <a id="err-XTDE1035"><span class="error">[ERR XTDE1035] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the
                           <code>collation</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> (after
                        resolving against the base URI) is not a URI that is recognized by the
                        implementation as referring to a collation.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>It is entirely for the implementation to determine whether it recognizes a
                     particular collation URI. For example, if the implementation allows collation
                     URIs to contain parameters in the query part of the URI, it is the
                     implementation that determines whether a URI containing an unknown or invalid
                     parameter is or is not a recognized collation URI. The fact that this situation
                     is described as an error thus does not prevent an implementation applying a
                     fallback collation if it chooses to do so.</p>
                  </div>
                  <p>The <code>lang</code> and <code>case-order</code> attributes are ignored if a
                     <code>collation</code> attribute is present. But in the absence of a
                     <code>collation</code> attribute, these attributes provide input to an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> algorithm to
                  locate a suitable collation:</p>
                  <ul>
                     <li>
                        <p>The <code>lang</code> attribute indicates that a collation suitable for a
                        particular natural language <span class="verb">should</span> be used. 
                        The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute <span class="verb">must</span>
                         either be a string in the value space of
                              <code>xs:language</code>, or a zero-length string. Supplying the
                           zero-length string has the same effect as omitting the attribute. If a
                           language is requested that is not supported, the processor
                              <span class="verb">may</span> use a fallback language identified by removing
                           successive hyphen-separated suffixes from the supplied value until a
                           supported language code is obtained; failing this, the processor behaves
                           as if the <code>lang</code> attribute were omitted. </p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The fallback algorithm described above is 
                        identical to the rules in RFC4647 Basic Filtering used in BCP 47,
                     and is specified in <a href="#RFC4647">[RFC4647]</a> in greater detail.</p>
                        </div>
                     </li>
                     <li>
                        <p>The <code>case-order</code> attribute indicates whether the desired
                        collation <span class="verb">should</span> sort upper-case letters before
                        lower-case or vice versa. The <a title="effective value" class="termref" href="#dt-effective-value">effective
                           value</a> of the attribute <span class="verb">must</span> be either
                           <code>lower-first</code> (indicating that lower-case letters precede
                        upper-case letters in the collating sequence) or <code>upper-first</code>
                        (indicating that upper-case letters precede lower-case).</p>
                        <p>When <code>lower-first</code> is requested, the returned collation
                           <span class="verb">should</span> have the property that when two strings differ
                        only in the case of one or more characters, then a string in which the first
                        differing character is lower-case should precede a string in which the
                        corresponding character is title-case, which should in turn precede a string
                        in which the corresponding character is upper-case. When upper-first is
                        requested, the returned collation <span class="verb">should</span> have the
                        property that when two strings differ only in the case of one or more
                        characters, then a string in which the first differing character is
                        upper-case should precede a string in which the corresponding character is
                        title-case, which should in turn precede a string in which the corresponding
                        character is lower-case.</p>
                        <p>So, for example, if <code>lang="en"</code>, then <code>A a B b</code> are
                        sorted with <code>case-order="upper-first"</code> and <code>a A b B</code>
                        are sorted with <code>case-order="lower-first"</code>.</p>
                        <p>As a further example, if <code>lower-first</code> is requested, then a sorted sequence
                        might be “MacAndrew, macintosh, macIntosh, Macintosh, MacIntosh,
                        macintoshes, Macintoshes, McIntosh”. If <code>upper-first</code> is requested, the same
                        sequence would sort as “MacAndrew, MacIntosh, Macintosh, macIntosh,
                        macintosh, MacIntoshes, macintoshes, McIntosh”.</p>
                     </li>
                  </ul>
                  <p>If none of the <code>collation</code>, <code>lang</code>, or
                     <code>case-order</code> attributes is present, the collation is chosen in an
                     <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. It is not
                     <span class="verb">required</span> that the default collation for sorting should be
                  the same as the <a title="default collation" class="termref" href="#dt-default-collation">default collation</a>
                  used when evaluating XPath expressions, as described in <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a> and <a href="#default-collation-attribute"><i>3.6.2 The default-collation Attribute</i></a>.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>It is usually appropriate, when sorting, to use a strong collation, that is,
                     one that takes account of secondary differences (accents) and tertiary
                     differences (case) between strings that are otherwise equal. A weak collation,
                     which ignores such differences, may be more suitable when comparing strings for
                     equality.</p>
                     <p>Useful background information on international sorting is provided in <a href="#UNICODE-TR10">[UNICODE TR10]</a>. The <code>case-order</code> attribute may be
                     interpreted as described in section 6.6 of <a href="#UNICODE-TR10">[UNICODE TR10]</a>.</p>
                  </div>
                  <p>
                  The <code>collation</code>, <code>case-order</code>, and <code>lang</code> attributes are 
                  ignored when no string comparisons are performed during the sorting process; this 
                  includes the cases where (a) the sequences to be sorted are empty, (b) the sort 
                  keys are of a non-string type such as <code>xs:integer</code>, or (c) <code>data-type="number"</code> is 
                  specified. In these cases, an implementation may raise errors in the value 
                  of these attributes, but is not required to do so. As always, an implementation 
                  may issue warnings.
               </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="creating-sorted-sequence"></a>13.2 <a href="#creating-sorted-sequence" style="text-decoration: none">Creating a Sorted Sequence</a></h3>
               <p class="element-syntax"><a id="element-perform-sort"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:perform-sort<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:perform-sort&gt;</code></p>
               <p>The <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction is used to return a <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a>.</p>
               <p>The <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> is obtained either
               by evaluating the <code>select</code> attribute or by evaluating the contained
               sequence constructor (but not both). If there is no <code>select</code> attribute and
               no sequence constructor then the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial
                  sequence</a> (and therefore, the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted
                  sequence</a>) is the empty sequence.</p>
               <p>
               <a id="err-XTSE1040"><span class="error">[ERR XTSE1040] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction with a <code>select</code>
                     attribute has any content other than <a href="#element-sort"><code>xsl:sort</code></a> and
                        <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.
            </p>
               <p>The result of the <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction is the result of
               sorting its <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a> using its
               contained <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key
               specification</a>.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e39058"></a>Example: Sorting a Sequence of Atomic Items</div>
                  <p>The following stylesheet function sorts a sequence of atomic items using the
                  value itself as the sort key.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="local:sort" 
          as="xs:anyAtomicType*"&gt;
  &lt;xsl:param name="in" as="xs:anyAtomicType*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="."/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e39063"></a>Example: Writing a Function to Perform a Sort</div>
                  <p>The following example defines a function that sorts books by price, and uses this
                  function to output the five books that have the lowest prices:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:function name="bib:books-by-price" 
          as="schema-element(bib:book)*"&gt;
  &lt;xsl:param name="in" as="schema-element(bib:book)*"/&gt;
  &lt;xsl:perform-sort select="$in"&gt;
    &lt;xsl:sort select="xs:decimal(bib:price)"/&gt;
  &lt;/xsl:perform-sort&gt;
&lt;/xsl:function&gt;
   ...
   &lt;xsl:copy-of select="bib:books-by-price(//bib:book)
                             [position() = 1 to 5]"/&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="sorted-iteration"></a>13.3 <a href="#sorted-iteration" style="text-decoration: none">Processing a Sequence in Sorted Order</a></h3>
               <p>When used within <a href="#element-for-each"><code>xsl:for-each</code></a> or
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> indicates that the sequence of items selected by
               that instruction is to be processed in sorted order, not in the order of the supplied
               sequence.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e39079"></a>Example: Processing Elements in Sorted Order</div>
                  <p>For example, suppose an employee database has the form</p>
                  <div class="exampleInner">
                     <pre>&lt;employees&gt;
  &lt;employee&gt;
    &lt;name&gt;
      &lt;given&gt;James&lt;/given&gt;
      &lt;family&gt;Clark&lt;/family&gt;
    &lt;/name&gt;
    ...
  &lt;/employee&gt;
&lt;/employees&gt;</pre>
                  </div>
                  <p>Then a list of employees sorted by name could be generated using:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="employees"&gt;
  &lt;ul&gt;
    &lt;xsl:apply-templates select="employee"&gt;
      &lt;xsl:sort select="name/family"/&gt;
      &lt;xsl:sort select="name/given"/&gt;
    &lt;/xsl:apply-templates&gt;
  &lt;/ul&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="employee"&gt;
  &lt;li&gt;
    &lt;xsl:value-of select="name/given"/&gt;
    &lt;xsl:text&gt; &lt;/xsl:text&gt;
    &lt;xsl:value-of select="name/family"/&gt;
  &lt;/li&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>When used within <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> indicates the
               order in which the groups are to be processed. For the effect of
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>, see <a href="#grouping"><i>14 Grouping</i></a>. </p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="grouping"></a>14 <a href="#grouping" style="text-decoration: none">Grouping</a></h2>
            <div class="changes">
               <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-current-group">next</a> | <a href="#comparing-sort-keys">previous</a>)</p>
               <ol>
                  <li>
                     <p>
               A new attribute <code>xsl:for-each-group/@split-when</code> is available to
               give applications more complete control over how a sequence is partitioned
            <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/571">571</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/740">740</a>&nbsp;26 September 2023]</i></p>
                  </li>
                  <li>
                     <p>
               A new attribute <code>xsl:for-each-group/@merge-when</code> is available to
               give applications control to create groups based on clustering, overlap, and networks.
            <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2051">2051</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2123">2123</a>&nbsp;30 September 2025]</i></p>
                  </li>
               </ol>
            </div>
            <p>The facilities described in this section are designed to allow items in a sequence to be
            grouped based on common values; for example it allows grouping of elements having the
            same value for a particular attribute, or elements with the same name, or elements with
            common values for any other <a title="expression" class="termref" href="#dt-expression">expression</a>. Since
            grouping identifies items with duplicate values, the same facilities also allow
            selection of the distinct values in a sequence of items, that is, the elimination of
            duplicates.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>Simple elimination of duplicates can also be achieved using the function
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-distinct-values"><code>distinct-values</code></a>: see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p>
            </div>
            <p>In addition these facilities allow grouping based on sequential position, for example
            selecting groups of adjacent <code>para</code> elements. The facilities also provide an
            easy way to do fixed-size grouping, for example identifying groups of three adjacent
            nodes, which is useful when arranging data in multiple columns.</p>
            <p>For each group of items identified, it is possible to evaluate a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> for the group. Grouping
            is nestable to multiple levels so that groups of distinct items can be identified, then
            from among the distinct groups selected, further sub-grouping of distinct items in the
            current group can be done. </p>
            <p>It is also possible for one item to participate in more than one group.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>Grouping can also be achieved by constructing a map. For example, 
            the function call <code>map:build(//employee, fn { department })</code> constructs a map
            in which employees are grouped by department.</p>
            </div>
            <div class="div2">
               
               <h3><a id="xsl-for-each-group"></a>14.1 <a href="#xsl-for-each-group" style="text-decoration: none">The <code>xsl:for-each-group</code> Element</a></h3>
               <p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> <a title="instruction" class="termref" href="#dt-instruction">instruction</a> 
               allows a flat sequence of items to be processed as a sequence
               of groups, allowing a number of criteria to be used to define the grouping. The
               instruction may be used anywhere within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
               constructor</a>.</p>
               <p class="element-syntax"><a id="element-for-each-group"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:for-each-group<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;group-by? = <var>expression</var><br>&nbsp;&nbsp;group-adjacent? = <var>expression</var><br>&nbsp;&nbsp;group-starting-with? = <var>pattern</var><br>&nbsp;&nbsp;group-ending-with? = <var>pattern</var><br>&nbsp;&nbsp;split-when? = <var>expression</var><br>&nbsp;&nbsp;merge-when? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each-group&gt;</code></p>
               <p>The <code>select</code> attribute contains an
               <a title="expression" class="termref" href="#dt-expression">expression</a> which is evaluated to produce a
               sequence, called the <a title="population" class="termref" href="#dt-population">population</a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-group" title="group"></a>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
                  instruction allocates the items in an input sequence into <b>groups</b> of
                  items (that is, it establishes a collection of sequences) based either on common
                  values of a grouping key, or on a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that
                  the initial or final item in a group must
                  match.<span class="definition">]</span> The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                  constructor</a> that forms the content of the
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is evaluated once for each of
               these groups.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-population" title="population"></a>The sequence of items to be grouped,
                  which is referred to as the <b>population</b>, is determined by evaluating
                  the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the
                  <code>select</code> attribute.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-population-order" title="population order"></a>The population is treated
                  as a sequence; the order of items in this sequence is referred to as
                     <b>population order</b>.<span class="definition">]</span></p>
               <p>A group is never empty. If the population is empty, the number of groups will be
               zero.</p>
               <p>The assignment of items to groups depends on the <code>group-by</code>, 
                  <code>group-adjacent</code>, <code>group-starting-with</code>, 
                  <code>group-ending-with</code>, <span><code>split-when</code>,</span>
               <span>and <code>merge-when</code></span> attributes. </p>
               <p>
               <a id="err-XTSE1080"><span class="error">[ERR XTSE1080] </span></a>These <span>six</span> attributes  are mutually exclusive: it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if none of these attributes is present or if
                     more than one of them is present.
            </p>
               <p>
               <a id="err-XTSE1090"><span class="error">[ERR XTSE1090] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to specify the
                        <code>collation</code> attribute or the
                           <code>composite</code> attribute if neither the
                        <code>group-by</code> attribute nor the <code>group-adjacent</code> attribute is
                     specified.
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-grouping-key" title="grouping key"></a>If the
                     <code>group-by</code> or <code>group-adjacent</code> attributes is present,
                  then for each item in the <a title="population" class="termref" href="#dt-population">population</a> a set
                  of <b>grouping keys</b> is calculated, as follows: the expression contained
                  in the <code>group-by</code> or <code>group-adjacent</code> attribute is
                  evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> items
                  are cast to <code>xs:string</code>. If
                        <code>composite="yes"</code> is specified, there is a single grouping key
                     whose value is the resulting sequence; otherwise, there is a set of grouping
                     keys, consisting of the distinct atomic items present in the result
                     sequence.<span class="definition">]</span>
            </p>
               <p>When calculating grouping keys for an item in the population, the 
               <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the <code>group-by</code> 
               or <code>group-adjacent</code> attribute is evaluated with that 
               item as the <a title="context item" class="termref" href="#dt-context-item">context item</a>, with its position in 
               <a title="population order" class="termref" href="#dt-population-order">population order</a> as the 
               <a title="context position" class="termref" href="#dt-context-position">context position</a>, and with the size of the
               population as the <a title="context size" class="termref" href="#dt-context-size">context size</a>.</p>
               <p>If the <code>group-by</code> attribute is present, and if
                  the <code>composite</code> attribute is omitted or takes the value
                  <code>no</code>, then an item in the population <span class="verb">may</span>
               have multiple grouping keys: that is, the <code>group-by</code> expression evaluates
               to a sequence, and each item in the sequence is treated as
                  a separate grouping key.  The item is included in as many groups as there
               are distinct grouping keys (which may be zero).</p>
               <p>If the <code>group-adjacent</code> attribute is used, and
                  if the <code>composite</code> attribute is omitted or takes the value
                     <code>no</code>, then each item in the population
                  <span class="verb">must</span> have exactly one grouping key value.</p>
               <p>
               <a id="err-XTTE1100"><span class="error">[ERR XTTE1100] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                     evaluating the <code>group-adjacent</code> expression is the empty sequence or a
                     sequence containing more than one item, unless
                           <code>composite="yes"</code> is specified.
            </p>
               <p>
               Atomic <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a> are compared using
               the rules of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-distinct-values"><code>distinct-values</code></a> function, using the relevant collation.
               The relevant collation is the collation specified as the 
               <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>collation</code>
               attribute, resolved if relative against the base URI of the
               <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element; if there is no <code>collation</code>
               attribute then the <a title="default collation" class="termref" href="#dt-default-collation">default collation</a> is
               used. Given this collation, two grouping keys <var>K<sub>1</sub></var> and <var>K<sub>2</sub></var>
               are considered equal if <code>count(distinct-values(($K1, $K2), $collation)) = 1</code>.
            </p>
               <p>Composite grouping keys are equal if they contain the same number
            of items and the items are pairwise equal when compared according to the rules in the previous
            paragraph.</p>
               <p>
               <a id="err-XTDE1110"><span class="error">[ERR XTDE1110] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the collation URI
                     specified to <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (after resolving against the
                     base URI) is a collation that is not recognized by the implementation. (For
                     notes, <span class="error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)
            </p>
               <p>For more information on collations, see <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>.</p>
               <p>The way in which an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element is
               evaluated depends on which of the six group-defining attributes is present:</p>
               <ul>
                  <li>
                     <p>If the <code>group-by</code> attribute is present, the items in the <a title="population" class="termref" href="#dt-population">population</a> are examined, in population order.
                     For each item <var>J</var>, the expression in the <code>group-by</code>
                     attribute is evaluated to produce a sequence of zero or more <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> values. If <code>composite="yes"</code> is specified, there will be a single
                        grouping key, which will in general be a sequence of zero or more atomic
                        items; otherwise, there will be zero or more grouping keys, each of which
                        will be a single atomic item. For each one of these <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a>, if there is already a group
                     created to hold items having that grouping key value, <var>J</var> is appended to that group; otherwise a new group is
                     created for items with that grouping key value, and <var>J</var> becomes its
                     first member.</p>
                     <p>An item in the population may thus be appended to zero, one, or many groups. An item will never be
                        appended more than once to the same
                     group; if two or more grouping keys for the same item are equal, then the
                     duplicates are ignored. An <em>item</em> here means the item at a
                     particular position within the population—if the
                     population contains the same node at several different positions in the
                     sequence then a group may indeed contain duplicate nodes.</p>
                     <p>The number of groups will be the same as the number of distinct grouping key
                     values present in the <a title="population" class="termref" href="#dt-population">population</a>. </p>
                  </li>
                  <li>
                     <p>If the <code>group-adjacent</code> attribute is present, the items in the
                        <a title="population" class="termref" href="#dt-population">population</a> are examined, in
                     population order. If an item has the same value for the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> as its preceding item within
                     the <a title="population" class="termref" href="#dt-population">population</a> (in <a title="population order" class="termref" href="#dt-population-order">population order</a>), then it is appended to the same group as its preceding item;
                     otherwise a new group is created and the item becomes its first member.</p>
                  </li>
                  <li>
                     <p>If the <code>group-starting-with</code> attribute is present, then its value
                        <span class="verb">must</span> be a <a href="#doc-xslt40-Pattern">pattern</a>. </p>
                     <p>The items in the <a title="population" class="termref" href="#dt-population">population</a> are examined in <a title="population order" class="termref" href="#dt-population-order">population order</a>. If an item matches the pattern, or is the first item in the population, then a new group is
                     created and the item becomes its first
                     member. Otherwise, the item is appended to the same group as its preceding
                        item within the population.</p>
                  </li>
                  <li>
                     <p>If the <code>group-ending-with</code> attribute is present, then its value
                        <span class="verb">must</span> be a <a href="#doc-xslt40-Pattern">pattern</a>. </p>
                     <p>The items in the <a title="population" class="termref" href="#dt-population">population</a> are examined in <a title="population order" class="termref" href="#dt-population-order">population order</a>. If an item is the first item in the population, or if the previous item in the population matches the pattern, then a new group
                     is created and the item becomes its first
                     member. Otherwise, the item is appended to the same group as its preceding
                        item within the population.</p>
                  </li>
                  <li>
                     <p>If the <code>split-when</code> attribute is present, then its value
                     <span class="verb">must</span> be an expression.
                     This expression is evaluated once for every item in the <a title="population" class="termref" href="#dt-population">population</a>
                     except the first. The context item is that item, the context position is its position
                     in the <a title="population" class="termref" href="#dt-population">population</a>, and the context size is the size of the population.
                     The expression is supplied with two variables: <code>$group</code> is set to the 
                     contents of the current group being constructed, and <code>$next</code> is the next item in the population. 
                     If the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup>
                     of the expression is <code>true</code>, then this
                  item forms the start of a new group; if it is <code>false</code>, the item is added to the existing
                  group.</p>
                     <ul>
                        <li>
                           <p>The variable <code>$group</code> is implicitly declared, and <a title="shadows" class="termref" href="#dt-shadows">shadows</a> any other variable
                           of the same name. Its name is in no namespace. Its scope is the <code>split-when</code>
                           expression, and its type is <code>item()+</code>.</p>
                        </li>
                        <li>
                           <p>The variable <code>$next</code> is implicitly declared, and <a title="shadows" class="termref" href="#dt-shadows">shadows</a> any other variable
                           of the same name. Its name is in no namespace. Its scope is the <code>split-when</code>
                           expression, and its type is <code>item()</code>.</p>
                        </li>
                     </ul>
                     <p>For example:</p>
                     <ul>
                        <li>
                           <p><code>split-when="count($group) = 3"</code> starts a new
                     group whenever the existing group has exactly three members; that is, it partitions the
                     population into groups of size 3 (with the last group being smaller if necessary).</p>
                        </li>
                        <li>
                           <p><code>split-when="$next[self::h1]"</code> starts a new
                        group whenever an <code>h1</code> element is encountered. The effect is the
                     same as specifying <code>group-starting-with="h1"</code></p>
                        </li>
                        <li>
                           <p><code>split-when="foot($group)/@continued='no'"</code> starts a new
                        group immediately after any element having <code>@continued="no"</code>. The effect is the
                        same as specifying <code>group-ending-with="*[@continued='no']"</code></p>
                        </li>
                        <li>
                           <p><code>split-when="node-name($group[last()] != node-name($next)"</code> 
                        starts a new group whenever the name of an item differs from the name of the previous
                     item. The effect is the same as specifying <code>group-adjacent="node-name(.)"</code>.</p>
                        </li>
                        <li>
                           <p><code>split-when="foot($group)[self::hr] or $next[self::hr]"</code> 
                        starts a new group immediately before and immediately after every <code>hr</code>
                        element. (That is, <code>hr</code> elements become singleton groups.)</p>
                        </li>
                        <li>
                           <p><code>split-when="$next ne foot($group) + 1"</code> 
                        starts a new group whenever the current item is not equal to the previous item
                     plus one. For example <code>1, 2, 5, 6, 7, 10, 11</code> is grouped as <code>(1, 2), (5, 6, 7),
                     (10, 11)</code>.</p>
                        </li>
                        <li>
                           <p><code>split-when="sum($group/string-length()) gt 40"</code> starts a new
                     group when the sum of the string lengths of the items in the current group exceeds 40.</p>
                        </li>
                        <li>
                           <p><code>split-when="ends-with(foot($group), '.') and matches($next, '^\p{Lu}')"</code> 
                        starts a new group when the last item in the current group ends with <code>"."</code> and the
                        next item starts with a capital letter.</p>
                        </li>
                        <li>
                           <p><code>split-when="deep-equal(slice($group, -2 to -1), ('', ''))"</code> 
                        starts a new group after two consecutive zero-length strings.</p>
                        </li>
                        <li>
                           <p><code>split-when="count($group) gt 1 and head($group)/@name = foot($group)/@name"</code> 
                        starts a new group if the last item in the current group has the same value for <code>@name</code>
                        as the first item in that group (provided they are not the same item).</p>
                        </li>
                     </ul>
                  </li>
                  <li>
                     <p>If the <code>merge-when</code> attribute is present, then its value
                        <span class="verb">must</span> be an expression that is a sequence comparator.
                        <span class="definition">[Definition:&nbsp;</span><a id="dt-sequence-comparator" title=""></a>A <b>sequence
                           comparator</b> is an expression that evaluates two sequences of items
                        and results in a true or false value. <span class="definition">]</span></p>
                     <p>The sequence comparator is
                     supplied with two variables: <code>$group-a</code> and <code>$group-b</code>.
                     Each of these variables is implicitly declared, and <a title="shadows" class="termref" href="#dt-shadows">shadows</a> any other variable
                           of the same name. Its name is in no namespace. Its scope is the <code>merge-when</code>
                           expression, and its type is <code>item()+</code>.</p>
                     <p>The sequence comparator is evaluated not item by item (as with
                        <code>split-when</code>) but group by group. The context item is <a title="absent" class="termref" href="#dt-absent">absent</a>, the context position is the position of
                     the first sequence (<code>$group-a</code>) within the sequence of groups being
                     constructed, and the context size is the number of groups at the moment of
                     evaluation.</p>
                     <p>The process begins by creating singleton groups. For each item in the <a title="population" class="termref" href="#dt-population">population</a> a group is created, with that
                     item's position as its grouping key, and the item as its only member.</p>
                     <p>After the groups are created, they are evaluated pairwise against the <a title="" class="termref" href="#dt-sequence-comparator">sequence comparator</a>. The pairwise
                     comparison begins with the first two groups, then the first and third groups,
                     and so on until the first and last groups, then pairwise comparison moves to
                     the second and third groups, then the second and fourth groups, and so forth.
                     Pairwise comparison proceeds until the next-to-last and last groups are
                     evaluated.</p>
                     <p><code>$group-a</code> is set to the items in the first group in a pair of 
                     groups, <var>G<sub>1</sub></var>, and <code>$group-b</code> to the second group, 
                     <var>G<sub>2</sub></var>.</p>
                     <p>If the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-ebv">effective boolean value</a><sup><small>XP</small></sup> of
                     the sequence comparator is <code>true</code>, then all items in <var>G<sub>2</sub></var>
                     are merged with the items in <var>G<sub>1</sub></var>, preserving original sequence order,
                     and the grouping keys of <var>G<sub>2</sub></var> are merged with those of <var>G<sub>1</sub></var>,
                     sorted in ascending order. The process of merging two groups is identical to
                     the process described in <a href="#merging"><i>15 Merging</i></a> to merge sequences. Pairwise
                     comparison then restarts from the beginning with the first pair of groups, as
                     described above. </p>
                     <p>The process is repeated until it is the case that there is no pair of groups
                     for which the <a title="" class="termref" href="#dt-sequence-comparator">sequence
                        comparator</a> evaluates to <code>true</code>, or there is only one
                     group.</p>
                     <p>Every item in the population will be appended to exactly one group. </p>
                     <p>Unlike other grouping methods, a group created by <code>merge-when</code> may
                     have more than one grouping key. Although those grouping keys are not
                     significant for the semantics of the grouping operation, they can be used to
                     examine the original population, and they are useful for the merge
                     operation.</p>
                     <p><code>merge-when</code> is most effective for building clusters or
                     networks. For example:</p>
                     <ul>
                        <li>
                           <p>
                           <code>merge-when="$group-a/(@id | is-related-to) = $group-b/(@id |
                              is-related-to)"</code> creates groups of elements. In a group with
                           more than one item, each item has at least one other item that it relates
                           to, or that relates to the same item it relates to. That is, each group
                           represents a kind of network cluster.</p>
                        </li>
                        <li>
                           <p>Suppose we have elements containing text units where word tokens of
                           significance are wrapped in children <code>tok</code> elements.
                              <code>merge-when="every $a in $group-a, $b in $group-b satisfies
                              count($a/tok[. = $b/tok]) ge 3"</code> creates groups of possibly
                           related texts. In groups of more than one item, any pair of texts has
                           at least three common word-tokens. </p>
                        </li>
                        <li>
                           <p><code>merge-when="some $a in $group-a, $b in $group-b satisfies
                              count($a/tok[. = $b/tok]) ge 3"</code> creates groups of related
                           texts, likely less cohesive than in the previous example. In groups of
                           more than one item, every text has at least one other text with which it
                           has three word-tokens in common. 
                        </p>
                        </li>
                        <li>
                           <p><code>merge-when="not($group-a = $group-b)"</code> creates maximal groups
                           of distinct values. For example, <code>4, 1, 5, 1, 9, 4, 1</code> is
                           grouped as <code>4, 1, 5, 9</code> (with grouping keys <code>1, 2, 3,
                              5</code>), <code>1, 4</code> (with grouping keys <code>4, 6</code>),
                           and <code>1</code> (with grouping key <code>7</code>). Note, the first
                           group is always the result of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-distinct-values"><code>distinct-values</code></a>
                           function, and the final group always contains the items that appear most
                           frequently in the original population. </p>
                        </li>
                        <li>
                           <p> In <code>merge-when="count($group-a) le 3 and
                              count(distinct-values(($group-a, $group-b) ! node-name(.))) eq 1"</code> no
                           group has more than three items. Within each group, every item has the
                           same node name. The effect is the same as specifying
                           <code>group-by="node-name(.)"</code> then subgrouping with 
                           <code>split-when="count($group) = 3"</code>.</p>
                        </li>
                        <li>
                           <p><code>merge-when="some $a in $group-a, $b in $group-b satisfies
                              tokenize($a/@class) = tokenize($b/@class)"</code> creates groups of
                           elements. In a group with multiple items, every item has at least one
                           other item that has at least one of its tokens in <code>@class</code>.</p>
                        </li>
                        <li>
                           <p><code>merge-when="some $a in $group-a, $b in $group-b satisfies abs($a -
                              $b) le 2"</code> creates groups of numerals. Each numeral has at least
                           one other numeral where the two differ by two or less. For example,
                              <code>3, 9, 4, 1, 10, 6</code> is grouped as <code>(3, 4, 1, 6)</code>
                           (with grouping keys <code>1, 3, 4, 6</code>) and <code>(9, 10)</code> (with
                           grouping keys <code>2, 5</code>).</p>
                        </li>
                        <li>
                           <p><code>merge-when="some $a in $group-a, $b in $group-b satisfies abs($a -
                              $b) le xs:dayTimeDuration('PT2H')"</code> creates groups of time
                           values. Within groups of more than one item, each time value has at least
                           one other time value that is two hours or less apart. For example,
                              <code>xs:time("11:12:00Z"), xs:time("13:24:55Z"),
                              xs:time("09:44:10Z"), xs:time("14:09:22Z"),
                              xs:time("08:16:30Z")</code> is grouped as <code>(xs:time("11:12:00Z"),
                              xs:time("09:44:10Z"), xs:time("08:16:30Z"))</code> (with grouping keys
                              <code>1, 3, 5</code>) and <code>(xs:time("13:24:55Z"),
                              xs:time("14:09:22Z"))</code> (with grouping keys <code>2,
                           4</code>).</p>
                        </li>
                        <li>
                           <p>
                           <code>merge-when="every $a in $group-a, $b in $group-b satisfies
                              (string-to-codepoints($a) = string-to-codepoints($b))"</code> creates
                           groups of strings. In groups with more than one member, each member
                           shares at least one codepoint with every other member. For example,
                              <code>("animal", "bison", "cat", "dog", "zebra")</code> is grouped as
                              <code>("animal", "bison", "zebra")</code> (linking letters are a, i,
                           n, and b), <code>("cat")</code> (although it shares letter a with
                           "animal," the group has already been merged with "bison," which has no
                           common letter with "cat"), and <code>("dog")</code>. The grouping keys
                           are <code>1, 2, 5</code>, <code>3</code>, and <code>4</code>,
                           respectively.</p>
                        </li>
                     </ul>
                  </li>
               </ul>
               <p>In all cases the order of items within each group is predictable,
               and reflects the original <a title="population order" class="termref" href="#dt-population-order">population
                  order</a>, in that the items are processed in population order and each item
               is appended at the end of zero or more groups.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>As always, a different algorithm may be used if it achieves the same effect.</p>
               </div>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-initial-item" title="initial item"></a>For each <a title="group" class="termref" href="#dt-group">group</a>, the item within the group that is first in <a title="population order" class="termref" href="#dt-population-order">population order</a> is known as the
                     <b>initial item</b> of the group.<span class="definition">]</span>
            </p>
               <p>The <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> contained in the
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element is evaluated once for each of the
                  <a title="group" class="termref" href="#dt-group">groups</a>, in <a title="processing order" class="termref" href="#dt-processing-order">processing order</a>. The sequences that result are concatenated, in
                  <a title="processing order" class="termref" href="#dt-processing-order">processing order</a>, to form the result
               of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element. Within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of the relevant group, the <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of this
                  group in the <a title="processing order" class="termref" href="#dt-processing-order">processing order</a> of the groups, and the <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of groups This has the effect
               that within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, a call on
                  <code>position()</code> takes successive values <code>1, 2, ... last()</code>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="information-about-group"></a>14.2 <a href="#information-about-group" style="text-decoration: none">Accessing Information about the Current Group Value</a></h3>
               <p>Two pieces of information are available during the processing of each group (that is,
               while evaluating the sequence constructor contained in the
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction, and also while evaluating the
               sort key of a group as expressed by the <code>select</code> attribute or sequence
               constructor of an <a href="#element-sort"><code>xsl:sort</code></a> child of the
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element):</p>
               <ul>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-group" title="current group"></a>The <b>current
                           group</b> is the <a title="group" class="termref" href="#dt-group">group</a> itself, as a
                        sequence of items<span class="definition">]</span>.</p>
                  </li>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-grouping-key" title="current grouping key"></a>The
                           <b>current grouping key</b> is a single atomic item, or in the
                        case of a composite key, a sequence of atomic items, containing the
                           <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of the items in the <a title="current group" class="termref" href="#dt-current-group">current group</a>.<span class="definition">]</span></p>
                  </li>
               </ul>
               <p>Information about the <a title="current group" class="termref" href="#dt-current-group">current group</a>
               and the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is held in the dynamic context, and
               is available using the <a href="#func-current-group"><code>current-group</code></a> and
                  <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> functions respectively.</p>
               <p>In XSLT 2.0, the <a title="current group" class="termref" href="#dt-current-group">current group</a> and the
                  <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> were passed unchanged through calls of
                  <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and <a href="#element-call-template"><code>xsl:call-template</code></a>, and
               also <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a>. This
               behavior is retained in XSLT 3.0 except in the case where streaming is in use:
               specifically, if the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                  <a href="#element-call-template"><code>xsl:call-template</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or
                  <a href="#element-next-match"><code>xsl:next-match</code></a> instruction occurs within a <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-declared-streamable">declared-streamable</a><sup><small>SG</small></sup> construct (typically, within an
                  <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, or within a streamable <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>), then the current group and current grouping key are set
               to <a title="absent" class="termref" href="#dt-absent">absent</a> in the called template. The reason for this is to allow
               the streamability of an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction to be
               assessed statically, as described in <a href="../xslt-streaming-40/#streamability-xsl-for-each-group">12.5.19 Streamability of</a><sup><small>SG</small></sup>.</p>
               <div class="div3">
                  
                  <h4><a id="func-current-group"></a>14.2.1 <a href="#func-current-group" style="text-decoration: none">fn:current-group</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-current-grouping-key">next</a> | <a href="#grouping">previous</a>)</p>
                     <ol>
                        <li>
                           <p>In XSLT 4.0, the function item <code>current-group#0</code> retains the value of the current
         group within its captured context.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the group currently being processed by an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
             instruction.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:current-group</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">item()*</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p> The evaluation context for XPath <a title="expression" class="termref" href="#dt-expression">expressions</a>
            includes a component called the <a title="current group" class="termref" href="#dt-current-group">current group</a>,
            which is a sequence. </p>
                        <p>The function <a href="#func-current-group"><code>current-group</code></a> returns the sequence
            of items making up the current group.</p>
                        <p>The current group is bound during evaluation of the
               <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction. If no
               <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is being evaluated, the current group
            will be <a title="absent" class="termref" href="#dt-absent">absent</a>: that is, any reference to it will cause a dynamic
            error.</p>
                        <p>The effect of <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation constructs</a> on the <a title="current group" class="termref" href="#dt-current-group">current group</a> is as
            follows:</p>
                        <ul>
                           <li>
                              <p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is contained within a <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-declared-streamable">declared-streamable</a><sup><small>SG</small></sup>
                  <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-construct">construct</a><sup><small>SG</small></sup> (for example, if it is within an
                     <a href="#element-source-document"><code>xsl:source-document</code></a> instruction with the attribute <code>streamable="yes"</code>, 
                  or within a streamable template), then the
                  invocation construct sets the current group to <a title="absent" class="termref" href="#dt-absent">absent</a>. In this
                  situation the scope of the current group is effectively static; it can only be
                  referenced within the body of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction
                  to which it applies.</p>
                           </li>
                           <li>
                              <p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is a (static or dynamic) function
                  call, then the invocation construct sets the current group to <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
                           </li>
                           <li>
                              <p>Otherwise the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> leaves the current group
                  unchanged. In this situation the scope of the current group is effectively
                  dynamic: it can be referenced within called templates and attribute sets.</p>
                           </li>
                        </ul>
                        <p>The current group is initially <a title="absent" class="termref" href="#dt-absent">absent</a>
            during the evaluation of global variables and stylesheet parameters, during the
         evaluation of the <code>use</code> attribute or contained sequence constructor of <a href="#element-key"><code>xsl:key</code></a>,
         and during the evaluation of the <code>initial-value</code> attribute of <a href="#element-accumulator"><code>xsl:accumulator</code></a>
         and the <code>select</code> attribute of contained sequence constructor of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTSE1060"><span class="error">[ERR XTSE1060] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-group"><code>current-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.
         </p>
                        <p>
            <a id="err-XTDE1061"><span class="error">[ERR XTDE1061] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-group"><code>current-group</code></a> function is used when the current group is
                     <a title="absent" class="termref" href="#dt-absent">absent</a>
                  , or when it is invoked in the course of evaluating a
                     pattern. The error <span class="verb">may</span> be reported statically if it
                  can be detected statically.
         </p>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-current-grouping-key"></a>14.2.2 <a href="#func-current-grouping-key" style="text-decoration: none">fn:current-grouping-key</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#merging">next</a> | <a href="#func-current-group">previous</a>)</p>
                     <ol>
                        <li>
                           <p>In XSLT 4.0, the function item <code>current-grouping-key#0</code> retains the value of the current
         grouping key within its captured context.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the grouping key of the group currently being processed using the
               <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
             instruction.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:current-grouping-key</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:anyAtomicType*</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p> The evaluation context for XPath <a title="expression" class="termref" href="#dt-expression">expressions</a>
            includes a component called the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping
               key</a>, which is a sequence of atomic
               items. The current grouping key is the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> 
            shared in common by all the items within the <a title="current group" class="termref" href="#dt-current-group">current group</a>. </p>
                        <p>The function <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> returns the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a>.</p>
                        <p>The current grouping key is bound during evaluation of an
               <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction that has a <code>group-by</code>, 
               <code>group-adjacent</code>, or <code>merge-when</code> attribute. If <span>no
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction is being evaluated, the current
               grouping key will be <a title="absent" class="termref" href="#dt-absent">absent</a>, which means that any reference to it
               causes a dynamic error. The current grouping key is also set to <a title="absent" class="termref" href="#dt-absent">absent</a> during the evaluation of an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
               instruction with a <code>group-starting-with</code>, <code>group-ending-with</code>,
               or <code>split-when</code> attribute</span>.</p>
                        <p>The effect of <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation constructs</a> on the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is
            as follows:</p>
                        <ul>
                           <li>
                              <p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is contained within a <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-declared-streamable">declared-streamable</a><sup><small>SG</small></sup>
                  <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-construct">construct</a><sup><small>SG</small></sup> (for example, if it is within an
                     <a href="#element-source-document"><code>xsl:source-document</code></a> instruction with the attribute <code>streamable="yes"</code>, 
                  or within a streamable template), then the
                  invocation construct sets the current grouping key to <a title="absent" class="termref" href="#dt-absent">absent</a>.
                  In this situation the scope of the current group is effectively static; it can
                  only be referenced within the body of the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
                  instruction to which it applies.</p>
                           </li>
                           <li>
                              <p>If the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> is a (static or dynamic) function
                  call, then the invocation construct sets the current grouping key to <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
                           </li>
                           <li>
                              <p>Otherwise the <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation construct</a> leaves the current grouping
                  key unchanged. In this situation the scope of the current group is effectively
                  dynamic: it can be referenced within called templates and attribute sets.</p>
                           </li>
                        </ul>
                        <p>The current grouping key is initially <a title="absent" class="termref" href="#dt-absent">absent</a>
            during the evaluation of global variables and stylesheet parameters, during the
            evaluation of the <code>use</code> attribute or contained sequence constructor of <a href="#element-key"><code>xsl:key</code></a>,
            and during the evaluation of the <code>initial-value</code> attribute of <a href="#element-accumulator"><code>xsl:accumulator</code></a>
            and the <code>select</code> attribute of contained sequence constructor of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>.</p>
                        <p>While an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction with a <code>group-by</code> or
               <code>group-adjacent</code> attribute is being evaluated, the
            <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> will be a single atomic
            item if <code>composite="no"</code> is specified (explicitly
               or implicitly), or a sequence of atomic items if <code>composite="yes"</code> is
               specified.
         </p>
                        <p>While an <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction with a <code>merge-when</code> 
            attribute is being evaluated, the
            <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> will be a sequence of 
            integers, indicating the positions of the items within the original sequence.
         </p>
                        <p>At other times, the current grouping key will be <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
                        <p>The <a title="grouping key" class="termref" href="#dt-grouping-key">grouping keys</a> of
               all items in a group are not necessarily identical. For example, one might be an
                  <code>xs:float</code> while another is a numerically equal
               <code>xs:decimal</code>. The <a href="#func-current-grouping-key"><code>current-grouping-key</code></a>
            function returns the grouping key of the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> in the group, after atomization and
            casting of <code>xs:untypedAtomic</code> items to <code>xs:string</code>.</p>
                        <p>The function takes no arguments.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTSE1070"><span class="error">[ERR XTSE1070] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.
         </p>
                        <p>
            <a id="err-XTDE1071"><span class="error">[ERR XTDE1071] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used when the current
                  grouping key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern.
                  The error <span class="verb">may</span> be reported statically if it can be detected
                  statically.
         </p>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="order-of-groups"></a>14.3 <a href="#order-of-groups" style="text-decoration: none">Ordering among Groups</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-first-appearance" title="order of first appearance"></a>There is a total ordering among <a title="group" class="termref" href="#dt-group">groups</a> referred to as the <b>order of first appearance</b>. A
                  group <var>G</var> is defined to precede a group <var>H</var> in order of first
                  appearance if the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of
                     <var>G</var> precedes the initial item of <var>H</var> in population order. If
                  two groups <var>G</var> and <var>H</var> have the same initial item (because the
                  item is in both groups) then <var>G</var> precedes <var>H</var> if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of <var>G</var> precedes the
                  grouping key of <var>H</var> in the sequence that results from evaluating the
                     <code>group-by</code> expression of this initial item.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-processing-order" title="processing order"></a>There is another total ordering among groups referred to as
                     <b>processing order</b>. If group <var>R</var> precedes group
                     <var>S</var> in processing order, then in the result sequence returned by the
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction the items generated by
                  processing group <var>R</var> will precede the items generated by processing group
                     <var>S</var>.<span class="definition">]</span>
            </p>
               <p>If there are no <a href="#element-sort"><code>xsl:sort</code></a> elements immediately within the
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element, the <a title="processing order" class="termref" href="#dt-processing-order">processing order</a> of the <a title="group" class="termref" href="#dt-group">groups</a> is the <a title="order of first appearance" class="termref" href="#dt-first-appearance">order of
                  first appearance</a>.</p>
               <p>Otherwise, the <a href="#element-sort"><code>xsl:sort</code></a> elements immediately within the
                  <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element define the processing order of the
                  <a title="group" class="termref" href="#dt-group">groups</a> (see <a href="#sorting"><i>13 Sorting</i></a>). They do
               not affect the order of items within each group. Multiple <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key components</a> are allowed, and are
               evaluated in major-to-minor order. If two groups have the same values for all their
               sort key components, they are processed in <a title="order of first appearance" class="termref" href="#dt-first-appearance">order of first appearance</a> if
               the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a> is
                  <a title="stable" class="termref" href="#dt-stable">stable</a>, otherwise in an <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</p>
               <p>The <code>select</code>
               <a title="expression" class="termref" href="#dt-expression">expression</a> of an <a href="#element-sort"><code>xsl:sort</code></a>
               element is evaluated once for each <a title="group" class="termref" href="#dt-group">group</a>. During
               this evaluation, the <a title="context item" class="termref" href="#dt-context-item">context item</a> is the
                  <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of the group, the <a title="context position" class="termref" href="#dt-context-position">context position</a> is the position of this item
               within the set of initial items (that is, one item for each group in the <a title="population" class="termref" href="#dt-population">population</a>) in <a title="population order" class="termref" href="#dt-population-order">population order</a>, the <a title="context size" class="termref" href="#dt-context-size">context
                  size</a> is the number of groups, the <a title="current group" class="termref" href="#dt-current-group">current group</a> is
               the group whose <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key value</a> is being
               determined, and the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is the grouping key for
               that group. If the <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction uses the
               <code>group-starting-with</code>, <code>group-ending-with</code><span>,
                  or <code>split-when</code></span>
               attributes, then the <a title="current grouping key" class="termref" href="#dt-current-grouping-key">current grouping key</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40645"></a>Example: Sorting Groups</div>
                  <p>For example, this means that if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping
                     key</a> is <code>@category</code>, you can sort the groups in order of
                  their grouping key by writing <code>&lt;xsl:sort
                     select="current-grouping-key()"/&gt;</code>; or you can sort the groups in
                  order of size by writing <code>&lt;xsl:sort
                     select="count(current-group())"/&gt;</code>
               </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="grouping-examples"></a>14.4 <a href="#grouping-examples" style="text-decoration: none">Examples of Grouping</a></h3>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40664"></a>Example: Grouping Nodes based on Common Values</div>
                  <p>The following example groups a list of nodes based on common values. The resulting
                  groups are numbered and sorted, and a
                  total is calculated for each group. </p>
                  <p>Source XML document:</p>
                  <div class="exampleInner">
                     <pre>&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"      pop="5"/&gt;
  &lt;city name="Paris"   country="France"      pop="7"/&gt;
  &lt;city name="München" country="Deutschland" pop="4"/&gt;
  &lt;city name="Lyon"    country="France"      pop="2"/&gt;
  &lt;city name="Venezia" country="Italia"      pop="1"/&gt;
&lt;/cities&gt;</pre>
                  </div>
                  <p>More specifically, the aim is to produce a four-column table, containing one row
                  for each distinct country. The four columns are to contain first, a sequence
                  number giving the number of the row; second, the name of the country, third, a
                  comma-separated alphabetical list of the city names within that country, and
                  fourth, the sum of the <code>pop</code> attribute for the cities in that
                  country.</p>
                  <p>Desired output:</p>
                  <div class="exampleInner">
                     <pre>&lt;table&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;List of Cities&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;1&lt;/td&gt;
    &lt;td&gt;Italia&lt;/td&gt;
    &lt;td&gt;Milano, Venezia&lt;/td&gt;
    &lt;td&gt;6&lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
    &lt;td&gt;2&lt;/td&gt;
    &lt;td&gt;France&lt;/td&gt;
    &lt;td&gt;Lyon, Paris&lt;/td&gt;
    &lt;td&gt;9&lt;/td&gt;
  &lt;/tr&gt;  
  &lt;tr&gt;
    &lt;td&gt;3&lt;/td&gt;
    &lt;td&gt;Deutschland&lt;/td&gt;
    &lt;td&gt;München&lt;/td&gt;
    &lt;td&gt;4&lt;/td&gt;
  &lt;/tr&gt;  
&lt;/table&gt;</pre>
                  </div>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>&lt;table xsl:version="3.0" xsl:expand-text="yes"
        xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
  &lt;tr&gt;
    &lt;th&gt;Position&lt;/th&gt;
    &lt;th&gt;Country&lt;/th&gt;
    &lt;th&gt;City List&lt;/th&gt;
    &lt;th&gt;Population&lt;/th&gt;
  &lt;/tr&gt;
  &lt;xsl:for-each-group select="cities/city" group-by="@country"&gt;
    &lt;tr&gt;
      &lt;td&gt;{position()}&lt;/td&gt;
      &lt;td&gt;{current-grouping-key()}&lt;/td&gt;
      &lt;td&gt;
        &lt;xsl:for-each select="current-group()/@name"&gt;
          &lt;xsl:sort select="."/&gt;
          &lt;xsl:if test="position() ne 1"&gt;, &lt;/xsl:if&gt;
          {.}
        &lt;/xsl:for-each&gt;  
      &lt;/td&gt;
      &lt;td&gt;{sum(current-group()/@pop)}&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/table&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40681"></a>Example: A Composite Grouping Key</div>
                  <p>Sometimes it is necessary to use a composite grouping key: for example, suppose
                  the source document is similar to the one used in the previous examples, but
                  allows multiple entries for the same country and city, such as:</p>
                  <div class="exampleInner">
                     <pre>&lt;cities&gt;
  &lt;city name="Milano"  country="Italia"  year="1950"   pop="5.23"/&gt;
  &lt;city name="Milano"  country="Italia"  year="1960"   pop="5.29"/&gt;  
  &lt;city name="Padova"  country="Italia"  year="1950"   pop="0.69"/&gt;
  &lt;city name="Padova"  country="Italia"  year="1960"   pop="0.93"/&gt;    
  &lt;city name="Paris"   country="France"  year="1951"   pop="7.2"/&gt;
  &lt;city name="Paris"   country="France"  year="1961"   pop="7.6"/&gt;
&lt;/cities&gt;</pre>
                  </div>
                  <p>Now suppose we want to list the average value of <code>@pop</code> for each
                  (country, name) combination. One way to handle this is to concatenate the parts of
                  the key, for example <code>&lt;xsl:for-each-group select="concat(@country, '/',
                     @name)"&gt;</code>. A second solution is to nest one
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> element directly inside another. XSLT 3.0
                  introduces a third option, which is to define the grouping key as composite:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:for-each-group select="cities/city" 
                    group -by="@name, @country" 
                    composite="yes"
                    expand-text="yes"&gt;
  &lt;p&gt;{current-grouping-key()[1]}, {current-grouping-key()[2]}: {avg(current-group()/@pop)"/&gt;
  &lt;/p&gt;
&lt;/xsl:for-each-group&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40698"></a>Example: Identifying a Group by its Initial Element</div>
                  <p>The next example identifies a group not by the presence of a common value, but
                  rather by adjacency in document order. A group consists of an <code>h2</code>
                  element, followed by all the <code>p</code> elements up to the next
                     <code>h2</code> element.</p>
                  <p>Source XML document:</p>
                  <div class="exampleInner">
                     <pre>&lt;body&gt;
  &lt;h2&gt;Introduction&lt;/h2&gt;
  &lt;p&gt;XSLT is used to write stylesheets.&lt;/p&gt;
  &lt;p&gt;XQuery is used to query XML databases.&lt;/p&gt;
  &lt;h2&gt;What is a stylesheet?&lt;/h2&gt;
  &lt;p&gt;A stylesheet is an XML document used to define a transformation.&lt;/p&gt;
  &lt;p&gt;Stylesheets may be written in XSLT.&lt;/p&gt;
  &lt;p&gt;XSLT 2.0 introduces new grouping constructs.&lt;/p&gt;
&lt;/body&gt;</pre>
                  </div>
                  <p>Desired output:</p>
                  <div class="exampleInner">
                     <pre>&lt;chapter&gt;
  &lt;section title="Introduction"&gt;
    &lt;para&gt;XSLT is used to write stylesheets.&lt;/para&gt;
    &lt;para&gt;XQuery is used to query XML databases.&lt;/para&gt;
  &lt;/section&gt; 
  &lt;section title="What is a stylesheet?"&gt;
    &lt;para&gt;A stylesheet is used to define a transformation.&lt;/para&gt;
    &lt;para&gt;Stylesheets may be written in XSLT.&lt;/para&gt;
    &lt;para&gt;XSLT 2.0 introduces new grouping constructs.&lt;/para&gt;
  &lt;/section&gt;
&lt;/chapter&gt;</pre>
                  </div>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="body"&gt;
  &lt;chapter&gt;
    &lt;xsl:for-each-group select="*" group-starting-with="h2"&gt;
      &lt;section title="{self::h2}"&gt;
        &lt;xsl:for-each select="current-group()[self::p]"&gt;
          &lt;para&gt;&lt;xsl:value-of select="."/&gt;&lt;/para&gt;
        &lt;/xsl:for-each&gt; 
      &lt;/section&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/chapter&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The use of <code>title="{self::h2}"</code> rather than <code>title="{.}"</code> is
                  to handle the case where the first element is not an <code>h2</code> element.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40731"></a>Example: Identifying a Group by its Final Element</div>
                  <p>The next example illustrates how a group of related elements can be identified by
                  the last element in the group, rather than the first. Here the absence of the
                  attribute <code>continued="yes"</code> indicates the end of the group.</p>
                  <p>Source XML document:</p>
                  <div class="exampleInner">
                     <pre>&lt;doc&gt;
  &lt;page continued="yes"&gt;Some text&lt;/page&gt;
  &lt;page continued="yes"&gt;More text&lt;/page&gt;    
  &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;page continued="yes"&gt;Some words&lt;/page&gt;
  &lt;page continued="yes"&gt;More words&lt;/page&gt;    
  &lt;page&gt;Yet more words&lt;/page&gt;        
&lt;/doc&gt;</pre>
                  </div>
                  <p>Desired output:</p>
                  <div class="exampleInner">
                     <pre>&lt;doc&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some text&lt;/page&gt;
    &lt;page&gt;More text&lt;/page&gt;    
    &lt;page&gt;Yet more text&lt;/page&gt;
  &lt;/pageset&gt;
  &lt;pageset&gt;
    &lt;page&gt;Some words&lt;/page&gt;
    &lt;page&gt;More words&lt;/page&gt;    
    &lt;page&gt;Yet more words&lt;/page&gt;
  &lt;/pageset&gt;
&lt;/doc&gt;</pre>
                  </div>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="doc"&gt;
&lt;doc&gt;
  &lt;xsl:for-each-group select="*" 
                      group-ending-with="page[not(@continued='yes')]"&gt;
    &lt;pageset&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;page&gt;&lt;xsl:value-of select="."/&gt;&lt;/page&gt;
      &lt;/xsl:for-each&gt; 
    &lt;/pageset&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/doc&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40747"></a>Example: Adding an Element to Several Groups</div>
                  <p>The next example shows how an item can be added to multiple groups. Book titles
                  will be added to one group for each indexing term marked up within the title.</p>
                  <p>Source XML document:</p>
                  <div class="exampleInner">
                     <pre>&lt;titles&gt;
    &lt;title&gt;A Beginner's Guide to &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Learning &lt;ix&gt;XML&lt;/ix&gt;&lt;/title&gt;
    &lt;title&gt;Using &lt;ix&gt;XML&lt;/ix&gt; with &lt;ix&gt;Java&lt;/ix&gt;&lt;/title&gt;
&lt;/titles&gt;</pre>
                  </div>
                  <p>Desired output:</p>
                  <div class="exampleInner">
                     <pre>&lt;h2&gt;Java&lt;/h2&gt;
    &lt;p&gt;A Beginner's Guide to Java&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;
&lt;h2&gt;XML&lt;/h2&gt;
    &lt;p&gt;Learning XML&lt;/p&gt;
    &lt;p&gt;Using XML with Java&lt;/p&gt;</pre>
                  </div>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="titles"&gt;
    &lt;xsl:for-each-group select="title" group-by="ix"&gt;
      &lt;h2&gt;&lt;xsl:value-of select="current-grouping-key()"/&gt;&lt;/h2&gt;
      &lt;xsl:for-each select="current-group()"&gt;
        &lt;p&gt;&lt;xsl:value-of select="."/&gt;&lt;/p&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40759"></a>Example: Grouping Alternating Sequences of Elements</div>
                  <p>In this example, the membership of a node within a group is based both on
                  adjacency of the nodes in document order, and on common values. In this case, the
                  grouping key is a boolean condition, <code>true</code> or <code>false</code>, so the effect is that a
                  grouping establishes a maximal sequence of nodes for which the condition is true,
                  followed by a maximal sequence for which it is false, and so on.</p>
                  <p>Source XML document:</p>
                  <div class="exampleInner">
                     <pre>&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    while you are in the cinema.&lt;/p&gt;</pre>
                  </div>
                  <p>Desired output:</p>
                  <div class="exampleInner">
                     <pre>&lt;p&gt;Do &lt;em&gt;not&lt;/em&gt;:&lt;/p&gt;
    &lt;ul&gt;
    &lt;li&gt;talk,&lt;/li&gt;
    &lt;li&gt;eat, or&lt;/li&gt;
    &lt;li&gt;use your mobile telephone&lt;/li&gt;
    &lt;/ul&gt;
    &lt;p&gt;while you are in the cinema.&lt;/p&gt;</pre>
                  </div>
                  <p>Solution:</p>
                  <p>This requires creating a <code>p</code> element around the maximal sequence of
                  sibling nodes that does not include a <code>ul</code> or <code>ol</code>
                  element.</p>
                  <p>This can be done by using <code>group-adjacent</code>, with a grouping key that is
                  <code>true</code> if the element is a <code>ul</code> or <code>ol</code> element, and <code>false</code>
                  otherwise:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="p"&gt;
    &lt;xsl:for-each-group select="node()" 
            group-adjacent="self::ul or self::ol"&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="current-grouping-key()"&gt;
                &lt;xsl:copy-of select="current-group()"/&gt;  
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;p&gt;
                    &lt;xsl:copy-of select="current-group()"/&gt;
                &lt;/p&gt;
            &lt;/xsl:otherwise&gt;  
        &lt;/xsl:choose&gt;
    &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40806"></a>Example: Grouping entries in a Map</div>
                  <p>Consider a map with composite keys that might appear in a JSON document as:</p>
                  <div class="exampleInner">
                     <pre>{
   "Africa/Abidjan": { "offset": "+00:00", "DST-offset": "+00:00" },
   "Africa/Algiers": { "offset": "+01:00", "DST-offset": "+01:00" },
   "Africa/Nairobi": { "offset": "+03:00", "DST-offset": "+03:00" },
   "America/Anchorage": { "offset": "-09:00", "DST-offset": "-08:00" },
   "America/Los_Angeles": { "offset": "-08:00", "DST-offset": "-07:00" },
   "Asia/Dubai": { "offset": "+04:00", "DST-offset": "+04:00" },
   "Asia/Kolkata": { "offset": "+05:30", "DST-offset": "+05:30" }                 
}</pre>
                  </div>
                  <p>And suppose we wish to group this into a two-level map, thus:</p>
                  <div class="exampleInner">
                     <pre>{
  "Africa": {
    "Abidjan": { "offset": "+00:00", "DST-offset": "+00:00" },
    "Algiers": { "offset": "+01:00", "DST-offset": "+01:00" },
    "Nairobi": { "offset": "+03:00", "DST-offset": "+03:00" }
  },
  "America": {
    "Anchorage": { "offset": "-09:00", "DST-offset": "-08:00" },
    "Los_Angeles": { "offset": "-08:00", "DST-offset": "-07:00" }
  },
  "Asia": {
    "Dubai": { "offset": "+04:00", "DST-offset": "+04:00" },
    "Kolkata": { "offset": "+05:30", "DST-offset": "+05:30" }
  }
}</pre>
                  </div>
                  <p>This can be achieved as follows:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:map&gt;
   &lt;xsl:for-each-group select="json-doc('tz.json') =&gt; map:pairs()" 
                       group-by="substring-before(?key, '/')"&gt;
     &lt;xsl:map-entry key="current-grouping-key()"&gt;
       &lt;xsl:map&gt;
         &lt;xsl:for-each select="current-group()"&gt;
           &lt;xsl:map-entry key="substring-after(?key, '/')" select="?value"/&gt;
         &lt;/xsl:for-each&gt;
       &lt;/xsl:map&gt;
     &lt;/xsl:map-entry&gt;
   &lt;/xsl:for-each-group&gt;
&lt;/xsl:map&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40817"></a>Example: Grouping Items by Proximity (Merging)</div>
                  <p>Consider a sequence of atomic items that we wish to group according to cluster.
                  For the sake of illustration we restrict ourselves to integers. For each integer,
                  the group it is in should include every other integer of proximate distance two or
                  less.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="ages" as="xs:integer*" select="5, 24, 9, 5, 6, 8, 36, 38, 28"&gt;</pre>
                  </div>
                  <p>We want to return the following four groups:</p>
                  <div class="exampleInner">
                     <pre>map { 1 : (5, 9, 5, 6, 8), 2 : (24), 3 : (36, 38), 4 : (28)}</pre>
                  </div>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:map&gt;
  &lt;xsl:for-each-group select="$ages" merge-when="function($a, $b){abs($a - $b) le 2}"&gt;
    &lt;xsl:map-entry key="position()" select="current-group()"/&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:map&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e40828"></a>Example: Collating Text Versions (Merging)</div>
                  <p>The next example shows how the component parts of multiple versions of a text can
                  be collated when they refer to overlapping reference systems. Suppose we have a
                  text, with various commentaries and glosses, and we wish to collate them by text
                  cluster, for online presentation.</p>
                  <div class="exampleInner">
                     <pre>&lt;body type="source"&gt;
  &lt;div ref="7a1"&gt;[text]&lt;/div&gt;
  &lt;div ref="7a2"&gt;[text]&lt;/div&gt;
  &lt;div ref="7a3"&gt;[text]&lt;/div&gt;
  &lt;div ref="7a4"&gt;[text]&lt;/div&gt;
  &lt;!-- . . . --&gt;
&lt;/body&gt;</pre>
                  </div>
                  <div class="exampleInner">
                     <pre>&lt;body type="commentary"&gt;
  &lt;div ref="7a1 7a2"&gt;[commentary A]&lt;/div&gt;
  &lt;!-- . . . --&gt;
&lt;/body&gt;</pre>
                  </div>
                  <div class="exampleInner">
                     <pre>&lt;body type="commentary"&gt;
  &lt;div ref="7a2 7a3"&gt;[commentary B]&lt;/div&gt;
  &lt;!-- . . . --&gt;
&lt;/body&gt;</pre>
                  </div>
                  <div class="exampleInner">
                     <pre>&lt;body type="gloss"&gt;
  &lt;div ref="7a1"&gt;[gloss A]&lt;/div&gt;
  &lt;!-- . . . --&gt;
&lt;/body&gt;</pre>
                  </div>
                  <div class="exampleInner">
                     <pre>&lt;body type="gloss"&gt;
  &lt;div ref="7a4"&gt;[gloss B]&lt;/div&gt;
  &lt;!-- . . . --&gt;
&lt;/body&gt;</pre>
                  </div>
                  <p>We wish to collate text portions, and display the grouped clusters in an HTML fragment:</p>
                  <div class="exampleInner">
                     <pre>&lt;div class="edition"&gt;
  &lt;div class="text-cluster"&gt;
    &lt;div class="ref"&gt;7a1&lt;/div&gt;
    &lt;div class="ref"&gt;7a2&lt;/div&gt;
    &lt;div class="ref"&gt;7a3&lt;/div&gt;
    &lt;div class="source"&gt;[text]&lt;/div&gt;
    &lt;div class="commentary"&gt;[commentary A]&lt;/div&gt;
    &lt;div class="commentary"&gt;[commentary B]&lt;/div&gt;
    &lt;div class="gloss"&gt;[gloss A]&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="text-cluster"&gt;
    &lt;div class="ref"&gt;7a4&lt;/div&gt;
    &lt;div class="source"&gt;[text]&lt;/div&gt;
    &lt;div class="gloss"&gt;[gloss B]&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre>
                  </div>
                  <p>In this solution, we bind all the texts to a variable, <code>$versions</code>, 
               and we pass a template copy of the desired HTML output through a designated XSLT mode. 
               At the appropriate place, we collate the versions by using <code>group-by-cluster</code>:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="html:div[@class eq 'edition']" mode="collate-versions"&gt;
  &lt;xsl:copy&gt;
    &lt;xsl:copy-of select="@*"/&gt;
    &lt;xsl:for-each-group select="$versions//body/div" merge-when="function($a, $b){tokenize($a/@ref) = tokenize($b/@ref)}"&gt;
      &lt;div class="text-cluster"&gt;
        &lt;xsl:for-each select="distinct-values(current-group() ! tokenize(@ref))"&gt;
          &lt;div class="ref"&gt;
            &lt;xsl:value-of select="."/&gt;
          &lt;/div&gt;
        &lt;/xsl:for-each&gt;
        &lt;xsl:for-each-group select="current-group()" group-by="../@type"&gt;
          &lt;div&gt;
            &lt;xsl:attribute name="class" select="current-grouping-key()"/&gt;
            &lt;xsl:apply-templates mode="#current"/&gt;
          &lt;/div&gt;
        &lt;/xsl:for-each-group&gt; 
      &lt;/div&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:copy&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="merging"></a>15 <a href="#merging" style="text-decoration: none">Merging</a></h2>
            <div class="changes">
               <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-current-merge-group">next</a> | <a href="#func-current-grouping-key">previous</a>)</p>
               <ol>
                  <li>
                     <p>
               Composite merge keys are now allowed.
            <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1684">1684</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1689">1689</a>&nbsp;9 January 2025]</i></p>
                  </li>
               </ol>
            </div>
            <p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction allows a sorted sequence of items to be
            constructed by merging several input sequences. Each
            input sequence <span class="verb">must</span> have a merge key (one or more
            atomic items that can be computed as a function of the items in the sequence); the
            input sequence <span class="verb">must</span> either already be sorted on the value of
            its merge keys, or pre-sorting on these values must be requested. 
            The merge keys for the different input sequences <span class="verb">must</span> be compatible in the sense that key
               values from an item in one sequence are always comparable with key values from an
               item in a different sequence.</p>
            <p>For example, if two log files contain details of events sorted by date and time, then
            the <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to combine these into a single
            sequence that is also sorted by date and time.</p>
            <p>The data written to the output sequence can be computed in an arbitrary way from the
            data in the input sequences, provided it follows the ordering of the input
            sequences.</p>
            <p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to merge several sequences of
            items that all have the same structure (more precisely, sequences whose merge keys are
            computed in the same way): for example, log files created by the same application
            running on different machines in a server farm. Alternatively,
               <a href="#element-merge"><code>xsl:merge</code></a> can be used to merge sequences that have different
            structure (sequences whose merge keys are computed in different ways), provided that the
            computed merge keys are compatible: an example might be two log files created by
            different applications, using different XML vocabularies, that both contain timestamped
            events but represent the timestamp in different ways. The
               <a href="#element-merge-source"><code>xsl:merge-source</code></a> element represents a set
               of input sequences that follow common rules, including the rules for
            computing the merge key. The <a href="#element-merge"><code>xsl:merge</code></a> operation may take any number of
               <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements representing different rules for input sequences, and each <a href="#element-merge-source"><code>xsl:merge-source</code></a>
            element may describe any number (zero or more) of input sequences. The number of input
            sequences to the merging operation is thus fixed only at the
               time the <a href="#element-merge"><code>xsl:merge</code></a> instruction is evaluated, and
                  <span class="verb">may</span> vary from one evaluation to another.</p>
            <p>The following examples illustrate some of the possibilities. The detailed explanation of
            the constructs used follows later in this section.</p>
            <div class="example">
               
               <div class="exampleHeader"><a id="d5e40988"></a>Example: Merging All the Files in a Collection</div>
               <p>This example takes as input a homogeneous collection of XML log files each of which
               contains a sorted sequence of <code>event</code> elements with a
                  <code>timestamp</code> attribute validated as an instance of
                  <code>xs:dateTime</code>. It merges the events from the input files into a single
               sorted output file.</p>
               <div class="exampleInner">
                  <pre>
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source for-each-source="uri-collection('log-files')"
                        select="events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:copy-of select="current-merge-group()"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;</pre>
               </div>
               <p>The example assumes that there are several input files each
                  of which has a structure similar to the following, in which the
                  <code>timestamp</code> attribute has a typed value that is an instance of
                  <code>xs:dateTime</code>:</p>
               <div class="exampleInner">
                  <pre>
&lt;events&gt;
   &lt;event timestamp="2009-08-20T12:01:01Z"&gt;Transaction T1234 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:08Z"&gt;Transaction T1235 started&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:12Z"&gt;Transaction T1235 ended&lt;/event&gt;
   &lt;event timestamp="2009-08-20T12:01:15Z"&gt;Transaction T1234 ended&lt;/event&gt;
&lt;/events&gt;</pre>
               </div>
               <p>The output file will have the same structure, and will contain copies of all the
                  <code>event</code> elements from all of the input files, in sorted order. Note that multiple events with the same timestamp can occur
                  either within a single file or across multiple files: the order of appearance of
                  these events in the output file corresponds to the order of the log files within
                  the collection (which might or might not be predictable, depending on the
                  implementation).</p>
            </div>
            <p>&nbsp;</p>
            <div class="example">
               
               <div class="exampleHeader"><a id="d5e41018"></a>Example: Merging Two Heterogeneous Files</div>
               <p>This example takes as input two log files with different structure, producing a
               single merged output in which the entries have a common structure:</p>
               <div class="exampleInner">
                  <pre>
&lt;xsl:result-document href="merged-events.xml"&gt;
  &lt;events&gt;
    &lt;xsl:merge&gt;
      &lt;xsl:merge-source select="doc('log-file-1.xml')/events/event"&gt;
        &lt;xsl:merge-key select="@timestamp"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-source select="doc('log-files-2.xml')/log/day/record"&gt;
        &lt;xsl:merge-key select="dateTime(../@date, time)"/&gt;
      &lt;/xsl:merge-source&gt;
      &lt;xsl:merge-action&gt;
        &lt;xsl:apply-templates select="current-merge-group()" 
                             mode="standardize-log-entry"/&gt;
      &lt;/xsl:merge-action&gt;
    &lt;/xsl:merge&gt;
  &lt;/events&gt;
&lt;/xsl:result-document&gt;</pre>
               </div>
               <p>Here the first input file has a structure similar to that shown in the previous
               example, while the second input has a different structure, of the form:</p>
               <div class="exampleInner">
                  <pre>
&lt;log&gt;
  &lt;day date="2009-08-20"&gt;
    &lt;record&gt;
      &lt;time&gt;12:01:09-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 15.4C&lt;/message&gt;
    &lt;/record&gt;
    &lt;record&gt;
      &lt;time&gt;12:03:00-05:00&lt;/time&gt;
      &lt;message&gt;Temperature 18.2C&lt;/message&gt;
    &lt;/record&gt;
  &lt;/day&gt;
&lt;/log&gt;</pre>
               </div>
               <p>The templates in mode <code>standardize-log-entry</code> convert the log entries to a
               common output format, for example:</p>
               <div class="exampleInner">
                  <pre>
&lt;xsl:template match="event" mode="standardize-log-entry" 
                            as="schema-element(event)"&gt;
  &lt;xsl:copy-of select="." validation="preserve"/&gt;
&lt;/xsl:template&gt;
  
&lt;xsl:template match="record" mode="standardize-log-entry" 
                             as="schema-element(event)"&gt;
  &lt;event timestamp="{dateTime(../@date, time)}" xsl:validation="strict"&gt;
    &lt;xsl:value-of select="message"/&gt;
  &lt;/event&gt;
&lt;/xsl:template&gt;</pre>
               </div>
            </div>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction is designed to enable streaming of data,
               so that there is no need to allocate memory to hold the input sequences. However, it can also be used in cases where streamed
                  processing is not possible, for example when the input needs to be
               sorted.</p>
            </div>
            <div class="div2">
               
               <h3><a id="merge-terminology"></a>15.1 <a href="#merge-terminology" style="text-decoration: none">Terminology for Merging</a></h3>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-source-definition" title="merge source definition"></a>A <b>merge
                     source definition</b> is the definition of one kind of input to the merge
                  operation. It selects zero or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge
                     input sequences</a>, and it includes a 
               <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> to define
                  how the <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key
                        values</a> are computed for each such merge input
                  sequence.<span class="definition">]</span> A merge source definition corresponds to an
                  <a href="#element-merge-source"><code>xsl:merge-source</code></a> element in the stylesheet.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-input-sequence" title="merge input sequence"></a>A <b>merge input
                     sequence</b> is an arbitrary <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-sequence">sequence</a><sup><small>DM</small></sup> of items which is already sorted according to the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> for the
                  corresponding <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source
                     definition</a>.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-specification" title="merge key specification"></a>A <b>merge
                     key specification</b> consists of one or more adjacent
                     <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements which together define how the 
               <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a> selected by a
                     <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a> are
                  sorted. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one 
               <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a>.<span class="definition">]</span> For
               example, a merge key specification for a log file might specify two merge key
               components, <code>date</code> and <code>time</code>.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-component" title="merge key component"></a>A <b>merge key
                     component</b> specifies one component of a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>; it
                  corresponds to a single <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the
                  stylesheet.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-key-value" title="merge key value"></a> For each item in a 
               <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is
                  computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key
                     component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge
                     key specification</a>. The value computed for an item by using the
                     <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the
                     <var>N</var>th <b>merge key value</b> of that item.<span class="definition">]</span>
               A merge key value may be any sequence of atomic items (including the empty sequence).</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-combined-merge-key-value" title="combined merge key value"></a> The
                  ordered collection of <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a>
                  computed for one item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input
                     sequence</a> (one for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge
                     key component</a> within the 
                     <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>) 
                     is referred to as a <b>combined merge key value</b>.<span class="definition">]</span>
                  Since each merge key value is (in general) a sequence of atomic items, the
                  combined merge key value is modeled as an array of such sequences.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-merge-activation" title="merge activation"></a>A <b>merge
                     activation</b> is a single evaluation of the sequence constructor contained
                  within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, which occurs once for each
                  distinct <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a>.<span class="definition">]</span></p>
            </div>
            <div class="div2">
               
               <h3><a id="merge-instruction"></a>15.2 <a href="#merge-instruction" style="text-decoration: none">The <code>xsl:merge</code> Instruction</a></h3>
               <p class="element-syntax"><a id="element-merge"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:merge&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-merge-source">xsl:merge-source</a>+, <a href="#element-merge-action">xsl:merge-action</a>, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:merge&gt;</code></p>
               <p>The effect of the <a href="#element-merge"><code>xsl:merge</code></a> instruction is to produce a sorted
               result sequence from a number of input sequences.</p>
               <p>The input sequences to the merge operation are defined by the
                  <a href="#element-merge-source"><code>xsl:merge-source</code></a> child elements, as described in the next
               section.</p>
               <p>The sequence constructor contained in the
                  <a href="#element-merge-action"><code>xsl:merge-action</code></a> element is evaluated once for each distinct
                  <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a> to form a partial result sequence.
               The result of the <a href="#element-merge"><code>xsl:merge</code></a> instruction is the concatenation of
               these partial result sequences. For example, the action might be to copy the items
               from all the input sequences to the result sequence without change; or it might be to
               select the items from one input sequence in preference to the others. In the general
               case, the items in the partial result sequence are produced by an arbitrary
               computation that has access to the items (from the various input sequences) that
               share the same value for the composite merge key.</p>
               <p>The <a href="#element-merge-source"><code>xsl:merge-source</code></a> and
                  <a href="#element-merge-action"><code>xsl:merge-action</code></a> elements are described in the following
               sections.</p>
               <p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a>
               instruction are ignored by an XSLT 3.0 processor, but are used by an XSLT 1.0 or XSLT
               2.0 processor to perform fallback processing.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>An <a href="#element-merge"><code>xsl:merge</code></a> instruction that has no input sequences returns an
                  empty sequence. An <a href="#element-merge"><code>xsl:merge</code></a> instruction with a single input
                  sequence performs processing that is very similar in concept to
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> with the <code>group-adjacent</code>
                  attribute, except that it requires the input to be sorted on the grouping key.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="merge-input-sequences"></a>15.3 <a href="#merge-input-sequences" style="text-decoration: none">Selecting the Sequences to be Merged</a></h3>
               <p class="element-syntax"><a id="element-merge-source"></a><code>&lt;xsl:merge-source<br>&nbsp;&nbsp;name? = <var>ncname</var><br>&nbsp;&nbsp;for-each-item? = <var>expression</var><br>&nbsp;&nbsp;for-each-source? = <var>expression</var><br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var>〔''〕<br>&nbsp;&nbsp;sort-before-merge? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-merge-key">xsl:merge-key</a>+ --&gt;<br>&lt;/xsl:merge-source&gt;</code></p>
               <p>Each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element defines one or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a>.</p>
               <p>The <code>name</code> attribute provides a means of
               distinguishing items from different merge sources within the
                  <a href="#element-merge-action"><code>xsl:merge-action</code></a> instructions. If the <code>name</code> attribute
               is present on an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, then it must not be equal
               to the <code>name</code> attribute of any sibling <a href="#element-merge-source"><code>xsl:merge-source</code></a>
               element. If the <code>name</code> attribute is absent, then an <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> name, different from all explicitly specified
               names, is allocated to the merge source.</p>
               <p><a id="err-XTSE3195"><span class="error">[ERR XTSE3195] </span></a>If the <code>for-each-item</code> attribute is present then the
                        <code>for-each-source</code>, <code>use-accumulators</code>, and <code>streamable</code> attributes
                     must all be absent. If <span>either or both of the
                        <code>use-accumulators</code> or <code>streamable</code> attributes is present </span>
                     then the <code>for-each-source</code> attribute must be present. If the
                        <code>for-each-source</code> attribute is present then the
                     <code>for-each-item</code> attribute must be absent. 
                     </p>
               <p>The <code>use-accumulators</code> attribute defines the
               set of accumulators that are applicable to the streamed document, as explained in
                  <a href="#applicability-of-accumulators"><i>19.2 Applicability of Accumulators</i></a>.</p>
               <p>If neither of
                     <code>for-each-item</code> and <code>for-each-source</code> is
               present, the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element defines a single
               merge input sequence. This sequence is the result of evaluating the expression in the
                  <code>select</code> attribute. This is evaluated using the dynamic context of the
               containing <a href="#element-merge"><code>xsl:merge</code></a> instruction. This sequence will be merged with
               the sequences defined by other <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, if
               present.</p>
               <p>When the <code>for-each-item</code>
               attribute is present, the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element defines a
               collection of merge input sequences. The selection of items in these input sequences
               is a two-stage process: the <code>for-each-item</code> attribute of the
                  <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is an expression that selects a sequence
               of <em>anchor items</em>, and for each anchor item, the <code>select</code>
               attribute is evaluated to select the items that make up one merge input sequence. The
                  <code>for-each-item</code> expression is evaluated with
               the dynamic context of the containing <a href="#element-merge"><code>xsl:merge</code></a> instruction, while
               the <code>select</code> attribute is evaluated with the <a title="focus" class="termref" href="#dt-focus">focus</a> for the evaluation as follows:</p>
               <ul>
                  <li>
                     <p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the anchor
                     item</p>
                  </li>
                  <li>
                     <p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the
                     position of the anchor item within the sequence of anchor items</p>
                  </li>
                  <li>
                     <p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is the number of
                     anchor items.</p>
                  </li>
               </ul>
               <p>When the <code>for-each-source</code> attribute is
               present, its value must be an expression that returns a sequence of URIs. 
               The expression is evaluated with the same
               dynamic context as the containing <a href="#element-merge"><code>xsl:merge</code></a> instruction. The
               expected type of the expression is <code>xs:string*</code>, and the actual result of
               the expression is converted to this type using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. Each of these URIs is used to obtain a
               document node. Each <span class="verb">must</span> be a valid URI reference. If it is an
               absolute URI reference, it is used as is; if it is a relative URI reference, it is
               made absolute by resolving it against the base URI of the
                  <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. The process of obtaining a document
               node given a URI is the same as for the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function, and may trigger the same error conditions.
               However, unlike the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function, the
                  <a href="#element-merge"><code>xsl:merge</code></a> instruction offers no guarantee that the resulting
               document will be stable (that is, that multiple calls specifying the same URI will
               return the same document). The resulting document nodes act as the <b>anchor
                  items</b>. These anchor items are then used in the same way as a sequence of
               anchor items selected directly using the <code>for-each-item</code> attribute:
               in particular, the <a title="focus" class="termref" href="#dt-focus">focus</a> is
               determined in the same way.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Examples of expressions that return a sequence of URIs are:</p>
                  <ul>
                     <li>
                        <p><code>for-each-source="'inputA.xml', 'inputB.xml'"</code></p>
                     </li>
                     <li>
                        <p><code>for-each-source="(1 to $N) ! ('input' || $N || '.xml')"</code></p>
                     </li>
                     <li>
                        <p><code>for-each-source="uri-collection('input/dir/')</code></p>
                     </li>
                  </ul>
                  <p>Relative URIs are resolved relative to the base URI of the
                     <a href="#element-merge-source"><code>xsl:merge-source</code></a> element.</p>
               </div>
               <p>The attributes <code>validation</code> and
                  <code>type</code> are used to control schema validation of documents read by
               virtue of their appearance in the result of the <code>for-each-source</code>
               expression. These attributes are mutually exclusive <span class="error">[see <a href="#err-XTSE1505">ERR XTSE1505</a>]</span>. 
               
               If the <code>for-each-source</code> attribute is absent, then the
                  <code>validation</code> and <code>type</code> attributes <span class="verb">must</span>
               both be absent. <span>The process of validation follows
               the rules defined in <a href="#validation"><i>25.4 Validation</i></a>.</span></p>
               <p>If the <code>sort-before-merge</code> attribute is absent or has
               the value <code>no</code>, then each merge input sequence <span class="verb">must</span> already
               be in the correct order for merging (a dynamic error occurs if it is not). If the
               attribute is present with the value <code>yes</code>, then each input sequence will
               first be sorted to ensure that it is in the correct order. <span>
                  The sorting is carried out as if by evaluating an <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> 
                  instruction with <a href="#element-sort"><code>xsl:sort</code></a> children corresponding one-to-one with 
                  the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> 
                  element, differing only (a) in the change of element name, 
                  and (b) in the addition of the attribute <code>stable="yes"</code> to the first such element.
                  
               </span></p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e41489"></a>Example: Merging Several Documents with the Same Structure</div>
                  <p>The following <a href="#element-merge-source"><code>xsl:merge-source</code></a> element selects two anchor items
                  (the root nodes of two documents), and for each of these it selects an input
                  sequence consisting of selected <code>event</code> elements within the relevant
                  document.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:merge-source for-each-source="'log-A.xml', 'log-B.xml'"
                  streamable="yes"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@timestamp" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</pre>
                  </div>
                  <p>This example can be extended to merge any number of input documents with the same
                  structure:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:merge-source for-each-source="uri-collection('log-collection')"
                  streamable="yes"
                  select="events/event"&gt;
   &lt;xsl:merge-key select="@time" order="ascending"/&gt;
&lt;/xsl:merge-source&gt;</pre>
                  </div>
                  <p>In both the above examples the anchor items are document nodes, and the items in
                  the input sequence are elements within the document that is rooted at this node.
                  This is a common usage pattern, but by no means the only way in which the
                  construct can be used.</p>
               </div>
               <p>The number of anchor items selected by an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element,
               and therefore the number of input sequences, is variable, but the input sequences
               selected by one <a href="#element-merge-source"><code>xsl:merge-source</code></a> element must all use the same
               expressions to select the items in the input sequence and to compute their merge
               keys. If different expressions are needed for different input sequences, then
               multiple <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements can be used.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e41512"></a>Example: Merging Two Documents with Different Structure</div>
                  <p>The following code merges two log files having different internal structure:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:merge-source for-each-source="'event-log.xml'" 
                  streamable="yes" select="/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source for-each-source="'error-log.xml'" 
                  streamable="yes" select="/*/error"&gt;
  &lt;xsl:merge-key select="dateTime(@date, @time)"/&gt;
&lt;/xsl:merge-source&gt;</pre>
                  </div>
                  <p>Although the merge keys are computed in different ways for the two input
                  sequences, the keys must be compatible across the two sequences: in this case they
                  are both atomic items of type <code>xs:dateTime</code>.</p>
               </div>
               <p>In the common case where there is only one input sequence of a particular kind, the
                  <code>for-each-item</code> attribute of
                  <a href="#element-merge-source"><code>xsl:merge-source</code></a> may be omitted; the <code>select</code>
               expression is then evaluated relative to the <a title="focus" class="termref" href="#dt-focus">focus</a>
               of the <a href="#element-merge"><code>xsl:merge</code></a> instruction itself.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e41537"></a>Example: Sorting before Merging</div>
                  <p>Where one or more of the inputs to the merging process is not pre-sorted, a sort
                  can be requested using the <code>sort-before-merge</code> attribute. For
                  example:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:merge-source select="doc('event-log.xml')/*/event"&gt;
  &lt;xsl:merge-key select="@timestamp"/&gt;
&lt;/xsl:merge-source&gt;
&lt;xsl:merge-source select="doc('error-log.xml')//error" 
                  sort-before-merge="yes"&gt;
  &lt;xsl:merge-key select="dateTime(current-date(), @time)"/&gt;
&lt;/xsl:merge-source&gt;</pre>
                  </div>
               </div>
               <p>
               <a id="err-XTSE3190"><span class="error">[ERR XTSE3190] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two sibling
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements have the same name.
            </p>
            </div>
            <div class="div2">
               
               <h3><a id="merge-keys"></a>15.4 <a href="#merge-keys" style="text-decoration: none">Defining the Merge Keys</a></h3>
               <p>The keys on which the input sequences are sorted are referred to as merge keys. If
               the attribute <code>sort-before-merge</code> has the value <code>yes</code>, the
               input sequences will be sorted into the correct sequence before the merge operation
               takes place (alternatively, the processor <span class="verb">may</span> use an algorithm
               that has the same effect as sorting followed by merging). If the attribute is absent
               or has the value <code>no</code>, then the input sequences <span class="verb">must</span>
               already be in the correct order.</p>
               <p>The merge key for each type of input sequence (that is, for each
                  <a href="#element-merge-source"><code>xsl:merge-source</code></a> element) is defined by a sequence of
                  <a href="#element-merge-key"><code>xsl:merge-key</code></a> element children of the
                  <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a>
               element defines one merge key component. The syntax and semantics of an
                  <a href="#element-merge-key"><code>xsl:merge-key</code></a> element are closely based on the rules for the
                  <a href="#element-sort"><code>xsl:sort</code></a> element (<span>with minor exceptions
                  noted below; the only difference in syntax is</span> the absence of the
                  <code>stable</code> attribute); the <span>main</span> difference is that
                  <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements do not cause a sort to take place, they
               merely declare the existing sort order of the input sequence. 
               </p>
               <p class="element-syntax"><a id="element-merge-key"></a><code>&lt;xsl:merge-key<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }〔'ascending'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-key&gt;</code></p>
               <p>The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are mutually
               exclusive:</p>
               <p>
               <a id="err-XTSE3200"><span class="error">[ERR XTSE3200] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> element with a <code>select</code> attribute
                     has non-empty content.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>From XSLT 4.0, the <code>select</code> expression or contained sequence constructor
            may evaluate (after atomization) to an arbitrary sequence of atomic items. Previously,
            only a singleton atomic item or the empty sequence was allowed.</p>
               </div>
               <p>The value of <var>N</var>th item in the merge key of an item
               <var>J</var> in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input
                  sequence</a>
               <var>S</var> is computed as follows, where <var>K</var> is the <var>N</var>th
               <a href="#element-merge-key"><code>xsl:merge-key</code></a> element of the relevant <a href="#element-merge-source"><code>xsl:merge-source</code></a>:</p>
               <ol class="enumar">
                  <li>
                     <p>If <var>K</var> has a <code>select</code> attribute, then the result 
                  of evaluating and atomizing that <code>select</code> expression;</p>
                  </li>
                  <li>
                     <p>If <var>K</var> contains a non-empty sequence constructor, then the 
                  result of evaluating and atomizing that sequence constructor;</p>
                  </li>
                  <li>
                     <p>Otherwise, the result of atomizing the context item.</p>
                  </li>
               </ol>
               <p>In each case the evaluation uses a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> 
               based on <var>J</var>, or, if <code>streamable="yes"</code> is specified on the
               <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on 
               a snapshot of <var>J</var> (see <a href="../xslt-streaming-40/#streamable-merging">10 Streamable Merging</a><sup><small>SG</small></sup>). 
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>This means that <code>position()</code> and <code>last()</code> return 1 (one).
                  This differs from the way <a href="#element-sort"><code>xsl:sort</code></a> keys are evaluated, where
                  <code>position()</code> is the position in the unsorted sequence, and
                  <code>last()</code> is the size of the unsorted sequence.</p>
               </div>
               <p>The effect of the <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements is defined in terms of the
               rules for an equivalent sequence of <a href="#element-sort"><code>xsl:sort</code></a> elements: if the rules
               for sorting (see <a href="#sorting-process"><i>13.1.1 The Sorting Process</i></a>) with <code>stable="yes"</code>
               would place an item <var>A</var> before an item <var>B</var> in the <a title="sorted sequence" class="termref" href="#dt-sorted-sequence">sorted sequence</a> produced by the sorting
               process, then <var>A</var> must precede <var>B</var> in the input sequence to the
               merging process.</p>
               <p>The merge keys of the various input sequences to a merge operation must be compatible
               with each other, since the merge operation will decide the ordering of the result
               sequence by comparing merge key values across input sequences. This means that across
               all the <a href="#element-merge-source"><code>xsl:merge-source</code></a> children of an <a href="#element-merge"><code>xsl:merge</code></a>
               instruction:</p>
               <ul>
                  <li>
                     <p>Each <a href="#element-merge-source"><code>xsl:merge-source</code></a> element <span class="verb">must</span> have the
                     same number of <a href="#element-merge-key"><code>xsl:merge-key</code></a> child elements; let this number
                     be <var>N</var>.</p>
                  </li>
                  <li>
                     <p>For each integer <var>J</var> in 1..<var>N</var>, consider the set <var>S</var> of
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements that are in position <var>J</var>
                     among the <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of their parent
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> element. 
                     For each attribute <var>A</var> in the set <code>lang</code>, <code>order</code>, <code>collation</code>,
                     <code>case-order</code>, and <code>data-type</code> it must be the case that for
                     any two elements <var>s1</var> and <var>s2</var> in <var>S</var>, the
                     <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of attribute <var>A</var> on <var>s1</var>
                     is the same as the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of attribute <var>A</var> on <var>s2</var>,
                     where two attributes are said to have the same effective value if either (a) both attributes
                     are absent, or (b) both attributes are present and the results of evaluating them 
                     (they are attribute value templates) are codepoint-equal. Furthermore, in the case
                     of the <code>collation</code> attribute, the absolute collation URI must be the same
                     after resolving against the base URI.</p>
                  </li>
               </ul>
               <p>If any of the attributes <code>lang</code>, <code>order</code>,
                  <code>collation</code>, <code>case-order</code>, or <code>data-type</code> are
                  <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value templates</a>,
               then their <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> are evaluated
               using the <a title="focus" class="termref" href="#dt-focus">focus</a> of the containing
                  <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p>
               <p>
               <a id="err-XTSE2200"><span class="error">[ERR XTSE2200] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the number of
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of a
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is not equal to the number of
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of another
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the same
                        <a href="#element-merge"><code>xsl:merge</code></a> instruction.
            </p>
               <p>
               <a id="err-XTDE2210"><span class="error">[ERR XTDE2210] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                        error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements
                     that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a>
                     children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that
                     have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for
                     any of the attributes <code>lang</code>, <code>order</code>,
                        <code>collation</code>, <code>case-order</code>, or <code>data-type</code>.
                     Values are considered to differ if  
                     they have different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a>. 
                     In the case of the <code>collation</code> attribute, the values are
                     compared as absolute URIs after resolving against the base URI. The error
                        <span class="verb">may</span> be raised statically if it is detected
                     statically.
            </p>
               <p>
               <a id="err-XTDE2220"><span class="error">[ERR XTDE2220] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if any input
                     sequence to an <a href="#element-merge"><code>xsl:merge</code></a> instruction contains two items that
                     are not correctly sorted according to the merge key values defined on the
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the corresponding
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, when compared using the collation
                     rules defined by the attributes of the corresponding
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a>
                     instruction, unless the attribute <code>sort-before-merge</code> is present
                     with the value <code>yes</code>.
            </p>
               <p>
               <a id="err-XTTE2230"><span class="error">[ERR XTTE2230] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if some item selected
                     by a particular merge key in one input sequence is not comparable using the
                     XPath <code>le</code> operator with the corresponding item selected by the corresponding
                     sort key in another input sequence.
            </p>
            </div>
            <div class="div2">
               
               <h3><a id="current-merge-group-and-key"></a>15.5 <a href="#current-merge-group-and-key" style="text-decoration: none">The Current Merge Group and Key</a></h3>
               <p>During processing of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, two additional values
               are available within the dynamic context:</p>
               <ul>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-merge-group" title="current merge group"></a>The
                           <b>current merge group</b> is a map. During
                        evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of
                        items with equal <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge
                           key values</a> is processed, the current merge group is set to a
                        map whose keys are the names of the various merge sources, and whose
                        associated values are the items from each merge source having the relevant
                        composite merge key value.<span class="definition">]</span></p>
                  </li>
                  <li>
                     <p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-merge-key" title="current merge key"></a>The <b>current
                           merge key</b> is a an array, whose members are sequences of atomic items.
                     There is one member in the array for each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element
                     in the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>.
                     During evaluation of an
                           <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal
                           <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key
                           values</a> is processed, the current merge key is set to the
                        combined merge key value that these items have in common.<span class="definition">]</span></p>
                  </li>
               </ul>
               <p>These values are made available through the functions
                  <a href="#func-current-merge-group"><code>current-merge-group</code></a>, <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> and
                  <a href="#func-current-merge-key"><code>current-merge-key</code></a>.</p>
               <p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> are available within the sequence
            constructor contained by an <a href="#element-merge-action"><code>xsl:merge-action</code></a> element. The values are initially
            <a title="absent" class="termref" href="#dt-absent">absent</a> during the evaluation of global variables and stylesheet parameters,
            during the evaluation of the <code>use</code> attribute or contained sequence constructor of
            <a href="#element-key"><code>xsl:key</code></a>, and during the evaluation of the <code>initial-value</code> attribute of
            <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> attribute of contained sequence constructor of
            <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>. All <a title="invocation construct" class="termref" href="#dt-invocation-construct">invocation constructs</a>
               set the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> to <a title="absent" class="termref" href="#dt-absent">absent</a>. </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Taken together, these rules mean that any invocation of
            <a href="#func-current-merge-group"><code>current-merge-group</code></a>, <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a>, 
               or <a href="#func-current-merge-key"><code>current-merge-key</code></a> that is not lexically scoped by an
            <a href="#element-merge-action"><code>xsl:merge-action</code></a> element will raise a dynamic error.</p>
               </div>
               <p>When an inner <a href="#element-merge"><code>xsl:merge</code></a> instruction is lexically nested within the
            <a href="#element-merge-action"><code>xsl:merge-action</code></a> element of an outer <a href="#element-merge"><code>xsl:merge</code></a> instruction, any use of
            <a href="#func-current-merge-group"><code>current-merge-group</code></a> or <a href="#func-current-merge-key"><code>current-merge-key</code></a> that appears within the
            <a href="#element-merge-action"><code>xsl:merge-action</code></a> of the inner <a href="#element-merge"><code>xsl:merge</code></a> instruction is a reference to the
               <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> or <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> of the inner
               <a href="#element-merge"><code>xsl:merge</code></a> instruction, while any such
            reference that appears within the outer <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, but not
               within the inner <a href="#element-merge-action"><code>xsl:merge-action</code></a>, is a reference to the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> or <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>
             of the outer <a href="#element-merge"><code>xsl:merge</code></a> instruction. This means, for example, that a
            reference to the current merge group of the outer <a href="#element-merge"><code>xsl:merge</code></a> can appear in the
            <code>select</code> attribute of an <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the inner <a href="#element-merge"><code>xsl:merge</code></a>.</p>
               <p>On completion of the evaluation of the <a href="#element-merge-action"><code>xsl:merge-action</code></a> sequence constructor, 
               the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a>
               and <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> revert to their previous values.</p>
               <div class="div3">
                  
                  <h4><a id="func-current-merge-group"></a>15.5.1 <a href="#func-current-merge-group" style="text-decoration: none">fn:current-merge-group</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-current-merge-key-array">next</a> | <a href="#merging">previous</a>)</p>
                     <ol>
                        <li>
                           <p>In XSLT 4.0, the function item <code>current-merge-group</code> retains the value of the current
         merge-key within its captured context.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the group of items currently being processed by an <a href="#element-merge"><code>xsl:merge</code></a>
            instruction.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:current-merge-group</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$source</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">xs:string?</code></td>
                                 <td><code class="assign">:=&nbsp;</code><code>()</code></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>item()*</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> is bound during evaluation of the
               <a href="#element-merge-action"><code>xsl:merge-action</code></a> child of an <a href="#element-merge"><code>xsl:merge</code></a> instruction. 
            If no <a href="#element-merge-action"><code>xsl:merge-action</code></a> is being
            evaluated, then the current merge group is <a title="absent" class="termref" href="#dt-absent">absent</a>, in which case the
            function raises a dynamic error (see below).</p>
                        <p>The <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> (if not absent) is a map. 
            It contains the set of items, from all merge inputs, that share a common value for
            the merge key. This is structured as a map so that the items from each merge source can
            be identified. The key in the map is the value of the <code>name</code> attribute of the
            corresponding <a href="#element-merge-source"><code>xsl:merge-source</code></a> element (or an invented name, in its
            absence), and the associated value is the set of items contributed by that merge
            group.</p>
                        <p>The map itself is not made visible, but this function returns values derived from the
            map. Specifically, if the map is denoted by <var>$G</var>:</p>
                        <ul>
                           <li>
                              <p><span>If <code>$source</code> is supplied
               and is non-empty, the</span> function returns the value of the expression
                     <code>if (map:contains($source)) then $G($source) else error()</code>.
                  Informally, if there is an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element whose
                     <code>name</code> attribute matches <code>$source</code>, the function returns
                  the items in the current merge group that are contributed by this merge source;
                  otherwise it raises a dynamic error (see below).</p>
                           </li>
                           <li>
                              <p><span>Otherwise (when <code>$source</code> is absent or empty)</span>
                  the function returns the value of the expression
                     <code>sort(map:keys($G))!$G(.)</code>, where the <code>sort()</code> function
                  sorts the names of <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements into the document
                  order of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements in the stylesheet.
                  Informally, it returns all the items in the current merge group regardless of
                  which merge source they derive from.</p>
                           </li>
                        </ul>
                        <p>Within the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a>, the ordering of items from the input
            sequences is as follows, in major-to-minor order:</p>
                        <ul>
                           <li>
                              <p>Items are first ordered by the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element that
                  defined the input sequence from which the item was taken; items from
                     <a href="#element-merge-source"><code>xsl:merge-source</code></a>
                  <var>A</var> precede items from <a href="#element-merge-source"><code>xsl:merge-source</code></a>
                  <var>B</var> if <var>A</var> precedes <var>B</var> in document order within the
                  stylesheet.</p>
                           </li>
                           <li>
                              <p>Items from different input sequences selected by the same
                     <a href="#element-merge-source"><code>xsl:merge-source</code></a> element are then ordered based on the order
                  of the anchor items in the sequence selected by evaluating the <code>select</code>
                  attribute of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element.</p>
                           </li>
                           <li>
                              <p>Finally, duplicate items from the same input sequence retain their order from the
                  input sequence.</p>
                           </li>
                        </ul>
                        <p>Duplicates are not eliminated: for example, if the same node is
            selected in more than one input sequence, it may appear twice in the current 
            merge group.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTSE3470"><span class="error">[ERR XTSE3470] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.
         </p>
                        <p>
            <a id="err-XTDE3480"><span class="error">[ERR XTDE3480] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used when the current
                  merge group is <a title="absent" class="termref" href="#dt-absent">absent</a>. The error
                     <span class="verb">may</span> be reported statically if it can be detected
                  statically.
         </p>
                        <p>
            <a id="err-XTDE3490"><span class="error">[ERR XTDE3490] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <code>$source</code> argument of the <a href="#func-current-merge-group"><code>current-merge-group</code></a>
                  function <span>(when supplied)</span>
                  does not match the <code>name</code> attribute of any
                     <a href="#element-merge-source"><code>xsl:merge-source</code></a> element for the current merge operation. The
                  error <span class="verb">may</span> be reported statically if it can be detected
                  statically.
         </p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>Because the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge group</a> is cleared by function calls and
            template calls, the <a href="#func-current-merge-group"><code>current-merge-group</code></a> function only has useful
            effect when the call appears as a descendant of an <a href="#element-merge-action"><code>xsl:merge-action</code></a>
            element.</p>
                           <p>If an <a href="#element-merge-source"><code>xsl:merge-source</code></a> element has no <code>name</code> attribute, then
            it is not possible to discover the items in the current merge group that derive
            specifically from that source, but these items will still be present in the current
            merge group, and will be included in the result when the function is called with no
            arguments.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-current-merge-key-array"></a>15.5.2 <a href="#func-current-merge-key-array" style="text-decoration: none">fn:current-merge-key-array</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-current-merge-key">next</a> | <a href="#func-current-merge-group">previous</a>)</p>
                     <ol>
                        <li>
                           <p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1684">1684</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1689">1689</a>&nbsp;14 January 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the merge key of the 
            merge group currently being processed using the
               <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:current-merge-key-array</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">array(xs:anyAtomicType*)</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The evaluation context for XPath <a title="expression" class="termref" href="#dt-expression">expressions</a>
            includes a component called the <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a>, which is an
            array whose members are sequence of atomic items. 
            The current merge key is the <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a> shared in common by all
            the items within the <a title="current merge group" class="termref" href="#dt-current-merge-group">current merge
            group</a>. </p>
                        <p>The function <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> returns the 
            <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> as an array.</p>
                        <p>While the <a href="#element-merge-action"><code>xsl:merge-action</code></a> child of an 
            <a href="#element-merge"><code>xsl:merge</code></a> instruction is being evaluated, the 
            <a title="current merge key" class="termref" href="#dt-current-merge-key">current merge key</a> will be an array with one member
            for each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element, where the value 
            of that member is the result of evaluating and atomizing the
            <code>select</code> expression, or the contained sequence constructor,
            or the context item, as appropriate.</p>
                        <p>At other times, the current merge key will be <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
                        <p>The <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">merge keys</a> of
               all items in a group are not necessarily identical. For example, one might be an
                  <code>xs:float</code> while another is a numerically equal
            <code>xs:decimal</code>. The <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a>
            function returns the combined merge key of the 
            first item in the group, after atomization and
            casting of <code>xs:untypedAtomic</code> items to <code>xs:string</code>.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTSE3500"><span class="error">[ERR XTSE3500] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> or
                  <a href="#func-current-merge-key"><code>current-merge-key</code></a> function 
                  is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.
         </p>
                        <p>
            <a id="err-XTDE3510"><span class="error">[ERR XTDE3510] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> or 
                  <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used when the current
                  merge key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked
                  in the course of evaluating a pattern. The error <span class="verb">may</span> be
                  reported statically if it can be detected statically.
         </p>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-current-merge-key"></a>15.5.3 <a href="#func-current-merge-key" style="text-decoration: none">fn:current-merge-key</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#analyze-string">next</a> | <a href="#func-current-merge-key-array">previous</a>)</p>
                     <ol>
                        <li>
                           <p>In XSLT 4.0, the function item <code>current-merge-key#0</code> retains the value of the current
         group within its captured context.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the merge key of the 
            merge group currently being processed using the
               <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:current-merge-key</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:anyAtomicType*</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The function returns the result of the expression
         <code>current-merge-key-array()?*</code>, that is, the result
         of flattening the contents of the current merge key into
         a sequence of atomic items.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>The same error conditions apply as for the <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a>
         function.</p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>This function is retained from XSLT 3.0 both for backwards compatibility,
            and for convenience. It is useful in the common case where there is a single
            merge key whose value is a single atomic item; it is also usable if there
            are multiple merge keys whose values are single atomic items. In the general
         case where there are multiple merge keys each of which may contain zero or more
         atomic items, the function <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a>
         is needed.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="merge-action"></a>15.6 <a href="#merge-action" style="text-decoration: none">The <code>xsl:merge-action</code> Element</a></h3>
               <p>The <a href="#element-merge-action"><code>xsl:merge-action</code></a> child of an <a href="#element-merge"><code>xsl:merge</code></a>
               instruction defines the processing to be applied for each distinct 
               <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a> found in the input sequences to the
                  <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p>
               <p class="element-syntax"><a id="element-merge-action"></a><code>&lt;xsl:merge-action&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-action&gt;</code></p>
               <p>The merge key values for each item in an input sequence are calculated based on the
               corresponding <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements, in the same way as <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> are calculated using a sequence
               of <a href="#element-sort"><code>xsl:sort</code></a> elements (see <a href="#sorting-process"><i>13.1.1 The Sorting Process</i></a>). If
               several items from the same or from different input sequences have the same values
               for all their merge keys (comparing pairwise), then they are considered to form a
               group. The sequence constructor contained in the <a href="#element-merge-action"><code>xsl:merge-action</code></a>
               element is evaluated once for each such group of items, and the result of the
                  <a href="#element-merge"><code>xsl:merge</code></a> instruction is the concatenation of the results
               obtained by processing each group in turn.</p>
               <p>The groups are processed one by one, based on the values of
                  the merge keys for the group. If group <var>G</var> has a set of merge
               key values <var>M</var>, while group <var>H</var> has a set of merge key values
                  <var>N</var>, then in the result of the <a href="#element-merge"><code>xsl:merge</code></a> instruction,
               the result of processing group <var>G</var> will precede the result of processing
                  <var>H</var> if and only if <var>M</var> precedes <var>N</var> in the sort order
               defined by the <code>lang</code>, <code>order</code>, <code>collation</code>,
                  <code>case-order</code>, and <code>data-type</code> attributes of the merge key
               definitions.</p>
               <p><span>Comparison of merge key values follows the rules for 
               <a href="#element-sort"><code>xsl:sort</code></a> given in <a href="#comparing-sort-keys"><i>13.1.2 Comparing Sort Key Values</i></a>. 
               This means that except for special cases such as empty sequences and <code>NaN</code></span>, 
               two sets of merge key values are distinct if any corresponding items in
               the two sets of values do not compare equal under the rules for the XPath
                  <code>eq</code> operator, under the collating rules for the corresponding merge
               key definition. In rare cases, when considering more than two sets of merge key
               values, ambiguities may arise because of the non-transitivity of the <code>eq</code>
               operator when applied across different numeric types. In this situation, the
               partitioning of items into sets having distinct key values is handled in the same way
               as for <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (see <a href="#non-transitivity"><i>14.5 Non-Transitivity</i></a>),
               and is to some extent <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. 
            
            </p>
               <p>The <a title="focus" class="termref" href="#dt-focus">focus</a> for evaluation of the sequence
               constructor contained in the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element is as
               follows:</p>
               <ul>
                  <li>
                     <p>The <a title="context item" class="termref" href="#dt-context-item">context item</a> is the first item in
                     the group being processed, that is
                           <code>current-merge-group()[1]</code></p>
                  </li>
                  <li>
                     <p>The <a title="context position" class="termref" href="#dt-context-position">context position</a> is the
                     position of the current group within the sequence of groups (so the first
                     evaluation of <a href="#element-merge-action"><code>xsl:merge-action</code></a> has <code>position()=1</code>,
                     the second has <code>position()=2</code>, and so on).</p>
                  </li>
                  <li>
                     <p>The <a title="context size" class="termref" href="#dt-context-size">context size</a> is as follows:</p>
                     <ul>
                        <li>
                           <p>If any of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements within the <a href="#element-merge"><code>xsl:merge</code></a> instruction specifies 
                        <code>streamable="yes"</code> (explicitly or implicitly), then absent.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>This means that within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> of a streamable <a href="#element-merge"><code>xsl:merge</code></a>, 
                           calling <code>last()</code> raises error <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.</p>
                           </div>
                        </li>
                        <li>
                           <p>Otherwise, the number of groups, that is, the number of distinct sets of merge key values.
                        </p>
                        </li>
                     </ul>
                  </li>
               </ul>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e42659"></a>Example: Selective Processing of Merge Inputs</div>
                  <p>Consider a situation where there are two merge sources, named <code>"master"</code> and
                  <code>"update"</code>; the master source identifies a single merge input file (the master
                  file), while the update source identifies a set of <var>N</var> update files,
                  perhaps one for each day of the week. The required logic is that if a merge key is
                  present only in the master file, then the corresponding item should be copied to
                  the output; if it is present in a single update file then that item replaces the
                  corresponding item from the master file; if it is present in several update files,
                  then an error is raised. This can be achieved as follows:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    for-each-source="'master.xml'"
                    streamable="yes"
                    select="/events/event"&gt;
      &lt;xsl:merge-key select="@key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates" 
                    for-each-source="uri-collection('updates')"
                    streamable="yes"
                    select="/events/event-change"&gt;
      &lt;xsl:merge-key select="@affected-key"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('master'))"&gt;
        &lt;xsl:message&gt;
           Error: update is present with no matching master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="current-merge-group('master')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="count(current-merge-group('updates')) = 1"&gt;
        &lt;xsl:copy-of select="current-merge-group('updates')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:otherwise&gt;
        &lt;xsl:message&gt;
           Conflict: multiple updates for the same master record!
        &lt;/xsl:message&gt;
      &lt;/xsl:otherwise&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;</pre>
                  </div>
                  <p>Some words of explanation:</p>
                  <ul>
                     <li>
                        <p>Error messages are produced if there is an update element
                        whose key does not correspond to any element in the master source, or if
                        there is more than one update element corresponding to the same master
                        element.</p>
                     </li>
                     <li>
                        <p>In the absence of errors, if there is a single update
                        element then it is copied to the output; if there is none, then the master
                        element is copied.</p>
                     </li>
                  </ul>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="merge-examples"></a>15.7 <a href="#merge-examples" style="text-decoration: none">Examples of xsl:merge</a></h3>
               <p>Previous sections introduced examples designed to illustrate some specific features
               of the <a href="#element-merge"><code>xsl:merge</code></a> instruction. This section provides some further
               examples to illustrate different ways in which the instruction can be used.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e42685"></a>Example: Applying Transactions to a Master File</div>
                  <p>This example applies transactions from a transaction file to a master file.
                  Records in the master file for which there is no corresponding transaction are
                  copied unchanged. The transaction file contains instructions to delete, replace,
                  or insert records identified by an ID value. The master file is known to be sorted
                  on the ID value; the transaction file is unsorted.</p>
                  <p>Master file document structure:</p>
                  <div class="exampleInner">
                     <pre>&lt;data&gt;
  &lt;record ID="A0001"&gt;...&lt;/record&gt;
  &lt;record ID="A0002"&gt;...&lt;/record&gt;
  &lt;record ID="A0003"&gt;...&lt;/record&gt;
&lt;/data&gt;</pre>
                  </div>
                  <p>Transaction file document structure:</p>
                  <div class="exampleInner">
                     <pre>&lt;transactions&gt;
  &lt;update record="A0004" action="insert"&gt;...&lt;/update&gt;
  &lt;update record="A0002" action="delete"/&gt;
  &lt;update record="A0003" action="replace"&gt;...&lt;/update&gt;
&lt;/transactions&gt;</pre>
                  </div>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>
 &lt;xsl:merge&gt;
  &lt;xsl:merge-source name="master" 
                    select="doc('master.xml')/data/record"&gt;
      &lt;xsl:merge-key select="@ID"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source name="updates"
                    sort-before-merge="yes"
                    select="doc('transactions.xml')/transactions/update"&gt;     
      &lt;xsl:merge-key select="@record"/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:choose&gt;
      &lt;xsl:when test="empty(current-merge-group('updates'))"&gt;
        &lt;xsl:copy-of select="current-merge-group('master')"/&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action=('insert', 'replace')"&gt;
        &lt;record ID="{current-merge-key()}"&gt;
          &lt;xsl:copy-of select="current-merge-group('updates')/*"/&gt;
        &lt;/record&gt;
      &lt;/xsl:when&gt;
      &lt;xsl:when test="current-merge-group('updates')/@action='delete'"/&gt;
    &lt;/xsl:choose&gt;
  &lt;/xsl:merge-action&gt;
  &lt;/xsl:merge&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e42697"></a>Example: Merging Two Sequences of Numbers</div>
                  <p>The <a href="#element-merge"><code>xsl:merge</code></a> instruction can be used to determine the union,
                  intersection, or difference of two sequences of numbers (or other atomic items).
                  This code gives the union:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:sequence select="current-merge-key()"/&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;</pre>
                  </div>
                  <p>While this gives the intersection:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:merge&gt;
  &lt;xsl:merge-source select="1 to 30"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-source select="20 to 40"&gt;
      &lt;xsl:merge-key select="."/&gt;
  &lt;/xsl:merge-source&gt;
  &lt;xsl:merge-action&gt;
    &lt;xsl:if test="count(current-merge-group()) eq 2"&gt;
      &lt;xsl:sequence select="current-merge-key()"/&gt;
    &lt;/xsl:if&gt;
  &lt;/xsl:merge-action&gt;
&lt;/xsl:merge&gt;</pre>
                  </div>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="splitting"></a>16 <a href="#splitting" style="text-decoration: none">Splitting</a></h2>
            <p>Sometimes it is convenient to be able to compute multiple results during a single scan
            of the input data. For example, a transformation may wish to rename selected elements,
            and also to output a count of how many elements have been renamed. Traditionally in a
            functional language this means computing two separate functions of the input sequence,
            which (in the absence of sophisticated optimization) will result in the input being
            scanned twice. This is inconsistent with streaming, where the input is only available to
            be scanned once, and it can also lead to poor performance in non-streaming
            applications.</p>
            <p>To meet this requirement, XSLT 3.0 introduces the instruction <a href="#element-fork"><code>xsl:fork</code></a>.
            The content of this instruction is a restricted form
               of
            <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and in a formal
            sense the effect of the instruction is simply to return the result of evaluating the
            sequence constructor. However, the presence of the instruction affects the analysis of
            streamability (see <a href="../xslt-streaming-40/#streamability">3 Streamability Analysis Principles</a><sup><small>SG</small></sup>). In particular, when
               <a href="#element-fork"><code>xsl:fork</code></a> is used in a context where streaming is required, each
            independent instruction within the sequence constructor must be streamable, but the
            analysis assumes that these instructions can all be evaluated during a single pass of
            the streamed input document.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>The semantics of the instruction require a number of result sequences to be computed
               during a single pass of the input. A processor may interpret this as a request to use
               multiple threads. However, implementations using a single thread are feasible, and
               this instruction is not intended primarily as a means for stylesheet authors to
               express their intentions with regard to multi-threaded execution.</p>
            </div>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>Because multiple results are computed during a single pass of the input, and then
               concatenated into a single sequence, this instruction will generally involve some
               buffering of results. The amount of memory used should not exceed that needed to hold
               the results of the instruction. However, within this principle, implementations may
               adopt a variety of strategies for evaluation; for example, there may be cases where
               buffering of the input is more efficient than buffering of output.</p>
               <p>Generally, stylesheet authors indicate that buffering of input is the preferred
               strategy by using the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a>
               functions, and indicate that buffering of output is preferred by using
                  <a href="#element-fork"><code>xsl:fork</code></a>. However, conformant processors are not constrained in
               their choice of evaluation strategies.</p>
            </div>
            <p>The content model of the <a href="#element-fork"><code>xsl:fork</code></a>
            instruction (given that an XSLT 3.0 processor ignores <a href="#element-fallback"><code>xsl:fallback</code></a>)
            takes two possible forms:</p>
            <ol class="enumar">
               <li>
                  <p>A sequence of <a href="#element-sequence"><code>xsl:sequence</code></a> instructions</p>
               </li>
               <li>
                  <p>A single <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction. This will normally use
                  the <code>group-by</code> attribute, because in all other cases the containing
                     <a href="#element-fork"><code>xsl:fork</code></a> instruction has no useful effect.</p>
               </li>
            </ol>
            <p>The first form is appropriate when splitting a single input
            stream into a fixed number of output streams, known statically: for example, one output
            stream for credit transactions, a second for debit transactions. The second form is
            appropriate when the number of output streams depends on the data: for example, one
            output stream for each distinct city name found in the input data.</p>
            <p>The following section describes the <a href="#element-fork"><code>xsl:fork</code></a> instruction more
            formally.</p>
            <div class="div2">
               
               <h3><a id="fork-instruction"></a>16.1 <a href="#fork-instruction" style="text-decoration: none">The <code>xsl:fork</code> Instruction</a></h3>
               <p class="element-syntax"><a id="element-fork"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:fork&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-fallback">xsl:fallback</a>*, ((<a href="#element-sequence">xsl:sequence</a>, <a href="#element-fallback">xsl:fallback</a>*)* | (<a href="#element-for-each-group">xsl:for-each-group</a>, <a href="#element-fallback">xsl:fallback</a>*))) --&gt;<br>&lt;/xsl:fork&gt;</code></p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The content model can be described as follows: there is either a single
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction, or a sequence of zero or more
                     <a href="#element-sequence"><code>xsl:sequence</code></a> instructions; in addition,
                     <a href="#element-fallback"><code>xsl:fallback</code></a> instructions may be added anywhere.</p>
               </div>
               <p>The result of the <a href="#element-fork"><code>xsl:fork</code></a> instruction is the sequence formed by
               concatenating the results of evaluating each of its contained  instructions, in order.
               That is, the result can be determined by treating the content as a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> and evaluating it as
               such.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> children will be ignored by an XSLT 3.0
                  processor.</p>
               </div>
               <p>By using the <a href="#element-fork"><code>xsl:fork</code></a> instruction, the
               stylesheet author is suggesting to the <a title="processor" class="termref" href="#dt-processor">processor</a> that buffering of output is acceptable even though this might
               use unbounded memory and thus violate the normal expectations of streamable
               processing</p>
               <p>The presence of an <a href="#element-fork"><code>xsl:fork</code></a> instruction affects the analysis of
               streamability, as described in <a href="../xslt-streaming-40/#streamability">3 Streamability Analysis Principles</a><sup><small>SG</small></sup>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="splitting-examples"></a>16.2 <a href="#splitting-examples" style="text-decoration: none">Examples of Splitting with Streamed Data</a></h3>
               <p>This section gives examples of how splitting using <a href="#element-fork"><code>xsl:fork</code></a> can be
               used to enable streaming of input documents in cases where several results need to be
               computed during a single pass over the input data.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e42820"></a>Example: Splitting a Transaction File into Credits and Debits</div>
                  <p>Consider a transaction file that contains a sequence of debits and credits:</p>
                  <div class="exampleInner">
                     <pre>&lt;transactions&gt;
  &lt;transaction value="5.60"/&gt;
  &lt;transaction value="11.20"/&gt;
  &lt;transaction value="-3.40"/&gt;
  &lt;transaction value="8.90"/&gt;
  &lt;transaction value="-1.99"/&gt;
&lt;/transactions&gt;</pre>
                  </div>
                  <p>where the requirement is to split this into two separate files containing credits
                  and debits respectively.</p>
                  <p>This can be achieved in <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup> code as
                  follows:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="credits.xml"&gt;
        &lt;credits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value &amp;gt;= 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/credits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:result-document href="debits.xml"&gt;
        &lt;debits&gt;
          &lt;xsl:for-each select="transactions/transaction[@value &amp;lt; 0]"&gt;
            &lt;xsl:copy-of select="."/&gt;
          &lt;/xsl:for-each&gt;
        &lt;/debits&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:source-document&gt;</pre>
                  </div>
                  <p>In the absence of the <a href="#element-fork"><code>xsl:fork</code></a> instruction, this would not be
                  streamable, because the sequence constructor includes two 
                  <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-consuming">consuming</a><sup><small>SG</small></sup> instructions. With the addition of the
                     <a href="#element-fork"><code>xsl:fork</code></a> instruction, however, each
                     <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is allowed to make a downwards
                  selection. </p>
                  <p>One possible implementation model for this is as follows: a single thread reads
                  the source document, and sends parsing events such as start-element and
                  end-element to two other threads, each of which is writing one of the two result
                  documents. Each of these implements the downwards-selecting path expression using
                  a process that waits until the next <code>transaction</code> start-element event
                  is received; when this event is received, the process examines the
                     <code>@value</code> attribute to determine whether or not this transaction is
                  to be copied; if it is, then all events until the matching
                     <code>transaction</code> end-element event are copied to the serializer for the
                  result document; otherwise, these events are discarded.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e42853"></a>Example: Splitting a Transaction File by Customer Account</div>
                  <p>Consider a transaction file that contains a sequence of debits and credits:</p>
                  <div class="exampleInner">
                     <pre>&lt;transactions&gt;
  &lt;transaction value="5.60" account="01826370"/&gt;
  &lt;transaction value="11.20" account="92741838"/&gt;
  &lt;transaction value="-3.40" account="01826370"/&gt;
  &lt;transaction value="8.90" account="92741838"/&gt;
  &lt;transaction value="-1.99" account="43861562"/&gt;
&lt;/transactions&gt;</pre>
                  </div>
                  <p>where the requirement is to split this into a number of separate files, one for
                  each account number found in the input.</p>
                  <p>This can be achieved in <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup> code as
                  follows:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:source-document streamable="yes" href="transactions.xml"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:for-each-group select="transactions/transaction" group-by="@account"&gt;
      &lt;xsl:result-document href="account{current-grouping-key()}.xml"&gt;
        &lt;transactions account="{current-grouping-key()}"&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/transactions&gt;
      &lt;/xsl:result-document&gt;
    &lt;/xsl:for-each-group&gt;
  &lt;/xsl:fork&gt;
&lt;/xsl:source-document&gt;</pre>
                  </div>
                  <p>In the absence of the <a href="#element-fork"><code>xsl:fork</code></a> instruction, this would not be
                  streamable, because in the general case the output of
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> with a <code>group-by</code> attribute
                  needs to be buffered. (The streamability rules do not recognize an
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> whose body comprises an
                     <a href="#element-result-document"><code>xsl:result-document</code></a> instruction as a special case.) With the
                  addition of the <a href="#element-fork"><code>xsl:fork</code></a> instruction, however, the code becomes
                  guaranteed streamable. </p>
                  <p>One possible implementation model for this is as follows: the processor opens a
                  new serializer each time a new account number is encountered in the input, and
                  writes the <code>&lt;transactions&gt;</code> start tag to the serializer. When a
                     <code>transaction</code> element is encountered in the input, it is copied to
                  the relevant serializer, according to the value of the <code>account</code>
                  attribute. At the end of the input, a <code>&lt;transactions&gt;</code> end tag is
                  written to each of the serializers, and each output file is closed.</p>
                  <p>In the more general case, where the body of the
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction contributes output to the
                  principal result document, the output generated by processing each group needs to
                  be buffered in memory. The requirement to use <a href="#element-fork"><code>xsl:fork</code></a> exists so
                  that this use of (potentially unbounded) memory has to be a conscious decision by
                  the stylesheet author.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e42901"></a>Example: Arithmetic using Multiple Child Elements as Operands</div>
                  <p>The rules for streamability do not allow two instructions in a sequence
                  constructor to both read child or descendant elements of the context node, which
                  makes it tricky to perform a calculation in which multiple child elements act as
                  operands. This restriction can be avoided by using <a href="#element-fork"><code>xsl:fork</code></a>, as
                  shown below, where each of the two branches of the <a href="#element-fork"><code>xsl:fork</code></a>
                  instruction selects children of the context node.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:template match="order" mode="a-streamable-mode"&gt;                  
  &lt;xsl:variable name="price-and-discount" as="xs:decimal+"&gt;
    &lt;xsl:fork&gt;
      &lt;xsl:sequence select="xs:decimal(price)"/&gt;
      &lt;xsl:sequence select="xs:decimal(discount)"/&gt;
    &lt;/xsl:fork&gt;
  &lt;/xsl:variable&gt;
  &lt;xsl:value-of select="$price-and-discount[1] - $price-and-discount[2]"/&gt;
  &lt;/xsl:template&gt;</pre>
                  </div>
                  <p>A possible implementation strategy here is for events from the XML parser to be
                  sent to two separate agents (perhaps but not necessarily running in different
                  threads), one of which computes <code>xs:decimal(price)</code> and the other
                     <code>xs:decimal(discount)</code>; on completion the results computed by the
                  two agents are appended to the sequence that forms the value of the variable.</p>
                  <p>With this strategy, the processor would require sufficient memory to hold the
                  results of evaluating each branch of the fork. If these results (unlike this
                  example) are large, this could defeat the purpose of streaming by requiring large
                  amounts of memory; nevertheless, this code is treated as streamable.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>An alternative solution to this requirement is to use map constructors: see
                        <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-map-constructors">4.15.1.1 Map Constructors</a>.</p>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e42925"></a>Example: Deleting Elements, and Counting Deletions</div>
                  <p>In this example the input is a narrative document containing <code>note</code>
                  elements at any level of nesting. The requirement is to output a copy of the input
                  document in which (a) the <code>note</code> elements have been removed, and (b) a
                     <code>footnote</code> is added at the end indicating how many <code>note</code>
                  elements have been deleted.</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:mode on-no-match="shallow-copy" streamable="yes"/&gt;

&lt;xsl:template match="note"/&gt;

&lt;xsl:template match="/*"&gt;
  &lt;xsl:fork&gt;
    &lt;xsl:sequence&gt;
      &lt;xsl:apply-templates/&gt;
    &lt;/xsl:sequence&gt;
    &lt;xsl:sequence&gt;
      &lt;footnote&gt;
        &lt;p&gt;Removed &lt;xsl:value-of select="count(.//note)"/&gt; 
                 note elements.&lt;/p&gt;
      &lt;/footnote&gt;
    &lt;/xsl:sequence&gt;  
  &lt;/xsl:fork&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
                  <p>The <a href="#element-fork"><code>xsl:fork</code></a> instruction contains two independent branches. These
                  can therefore be evaluated in the same pass over the input data. The first branch
                  (the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction) causes everything except
                  the <code>note</code> elements to be copied to the result; the second instruction
                  (the literal result element <code>footnote</code>) outputs a count of the number
                  of descendant <code>note</code> elements.</p>
                  <p>Note that although the processing makes a single pass over the input stream, there
                  is some buffering of results required, because the results of the instructions
                  within the <a href="#element-fork"><code>xsl:fork</code></a> instruction need to be concatenated. In this
                  case an intelligent implementation might be able to restrict the buffered data to
                  a single integer.</p>
                  <p>In a formal sense, however, the result is exactly the same as if the
                     <a href="#element-fork"><code>xsl:fork</code></a> element were not there.</p>
                  <p>An alternative way of solving this example problem would be to
                  count the number of <code>note</code> elements using an accumulator: see <a href="#accumulators"><i>19 Accumulators</i></a>.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="regular-expressions"></a>17 <a href="#regular-expressions" style="text-decoration: none">Regular Expressions</a></h2>
            <p>The function library for XPath 3.0
            defines several functions that make use of
            regular expressions:</p>
            <ul>
               <li>
                  <p>
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-matches"><code>matches</code></a> returns a boolean result that indicates whether or
                  not a string matches a given regular expression.</p>
               </li>
               <li>
                  <p>
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-replace"><code>replace</code></a> takes a string as input and returns a string
                  obtained by replacing all substrings that match a given regular expression with a
                  replacement string.</p>
               </li>
               <li>
                  <p>
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>tokenize</code></a> returns a sequence of strings formed by breaking a
                  supplied input string at any separator that matches a given regular
                  expression.</p>
               </li>
               <li>
                  <p>
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a> returns a tree of nodes that effectively add
                  markup to a string indicating the parts of the string that matched the regular
                  expression, as well as its captured groups.</p>
               </li>
            </ul>
            <p>These functions are described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p>
            <p>Supplementing these functions, XSLT provides
            an instruction <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>, which is defined in this
            section.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction predates the
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-analyze-string"><code>analyze-string</code></a> function, and provides very similar
               functionality, though in a different way.</p>
            </div>
            <p>The regular expressions used by this instruction, and the flags that control the
            interpretation of these regular expressions, <span class="verb">must</span> conform to the
            syntax defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> (see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#regex-syntax">6.1 Regular expression syntax</a>), 
            which is itself based on the syntax defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p>
            <p>As described in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#regex-syntax">6.1 Regular expression syntax</a>, the effect of processing a string
         using a regular expression is a sequence of non-overlapping matching segments, each of which is
         associated with a set of captured groups, represented as a map from a group number to a segment
         of the input string. The term <b>segment</b> here means a contiguous (and possibly empty)
         subsequence of characters from the input string, characterized by a starting position and ending
         position within that string.</p>
            <div class="div2">
               
               <h3><a id="analyze-string"></a>17.1 <a href="#analyze-string" style="text-decoration: none">The <code>xsl:analyze-string</code> Instruction</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-regex-groups">next</a> | <a href="#func-current-merge-key">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
                  elements within <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> may now take a <code>select</code> attribute
                  in place of a contained sequence constructor.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/443">443</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/489">489</a>&nbsp;16 May 2023]</i></p>
                     </li>
                     <li>
                        <p>
                  The rules for <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> have been adjusted to allow for new capabilities in regular expressions, such as
                  zero-width assertions.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/998">998</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1856">1856</a>&nbsp;18 March 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-analyze-string"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:analyze-string<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;<b>regex</b> = { <var>string</var> }<br>&nbsp;&nbsp;flags? = { <var>string</var> }〔''〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-matching-substring">xsl:matching-substring</a>?, <a href="#element-non-matching-substring">xsl:non-matching-substring</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:analyze-string&gt;</code></p>
               <p class="element-syntax"><a id="element-matching-substring"></a><code>&lt;xsl:matching-substring<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:matching-substring&gt;</code></p>
               <p class="element-syntax"><a id="element-non-matching-substring"></a><code>&lt;xsl:non-matching-substring<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:non-matching-substring&gt;</code></p>
               <p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction takes as input a string (the
               result of evaluating the expression in the <code>select</code> attribute), a
               regular expression (the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>regex</code> attribute),
            and a set of flags.</p>
               <p>If the result of evaluating the <code>select</code> expression is the empty sequence, 
               it is treated as a zero-length string.
                  If the value is not a string, it is converted to a string by applying the
                  <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>.</p>
               <p>The <code>flags</code> attribute may be used to control the interpretation of the
               regular expression. If the attribute is omitted, the effect is the same as supplying
               a zero-length string. This is interpreted in the same way as the <code>$flags</code>
               attribute of the functions <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-matches"><code>matches</code></a>,
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-replace"><code>replace</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-tokenize"><code>tokenize</code></a>. Specifically,
               if it contains the letter <code>m</code>, the match operates in multiline mode. If it
               contains the letter <code>s</code>, it operates in dot-all mode. If it contains the
               letter <code>i</code>, it operates in case-insensitive mode. If it contains the
               letter <code>x</code>, then whitespace within the regular expression is ignored. For
               more detailed specifications of these modes, see <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>
                  (<a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#flags">6.2 Flags</a>).</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Because the <code>regex</code> attribute is an attribute value template, curly
                  brackets within the regular expression must be doubled. For example, to match a
                  sequence of one to five characters, write <code>regex=".{{1,5}}"</code>. For
                  regular expressions containing many curly brackets it may be more convenient to
                  use a notation such as <code>regex="{'[0-9]{1,5}[a-z]{3}[0-9]{1,2}'}"</code>, or
                  to use a variable:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="regex" 
               expand-text="no"&gt;[0-9]{1,5}[a-z]{3}[0-9]{1,2}&lt;/xsl:variable&gt;
&lt;xsl:analyze-string regex="{$regex}"....</pre>
                  </div>
               </div>
               <p>The <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction may have two child elements:
                  <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and
                  <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>. Both elements are optional, and
               neither may appear more than once. At least one of them must be present. If both are
               present, the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> element must come first.</p>
               <p>The content of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction must take one of
               the following forms:</p>
               <ol class="enumar">
                  <li>
                     <p>A single <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction, followed by zero
                     or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p>
                  </li>
                  <li>
                     <p>A single <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction, followed by
                     zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p>
                  </li>
                  <li>
                     <p>A single <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction, followed by a
                     single <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction, followed by
                     zero or more <a href="#element-fallback"><code>xsl:fallback</code></a> instructions</p>
                  </li>
               </ol>
               <p>
               <a id="err-XTSE1130"><span class="error">[ERR XTSE1130] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction contains neither an
                        <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> nor an
                        <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element.
            </p>
               <p>Any <a href="#element-fallback"><code>xsl:fallback</code></a> elements among the children of the
                  <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction are ignored by an 
               processor supporting XSLT 2.0 or later, but allow fallback behavior to be
               defined when the stylesheet is used with an XSLT 1.0 processor operating with
               forwards-compatible behavior.</p>
               <p>For the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and
               <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> elements, the <code>select</code> 
               attribute and the contained sequence
               constructor are mutually exclusive <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p>
               <p>This instruction is designed to process all the non-overlapping substrings of the
               input string that match the regular expression supplied: that is,
            the <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-disjoint-matching-segments">disjoint matching segments</a><sup><small>FO</small></sup> that result from
            processing the input string using the supplied regular expression and the supplied flags.</p>
               <p>
               <a id="err-XTDE1140"><span class="error">[ERR XTDE1140] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                     of the <code>regex</code>
                     attribute  does not conform to the
                        <span class="verb">required</span> syntax for regular expressions, as specified in
                        <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the regular expression is known
                     statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then
                     the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. 
            </p>
               <p>
               <a id="err-XTDE1145"><span class="error">[ERR XTDE1145] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>flags</code>
                     attribute  has a value other than the values defined in
                        <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the value of the attribute is known
                     statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then
                     the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. 
            </p>
               <p>Processing proceeds as follows.
               Let <var>M</var> be the sequence of 
               <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-disjoint-matching-segments">disjoint matching 
               segments</a><sup><small>FO</small></sup> that results from
            applying the regular expression to the input string, with the given flags, in order of their
            start position. Between any two adjacent matching segments <var>M<sub>1</sub></var> and <var>M<sub>2</sub></var>, 
            if the end position of <var>M<sub>1</sub></var> is not the same as the start position of <var>M<sub>2</sub></var>,
            insert a non-matching segment comprising the characters from the input string between the
            end of <var>M<sub>1</sub></var> and the start of <var>M<sub>2</sub></var>. Similarly, insert a non-matching segment
               at the start of the sequence if the first matching segment is not positioned at the start of the input, 
               and insert a non-matching segment at the end if the last matching segment is not positioned
               at the end of the input. The result is a sequence consisting of matching and non-matching segments,
               that together define a partitioning of the input string.</p>
               <p>The instruction then processes each of these segments in turn. For a matching segment, it evaluates
               the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> child if it exists.
               For a non-matching segment, it evaluates the <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
               if it exists. The child <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> or 
               <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> is evaluated by evaluating its <code>select</code>
               attribute or its contained sequence constructor. The context item for this evaluation
               is the string value of the matching or non-matching segment (as an instance of <code>xs:string</code>); 
               the context position is the
               position of this segment within the sequence of matching and non-matching segments, and
               the context size is the number of segments.</p>
               <p>If the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> or <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
               child is absent, then processing proceeds as if the element were present with empty content
               and no <code>select</code> attribute. That is, the corresponding segment produces no output.</p>
            </div>
            <div class="div2">
               
               <h3><a id="func-regex-group-functions"></a>17.2 <a href="#func-regex-group-functions" style="text-decoration: none">Captured Groups</a></h3>
               <p>Two functions are available for processing the values of captured groups associated
            with a matching segment.</p>
               <p>Examples of the use of these functions can be found in <a href="#regex-examples"><i>17.3 Examples of Regular Expression Matching</i></a>.</p>
               <div class="div3">
                  
                  <h4><a id="func-regex-groups"></a>17.2.1 <a href="#func-regex-groups" style="text-decoration: none">fn:regex-groups</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-regex-group">next</a> | <a href="#analyze-string">previous</a>)</p>
                     <ol>
                        <li>
                           <p>New in 4.0<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2233">2233</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2246">2246</a>&nbsp;18 November 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the set of captured groups associated with a matching segment
            during evaluation of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:regex-groups</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">map(xs:integer, record(value as xs:string, position as xs:integer))</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-current-captured-groups" title="current captured groups"></a>While
               the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active, a set of
                  <b>current captured groups</b> is available, corresponding to the
               capturing subexpressions of the regular expression.<span class="definition">]</span> These captured
            groups are accessible using the <a href="#func-regex-groups"><code>regex-groups</code></a>
            and <a href="#func-regex-group"><code>regex-group</code></a> functions. </p>
                        <p>The <a href="#func-regex-groups"><code>regex-groups</code></a> function returns this information as a map.</p>
                        <p>The <var>N</var>th captured group (where <var>N</var> &gt; 0) is the segment of the input string matched
            by the subexpression contained by the <var>N</var>th left parenthesis in the regex,
               excluding any non-capturing parenthesized expressions. The zeroth captured substring is the segment
               of the input string that matches the entire regex. In both cases, a segment
               is identified by a record containing both the captured string itself (as <code>value</code>)
            and the start position (1-based) of the
               captured group within the input string (as <code>position</code>).</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>This means that the string value of group zero is
            the same as the value of <code>.</code> (dot).</p>
                        </div>
                        <p>The result map contains no entry for a number <var>N</var> if there is no captured group with the
            number <var>N</var>. This can occur for a number of reasons:</p>
                        <ol class="enumar">
                           <li>
                              <p><var>N</var> is negative.</p>
                           </li>
                           <li>
                              <p>The regular expression contains fewer than <var>N</var> capturing subexpressions.</p>
                           </li>
                           <li>
                              <p>The <var>N</var>th capturing subexpression exists, but did not match any part of the input
                  string.</p>
                           </li>
                        </ol>
                        <p>The string value of a captured group may be the empty string.</p>
                        <p>The set of captured groups is a context variable with dynamic scope. It is initially
            an empty sequence. During the evaluation of an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>
            instruction it is set to the sequence of matched segments for that regex match. During
            the evaluation of an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction or a
               <a title="pattern" class="termref" href="#dt-pattern">pattern</a> or a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> it is set to an empty
            sequence. On completion of an instruction that changes the value, the variable reverts
            to its previous value.</p>
                        <p>The value of the <a title="current captured groups" class="termref" href="#dt-current-captured-groups">current captured groups</a> is unaffected through calls of
               <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>,
               <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>, or by
            expansion of named <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a>.</p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The <a href="#func-regex-groups"><code>regex-groups</code></a> function provides additional information that is
         not available via <a href="#func-regex-group"><code>regex-group</code></a>:</p>
                           <ul>
                              <li>
                                 <p>It distinguishes capturing subexpressions that matched an empty string from
            capturing subexpressions that did not match anything.</p>
                              </li>
                              <li>
                                 <p>It identifies not just the string that was captured, but its position within the input.</p>
                              </li>
                           </ul>
                           <p>In 4.0 regular expressions may contain capturing subexpressions within a lookahead. In this
         situation a segment returned in the result of <a href="#func-regex-groups"><code>regex-groups</code></a> may be positioned
         beyond the end of the corresponding matching segment.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-regex-group"></a>17.2.2 <a href="#func-regex-group" style="text-decoration: none">fn:regex-group</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#capturing-accumulators">next</a> | <a href="#func-regex-groups">previous</a>)</p>
                     <ol>
                        <li>
                           <p>In XSLT 4.0, the function item <code>regex-group#1</code> retains the value of the current
         captured substrings within its captured context.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the string captured by a capturing subexpression of the regular expression
            used during evaluation of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:regex-group</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$number</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">xs:integer</code></td>
                                 <td></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:string</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The function <a href="#func-regex-group"><code>regex-group</code></a> is retained for backwards compatibility.
         The function call <code>regex-group(<var>N</var>)</code> returns the result of the
         expression <code>regex-groups()?<var>N</var>?value otherwise ""</code>.</p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The function may return a zero-length string for a number of reasons:</p>
                           <ol class="enumar">
                              <li>
                                 <p><code>$number</code> is negative.</p>
                              </li>
                              <li>
                                 <p>The regular expression does not contain a capturing subexpression with the
                  given number.</p>
                              </li>
                              <li>
                                 <p>The capturing subexpression exists, and did not match any part of the input
                  string.</p>
                              </li>
                              <li>
                                 <p>The capturing subexpression exists, and matched a zero-length substring of
                  the input string.</p>
                              </li>
                           </ol>
                           <p>The set of captured groups is a context variable with dynamic scope. It is initially
            an empty sequence. During the evaluation of an <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>
            instruction it is set to the sequence of matched substrings for that regex match. During
            the evaluation of an <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> instruction or a
               <a title="pattern" class="termref" href="#dt-pattern">pattern</a> or a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> it is set to an empty
            sequence. On completion of an instruction that changes the value, the variable reverts
            to its previous value.</p>
                           <p>The value of the <a title="" class="termref" href="#"></a> is unaffected through calls of
               <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-call-template"><code>xsl:call-template</code></a>,
               <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>, or by
            expansion of named <a title="attribute set" class="termref" href="#dt-attribute-set">attribute sets</a>.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="regex-examples"></a>17.3 <a href="#regex-examples" style="text-decoration: none">Examples of Regular Expression Matching</a></h3>
               <p>The examples in this section assume that the stylesheet specifies <code>expand-text="yes"</code>
            to enable the use of <a title="text value template" class="termref" href="#dt-text-value-template">text value templates</a>.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e43581"></a>Example: Replacing Characters by Elements</div>
                  <p>Task: replace all newline characters in the <code>abstract</code> element by
                  empty <code>br</code> elements:</p>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:analyze-string select="abstract" regex="\n"&gt;
  &lt;xsl:matching-substring&gt;&lt;br/&gt;&lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e43594"></a>Example: Recognizing non-XML Markup Structure</div>
                  <p>Task: replace all occurrences of <code>[...]</code> in the <code>body</code> by
                     <code>cite</code> elements, retaining the content between the square brackets
                  as the content of the new element.</p>
                  <p>Solution:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:analyze-string select="body" regex="\[(.*?)\]"&gt;
  &lt;xsl:matching-substring&gt;
    &lt;cite&gt;{regex-group(1)}&lt;/cite&gt;
  &lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</pre>
                  </div>
                  <p>Note that this simple approach fails if the <code>body</code> element contains
                  markup that needs to be retained. In this case it is necessary to apply the
                  regular expression processing to each text node individually. If the
                     <code>[...]</code> constructs span multiple text nodes (for example, because
                  there are elements within the square brackets) then it probably becomes necessary
                  to make two or more passes over the data.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e43618"></a>Example: Parsing a Date</div>
                  <p>Task: the input string contains a date such as <code>23 March 2002</code>.
                  Convert it to the form <code>2002-03-23</code>.</p>
                  <p>Solution (with no error handling if the input format is incorrect):</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:variable name="months" 
        select="'January', 'February', 'March', ..."/&gt;

&lt;xsl:analyze-string select="normalize-space($input)" 
    regex="([0-9]{{1,2}})\s([A-Z][a-z]+)\s([0-9]{{4}})"&gt;
    &lt;xsl:matching-substring&gt;
        &lt;xsl:number value="regex-group(3)" format="0001"/&gt;;          
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="index-of($months, regex-group(2))" format="01"/&gt;
        &lt;xsl:text&gt;-&lt;/xsl:text&gt;
        &lt;xsl:number value="regex-group(1)" format="01"/&gt;
    &lt;/xsl:matching-substring&gt;
&lt;/xsl:analyze-string&gt;</pre>
                  </div>
                  <p>Note the use of <code>normalize-space</code> to simplify the work done by the
                  regular expression, and the use of doubled curly brackets because the
                     <code>regex</code> attribute is an attribute value template.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e43639"></a>Example: Matching Zero-Length Strings</div>
                  <p>Task: remove all empty and whitespace-only lines from a file.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:analyze-string select="unparsed-text('in.txt')"
                    regex="^[\t ]*$" flags="m"&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e43644"></a>Example: Captured Groups within Lookahead</div>
                  <p>Task: extract a chapter or appendix number from a string such
                  as <code>Chapter 5</code> or <code>Appendix A</code>.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:analyze-string select="(Chapter|Appendix) (?=[A-Z0-9]+)"
                    regex="(Chapter|Appendix)\s+(?=[A-Z0-9]+)"&gt;
  &lt;xsl:matching-substring select="regex-groups()?2?value"/&gt;
&lt;/xsl:analyze-string&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e43656"></a>Example: Converting camelCase to camel-Case</div>
                  <p>Task: insert hyphens at the points in a string marked by
                  transition from lower-case to upper-case.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:analyze-string select="aLongPieceOfString"
                    regex="(?&lt;=[a-z])(?=([A-Z]))"&gt;
  &lt;xsl:matching-substring&gt;-&lt;/xsl:matching-substring&gt;
  &lt;xsl:non-matching-substring&gt;{.}&lt;/xsl:non-matching-substring&gt;
&lt;/xsl:analyze-string&gt;</pre>
                  </div>
                  <p>In this example the matching substrings are zero-length, and these
               zero-length strings are replaced with hyphens. The parts between the
               lower-to-upper case transitions are non-matching substrings, and these
               are output <em>as is</em>. It would be easy, of course, to 
               extend the example to change the leading upper-case letters to lower-case.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e43665"></a>Example: Parsing comma-separated values</div>
                  <p>There are many variants of CSV formats. Some, but not all,
                  are handled by new XPath 4.0 functions such as <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-parse-csv"><code>parse-csv</code></a>.
                  This example is designed to handle input
                  where:</p>
                  <ul>
                     <li>
                        <p>Each record occupies one line.</p>
                     </li>
                     <li>
                        <p>Fields are separated by commas.</p>
                     </li>
                     <li>
                        <p>Quotation marks around a field are optional, unless the field contains a
                        comma or quotation mark, in which case they are mandatory.</p>
                     </li>
                     <li>
                        <p>A quotation mark within the value of a field is represented by a pair of two
                        adjacent quotation marks.</p>
                     </li>
                  </ul>
                  <p>For example, the input record:</p>
                  <div class="exampleInner">
                     <pre>Ten Thousand,10000,,"10,000","It's ""10 Grand"", mister",10K</pre>
                  </div>
                  <p>contains six fields, specifically:</p>
                  <ul>
                     <li>
                        <p>Ten Thousand</p>
                     </li>
                     <li>
                        <p>10000</p>
                     </li>
                     <li>
                        <p>&lt;zero-length-string&gt;</p>
                     </li>
                     <li>
                        <p>10,000</p>
                     </li>
                     <li>
                        <p>It's "10 Grand", mister</p>
                     </li>
                     <li>
                        <p>10K</p>
                     </li>
                  </ul>
                  <p>The following code parses such CSV input into an XML structure containing
                     <code>row</code> and <code>col</code> elements:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:for-each select="unparsed-text-lines('in.csv')" expand-text="yes"&gt;
  &lt;row&gt;
    &lt;xsl:analyze-string select="." 
                        regex='(?:^|,)(?:"((?:[^"]|"")*)"|([^",]*))'&gt;
      &lt;xsl:matching-substring&gt;
        &lt;col&gt;{replace(regex-group(1), '""', '"')||regex-group(2)}&lt;/col&gt;
      &lt;/xsl:matching-substring&gt;
    &lt;/xsl:analyze-string&gt;
  &lt;/row&gt;
&lt;/xsl:for-each&gt;</pre>
                  </div>
                  <p>Note that because this regular expression matches a zero-length string, it is not
                  permitted in XSLT 2.0.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="source-document-instruction"></a>18 <a href="#source-document-instruction" style="text-decoration: none">The <code>xsl:source-document</code> instruction</a></h2>
            <p>The <a href="#element-source-document"><code>xsl:source-document</code></a> instruction was specifically designed to handle streaming;
         it is described here because it is useful whether or not the source document
         is processed using streaming.</p>
            <p class="element-syntax"><a id="element-source-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:source-document<br>&nbsp;&nbsp;<b>href</b> = { <var>uri</var> }<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var>〔''〕<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:source-document&gt;</code></p>
            <p>The <a href="#element-source-document"><code>xsl:source-document</code></a> instruction reads a source document whose URI is
               supplied, and processes the content of the document  by evaluating the
               contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>. 
               The <code>streamable</code> attribute (default <code>"no"</code>)
            allows streamed processing to be requested.</p>
            <p>The document to be read is determined by the <a href="https://qt4cg.org/specifications/xslt-40/#dt-effective-value">effective value</a><sup><small>XT</small></sup> 
               of the <code>href</code> attribute (which is defined as
               an <a href="https://qt4cg.org/specifications/xslt-40/#dt-attribute-value-template">attribute value template</a><sup><small>XT</small></sup>).
                  This <span class="verb">must</span> be a valid URI reference.
                  If it is an absolute URI reference, it is used as is; if it is a relative URI
                  reference, it is made absolute by resolving it against the base URI of the
                     <a href="#element-source-document"><code>xsl:source-document</code></a> element. The process of obtaining a
               document node given a URI is the same as for the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function.
               However, unlike the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function, the
                  <a href="#element-source-document"><code>xsl:source-document</code></a> instruction offers no guarantee that the resulting
               document will be stable (that is, that multiple calls specifying the same URI will
               return the same document).</p>
            <p>Specifically, if an <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is evaluated several
               times (or if different <a href="#element-source-document"><code>xsl:source-document</code></a> instructions are evaluated) with
               the same URI (after making it absolute) as the
               value of the <code>href</code> attribute, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether the
               same nodes or different nodes are returned on each occasion; it is also possible that
               the actual document content will be different. </p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>A different node will necessarily be returned if there
               are differences in attributes such as <code>validation</code>, <code>type</code>,
               <code>streamable</code>, or <code>use-accumulators</code>, or if the calls are in different
               <a title="package" class="termref" href="#dt-package">packages</a> with variations in the rules for whitespace
               stripping or stripping of type annotations.</p>
            </div>
            <p>The result of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction is the same as the result
               of the following (non-streaming) process:</p>
            <ol class="enumar">
               <li>
                  <p>The source document is read from the supplied URI and parsed to form a
                     tree of nodes in the XDM data model.</p>
               </li>
               <li>
                  <p>The contained sequence constructor is evaluated with the root node of this tree
                     as the context item, and with the context
                     position and context size set to one; and the resulting sequence is returned as
                     the result of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction.</p>
               </li>
            </ol>
            <p>The <code>use-accumulators</code> attribute defines the
               set of accumulators that are applicable to the document, as explained in
                  <a href="#applicability-of-accumulators"><i>19.2 Applicability of Accumulators</i></a>.</p>
            <div class="div2">
               
               <h3><a id="source-document-validation"></a>18.1 <a href="#source-document-validation" style="text-decoration: none">Validation of Source Documents</a></h3>
               <p>The <code>validation</code> and <code>type</code> attributes of
                     <a href="#element-source-document"><code>xsl:source-document</code></a> may be used to control schema validation of the
                  input document. They have the same effect as the
                  corresponding attributes of the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction when
                  applied to a document node, except that 
                  when <code>streamable="yes"</code> is specified, 
                  the copy that is produced is itself a
                  streamed document. The process is described in more detail in 
                  section <a href="../xslt-40/#validating-document-nodes">25.4.2 Validating Document Nodes</a>.</p>
               <p>These two attributes are both optional, and if one is specified then the other
                     <span class="verb">must</span> be omitted (<span class="error">[see <a href="#err-XTSE1505">ERR XTSE1505</a>]</span>).</p>
               <p>The presence of a <code>validation</code> or <code>type</code> attribute on an
                     <a href="#element-source-document"><code>xsl:source-document</code></a> instruction causes any
                     <code>input-type-annotations</code> attribute to have no effect on any document
                  read using that instruction.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In effect, setting <code>validation</code> to <code>strict</code> or
                        <code>lax</code>, or supplying the <code>type</code> attribute, requests
                     document-level validation of the input as it is read. Setting
                        <code>validation="preserve"</code> indicates that if the incoming document
                     contains type annotations (for example, produced by validating the output of a
                     previous step in a streaming pipeline) then they should be retained, while the
                     value <code>strip</code> indicates that any such type annotations should be
                     dropped.</p>
                  <p>It is a consequence of the way validation is defined in XSD that the type
                     annotation of an element node can be determined during the processing of its
                     start tag, although the actual validity of the element is not known until the
                     end tag is encountered. When validation is requested, a streamed document
                     should not present data to the stylesheet except to the extent that such data
                     could form the leading part of a valid document. If the document proves to be
                     invalid, the processor should not pass invalid data to the stylesheet to be
                     processed, but should immediately raise the appropriate error. For the
                     purposes of <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a>, this error
                     can only be caught at the level of the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction
                     that initiated validation, not at a finer level. If validation errors are
                     caught in this way, any output that has been computed up to the point of the
                     error is not added to the final result tree; the mechanisms to achieve this may
                     use memory, which may reduce the efficacy of streaming.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="func-stream-available"></a>18.2 <a href="#func-stream-available" style="text-decoration: none">fn:stream-available</a></h3>
               <dl>
                  <dt class="label">Summary</dt>
                  <dd>
                     <p>Determines, as far as possible, whether a document is available for streamed processing using <a href="#element-source-document"><code>xsl:source-document</code></a>.</p>
                  </dd>
                  <dt class="label">Signature</dt>
                  <dd>
                     <div class="proto">
                        <table class="proto" border="0">
                           <tr class="name">
                              <td colspan="3"><code class="function">fn:stream-available</code>(</td>
                           </tr>
                           <tr class="arg">
                              <td><code>$uri</code></td>
                              <td><code class="as">as&nbsp;</code><code class="type">xs:string?</code></td>
                              <td></td>
                           </tr>
                           <tr class="return-type">
                              <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:boolean</code></td>
                           </tr>
                        </table>
                     </div>
                  </dd>
                  <dt class="label">Properties</dt>
                  <dd>
                     <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic">nondeterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>.  It depends on 
		available documents.
	</p>
                  </dd>
                  <dt class="label">Rules</dt>
                  <dd>
                     <p>The intent of the <a href="#func-stream-available"><code>stream-available</code></a> function is to allow a stylesheet author to determine,
            before calling <a href="#element-source-document"><code>xsl:source-document</code></a> with <code>streamable="yes"</code> and 
            with a particular URI as the value of its <code>href</code>
         attribute, whether a document is available at that location for streamed processing.</p>
                     <p>If the <code>$uri</code> argument is an empty sequence then the function returns <code>false</code>.</p>
                     <p>If the function returns <code>true</code> then the caller can conclude that the following conditions are true:</p>
                     <ol class="enumar">
                        <li>
                           <p>The supplied URI is valid;</p>
                        </li>
                        <li>
                           <p>A resource can be retrieved at that URI;</p>
                        </li>
                        <li>
                           <p>An XML representation of the resource can be delivered, which is well-formed at least to the extent
            that some initial sequence of octets can be decoded into characters and matched against the production:</p>
                           <p>
                  <code>prolog (EmptyElemTag | STag )</code>
               </p>
                           <p>as defined in the XML 1.0 or XML 1.1 Recommendation.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>That is, the XML is well-formed at least as far as the end of the first element start
                              tag; to establish this,
                              a parser will typically retrieve any external entities referenced in the Doctype declaration
                              or DTD.</div>
                        </li>
                     </ol>
                     <p>If the function returns <code>false</code>, the caller can conclude that either one of the above conditions is not satisfied, or
         the processor detected some other condition that would prevent a call on <a href="#element-source-document"><code>xsl:source-document</code></a> with
            <code>streamable="yes"</code> executing successfully.</p>
                     <p>Like <a href="#element-source-document"><code>xsl:source-document</code></a> itself, the function is not deterministic, which means that multiple calls during the execution
         of a stylesheet will not necessarily return the same result. The caller cannot make any inferences about the point in time at which
         the input conditions for <a href="#func-stream-available"><code>stream-available</code></a> are present, and in particular there is no guarantee that because
         <a href="#func-stream-available"><code>stream-available</code></a> returns <code>true</code>, <a href="#element-source-document"><code>xsl:source-document</code></a> will necessarily succeed.</p>
                     <p>The value of the <code>$uri</code> argument <span class="verb">must</span> be a URI in the form of a string. If it is a relative URI,
            it is resolved relative to the static base URI of the function call.</p>
                  </dd>
                  <dt class="label">Error Conditions</dt>
                  <dd>
                     <p>If the URI is invalid, such that a call on <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc-available"><code>doc-available</code></a> would raise an error, then 
            <a href="#func-stream-available"><code>stream-available</code></a> raises the same error: <a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFODC0005" title="FODC0005"><span class="error">[ERR FODC0005] </span></a><sup><small>FO40</small></sup>.</p>
                  </dd>
               </dl>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="accumulators"></a>19 <a href="#accumulators" style="text-decoration: none">Accumulators</a></h2>
            <p>Accumulators were introduced in XSLT 3.0 to enable data that is read during streamed
               processing of a document to be accumulated, processed or retained for later use.
               However, they may equally be used with non-streamed processing.</p>
            <p><span class="definition">[Definition:&nbsp;</span><a id="dt-accumulator" title="accumulator"></a>An
                     <b>accumulator</b> defines a series of
                     values associated with the nodes of the tree. If an accumulator is
                  applicable to a particular tree, then for each node in the tree, other than
                  attribute and namespace nodes, there will be two values available, called the
                  pre-descent and post-descent values. These two values are available via a pair of
                  functions, <a href="#func-accumulator-before"><code>accumulator-before</code></a> and
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a>.<span class="definition">]</span></p>
            <p>There are two ways the values of an accumulator can be
               established for a given tree: they can be computed by evaluating the rules appearing
               in the <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration, or they can be copied from the
               corresponding nodes in a different tree. The second approach (copying the values) is
               available via the <a href="#func-snapshot"><code>snapshot</code></a> and <a href="#func-copy-of"><code>copy-of</code></a>
               functions, or by use of the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction specifying
                  <code>copy-accumulators="yes"</code>. Accumulator values are also copied during
               the implicit invocation of the snapshot function performed by the
                  <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>Accumulators can apply to trees rooted at any kind of node. But
                  because they are most often applied to trees rooted at a document node, this
                  section sometimes refers to the “document” to which an accumulator applies; use of
                  this term should be taken to include all trees whether or not they are rooted at a
                  document node.</p>
               <p>Accumulators can apply to trees rooted at nodes (such
                  as text nodes) that cannot have children, though this serves no useful purpose. In
                  the case of a tree rooted at an attribute or namespace node, there is no way to
                  obtain the value of the accumulator.</p>
            </div>
            <p>The following sections give first, the syntax rules for defining an accumulator; then
               an informal description of the semantics; then a more formal definition; and finally,
               examples. But to illustrate the concept intuitively, the following simple example
               shows how an accumulator can be used for numbering of nodes:</p>
            <div class="example">
               
               <div class="exampleHeader"><a id="d5e44034"></a>Example: Numbering Figures within a Chapter</div>
               <p>This example assumes document input in which <code>figure</code> elements can
                  appear within <code>chapter</code> elements (which we assume are not nested), and
                  the requirement is to render the figures with a caption that includes the figure
                  number within its containing chapter.</p>
               <p>When the document is processed using streaming, the <a href="#element-number"><code>xsl:number</code></a>
                  instruction is not available, so a solution using accumulators is needed.</p>
               <p>The required accumulator can be defined and used like this:</p>
               <div class="exampleInner">
                  <pre>&lt;xsl:accumulator name="figNr" as="xs:integer" 
                    initial-value="0" streamable="yes"&gt;
     &lt;xsl:accumulator-rule match="chapter" select="0"/&gt;
     &lt;xsl:accumulator-rule match="figure" select="$value + 1"/&gt;
&lt;/xsl:accumulator&gt;
   
&lt;xsl:mode streamable="yes"/&gt;
&lt;xsl:template match="figure" expand-text="yes"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Figure {accumulator-before('figNr')}&lt;/p&gt;
&lt;/xsl:template&gt;</pre>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="accumulator-declaration"></a>19.1 <a href="#accumulator-declaration" style="text-decoration: none">Declaring an Accumulator</a></h3>
               <p class="element-syntax"><a id="element-accumulator"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:accumulator<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>initial-value</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br>&lt;/xsl:accumulator&gt;</code></p>
               <p class="element-syntax"><a id="element-accumulator-rule"></a><code>&lt;xsl:accumulator-rule<br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;phase? = "start" | "end"〔'start'〕<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;capture? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:accumulator-rule&gt;</code></p>
               <p>An <a href="#element-accumulator"><code>xsl:accumulator</code></a> element is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-declaration">declaration</a><sup><small>XT</small></sup> of an accumulator. The
                     <code>name</code> attribute defines the name of the accumulator. The value of
                  the <code>name</code> attribute is an <a href="https://qt4cg.org/specifications/xslt-40/#dt-eqname">EQName</a><sup><small>XT</small></sup>,
                  which is expanded as described in  section <a href="../xslt-40/#qname">5.1.1 Qualified Names</a>.</p>
               <p>An <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration can only appear as a <a href="https://qt4cg.org/specifications/xslt-40/#dt-top-level">top-level</a><sup><small>XT</small></sup> element in a stylesheet module.</p>
               <p>The <code>capture</code> attribute is allowed only on an <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> element
               that specifies <code>phase="end"</code>. Its effect is described in <a href="#capturing-accumulators"><i>19.9 Capturing Accumulators</i></a>.</p>
               <p>The functions <a href="#func-accumulator-before"><code>accumulator-before</code></a>
                     and <a href="#func-accumulator-after"><code>accumulator-after</code></a> return, respectively, the
                  value of the accumulator before visiting the descendants of a given node, and the
                  value after visiting the descendants of a node. Each of these functions takes a single argument, the name of the
                  accumulator, and the function applies implicitly to the context node. The
                  type of the return value (for both functions) is determined by the <code>as</code>
                  attribute of the <a href="#element-accumulator"><code>xsl:accumulator</code></a> element.</p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-accumulator-function" title="accumulator function"></a>The functions
                        <a href="#func-accumulator-before"><code>accumulator-before</code></a> and
                        <a href="#func-accumulator-after"><code>accumulator-after</code></a> are referred to as the
                        <b>accumulator functions</b>.<span class="definition">]</span></p>
               <p>The initial value of the accumulator is obtained by evaluating the expression in
                  the <code>initial-value</code> attribute. This
                     attribute is mandatory. The expression in the
                     <code>initial-value</code> attribute is evaluated with a 
                 <a href="https://qt4cg.org/specifications/xslt-40/#dt-singleton-focus">singleton focus</a><sup><small>XT</small></sup> based on the root node of
                     the streamed input tree to which the accumulator is being applied.</p>
               <p>The values of the accumulator for individual nodes in a tree are obtained by
                  applying the <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> rules contained within the
                     <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration, as described in subsequent
                  sections. The <code>match</code> attribute of
                        <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-pattern">pattern</a><sup><small>XT</small></sup> which
                     determines which nodes trigger execution of the rule; the <code>phase</code>
                     attribute indicates whether the rule fires before descendants are processed
                        (<code>phase="start"</code>, which is the default), or after descendants are
                     processed (<code>phase="end"</code>).</p>
               <p>The <code>select</code> attribute and the contained sequence constructor of the
                     <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> element are mutually exclusive: if the
                     <code>select</code> attribute is present then the sequence constructor must be
                  empty. The expression in the <code>select</code>
                  attribute of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
                  or the contained sequence constructor
                  is evaluated with a static context that follows the normal rules for expressions
                  in stylesheets, except that:</p>
               <ul>
                  <li>
                     <p>An additional variable is present in the context. The name of this variable
                        is <code>value</code> (in no namespace), and its type is the type that
                        appears in the <code>as</code> attribute of the
                           <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration.</p>
                  </li>
                  <li>
                     <p>The context item for evaluation of the expression or sequence constructor will always be a node
                        that matches the <a href="https://qt4cg.org/specifications/xslt-40/#dt-pattern">pattern</a><sup><small>XT</small></sup> in the
                           <code>match</code> attribute.</p>
                  </li>
               </ul>
               <p>The result of both the <code>initial-value</code> and <code>select</code> expressions (or contained sequence
                     constructor) is converted to the type declared in the <code>as</code>
                  attribute by applying the <a href="https://qt4cg.org/specifications/xslt-40/#dt-coercion-rules">coercion rules</a><sup><small>XT</small></sup>. A
                     <a href="https://qt4cg.org/specifications/xslt-40/#dt-type-error">type error</a><sup><small>XT</small></sup> occurs if conversion is not
                  possible. The <code>as</code> attribute defaults to <code>item()*</code>.</p>
               <p>The effect of the <code>streamable</code>  attribute 
                  is defined in <a href="../xslt-streaming-40/#streamability-of-accumulators">11 Streamable Accumulators</a><sup><small>SG</small></sup>.</p>
               <p>The effect of the <code>capture</code> attribute 
                  is defined in <a href="#capturing-accumulators"><i>19.9 Capturing Accumulators</i></a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="applicability-of-accumulators"></a>19.2 <a href="#applicability-of-accumulators" style="text-decoration: none">Applicability of Accumulators</a></h3>
               <p>It is not the case that every accumulator is applicable to every tree. The details
                  depend on how the accumulator is declared, and how the tree is created. The rules
                  are as follows:</p>
               <ol class="enumar">
                  <li>
                     <p>An accumulator is applicable to a tree unless otherwise specified in these rules.
                  (For example, when a document is read using the <a href="#func-document"><code>document</code></a>,
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions,
                  all accumulators are applicable. Similarly, all accumulators are applicable
                  to a <a href="https://qt4cg.org/specifications/xslt-40/#dt-temporary-tree">temporary tree</a><sup><small>XT</small></sup> created using <a href="#element-variable"><code>xsl:variable</code></a>.)</p>
                  </li>
                  <li>
                     <p>Regardless of the rules below, an accumulator is not applicable to a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed document</a>
                     unless the accumulator is declared with <code>streamable="yes"</code>. (The converse
                  does not apply: for unstreamed documents, accumulators are applicable regardless
                  of the value of the <code>streamable</code> attribute.)</p>
                  </li>
                  <li>
                     <p>For a document read using the
                     <a href="#element-source-document"><code>xsl:source-document</code></a> instruction, the accumulators that are applicable 
                     are those determined by the <code>use-accumulators</code>
                  attribute of that instruction.</p>
                  </li>
                  <li>
                     <p>For a document read using the <code>for-each-source</code> attribute of an
                     <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of an <a href="#element-merge"><code>xsl:merge</code></a> instruction,
                     the accumulators that are applicable are those determined by the <code>use-accumulators</code>
                     attribute of the <a href="#element-merge-source"><code>xsl:merge-source</code></a> element.</p>
                  </li>
                  <li>
                     <p>For a document containing nodes supplied in the
                     <a href="https://qt4cg.org/specifications/xslt-40/#dt-initial-match-selection">initial match selection</a><sup><small>XT</small></sup>, the accumulators that are
                     applicable are those determined by the <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration of the <a href="https://qt4cg.org/specifications/xslt-40/#dt-initial-mode">initial mode</a><sup><small>XT</small></sup>. This means that in the
                     absence of an <a href="#element-mode"><code>xsl:mode</code></a> declaration, no accumulators are applicable.</p>
                  </li>
                  <li>
                     <p>For a tree <var>T</var> created by copying a node in a tree <var>S</var>
                     using the <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a>
                     functions, or the instruction <a href="#element-copy-of"><code>xsl:copy-of</code></a> with
                     <code>copy-accumulators="yes"</code>, an accumulator is applicable to
                     <var>T</var> if and only if it is applicable to <var>S</var>.</p>
                  </li>
               </ol>
               <p>If an accumulator is not applicable to the tree containing the context item, calls
                  to the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a>, supplying the name of that accumulator,
                  will fail with a dynamic error.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The reason that accumulators are not automatically applicable to every streamed
                     document is to avoid the cost of evaluating them, and to avoid the possibility
                     of dynamic errors occuring if they are not designed to work with a particular
                     document structure.</p>
                  <p>In the case of unstreamed documents, there are no compelling reasons to
                     restrict which accumulators are applicable, because an implementation can avoid the cost of
                     evaluating every accumulator against every document by evaluating the
                     accumulator lazily, for example, by only evaluating the accumulator for a
                     particular tree the first time its value is requested for a node in that tree.
                     In the interests of orthogonality, however, restricting the applicable 
                     accumulators works in the same way for streamable and non-streamable documents.
                  </p>
               </div>
               <p>The value of the <code>use-accumulators</code> attribute of
               <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-merge-source"><code>xsl:merge-source</code></a>,
                  or <a href="#element-mode"><code>xsl:mode</code></a> must either be a
                  whitespace-separated list of <a href="https://qt4cg.org/specifications/xslt-40/#dt-eqname">EQNames</a><sup><small>XT</small></sup>, or the
                  special token <code>#all</code>. The list may be empty, and the default value is
                  an empty list. Every <code>EQName</code> in the list must be the name of an
                  accumulator, visible in the containing package, and declared with
                     <code>streamable="yes"</code>. The value <code>#all</code> indicates that all
                  accumulators that are visible in the containing package are applicable (except
                  that for a streamable input document, an accumulator is not applicable unless
                  it specifies <code>streamable="yes"</code>).</p>
               <p>
                  <a id="err-XTSE3300"><span class="error">[ERR XTSE3300] </span></a>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> if the list of
                        accumulator names  contains an invalid token, contains the same
                        token more than once, or contains the token <code>#all</code> along with any
                        other value; or if any token (other than
                              <code>#all</code>) is not the name of a <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-declared-streamable">declared-streamable</a><sup><small>SG</small></sup> accumulator visible in the containing
                           package.

               </p>
            </div>
            <div class="div2">
               
               <h3><a id="accumulator-informal-rules"></a>19.3 <a href="#accumulator-informal-rules" style="text-decoration: none">Informal Model for Accumulators</a></h3>
               <p><em>This section describes how accumulator values are
                     established by evaluating the rules in an <a href="#element-accumulator"><code>xsl:accumulator</code></a>
                     declaration. This process does not apply to trees created with accumulator
                     values copied from another document, for example by using the
                        <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a>
                     functions.</em></p>
               <p>Informally, an accumulator is evaluated by traversing a tree, as
                     follows.</p>
               <p>Each node is visited twice, once before processing its descendants, and once after
                  processing its descendants. For consistency, this applies even to leaf nodes: each
                  is visited twice. Attribute and namespace nodes, however, are not visited.</p>
               <p>Before the traversal starts, a variable (called the accumulator variable) is
                  initialized to the value of the expression given as the <code>initial-value</code>
                  attribute.</p>
               <p>On each node visit, the <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> elements are
                  examined to see if there is a matching rule. For a match to occur, the pattern in
                  the <code>match</code> attribute must match the node, and the <code>phase</code>
                  attribute must be <code>start</code> if this is the first visit, and
                     <code>end</code> if it is the second visit. If there is a matching rule, then a
                  new value is computed for the accumulator variable using the expression contained
                  in that rule’s <code>select</code>
                     attribute or the contained sequence constructor. If there is more than
                  one matching rule, the last in document order is used. If there is no matching
                  rule, the value of the accumulator variable does not change.</p>
               <p>Each node is labeled with a pre-descent value for the accumulator, which is the
                  value of the accumulator variable immediately <em>after</em> processing the
                  first visit to that node, and with a post-descent value for the accumulator, which
                  is the value of the accumulator variable immediately <em>after</em> processing the second visit.</p>
               <p>The function <a href="#func-accumulator-before"><code>accumulator-before</code></a> delivers
                  the pre-descent value of the accumulator at the context node; the function
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a> delivers the post-descent value of the
                  accumulator at the context node.</p>
               <p>Although this description is expressed in procedural terms, it can be seen that
                  the two values of the accumulator for any given node depend only on the node and
                  its preceding and (in the case of the post-descent value) descendant nodes.
                  Calculation of both values is therefore deterministic and free of side-effects;
                  moreover, it is clear that the values can be computed during a streaming pass of a
                  document, provided that the rules themselves use only information that is
                  available without repositioning the input stream.</p>
               <p>It is permitted for the <code>select</code> expression of an accumulator rule, or the contained
                     sequence constructor, to invoke an accumulator function. For a streamable accumulator, the rules ensure that
                     a rule with <code>phase="start"</code> cannot call the
                        <a href="#func-accumulator-after"><code>accumulator-after</code></a> function. When such function calls
                     exist in an accumulator rule, they impose a dependency of one accumulator on
                     another, and create the possibility of cyclic dependencies. Processors are
                     allowed to raise the error statically if they can detect it statically.
                     Failing this, processors are allowed to fail catastrophically in the event of a
                     cycle, in the same way as they might fail in the event of infinite function or
                     template recursion. Catastrophic failure might manifest itself, for example, as
                     a stack overflow, or as non-termination of the transformation.</p>
            </div>
            <div class="div2">
               
               <h3><a id="accumulator-formal-rules"></a>19.4 <a href="#accumulator-formal-rules" style="text-decoration: none">Formal Model for Accumulators</a></h3>
               <p><em>This section describes how accumulator values are
                     established by evaluating the rules in an <a href="#element-accumulator"><code>xsl:accumulator</code></a>
                     declaration. This process does not apply to trees created with accumulator
                     values copied from another document, for example by using the
                        <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a>
                     functions.</em></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-traversal" title="traversal"></a>A <b>traversal</b> of a tree is
                     a sequence of <a title="traversal-event" class="termref" href="#dt-traversal-event">traversal
                     events</a>.<span class="definition">]</span></p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-traversal-event" title="traversal-event"></a>a <b>traversal
                        event</b> (shortened to <b>event</b> in this section) is a pair
                     comprising a phase (start or end) and a node.<span class="definition">]</span> It is modelled as a map
                  with two entries: <code>{ "phase": p, "node": n }</code> where p is the string
                     <code>"start"</code> or <code>"end"</code> and <code>n</code> is a node.</p>
               <p>The traversal of a tree contains two
                  traversal events for each node in the tree, other than attribute and namespace
                  nodes. One of these events (the “start event”) has phase <code>"start"</code>, the other (the
                  “end event”) has phase <code>"end"</code>.</p>
               <p>The order of traversal events within a traversal is such that, given any two nodes
                     <var>M</var> and <var>N</var> with start/end events denoted by <var>M<sub>0</sub></var>,
                     <var>M<sub>1</sub></var>, <var>N<sub>0</sub></var>, and <var>N<sub>1</sub></var>, :</p>
               <ul>
                  <li>
                     <p>For any node <var>N</var>, <var>N<sub>0</sub></var> precedes <var>N<sub>1</sub></var>;</p>
                  </li>
                  <li>
                     <p>If <var>M</var> is an ancestor of <var>N</var> then <var>M<sub>0</sub></var> precedes
                           <var>N<sub>0</sub></var> and <var>N<sub>1</sub></var> precedes <var>M<sub>1</sub></var>;</p>
                  </li>
                  <li>
                     <p>If <var>M</var> is on the preceding axis of <var>N</var> then <var>M<sub>1</sub></var>
                        precedes <var>N<sub>0</sub></var>.</p>
                  </li>
               </ul>
               <p>The accumulator defines a (private) delta function <var>Δ</var>. The delta
                  function computes the value of the accumulator for one traversal event in terms of
                  its value for the previous traversal event. The function is defined as
                  follows:</p>
               <ol class="enumar">
                  <li>
                     <p>The signature of <var>Δ</var> is <code>function ($old-value as T,
                           $event as map(*)) as T</code>, where <var>T</var> is the sequence type
                        declared in the <code>as</code> attribute of the accumulator
                        declaration;</p>
                  </li>
                  <li>
                     <p>The implementation of the function is equivalent to the following
                        algorithm:</p>
                     <ol class="enumla">
                        <li>
                           <p>Let <var>R</var> be the set of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>
                              elements among the children of the accumulator declaration whose
                                 <code>phase</code> attribute equals <code>$event("phase")</code>
                              and whose <code>match</code> attribute is a 
                             <a href="https://qt4cg.org/specifications/xslt-40/#dt-pattern">pattern</a><sup><small>XT</small></sup> that matches <code>$event("node")</code></p>
                        </li>
                        <li>
                           <p>If <var>R</var> is empty, return <code>$old-value</code></p>
                        </li>
                        <li>
                           <p>Let <var>Q</var> be the <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> in
                                 <var>R</var> that is last in document order</p>
                        </li>
                        <li>
                           <p>Return the value of the expression in the <code>select</code>
                              attribute of <var>Q</var>, or the
                                 contained sequence constructor, evaluating this with a
                                 <a href="https://qt4cg.org/specifications/xslt-40/#dt-singleton-focus">singleton focus</a><sup><small>XT</small></sup> set to
                                 <code>$event("node")</code> and with a dynamic context that binds
                              the variable whose name is <code>$value</code> (in no namespace) to the value
                                 <code>$old-value</code>.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>The argument names <code>old-value</code> and <code>event</code>
                                 are used here purely for definitional purposes; these names are not
                                 available for use within the <code>select</code> expression or contained sequence
                                    constructor.</p>
                           </div>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>There is a slight variation here for an accumulator rule specifying
                              <code>phase="end"</code> and <code>capture="yes"</code>. For details,
                              see <a href="../xslt-streaming-40/#streamability-of-accumulators">11 Streamable Accumulators</a><sup><small>SG</small></sup>.</p>
                           </div>
                        </li>
                     </ol>
                  </li>
               </ol>
               <p>For every node <var>N</var>, other than attribute and namespace nodes, the
                  accumulator defines a pre-descent value <var>B<sub>N</sub></var> and a post-descent value
                     <var>A<sub>N</sub></var> whose values are as follows:</p>
               <ol class="enumar">
                  <li>
                     <p>Let <var>T</var> be the <a title="traversal" class="termref" href="#dt-traversal">traversal</a> of
                        the tree rooted at <code>fn:root(N)</code>.</p>
                  </li>
                  <li>
                     <p>Let <var>SB</var> be the subsequence of <var>T</var> starting at the first
                        event in <var>T</var> and ending with the start event for node <var>N</var>
                        (that is, the event <code>{ "phase": "start", "node": N }</code>).</p>
                  </li>
                  <li>
                     <p>Let <var>SA</var> be the subsequence of <var>T</var> starting at the first
                        event in <var>T</var>, and ending with the  end event
                        for node <var>N</var> (that is, the event <code>{ "phase": "end", "node": N
                           }</code>).</p>
                  </li>
                  <li>
                     <p>Let <var>Z</var> be the result of evaluating the expression contained in the
                           <code>initial-value</code> attribute of the
                           <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration, evaluated with a <a href="https://qt4cg.org/specifications/xslt-40/#dt-singleton-focus">singleton focus</a><sup><small>XT</small></sup>
                           based on <code>root(N)</code>.</p>
                  </li>
                  <li>
                     <p>Then the pre-descent value <var>B<sub>N</sub></var> is the value of
                           <code>fn:fold-left(SB, Z, Δ)</code>, and the post-descent value
                           <var>A<sub>N</sub></var> is the value of <code>fn:fold-left(SA, Z,
                        Δ)</code>.</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="errors-in-accumulators"></a>19.5 <a href="#errors-in-accumulators" style="text-decoration: none">Dynamic Errors in Accumulators</a></h3>
               <p>If a dynamic error occurs when evaluating the <code>initial-value</code> expression
               of <a href="#element-accumulator"><code>xsl:accumulator</code></a>, or the <code>select</code> expression of <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>,
                  <span>or the sequence constructor contained in <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>, </span>
               then the error is raised as an error from any subsequent call on <a href="#func-accumulator-before"><code>accumulator-before</code></a>
                  or <a href="#func-accumulator-after"><code>accumulator-after</code></a> that references the accumulator. If no such call on <a href="#func-accumulator-before"><code>accumulator-before</code></a>
                  or <a href="#func-accumulator-after"><code>accumulator-after</code></a> happens, then the error goes unreported.
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In the above rule, the phrase <b>subsequent call</b> is to be understood in terms of functional dependency; that is, a call to
                  <a href="#func-accumulator-before"><code>accumulator-before</code></a> or <a href="#func-accumulator-after"><code>accumulator-after</code></a> raises an error if the accumulator value at the node in question is
               functionally dependent on a computation that fails with a dynamic error.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Particularly in the case of streamed accumulators, this may mean that the implementation has to “hold back” the error
               until the next time the accumulator is referenced, to give applications the opportunity to catch the error using <a href="#element-try"><code>xsl:try</code></a>
               and <a href="#element-catch"><code>xsl:catch</code></a> in a predictable way.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Errors that occur during the evaluation of the pattern in the <code>match</code> attribute of
               <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> are handled as described in  section <a href="../xslt-40/#pattern-errors">6.3.4 Errors in Patterns</a>:
               specifically, the pattern does not match the relevant node, and no error is raised.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="func-accumulator-before"></a>19.6 <a href="#func-accumulator-before" style="text-decoration: none">fn:accumulator-before</a></h3>
               <dl>
                  <dt class="label">Summary</dt>
                  <dd>
                     <p>Returns the pre-descent value of the selected accumulator at the context node.</p>
                  </dd>
                  <dt class="label">Signature</dt>
                  <dd>
                     <div class="proto">
                        <table class="proto" border="0">
                           <tr class="name">
                              <td colspan="3"><code class="function">fn:accumulator-before</code>(</td>
                           </tr>
                           <tr class="arg">
                              <td><code>$name</code></td>
                              <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code></td>
                              <td></td>
                           </tr>
                           <tr class="return-type">
                              <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>item()*</code></td>
                           </tr>
                        </table>
                     </div>
                  </dd>
                  <dt class="label">Properties</dt>
                  <dd>
                     <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>. </p>
                  </dd>
                  <dt class="label">Rules</dt>
                  <dd>
                     <p>The <code>$name</code> argument specifies the name of the <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>. 
            The value of the argument <span class="verb">must</span> be 
            <span>either an <code>xs:QName</code>, or</span>
            a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a 
            <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then it is expanded as described in
               <a href="#qname"><i>5.1.1 Qualified Names</i></a> (no prefix means no namespace).</p>
                     <p>The function returns the pre-descent value <var>B(N)</var>of the selected accumulator
            where <var>N</var> is the context node, as defined in <a href="#accumulator-formal-rules"><i>19.4 Formal Model for Accumulators</i></a>.</p>
                     <p>If the context item is a node in a streamed document, then the accumulator 
            must be declared with <code>streamable="yes"</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The converse is not true: an accumulator declared to be streamable is available on both
         streamed and unstreamed nodes.</p>
                     </div>
                  </dd>
                  <dt class="label">Error Conditions</dt>
                  <dd>
                     <p>
            <a id="err-XTDE3340"><span class="error">[ERR XTDE3340] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the first
                     argument to the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                        <a href="#func-accumulator-after"><code>accumulator-after</code></a> function is 
                  <span>a string that is</span> not a valid
                     <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if there is no namespace declaration in scope
                  for the prefix of the QName, or if the name obtained by expanding the QName is not
                  the same as the expanded name of any <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration
                  appearing in the <a title="package" class="termref" href="#dt-package">package</a> in which the function
                  call appears. If the processor is able to detect the error statically (for
                  example, when the argument is supplied as a string literal), then the processor
                     <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.
         </p>
                     <p>
            <a id="err-XTDE3350"><span class="error">[ERR XTDE3350] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the
                     <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when there is no <a title="context item" class="termref" href="#dt-context-item">context item</a>.
         </p>
                     <p>
            <a id="err-XTTE3360"><span class="error">[ERR XTTE3360] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to call the
                     <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is 
                  not a node, or when it is an attribute or namespace node.
         </p>
                     <p>
            <a id="err-XTDE3362"><span class="error">[ERR XTDE3362] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the
                     <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the context
                  item is a node in a tree to which the selected accumulator is not
                  applicable (including the case where it is not applicable
                     because the document is streamed and the accumulator is not 
                  declared with <code>streamable="yes"</code>). Implementations
                  <span class="verb">may</span> raise this error but are <span class="verb">not required</span> to do so,
                  if they are capable of streaming documents without imposing this restriction.
         </p>
                     <p>
            <a id="err-XTDE3400"><span class="error">[ERR XTDE3400] </span></a>It is an error if there is a cyclic set of dependencies among accumulators such
                  that the (pre- or post-descent) value of an accumulator depends directly or indirectly on itself.
                  A processor <span class="verb">may</span> report this as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if it
                  can be detected statically. Alternatively a processor <span class="verb">may</span> report this as a 
                  <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>. As a further option, a processor may fail catastrophically when
                  this error occurs.
         </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The term <b>catastrophic failure</b> here means a failure similar to infinite function or template
         recursion, which might result in stack overflow or even in non-termination of the transformation, rather than in 
         a dynamic error of the kind that can be processed using <a href="#element-try"><code>xsl:try</code></a> and <a href="#element-catch"><code>xsl:catch</code></a>.</p>
                     </div>
                  </dd>
                  <dt class="label">Notes</dt>
                  <dd>
                     <div class="note">
                        <p>The <a href="#func-accumulator-before"><code>accumulator-before</code></a> function can be applied to a node whether or not the accumulator
            has a <code>phase="start"</code> rule for that node. In effect, there is a <code>phase="start"</code> rule
            for every node, where the default rule is to leave the accumulator value unchanged; the 
            <a href="#func-accumulator-before"><code>accumulator-before</code></a> function delivers the value of the accumulator after processing
            the explicit or implicit <code>phase="start"</code> rule.</p>
                        <p>In XSLT 4.0, the argument can be supplied as a QName literal, for example
         <code>accumulator-before( #accum )</code>.</p>
                     </div>
                  </dd>
                  <dt class="label">Examples</dt>
                  <dd>
                     <div class="example">
                        <table style="border:1px solid; padding:5px; width:100%" class="medium">
                           <tbody>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>Given the accumulator:</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <div class="exampleInner">
                                       <pre>
&lt;xsl:accumulator name="a" initial-value="0"&gt;
   &lt;xsl:accumulator-rule match="section" select="$value + 1"/&gt;
&lt;/xsl:accumulator&gt;</pre>
                                    </div>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>and the template rule:</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <div class="exampleInner">
                                       <pre>
&lt;xsl:template match="section"&gt;
   &lt;xsl:value-of select="accumulator-before('a')"/&gt;
   &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
                                    </div>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>The stylesheet will precede the output from processing each section with a section
               number that runs sequentially 1, 2, 3... irrespective of the nesting of sections.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="func-accumulator-after"></a>19.7 <a href="#func-accumulator-after" style="text-decoration: none">fn:accumulator-after</a></h3>
               <dl>
                  <dt class="label">Summary</dt>
                  <dd>
                     <p>Returns the post-descent value of the selected accumulator at the context node.</p>
                  </dd>
                  <dt class="label">Signature</dt>
                  <dd>
                     <div class="proto">
                        <table class="proto" border="0">
                           <tr class="name">
                              <td colspan="3"><code class="function">fn:accumulator-after</code>(</td>
                           </tr>
                           <tr class="arg">
                              <td><code>$name</code></td>
                              <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code></td>
                              <td></td>
                           </tr>
                           <tr class="return-type">
                              <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>item()*</code></td>
                           </tr>
                        </table>
                     </div>
                  </dd>
                  <dt class="label">Properties</dt>
                  <dd>
                     <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>. </p>
                  </dd>
                  <dt class="label">Rules</dt>
                  <dd>
                     <p>The <code>$name</code> argument specifies the name of the <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>. 
            The value of the argument <span class="verb">must</span> be 
            <span>either an <code>xs:QName</code>, or</span>
            a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a
               <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then it is expanded as
            described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> (no prefix means no namespace).</p>
                     <p>The function returns the post-descent value <var>A(N)</var> of the selected accumulator
            where <var>N</var> is the context node, as defined in <a href="#accumulator-formal-rules"><i>19.4 Formal Model for Accumulators</i></a>.</p>
                     <p>If the context item is a node in a streamed document, then the accumulator 
            must be declared with <code>streamable="yes"</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The converse is not true: an accumulator declared to be streamable is available on both
            streamed and unstreamed nodes.</p>
                     </div>
                  </dd>
                  <dt class="label">Error Conditions</dt>
                  <dd>
                     <p>The following errors apply: <span class="error">[see <a href="#err-XTDE3340">ERR XTDE3340</a>]</span>,
               <span class="error">[see <a href="#err-XTDE3350">ERR XTDE3350</a>]</span>, <span class="error">[see <a href="#err-XTTE3360">ERR XTTE3360</a>]</span>, <span class="error">[see <a href="#err-XTDE3362">ERR XTDE3362</a>]</span>, <span class="error">[see <a href="#err-XTDE3400">ERR XTDE3400</a>]</span>. </p>
                     <p>For constraints on the use of <a href="#func-accumulator-after"><code>accumulator-after</code></a> when streaming, see
         <a href="../xslt-streaming-40/#streamability-fn-accumulator-after">12.8.1 Streamability of the accumulator-after Function</a><sup><small>SG</small></sup>.</p>
                  </dd>
                  <dt class="label">Notes</dt>
                  <dd>
                     <div class="note">
                        <p>The <a href="#func-accumulator-after"><code>accumulator-after</code></a> function can be applied to a node whether or not the accumulator
            has a <code>phase="end"</code> rule for that node. In effect, there is a <code>phase="end"</code> rule
            for every node, where the default rule is to leave the accumulator value unchanged; the 
            <a href="#func-accumulator-after"><code>accumulator-after</code></a> function delivers the value of the accumulator after processing
            the explicit or implicit <code>phase="end"</code> rule.</p>
                        <p>In XSLT 4.0, the argument can be supplied as a QName literal, for example
         <code>accumulator-before( #accum )</code>.</p>
                     </div>
                  </dd>
                  <dt class="label">Examples</dt>
                  <dd>
                     <div class="example">
                        <table style="border:1px solid; padding:5px; width:100%" class="medium">
                           <tbody>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>Given the accumulator:</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <div class="exampleInner">
                                       <pre>
&lt;xsl:accumulator name="w" initial-value="0" streamable="true" as="xs:integer"&gt;
   &lt;xsl:accumulator-rule match="text()" 
                         select="$value + count(tokenize(.))"/&gt;
&lt;/xsl:accumulator&gt;</pre>
                                    </div>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>and the template rule:</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <div class="exampleInner">
                                       <pre>
&lt;xsl:template match="section"&gt;
   &lt;xsl:apply-templates/&gt;
   (words: &lt;xsl:value-of select="accumulator-after('w') - accumulator-before('w')"/&gt;)
&lt;/xsl:template&gt;</pre>
                                    </div>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>The stylesheet will output at the end of each section a (crude) count of the number of words
               in that section.</p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="accumulators-visibility-and-overriding"></a>19.8 <a href="#accumulators-visibility-and-overriding" style="text-decoration: none">Importing of Accumulators</a></h3>
               <p>If a <a title="package" class="termref" href="#dt-package">package</a> contains more than one
                     <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration with a particular name, then the
                  one with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p>
               <p>
                  <a id="err-XTSE3350"><span class="error">[ERR XTSE3350] </span></a>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> for a 
                        <a title="package" class="termref" href="#dt-package">package</a> to contain two or more 
                        
                        accumulators with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                           precedence</a>, unless there is another accumulator with the same
                           <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, and a higher
                        import precedence.
               </p>
               <p>Accumulators cannot be referenced from, or overridden
                  in, a different package from the one in which they are declared.</p>
            </div>
            <div class="div2">
               
               <h3><a id="capturing-accumulators"></a>19.9 <a href="#capturing-accumulators" style="text-decoration: none">Capturing Accumulators</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#add-func">next</a> | <a href="#func-regex-group">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                     Capturing accumulators have been added; when streaming with a capturing accumulator,
                     the <a href="#func-accumulator-after"><code>accumulator-after</code></a> has full access to a snapshot of the matched
                     element node.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/211">211</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/717">717</a>&nbsp;29 September 2023]</i></p>
                     </li>
                  </ol>
               </div>
               <p>The <code>capture</code> attribute is intended primarily for use with streamable accumulators, but
                  in the interests of consistency, it has the same effect both for streamable and non-streamable
                  accumulators. If an accumulator rule with <code>phase="end"</code> and <code>capture="yes"</code>
                  matches an element node,
                  then the rule is evaluated not with the matched element node as the context item, but rather with a snapshot
                  copy of the matched node. The snapshot copy is made following the rules of the <a href="#func-snapshot"><code>snapshot</code></a>
                  function, with one exception: no accumulator values are copied into the snapshot tree (which would otherwise
                  happen: see <a href="#copying-accumulators"><i>19.10 Copying Accumulator Values</i></a>).</p>
               <p>If a rule with <code>capture="yes"</code> matches a node other than an element, the attribute
               has no effect.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The principal effect of specifying <code>capture="yes"</code> is to relax
                  the rules for streamability. With this option, the <code>phase="end"</code> accumulator rule
                  has access to the full subtree rooted at the node being visited. In a typical implementation,
                  a streaming processor encountering an element that matches a capturing accumulator rule
                  will make an on-the-fly in-memory copy of that element, allowing the <code>phase="end"</code>
                  accumulator rule full access to the subtree, and also to attributes of ancestors.</p>
                  <p>This means that an accumulator that needs access to the typed value or string value of an element 
                     can get this directly with a rule that matches the element, avoiding the need 
                     to write rules that match the element’s text node children.
                  </p>
                  <p>For example, to capture a copy of the most recent <code>h2</code> element in a document,
                  the following accumulator might be declared:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:accumulator name="most-recent-h2" streamable="yes"&gt;
  &lt;xsl:accumulator-rule match="h2" phase="end" capture="yes" select="."/&gt;
&lt;/xsl:accumulator&gt;</pre>
                  </div>
                  <p>and subsequent processing wishing to copy the most recent <code>h2</code> element into the result
                  tree can simply use <code>&lt;xsl:copy-of select="accumulator-before('most-recent-h2')"/&gt;</code>.</p>
                  <p>Without the <code>capture="yes"</code> attribute, this accumulator would be rejected
                  as non-streamable, because the <code>select</code> expression on the accumulator rule
                  is consuming.</p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="use-accumulator-to-create-glossary"></a>Example: Using a capturing accumulator to construct a glossary</div>
                  <p>Suppose a document contains definitions of technical terms with markup such as:</p>
                  <div class="exampleInner">
                     <pre>&lt;define term="oxidation"&gt;In &lt;topic&gt;chemistry&lt;/topic&gt;, 
   &lt;term&gt;oxidation&lt;/term&gt; is a chemical process in which atoms lose electrons.&lt;/define&gt;</pre>
                  </div>
                  <p>and the requirement is to generate a glossary that lists all the defined terms in the document, as an appendix.</p>
                  <p>This can be achieved by capturing all the defined terms in a map:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:accumulator name="glossary-terms" 
         as="{ xs:string, element(define) }" 
         initial-value="{}"
         streamable="yes"&gt;
   &lt;xsl:accumulator-rule match="define[@term]" 
           phase="end" 
           capture="yes"
           select="map:put($value, @term, .)"/&gt;
&lt;/xsl:accumulator&gt;</pre>
                  </div>
                  <p>Suppose that the input XML document contains an element <code>&lt;glossary/&gt;</code> marking
                     the point where the glossary is to be inserted. The glossary can then be generated
                     using a template rule such as:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:template match="glossary"&gt;
  &lt;h2&gt;Glossary&lt;/h2&gt;
  &lt;dl&gt;
    &lt;xsl:for-each select="map:pairs(accumulator-before('glossary-terms'))"&gt;
      &lt;xsl:sort select="?key"/&gt;
      &lt;dt&gt;{?key}&lt;/dt&gt;
      &lt;dd&gt;&lt;xsl:apply-templates select="?value"/&gt;&lt;/dd&gt;
    &lt;/xsl:for-each&gt;
  &lt;/dl&gt;  
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>
                  <a id="err-XTSE3355"><span class="error">[ERR XTSE3355] </span></a>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> for a 
                        an <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> element to specify
                     <code>capture="yes"</code> unless it also specifies <code>phase="end"</code>.
               </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Since <code>capture="yes"</code> causes the subtree of the relevant element node
                  to be built in memory, using this option on an element that has a large subtree is best
                  avoided, because it can defeat the purpose of streaming.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="copying-accumulators"></a>19.10 <a href="#copying-accumulators" style="text-decoration: none">Copying Accumulator Values</a></h3>
               <p>When nodes (including streamed nodes) are copied using the
                     <a href="#func-snapshot"><code>snapshot</code></a> or <a href="#func-copy-of"><code>copy-of</code></a> functions, or
                  using the <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with the attribute
                     <code>copy-accumulators="yes"</code>, then the pre-descent and post-descent
                  values of accumulators for that tree are not determined by traversing the tree as
                  described in <a href="#accumulator-informal-rules"><i>19.3 Informal Model for Accumulators</i></a> and <a href="#accumulator-formal-rules"><i>19.4 Formal Model for Accumulators</i></a>. Instead the values are the same as the values
                  on the corresponding nodes of the source tree. </p>
               <p>This applies also to the implicit invocation of the <a href="#func-snapshot"><code>snapshot</code></a>
                  function that happens during the evaluation of <a href="#element-merge"><code>xsl:merge</code></a>.</p>
               <p>If an accumulator is not applicable to a tree <var>S</var>, then it is also not
                  applicable to any tree formed by copying nodes from <var>S</var> using the above
                  methods.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>During streamed processing, accumulator values will typically be computed “on
                     the fly”; when the <a href="#func-copy-of"><code>copy-of</code></a> or
                        <a href="#func-snapshot"><code>snapshot</code></a> functions are applied to a streamed node, the
                     computed accumulator values for the streamed document will typically be
                     materialized and saved as part of the copy.</p>
                  <p>Accumulator values for a non-streamed document will often be computed lazily,
                     that is, they will not be computed unless and until they are needed. A call on
                        <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> on a
                     non-streamed document whose accumulator values have not yet been computed can
                     then be handled in a variety of ways. The implementation might interpret the
                     call on <a href="#func-copy-of"><code>copy-of</code></a> or <a href="#func-snapshot"><code>snapshot</code></a> as a
                     trigger causing the accumulator values to be computed; or it might retain a
                     link between the nodes of the copied tree and the nodes of the original tree,
                     so that a request for accumulator values on the copied tree can trigger
                     computation of accumulator values for the original tree. </p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="accumulator-examples"></a>19.11 <a href="#accumulator-examples" style="text-decoration: none">Examples of Accumulators</a></h3>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e45326"></a>Example: Remember the Title of a Document</div>
                  <p>Consider an XHTML document in which the title of the document is represented by
                     the content of a <code>title</code> element appearing as a child of the
                        <code>head</code> element, which in turn appears as a child of the
                        <code>html</code> element. Suppose that we want to process the document in
                     streaming mode, and that we want to avoid outputting the content of the
                        <code>h1</code> element if it is the same as the document title.</p>
                  <p>This can be achieved by remembering the value of the title in an accumulator
                     variable.</p>
                  <div class="exampleInner">
                     <pre>
  &lt;xsl:accumulator name="firstTitle" as="xs:string?" initial-value="()" 
                                                     streamable="yes"&gt;
    &lt;xsl:accumulator-rule match="/html/head/title/text()" select="string(.)"/&gt;
  &lt;/xsl:accumulator&gt;</pre>
                  </div>
                  <p>Subsequently, while processing an <code>h1</code> element appearing later in
                     the document, the value can be referenced:</p>
                  <div class="exampleInner">
                     <pre>
  &lt;xsl:template match="h1"&gt;
    &lt;xsl:variable name="firstTitle" select="accumulator-before('firstTitle')"/&gt;
    &lt;xsl:variable name="thisTitle" select="string(.)"/&gt;
    &lt;xsl:if test="$thisTitle ne $firstTitle"&gt;
      &lt;div class="heading-1"&gt;&lt;xsl:value-of select="$thisTitle"/&gt;&lt;/div&gt;
    &lt;/xsl:if&gt;
    &lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e45352"></a>Example: Keep a Word Count</div>
                  <p>Suppose that there is a requirement to output, at the end of the HTML rendition
                     of a document, a paragraph giving the total number of words in the
                     document.</p>
                  <p>An accumulator can be used to maintain a (crude) word count as follows:</p>
                  <div class="exampleInner">
                     <pre>
  &lt;xsl:accumulator name="word-count" 
                   as="xs:integer" 
                   initial-value="0"&gt;
    &lt;xsl:accumulator-rule match="text()" 
         select="$value + count(tokenize(.))"/&gt;
  &lt;/xsl:accumulator&gt;</pre>
                  </div>
                  <p>The final value can be output at the end of the document:</p>
                  <div class="exampleInner">
                     <pre>
   &lt;xsl:template match="/"&gt;
     &lt;xsl:apply-templates/&gt;
     &lt;p&gt;Word count: &lt;xsl:value-of select="accumulator-after('word-count')"/&gt;&lt;/p&gt;
   &lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e45367"></a>Example: Output Hierarchic Section Numbers</div>
                  <p>Consider a document in which <code>section</code> elements are nested within
                        <code>section</code> elements to arbitrary depth, and there is a requirement
                     to render the document with hierarchic section numbers of the form
                        <code>3.5.1.4</code>.</p>
                  <p>The current section number can be maintained in an accumulator in the form of a
                     sequence of integers, managed as a stack. The number of integers represents the
                     current level of nesting, and the value of each integer represents the number
                     of preceding sibling sections encountered at that level. For convenience the
                     first item in the sequence represents the top of the stack.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:accumulator name="section-nr" as="xs:integer*" 
                 initial-value="0"&gt;
  &lt;xsl:accumulator-rule match="section" phase="start" 
                 select="0, head($value)+1, tail($value)"/&gt;
  &lt;xsl:accumulator-rule match="section" phase="end" 
                 select="tail($value) (:pop:)"/&gt;
&lt;/xsl:accumulator&gt;</pre>
                  </div>
                  <p>To illustrate this, consider the values after processing a series of start and
                     end tags:</p>
                  <table class="data">
                     <caption>Example data illustrating the effect of parsing events on an accumulator</caption>
                     <thead>
                        <tr>
                           <th style="text-align:left; vertical-align:top">events</th>
                           <th style="text-align:left; vertical-align:top">accumulator value</th>
                           <th style="text-align:left; vertical-align:top">required section number</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>0, 1</code></td>
                           <td style="text-align:left; vertical-align:top">1</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>0, 1, 1</code></td>
                           <td style="text-align:left; vertical-align:top">1.1</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>1, 1</code></td>
                           <td style="text-align:left; vertical-align:top"> </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>0, 2, 1</code></td>
                           <td style="text-align:left; vertical-align:top">1.2</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>2, 1</code></td>
                           <td style="text-align:left; vertical-align:top"> </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>0, 3, 1</code></td>
                           <td style="text-align:left; vertical-align:top">1.3</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>0, 1, 3, 1</code></td>
                           <td style="text-align:left; vertical-align:top">1.3.1</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>1, 3, 1</code></td>
                           <td style="text-align:left; vertical-align:top"> </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>0, 2, 3, 1</code></td>
                           <td style="text-align:left; vertical-align:top">1.3.2</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>2, 3, 1</code></td>
                           <td style="text-align:left; vertical-align:top"> </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>3, 1</code></td>
                           <td style="text-align:left; vertical-align:top"> </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>&lt;/section&gt;</code></td>
                           <td style="text-align:left; vertical-align:top"><code>1</code></td>
                           <td style="text-align:left; vertical-align:top"> </td>
                        </tr>
                     </tbody>
                  </table>
                  <p>The section number for a section can thus be generated as:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:template match="section"&gt;
  &lt;p&gt;
    &lt;xsl:value-of select="reverse(tail(accumulator-before('section-nr')))" 
                  separator="."/&gt;
  &lt;/p&gt;
  &lt;xsl:apply-templates/&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e45507"></a>Example: Compute a Histogram showing the Number of Books, by Publisher</div>
                  <div class="exampleInner">
                     <pre>
 &lt;xsl:accumulator name="histogram" as="map(xs:string, xs:integer)"
    initial-value="{}"&gt;
    &lt;xsl:accumulator-rule match="book"&gt;
      &lt;xsl:choose&gt;
        &lt;xsl:when test="map:contains($value, @publisher)"&gt;
          &lt;xsl:sequence select="map:put($value, string(@publisher), 
                                        $value(@publisher)+1)"/&gt;
        &lt;/xsl:when&gt;
        &lt;xsl:otherwise&gt;
          &lt;xsl:sequence select="map:put($value, string(@publisher), 1)"/&gt;
        &lt;/xsl:otherwise&gt;
      &lt;/xsl:choose&gt;
    &lt;/xsl:accumulator-rule&gt;  
 &lt;/xsl:accumulator&gt;</pre>
                  </div>
                  <p>The <code>contained sequence constructor</code> is
                     evaluated with the variable <code>$value</code> set to the current value, and
                     with the context node as the node being visited.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>In the two calls on <code>map:put()</code>, it is necessary to explicitly
                        convert <code>@publisher</code> to an <code>xs:string</code> value, because
                        this is the declared type of the keys in the result map. Relying on
                        atomization would produce keys of type <code>xs:untypedAtomic</code>, which
                        would not satisfy the declared type of the map.</p>
                  </div>
                  <p>The accumulated histogram might be displayed as
                     follows:</p>
                  <div class="exampleInner">
                     <pre>
 &lt;xsl:source-document streamable="yes" href="booklist.xml" expand-text="yes"&gt;
   .....
   &lt;h1&gt;Number of books, by publisher&lt;/h1&gt;
   &lt;table&gt;
     &lt;thead&gt;
       &lt;th&gt;Publisher&lt;/th&gt;
       &lt;th&gt;Number of books&lt;/th&gt;
     &lt;/thead&gt;
     &lt;tbody&gt;
       &lt;xsl:variable name="histogram" select="accumulator-after('histogram')"/&gt;
       &lt;xsl:for-each select="map:keys($histogram)"&gt;
         &lt;tr&gt;
           &lt;td&gt;{.}&lt;/td&gt;
           &lt;td&gt;{$histogram(.)}&lt;/td&gt;
         &lt;/tr&gt;
       &lt;/xsl:for-each&gt;
     &lt;/tbody&gt;
   &lt;/table&gt;
 &lt;/xsl:source-document&gt;</pre>
                  </div>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="add-func"></a>20 <a href="#add-func" style="text-decoration: none">Additional Functions</a></h2>
            <div class="changes">
               <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-document">next</a> | <a href="#capturing-accumulators">previous</a>)</p>
               <ol>
                  <li>
                     <p>
               Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>,
               <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>,
               <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>,
               <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>,
               now have the option of supplying an <code>xs:QName</code> value instead.
               [This change was in the editor's draft accepted by the WG as its baseline when
               it started work.]
            <i>&nbsp;&nbsp;[&nbsp;&nbsp;1 January 2022]</i></p>
                  </li>
               </ol>
            </div>
            <p>This section describes XSLT-specific additions to the XPath function library. Some of these 
            additional functions also make use of
            information specified by <a title="declaration" class="termref" href="#dt-declaration">declarations</a> in the
            stylesheet; this section also describes these declarations.</p>
            <div class="div2">
               
               <h3><a id="func-document"></a>20.1 <a href="#func-document" style="text-decoration: none">fn:document</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-key">next</a> | <a href="#add-func">previous</a>)</p>
                  <ol>
                     <li>
                        <p>An options parameter has been added.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2292">2292</a>&nbsp;]</i></p>
                     </li>
                  </ol>
               </div>
               <dl>
                  <dt class="label">Summary</dt>
                  <dd>
                     <p>Provides access to XML documents identified by a URI.</p>
                  </dd>
                  <dt class="label">Signature</dt>
                  <dd>
                     <div class="proto">
                        <table class="proto" border="0">
                           <tr class="name">
                              <td colspan="3"><code class="function">fn:document</code>(</td>
                           </tr>
                           <tr class="arg">
                              <td><code>$uri-sequence</code></td>
                              <td><code class="as">as&nbsp;</code><code class="type">item()*</code>,</td>
                              <td></td>
                           </tr>
                           <tr class="arg">
                              <td><code>$options</code></td>
                              <td><code class="as">as&nbsp;</code><code class="type">(map(*)|node())?</code></td>
                              <td><code class="assign">:=&nbsp;</code><code>map{}</code></td>
                           </tr>
                           <tr class="return-type">
                              <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>node()*</code></td>
                           </tr>
                        </table>
                     </div>
                  </dd>
                  <dt class="label">Properties</dt>
                  <dd>
                     <p>The one-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>.  It depends on 
		static base URI.
	</p>
                     <p>The two-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-independent">context-independent</a><sup><small>FO</small></sup>. </p>
                  </dd>
                  <dt class="label">Rules</dt>
                  <dd>
                     <p>The <a href="#func-document"><code>document</code></a> function allows access to XML documents identified by
            a URI.</p>
                     <p>The first argument contains a sequence of URI references. These are resolved
            as described below.</p>
                     <p>The second argument, if present, may be either a node, or an options map. 
            Supplying a node is allowed for backwards compatibility: the effect of supplying a node <code>$N</code>
            is the same as supplying the map <code>{"base-uri": fn:base-uri($N)}</code>.
            The effect is that the base URI of the node is used to resolve any relative URI references
            contained in the first argument.</p>
                     <p>If the second argument is supplied as a map, then the 
            <a href="https://qt4cg.org/specifications/xpath-functions-40/#option-parameter-conventions">option parameter conventions</a><sup><small>FO</small></sup> apply. The options available are as follows, and
         apply to each of the documents constructed by the function:</p>
                     <div>
                        <div class="record">
                           <table class="record" border="0">
                              <tr>
                                 <td colspan="2"><code>record(</code></td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">base-uri?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:anyURI</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">trusted?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">dtd-validation?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">stable?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">strip-space?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:boolean?</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">xinclude?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">xsd-validation?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:string</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">use-xsi-schema-location?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:boolean</code>,</td>
                              </tr>
                              <tr class="arg">
                                 <td><code class="opt">schema?</code></td>
                                 <td><code class="as">as&nbsp;</code><code>xs:NCName</code></td>
                              </tr>
                              <tr>
                                 <td colspan="2"><code>)</code></td>
                              </tr>
                           </table>
                        </div>
                     </div>
                     <table class="fos-options">
                        <thead>
                           <tr>
                              <th style="text-align:left; vertical-align:top">Key</th>
                              <th style="text-align:left; vertical-align:top">Value</th>
                              <th style="text-align:left; vertical-align:top">Meaning</th>
                           </tr>
                        </thead>
                        <tbody>
                           <tr>
                              <td style="text-align:left; vertical-align:top">
                                 <p><code>base-uri?</code></p>
                              </td>
                              <td class="fos-thin" colspan="2">Determines the base URI used to resolve any relative URI supplied
                                 in the first argument. This in turn affects the base URI of the constructed
                                 document.
                                 
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:anyURI</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b>Where the first argument supplies a node, the base URI property of that node is used
                     to resolve the URI. Where the first argument supplies an atomic value,
                     the static base URI of the function call is used.</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top" rowspan="3">
                                 <p><code>trusted?</code></p>
                              </td>
                              <td class="fos-thick" colspan="2">Indicates whether processing the document may cause other
                                 external resources to be fetched (including, for example, external entities, an external
                                 DTD,
                                 or documents referenced using <code>xsi:schemaLocation</code> or
                                 XInclude elements).
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:boolean</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b><code>false</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>true</code></td>
                              <td style="text-align:left; vertical-align:top">The document may include references to other external
                                 resources.
                                 </td>
                           </tr>
                           <tr>
                              <td class="fos-thick"><code>false</code></td>
                              <td style="text-align:left; vertical-align:top">The document must not include references to other
                                 external resources unless access to these resources has been explicitly
                                 enabled.
                                 </td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top" rowspan="3">
                                 <p><code>dtd-validation?</code></p>
                              </td>
                              <td class="fos-thick" colspan="2">Determines whether DTD validation takes place.
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:boolean</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b><code>false</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>true</code></td>
                              <td style="text-align:left; vertical-align:top">The input is parsed using a validating XML parser.
                                 The input must contain a <code>DOCTYPE</code> declaration to identify
                                 the DTD to be used for validation. The DTD may be internal or external.
                                 </td>
                           </tr>
                           <tr>
                              <td class="fos-thick"><code>false</code></td>
                              <td style="text-align:left; vertical-align:top">DTD validation does not take place. However, if a
                                 <code>DOCTYPE</code> declaration is present, then it is read, for example
                                 to perform entity expansion.
                                 </td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top" rowspan="3">
                                 <p><code>stable?</code></p>
                              </td>
                              <td class="fos-thick" colspan="2">Determines whether two calls on the <a href="#func-document"><code>document</code></a> function,
                                 with the same URI, the same options, and the same context, are guaranteed to return
                                 the same document node. The default value is <code>true</code>, but this may be overridden
                                 by implementation-defined configuration options.
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:boolean</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b><code>true</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>true</code></td>
                              <td style="text-align:left; vertical-align:top">Given the same explicit and implicit arguments, multiple
                                 calls return the same document node: that is, the function is <a title="" class="termref" href="#"></a>.
                                 </td>
                           </tr>
                           <tr>
                              <td class="fos-thick"><code>false</code></td>
                              <td style="text-align:left; vertical-align:top">Multiple calls with the same explicit and implicit arguments
                                 may return the same document node or different document nodes at the discretion of
                                 the implementation.
                                 </td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top" rowspan="3">
                                 <p><code>strip-space?</code></p>
                              </td>
                              <td class="fos-thick" colspan="2">Determines whether whitespace-only text nodes are removed
                                 from the resulting document.
                                 
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:boolean?</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b><code>true</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>true</code></td>
                              <td style="text-align:left; vertical-align:top">Whitespace stripping is to take place according 
                                 to the <a href="#element-strip-space"><code>xsl:strip-space</code></a>
                                 and <a href="#element-preserve-space"><code>xsl:preserve-space</code></a> declarations of the containing <a title="package" class="termref" href="#dt-package">package</a>:
                                 see <a href="#strip"><i>4.2.2 Stripping Whitespace from a Source Tree</i></a>.
                                 </td>
                           </tr>
                           <tr>
                              <td class="fos-thick"><code>false</code></td>
                              <td style="text-align:left; vertical-align:top">All whitespace-only text nodes are preserved,
                                 unless either (a) DTD validation marks them as ignorable, or (b) XSD validation recognizes
                                 the containing element as having element-only or empty content.
                                 </td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top" rowspan="3">
                                 <p><code>xinclude?</code></p>
                              </td>
                              <td class="fos-thick" colspan="2">Determines whether any <code>xi:include</code> elements in the input
                                 are to be processed using an XInclude processor.
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:boolean</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b><code>false</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>true</code></td>
                              <td style="text-align:left; vertical-align:top">Any <code>xi:include</code> elements are expanded. If there are
                                 <code>xi:include</code> elements and no XInclude processor is available then 
                                 a dynamic error is raised.
                                 </td>
                           </tr>
                           <tr>
                              <td class="fos-thick"><code>false</code></td>
                              <td style="text-align:left; vertical-align:top">Any <code>xi:include</code> elements are handled as
                                 ordinary elements without expansion.
                                 </td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top" rowspan="5">
                                 <p><code>xsd-validation?</code></p>
                              </td>
                              <td class="fos-thick" colspan="2">Determines whether XSD validation takes place, using the
                                 schema definitions present in the static context. The effect of requesting
                                 validation is the same as invoking the <a href="#func-document"><code>document</code></a> function without
                                 validation, and then applying the instruction <a href="#element-copy-of"><code>xsl:copy-of</code></a> to the result,
                                 with corresponding <code>validation</code> and <code>type</code> options,
                                 using the schema identified in the <code>schema</code> option if specified.
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:string</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b><code>skip</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>strict</code></td>
                              <td style="text-align:left; vertical-align:top">Strict XSD validation takes place</td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>lax</code></td>
                              <td style="text-align:left; vertical-align:top">Lax XSD validation takes place</td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>skip</code></td>
                              <td style="text-align:left; vertical-align:top">No XSD validation takes place</td>
                           </tr>
                           <tr>
                              <td class="fos-thick"><code>type Q{uri}local</code></td>
                              <td style="text-align:left; vertical-align:top">XSD validation takes place against the
                                 schema-defined type, present in the selected schema, that has the given URI
                                 and local name.</td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top" rowspan="3">
                                 <p><code>use-xsi-schema-location?</code></p>
                              </td>
                              <td class="fos-thick" colspan="2">When XSD validation takes place, determines whether
                                 schema components referenced using <code>xsi:schemaLocation</code> or <code>xsi:noNamespaceSchemaLocation</code>
                                 attributes within the source document are to be used. The option is ignored
                                 if XSD validation does not take place.
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:boolean</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b><code>false</code></p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                           <tr>
                              <td class="fos-thin"><code>true</code></td>
                              <td style="text-align:left; vertical-align:top">XSD validation uses the schema components referenced 
                                 using <code>xsi:schemaLocation</code> or <code>xsi:noNamespaceSchemaLocation</code>
                                 attributes in addition to the schema components present in the static context;
                                 these components must be compatible as described in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#schema-consistency">4.1.2 Schema Consistency</a>.</td>
                           </tr>
                           <tr>
                              <td class="fos-thick"><code>false</code></td>
                              <td style="text-align:left; vertical-align:top">Any <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code>
                                 attributes in the document are ignored.</td>
                           </tr>
                           <tr>
                              <td style="text-align:left; vertical-align:top">
                                 <p><code>schema?</code></p>
                              </td>
                              <td class="fos-thin" colspan="2">When XSD validation takes place, identifies the schema to be used for validation.
                                 If supplied, the value must match the <code>role</code> attribute of an <a href="#element-import-schema"><code>xsl:import-schema</code></a>
                                 declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. A zero-length string refers to the
                                 schema imported using an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration with no <code>role</code>
                                 attribute.
                                 
                                 <ul>
                                    <li>
                                       <p><b>Type: </b><code>xs:NCName</code></p>
                                    </li>
                                    <li>
                                       <p><b>Default: </b>The schema in the static context of the <a href="#func-document"><code>fn:document</code></a>
               function call (determined by the innermost element with an <code>[xsl:]schema-role</code>
                  attribute if present).</p>
                                    </li>
                                 </ul>
                              </td>
                           </tr>
                        </tbody>
                     </table>
                     <p>A sequence of absolute URI references is obtained as follows.</p>
                     <ul>
                        <li>
                           <p>For an item in <code>$uri-sequence</code> that is an instance of
                     <code>xs:string</code>, <code>xs:anyURI</code>, or
                     <code>xs:untypedAtomic</code>, the value is cast to <code>xs:anyURI</code>. If
                  the resulting URI reference is an absolute URI reference then it is used <em>as
                     is</em>. If it is a relative URI reference <var>R</var>, then it is resolved as follows:</p>
                           <ol class="enumar">
                              <li>
                                 <p>If the second argument <code>$options</code> is an XNode, 
                        then <var>R</var> is resolved against the base URI of that node.</p>
                              </li>
                              <li>
                                 <p>If <code>$options</code> is supplied as a map and includes a value for the
                     <code>base-uri</code> option, then <var>R</var> is resolved against that URI.</p>
                              </li>
                              <li>
                                 <p>Otherwise <var>R</var> is resolved against the static base URI from the static context of the
                  expression containing the call to the <a href="#func-document"><code>document</code></a> function. In cases where the source
                  code of the stylesheet is available at execution time, this will typically be the location of the
                  relevant stylesheet module.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>For an item in <code>$uri-sequence</code> that is a node <var>N</var>, 
                  the node is <a title="atomize" class="termref" href="#dt-atomization">atomized</a>. The result <span class="verb">must</span> be
                  a sequence whose items are all instances of <code>xs:string</code>,
                     <code>xs:anyURI</code>, or <code>xs:untypedAtomic</code>. Each of these values
                  is cast to <code>xs:anyURI</code>, and if the resulting URI reference is an
                  absolute URI reference then it is used <em>as is</em>. If it is a relative URI
                  reference <var>R</var>, then it is resolved as follows:</p>
                           <ol class="enumar">
                              <li>
                                 <p>If the second argument <code>$options</code> is an XNode, 
                        then <var>R</var> is resolved against the base URI of that node.</p>
                              </li>
                              <li>
                                 <p>If <code>$options</code> is supplied as a map and includes a value for the
                     <code>base-uri</code> option, then <var>R</var> is resolved against that URI.</p>
                              </li>
                              <li>
                                 <p>Otherwise <var>R</var> is resolved against the base URI of <var>N</var>.</p>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>A relative URI is resolved against a base URI using the rules of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-resolve-uri"><code>resolve-uri</code></a>
                  function. A dynamic error occurs (see below) if no base URI is available.</p>
                        </li>
                        <li>
                           <p> If <code>$uri-sequence</code> (after atomizing any nodes) contains an 
                  item other than an atomic item of type <code>xs:string</code>, <code>xs:anyURI</code>, or
                     <code>xs:untypedAtomic</code> then a type error is raised <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPTY0004" title="XPTY0004"><span class="error">[ERR XPTY0004] </span></a><sup><small>XP40</small></sup>. </p>
                        </li>
                     </ul>
                     <p>Each of these absolute URI references is then processed as follows. Any fragment
            identifier that is present in the URI reference is removed, and the resulting absolute
            URI is cast to a string and then passed to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function
            defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. This returns a document node. If an error
            occurs during evaluation of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> function, the processor
               <span class="verb">may</span> either raise this error in the normal way, or
               <span class="verb">may</span> recover by ignoring the failure, in which case the failing URI
            will not contribute any nodes to the result of the <a href="#func-document"><code>document</code></a>
            function.</p>
                     <p>If the URI reference contained no fragment identifier, then this document node is
            included in the sequence of nodes returned by the <a href="#func-document"><code>document</code></a>
            function.</p>
                     <p>If the URI reference contained a fragment identifier, then the fragment identifier is
            interpreted according to the rules for the media type of the resource representation
            identified by the URI, and is used to select zero or more nodes that are
            descendant-or-self nodes of the returned document node. As described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>, the media type is available as part of the evaluation context for
            a transformation.</p>
                     <p>The sequence of nodes returned by the function is in document order, with no duplicates.
            This order has no necessary relationship to the order in which URIs were supplied in the
               <code>$uri-sequence</code> argument.</p>
                  </dd>
                  <dt class="label">Error Conditions</dt>
                  <dd>
                     <p>
            <a id="err-XTDE1160"><span class="error">[ERR XTDE1160] </span></a>When a URI reference  contains a fragment identifier, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the media type is not one that is recognized by the
                  processor, or if the fragment identifier does not conform to the rules for
                  fragment identifiers for that media type, or if the fragment identifier selects
                  something other than a sequence of nodes (for example, if it selects a range of
                  characters within a text node). 
         </p>
                     <p>A processor <span class="verb">may</span> provide an option which, if
            selected, causes the processor instead of raising this error, to ignore the fragment
            identifier and return the document node.</p>
                     <p>The set of media types recognized by a processor is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
                     <p>
            
            <a id="err-XTDE1162"><span class="error">[ERR XTDE1162] </span></a>When a URI reference  is a relative reference, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if no base URI is available to
                  resolve the relative reference. This can arise for example when the URI is
                  contained in a node that has no base URI (for example a parentless text node), or
                  when the second argument to the function is a node that has no base URI, or when
                  the base URI from the static context is undefined. 
         </p>
                  </dd>
                  <dt class="label">Notes</dt>
                  <dd>
                     <div class="note">
                        <p>One effect of these rules is that in an interpreted environment 
            where the source code of the stylesheet is available and its base URI is known, then unless
            XML entities or <code>xml:base</code> are used, the expression <code>document("")</code> refers 
            to the document node of the containing stylesheet module (the definitive rules are in <a href="#RFC3986">[RFC3986]</a>). 
            The XML resource containing the stylesheet module is then processed exactly as if it were any 
            other XML document, for example there is no special recognition of <a href="#element-text"><code>xsl:text</code></a> elements, 
            and no special treatment of comments and processing instructions.</p>
                        <p>The XPath rules for function calling ensure that it is a type error if the supplied
            value of the second argument is anything other than a single node. If <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> is enabled, then a
            sequence of nodes may be supplied, and the first node in the sequence will be used.</p>
                     </div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="key"></a>20.2 <a href="#key" style="text-decoration: none">Keys</a></h3>
               <p>Keys provide a way to work with documents that contain an implicit cross-reference
               structure. They make it easier to locate the nodes within a document that have a
               given value for a given attribute or child element, and they provide a hint to the
               implementation that certain access paths in the document need to be efficient.</p>
               <div class="div3">
                  
                  <h4><a id="xsl-key"></a>20.2.1 <a href="#xsl-key" style="text-decoration: none">The <code>xsl:key</code> Declaration</a></h4>
                  <p class="element-syntax"><a id="element-key"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:key<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;use? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;collation? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:key&gt;</code></p>
                  <p>The <a href="#element-key"><code>xsl:key</code></a>
                  <a title="declaration" class="termref" href="#dt-declaration">declaration</a> is used to declare <a title="key" class="termref" href="#dt-key">keys</a>. 
                  The <code>name</code> attribute specifies the name
                  of the key. The value of the <code>name</code> attribute is 
                  an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, which is expanded as
                  described in <a href="#qname"><i>5.1.1 Qualified Names</i></a>. The <code>match</code> attribute 
                  is a <a href="#doc-xslt40-Pattern">Pattern</a>; an <a href="#element-key"><code>xsl:key</code></a> element applies to
                  all nodes that match the pattern specified in the <code>match</code>
                  attribute.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-key" title="key"></a>A <b>key</b> is defined as a set of
                        <a href="#element-key"><code>xsl:key</code></a> declarations in the same
                           <a title="package" class="termref" href="#dt-package">package</a> that share the same
                     name.<span class="definition">]</span>
               </p>
                  <p>The key name is scoped to the containing <a title="package" class="termref" href="#dt-package">package</a>, 
                  and is available for use in calls to the
                     <a href="#func-key"><code>key</code></a> function within that package.</p>
                  <p>The value of the key may be specified either using the <code>use</code> attribute
                  or by means of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a>.</p>
                  <p>
                  <a id="err-XTSE1205"><span class="error">[ERR XTSE1205] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                           <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>use</code> attribute and
                        has non-empty content, or if it has empty content and no <code>use</code>
                        attribute.
               </p>
                  <p>If the <code>use</code> attribute is present, its value is an 
                  <a title="expression" class="termref" href="#dt-expression">expression</a> specifying the values of the key. The
                  expression will be evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> 
                  based on the node that matches the pattern. The result of evaluating the expression is
                     <a title="atomize" class="termref" href="#dt-atomization">atomized</a>. </p>
                  <p>Similarly, if a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a> is present, it is used to determine the values of the
                  key. The sequence constructor will be evaluated with the node that matches the
                  pattern as the context node. The result of evaluating the sequence constructor is
                     <a title="atomize" class="termref" href="#dt-atomization">atomized</a>.</p>
                  <p>
                  <span class="definition">[Definition:&nbsp;</span><a id="dt-key-specifier" title="key specifier"></a>The expression in the
                        <code>use</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
                     within an <a href="#element-key"><code>xsl:key</code></a>
                     declaration are referred to collectively as the <b>key specifier</b>. The
                     key specifier determines the values that may be used to find a node using this
                        <a title="key" class="termref" href="#dt-key">key</a>.<span class="definition">]</span>
               </p>
                  <p>When evaluation of the <a title="key specifier" class="termref" href="#dt-key-specifier">key
                     specifier</a> results in a sequence (after atomization) containing more
                  than one atomic item, the effect depends on the value of the
                     <code>composite</code> attribute:</p>
                  <ul>
                     <li>
                        <p>When the attribute is absent or has the value <code>no</code>, each atomic
                        item in the sequence acts as an individual key. For example, if
                           <code>match="book" use="author" composite="no"</code> is specified, then
                        a <code>book</code> element may be located using the value of any
                           <code>author</code> element.</p>
                     </li>
                     <li>
                        <p>When the attribute is present and has the value <code>yes</code>, the
                        sequence of atomic items is treated as a composite key that must be matched
                        in its entirety. For example, if <code>match="book" use="author"
                           composite="yes"</code> is specified, then a <code>book</code> element may
                        be located using the value of all its <code>author</code> elements, supplied
                        in the correct order.</p>
                     </li>
                  </ul>
                  <p>If there are several <a href="#element-key"><code>xsl:key</code></a> declarations in
                  the same package with the same key name, then
                  they must all have the same <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> for their <code>composite</code>
                  attribute. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is the actual value of the attribute if present, or
                  <code>"no"</code> if the attribute is absent.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>There is no requirement that all the values of a key should have the same
                     type.</p>
                  </div>
                  <p>The presence of an <a href="#element-key"><code>xsl:key</code></a> declaration makes it easy to find a
                  node that matches the <code>match</code> pattern if  the values of the <a title="key specifier" class="termref" href="#dt-key-specifier">key
                     specifier</a> (when applied to that node) are known. It also provides a
                  hint to the implementation that access to the nodes by means of these values needs
                  to be efficient (many implementations are likely to construct an index or hash
                  table to achieve this). </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>An <a href="#element-key"><code>xsl:key</code></a> declaration is not bound to a specific source
                     document. The source document to which it applies is determined only when the
                        <a href="#func-key"><code>key</code></a> function is used to locate nodes using the key.
                     Keys can be used to locate nodes within any source document (including
                     temporary trees), but each use of the <a href="#func-key"><code>key</code></a> function
                     searches one document only.</p>
                     <p>Keys can only be used to search within a tree 
                     that is rooted at a document node.</p>
                  </div>
                  <p>The optional <code>collation</code> attribute is used only when deciding whether
                  two strings are equal for the purposes of key matching. Specifically, two key
                  values <code>$a</code> and <code>$b</code> are considered equal if the result of
                  the function call <code>deep-equal($a, $b,
                        $collation)</code> returns <code>true</code>. The effective collation for an
                     <a href="#element-key"><code>xsl:key</code></a> declaration is the collation specified in its
                     <code>collation</code> attribute if present, resolved against the base URI of
                  the <a href="#element-key"><code>xsl:key</code></a> element, or the 
                  <a title="default collation" class="termref" href="#dt-default-collation">default collation</a> that is in scope for the <a href="#element-key"><code>xsl:key</code></a>
                  declaration otherwise; the effective collation must be the same for all the
                     <a href="#element-key"><code>xsl:key</code></a> declarations making up a <a title="key" class="termref" href="#dt-key">key</a>.</p>
                  <p>
                  <a id="err-XTSE1210"><span class="error">[ERR XTSE1210] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>collation</code>
                        attribute whose value (after resolving against the base URI) is not a URI
                        recognized by the implementation as referring to a collation.
               </p>
                  <p>
                  <a id="err-XTSE1220"><span class="error">[ERR XTSE1220] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are
                        several <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> with the
                        same key name and different effective collations. Two collations are the
                        same if their URIs are equal under the rules for comparing
                           <code>xs:anyURI</code> values, or if the implementation can determine
                        that they are different URIs referring to the same collation.
               </p>
                  <p>
                  <a id="err-XTSE1222"><span class="error">[ERR XTSE1222] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are
                        several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> 
                        with the same key name and
                        different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> 
                        for the <code>composite</code> attribute.
               </p>
                  <p>It is possible to have:</p>
                  <ul>
                     <li>
                        <p>multiple <a href="#element-key"><code>xsl:key</code></a> declarations with the same name;</p>
                     </li>
                     <li>
                        <p>a node that matches the <code>match</code> patterns of several different
                           <a href="#element-key"><code>xsl:key</code></a> declarations, whether these have the same key
                        name or different key names;</p>
                     </li>
                     <li>
                        <p>a node that returns more than one value from its <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a>
                        (which can be treated either as separate
                           individual key values, or as a single composite key value);</p>
                     </li>
                     <li>
                        <p>a key value that identifies more than one node (the key values for different
                        nodes do not need to be unique).</p>
                     </li>
                  </ul>
                  <p>An <a href="#element-key"><code>xsl:key</code></a> declaration with higher 
                  <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> does not override
                  another of lower import precedence; all the <a href="#element-key"><code>xsl:key</code></a> declarations
                  in the stylesheet are effective regardless of their import precedence.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-key"></a>20.2.2 <a href="#func-key" style="text-decoration: none">fn:key</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-map-for-key">next</a> | <a href="#func-document">previous</a>)</p>
                     <ol>
                        <li>
                           <p>The rules for equality comparison have changed to bring keys into line with maps.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1619">1619</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1622">1622</a>&nbsp;29 November 2024]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the nodes within a document or subtree that match a supplied key value.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:key</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$key-name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code>,</td>
                                 <td></td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$key-value</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">xs:anyAtomicType*</code>,</td>
                                 <td></td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$top</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">node()</code></td>
                                 <td><code class="assign">:=&nbsp;</code><code>/</code></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>node()*</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>The two-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>. </p>
                        <p>The three-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The <a href="#func-key"><code>key</code></a> function returns the nodes within a document or subtree that
            have a specified key value.</p>
                        <p>The <code>$key-name</code> argument specifies the name of the <a title="key" class="termref" href="#dt-key">key</a>. 
            The value of the argument <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or </span>
            a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is
            a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then it is expanded as
            described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> (no prefix means no namespace).</p>
                        <p>The <code>$key-value</code> argument to the <a href="#func-key"><code>key</code></a> function is
            considered as a sequence. The effect depends on the value of
               the <code>composite</code> attribute of the corresponding <code>xsl:key</code>
               declaration.</p>
                        <ul>
                           <li>
                              <p>If <code>composite</code> is <code>no</code> or
                     absent, the set of requested key values is formed by atomizing the
                  supplied value of the argument, using the standard <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. Each of
                  the resulting atomic items is considered as a requested key value. The result of
                  the function is a sequence of nodes, in document order and with duplicates
                  removed, comprising those nodes in the selected subtree (see below) that are
                  matched by an <a href="#element-key"><code>xsl:key</code></a> declaration whose name is the same as the
                  supplied key name, where the result of evaluating the 
                  <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> contains a value that is equal
                  to one of these requested key values: the rules for comparing two items
                  are given below. No error is reported if two values are encountered that
                  are not comparable; they are regarded for the purposes of this function as being
                  not equal. </p>
                              <p>If the second argument is an empty sequence, the result of the function will be an
                  empty sequence.</p>
                           </li>
                           <li>
                              <p>If <code>composite</code> is <code>yes</code>, the requested key
                  value is the sequence formed by atomizing the supplied value of the argument,
                  using the standard <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. 
                  The result of the function is a sequence of nodes, in document
                  order and with duplicates removed, comprising those nodes in the selected subtree
                  (see below) that are matched by an <a href="#element-key"><code>xsl:key</code></a> declaration whose name
                  is the same as the supplied key name, where the result of evaluating the <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> is deep-equal to the requested
                  key value, under the rules appropriate to the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>deep-equal</code></a>
                  function applied to the two values in question: the detailed comparison rules are 
                  defined below.</p>
                              <p>If the second argument is an empty sequence, the result of the
                  function will be the set of nodes having an empty sequence as the value of the key
                  specifier.</p>
                           </li>
                        </ul>
                        <p>Two atomic items <var>K<sub>1</sub></var> and <var>K<sub>2</sub></var> are deemed equal if they satisfy 
            one of the following rules:</p>
                        <ol class="enumar">
                           <li>
                              <p>If both <var>K<sub>1</sub></var> and <var>K<sub>2</sub></var> are of type 
               <code>xs:string</code>, <code>xs:untypedAtomic</code>,
            or <code>xs:anyURI</code>, then they are deemed equal if 
               <code>compare(<var>K<sub>1</sub></var>, <var>K<sub>2</sub></var>, $collation)</code>
            returns zero, where <code>$collation</code> is the collation of the key definition.</p>
                           </li>
                           <li>
                              <p>Otherwise, they are deemed equal if <code>atomic-equal(<var>K<sub>1</sub></var>, <var>K<sub>2</sub></var>)</code>
            returns true.</p>
                           </li>
                        </ol>
                        <p>When <code>composite="yes"</code>, then two sequences of atomic
            items <var>S<sub>1</sub></var> and <var>S<sub>2</sub></var> are deemed equal if <code>deep-equal(<var>S<sub>1</sub></var>,
            <var>S<sub>2</sub></var>, { 'items-equal': $F }))</code> returns true, where <code>$F</code> is the function
            just described for comparing atomic items.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The rules for comparing items have changed in this version of the specification,
            in the interests of bringing keys into line with maps. The main differences are:</p>
                           <ul>
                              <li>
                                 <p>Numeric equality is transitive. In particular, when comparing an <code>xs:double</code>
               value to an <code>xs:decimal</code>, they must now be exactly numerically equal; the <code>xs:decimal</code>
               was previously converted to the nearest <code>xs:double</code>.</p>
                              </li>
                              <li>
                                 <p>The implicit timezone is no longer used when comparing date/time values with a timezone
               to values without one. To be equal, the values must either both have a timezone, or both be without one.</p>
                              </li>
                           </ul>
                        </div>
                        <p>The third argument is used to identify the selected subtree. If the argument is present,
            the selected subtree is the set of nodes that have <var>$top</var> as an
            ancestor-or-self node. If the argument is omitted, the selected subtree is the document
            containing the context node. This means that the third argument effectively defaults to
               <code>/</code>.</p>
                        <p>The result of the <a href="#func-key"><code>key</code></a> function can be described more specifically
            as follows. The result is a sequence containing every node <var>$N</var> that satisfies
            the following conditions:</p>
                        <ul>
                           <li>
                              <p>
                  <code>$N/ancestor-or-self::node() intersect $top</code> is non-empty. (If the
                  third argument is omitted, <code>$top</code> defaults to <code>/</code>)</p>
                           </li>
                           <li>
                              <p>
                  <var>$N</var> matches the pattern specified in the <code>match</code> attribute of
                  an <a href="#element-key"><code>xsl:key</code></a> declaration whose <code>name</code> attribute matches
                  the name specified in the <code>$key-name</code> argument.</p>
                           </li>
                           <li>
                              <p>When <code>composite="no"</code>,  and the
                     <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> of that
                     <a href="#element-key"><code>xsl:key</code></a> declaration is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>$N</var>, the
                     <a title="atomize" class="termref" href="#dt-atomization">atomized</a> value of the resulting
                  sequence includes a value that compares equal to at least one item in the atomized
                  value of the sequence supplied as <code>$key-value</code>, using the equality
                  comparison defined above.</p>
                              <p>When <code>composite="yes"</code>,  and the
                     <a title="key specifier" class="termref" href="#dt-key-specifier">key specifier</a> of that
                     <a href="#element-key"><code>xsl:key</code></a> declaration is evaluated with a <a title="singleton focus" class="termref" href="#dt-singleton-focus">singleton focus</a> based on <var>$N</var>, the
                     <a title="atomize" class="termref" href="#dt-atomization">atomized</a> value of the resulting
                  sequence compares equal to the atomized value of the sequence supplied as
                     <code>$key-value</code>, under the rules of the
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-deep-equal"><code>deep-equal</code></a> function as described above.</p>
                           </li>
                        </ul>
                        <p>The sequence returned by the <a href="#func-key"><code>key</code></a> function will be in document
            order, with duplicates (that is, nodes having the same identity) removed. </p>
                        <p>Different rules apply when <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0 compatible behavior</a> is enabled.</p>
                        <p>A key (that is, a set of <a href="#element-key"><code>xsl:key</code></a>
            declarations sharing the same key name) is processed in backwards compatible mode if (a)
            at least one of the <a href="#element-key"><code>xsl:key</code></a> elements in the definition of the key enables backwards
            compatible behavior, and (b) the effective value of the <code>composite</code> attribute
            is <code>no</code>.</p>
                        <p>When a key is processed in backwards compatible mode,
            then:</p>
                        <ul>
                           <li>
                              <p>The result of evaluating the key specifier in any <a href="#element-key"><code>xsl:key</code></a>
               declaration having this key name is converted after atomization to a sequence of
               strings, by applying a cast to each item in the sequence.</p>
                           </li>
                           <li>
                              <p>When the first argument to the <a href="#func-key"><code>key</code></a> function specifies this key
               name, then the value of the second argument is converted after atomization to a
               sequence of strings, by applying a cast to each item in the sequence. The values are
               then compared as strings.</p>
                           </li>
                        </ul>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1260"><span class="error">[ERR XTDE1260] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value
                     of <code>$key-name</code> is not a valid QName, or if there is no namespace
                  declaration in scope for the prefix of the QName, or if the name obtained by
                  expanding the QName is not the same as the expanded name of any
                     <a href="#element-key"><code>xsl:key</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the
                  processor is able to detect the error statically (for example, when the argument
                  is supplied as a string literal), then the processor <span class="verb">may</span>
                  optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static
                  error</a>.
         </p>
                        <p>
            <a id="err-XTDE1270"><span class="error">[ERR XTDE1270] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                        error</a> to call the <a href="#func-key"><code>key</code></a> function with
                  two arguments if there is no <a title="context node" class="termref" href="#dt-context-node">context
                  node</a>, or if the root of the tree containing the context node is not a
                  document node; or to call the function with three arguments if the root of the
                  tree containing the node supplied in the third argument is not a document
                  node.
         </p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>Untyped atomic items are converted to strings, not to the type of the other operand.
            This means, for example, that if the expression in the <code>use</code> attribute
            returns a date, supplying an untyped atomic item in the call to the
               <a href="#func-key"><code>key</code></a> function will return an empty sequence.</p>
                        </div>
                     </dd>
                     <dt class="label">Examples</dt>
                     <dd>
                        <div class="example">
                           <table style="border:1px solid; padding:5px; width:100%" class="medium">
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="example">
                                          
                                          <div class="exampleHeader"><a id="d5e46947"></a>Example: Using a Key to Follow Cross-References</div>
                                          <p>Given a declaration</p>
                                          <div class="exampleInner">
                                             <pre>&lt;xsl:key name="idkey" match="div" use="@id"/&gt;</pre>
                                          </div>
                                          <p>an expression <code>key("idkey",@ref)</code> will return the same nodes as
                     <code>id(@ref)</code>, assuming that the only ID attribute declared in the XML
                  source document is:</p>
                                          <div class="exampleInner">
                                             <pre>&lt;!ATTLIST div id ID #IMPLIED&gt;</pre>
                                          </div>
                                          <p>and that the <code>ref</code> attribute of the context node contains no
                  whitespace.</p>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="example">
                                          
                                          <div class="exampleHeader"><a id="d5e46969"></a>Example: Using a Key to Generate Hyperlinks</div>
                                          <p>Suppose a document describing a function library uses a <code>prototype</code>
                  element to define functions</p>
                                          <div class="exampleInner">
                                             <pre>&lt;prototype name="sqrt" return-type="xs:double"&gt;
  &lt;arg type="xs:double"/&gt;
&lt;/prototype&gt;</pre>
                                          </div>
                                          <p>and a <code>function</code> element to refer to function names</p>
                                          <div class="exampleInner">
                                             <pre>&lt;function&gt;sqrt&lt;/function&gt;</pre>
                                          </div>
                                          <p>Then the stylesheet could generate hyperlinks between the references and
                  definitions as follows:</p>
                                          <div class="exampleInner">
                                             <pre>&lt;xsl:key name="func" match="prototype" use="@name"/&gt;

&lt;xsl:template match="function"&gt;
&lt;b&gt;
  &lt;a href="#{generate-id(key('func',.))}"&gt;
    &lt;xsl:apply-templates/&gt;
  &lt;/a&gt;
&lt;/b&gt;
&lt;/xsl:template&gt;

&lt;xsl:template match="prototype"&gt;
  &lt;p&gt;
    &lt;a name="{generate-id()}"&gt;
      &lt;b&gt;Function: &lt;/b&gt;
      ...
    &lt;/a&gt;
  &lt;/p&gt;
  &lt;/xsl:template&gt;</pre>
                                          </div>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>When called with two arguments, the <a href="#func-key"><code>key</code></a> function always returns
               nodes that are in the same document as the context node. To retrieve a node from any
               other document, it is necessary either to change the context node, or to supply a
               third argument.</p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="example">
                                          
                                          <div class="exampleHeader"><a id="d5e46996"></a>Example: Using Keys to Reference other Documents</div>
                                          <p>For example, suppose a document contains bibliographic references in the form
                     <code>&lt;bibref&gt;XSLT&lt;/bibref&gt;</code>, and there is a separate XML
                  document <code>bib.xml</code> containing a bibliographic database with entries in
                  the form:</p>
                                          <div class="exampleInner">
                                             <pre>&lt;entry name="XSLT"&gt;...&lt;/entry&gt;</pre>
                                          </div>
                                          <p>Then the stylesheet could use the following to transform the <code>bibref</code>
                  elements:</p>
                                          <div class="exampleInner">
                                             <pre>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:variable name="name" select="."/&gt;
  &lt;xsl:apply-templates select="document('bib.xml')/key('bib', $name)"/&gt;
&lt;/xsl:template&gt;</pre>
                                          </div>
                                          <div class="note">
                                             <p class="prefix"><b>Note:</b></p>
                                             <p>This relies on the ability in XPath 2.0 to have a function call on the
                     right-hand side of the <code>/</code> operator in a path expression.</p>
                                          </div>
                                          <p>The following code would also work:</p>
                                          <div class="exampleInner">
                                             <pre>&lt;xsl:key name="bib" match="entry" use="@name"/&gt;

&lt;xsl:template match="bibref"&gt;
  &lt;xsl:apply-templates select="key('bib', ., document('bib.xml'))"/&gt;
&lt;/xsl:template&gt;</pre>
                                          </div>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="example">
                                          
                                          <div class="exampleHeader"><a id="d5e47026"></a>Example: Using a Composite Key</div>
                                          <p>This example uses a composite key consisting of first name and last name to locate
                  employees in an employee file.</p>
                                          <p>The key can be defined like this:</p>
                                          <div class="exampleInner">
                                             <pre>
&lt;xsl:key name="emp-name-key" 
         match="employee" 
         use="name/first, name/last" 
         composite="yes"/&gt;</pre>
                                          </div>
                                          <p>A particular employee can then be located using the function call:</p>
                                          <div class="exampleInner">
                                             <pre>key('emp-name-key', ('Tim', 'Berners-Lee'), doc('employees.xml'))</pre>
                                          </div>
                                       </div>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-map-for-key"></a>20.2.3 <a href="#func-map-for-key" style="text-decoration: none">fn:map-for-key</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-current">next</a> | <a href="#func-key">previous</a>)</p>
                     <ol>
                        <li>
                           <p>New in 4.0.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1619">1619</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1622">1622</a>&nbsp;29 November 2024]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Delivers the content of a key, for a specific document or subtree, as a map.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:map-for-key</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$key-name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code>,</td>
                                 <td></td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$top</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">(document-node() | element())</code></td>
                                 <td><code class="assign">:=&nbsp;</code><code>/</code></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>map(xs:anyAtomicType, node()*)</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The effect of the function is to return a map <code>$M</code> such that
         <code>map:get($M, $key)</code> returns the same result as <code>key($key-name, $key, $top)</code>.</p>
                        <p>The function is defined only for maps that satisfy the following constraints:</p>
                        <ol class="enumar">
                           <li>
                              <p>The key's collation must be the Unicode Codepoint Collation.</p>
                           </li>
                           <li>
                              <p>The key must not specify <code>composite=yes</code>.</p>
                           </li>
                        </ol>
                        <p>The <code>$key-name</code> argument specifies the name of the <a title="key" class="termref" href="#dt-key">key</a>. 
            The value of the argument <span class="verb">must</span> be either an <code>xs:QName</code>, or 
            a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is
            a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, then it is expanded as
            described in <a href="#qname"><i>5.1.1 Qualified Names</i></a> (no prefix means no namespace).</p>
                        <p>The <code>$top</code> argument is used to identify the selected subtree. If the argument is present,
            the selected subtree is the set of nodes that have <code>$top</code> as an
            ancestor-or-self node. If the argument is omitted, the selected subtree is the document
            containing the context node. This means that the third argument effectively defaults to
               <code>/</code>.</p>
                        <p>The returned map contains one entry (<var>K</var>, <var>V</var>) for every atomic item <var>K</var>
         where the result of <code>key($key-name, <var>K</var>, $top)</code> is not empty, with <var>V</var>
         set to the result of <code>key($key-name, <var>K</var>, $top)</code>.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value
                      is not a valid QName, or if there is no namespace
                  declaration in scope for the prefix of the QName, or if the name obtained by
                  expanding the QName is not the same as the expanded name of any
                     <a href="#element-key"><code>xsl:key</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the
                  processor is able to detect the error statically (for example, when the argument
                  is supplied as a string literal), then the processor <span class="verb">may</span>
                  optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static
                  error</a> <span class="error">[see <a href="#err-XTDE1260">ERR XTDE1260</a>]</span>.          
         </p>
                        <p>
            <a id="err-XTDE1262"><span class="error">[ERR XTDE1262] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                        error</a> if the key identified in a call to the function <a href="#func-map-for-key"><code>map-for-key</code></a>
               is unsuitable because it uses a collation other than the Unicode Codepoint Collation, or because
               it is defined with <code>composite=yes</code>.
         </p>
                        <p>
            It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                        error</a> to call the <a href="#func-key"><code>key</code></a> function with
                  two arguments if there is no <a title="context node" class="termref" href="#dt-context-node">context
                  node</a>, or if the root of the tree containing the context node is not a
                  document node; or to call the function with three arguments if the root of the
                  tree containing the node supplied in the third argument is not a document
                  node <span class="error">[see <a href="#err-XTDE1270">ERR XTDE1270</a>]</span>. 
         </p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The function has two main uses:</p>
                           <ul>
                              <li>
                                 <p>It enables the key values present in a key to be enumerated.</p>
                              </li>
                              <li>
                                 <p>It enables the keys for multiple documents to be combined into a single map, for example
            by using <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-map-merge"><code>map:merge</code></a>.</p>
                              </li>
                           </ul>
                        </div>
                     </dd>
                     <dt class="label">Examples</dt>
                     <dd>
                        <div class="example">
                           <table style="border:1px solid; padding:5px; width:100%" class="medium">
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="example">
                                          
                                          <div class="exampleHeader"><a id="d5e47212"></a>Example: Finding keys that are present in one document but absent in another</div>
                                          <p>This example uses a key identifying employees in an employee file by their social security
                     number.</p>
                                          <p>The key might be defined like this:</p>
                                          <div class="exampleInner">
                                             <pre>
   &lt;xsl:key name="emp-name-key" 
         match="employee" 
         use="SSN"/&gt;</pre>
                                          </div>
                                          <p>Given two documents <code>$doc1</code> and <code>$doc2</code>, the following expression
                     returns a map representing the employees who are present in the first document
                     but not the second:</p>
                                          <div class="exampleInner">
                                             <pre>map-for-key('emp-name-key', $doc1)
   =&gt; map:remove(map-for-key('emp-name-key', $doc2) =&gt; map:keys())</pre>
                                          </div>
                                       </div>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="func-copy-of"></a>20.3 <a href="#func-copy-of" style="text-decoration: none">fn:copy-of</a></h3>
               <dl>
                  <dt class="label">Summary</dt>
                  <dd>
                     <p>Returns a deep copy of the sequence supplied as the <code>$input</code> argument, or of the
            context item if the argument is absent.</p>
                  </dd>
                  <dt class="label">Signature</dt>
                  <dd>
                     <div class="proto">
                        <table class="proto" border="0">
                           <tr class="name">
                              <td colspan="3"><code class="function">fn:copy-of</code>(</td>
                           </tr>
                           <tr class="arg">
                              <td><code>$input</code></td>
                              <td><code class="as">as&nbsp;</code><code class="type">item()*</code></td>
                              <td><code class="assign">:=&nbsp;</code><code>.</code></td>
                           </tr>
                           <tr class="return-type">
                              <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>item()*</code></td>
                           </tr>
                        </table>
                     </div>
                  </dd>
                  <dt class="label">Properties</dt>
                  <dd>
                     <p>The zero-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic">nondeterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-independent">context-independent</a><sup><small>FO</small></sup>. </p>
                     <p>The one-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic">nondeterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-independent">context-independent</a><sup><small>FO</small></sup>. </p>
                  </dd>
                  <dt class="label">Rules</dt>
                  <dd>
                     <p>The zero-argument form of this function is defined so that <code>copy-of()</code>
         returns the value of <code>internal:copy-item(.)</code>, where <code>internal:copy-item</code> (which
            exists only for the purpose of this exposition) is defined below. Informally, <code>copy-of()</code>
         copies the context item.</p>
                     <p>The single argument form of this function is defined in terms of the
         <code>internal:copy-item</code> as follows: <code>copy-of($input)</code> is equivalent
            to <code>$input ! internal:copy-item(.)</code>. Informally, <code>copy-of($input)</code> copies each item in the
         input sequence in turn.</p>
                     <p>The <code>internal:copy-item</code> function is defined as follows:</p>
                     <div class="exampleInner">
                        <pre>
&lt;xsl:function name="internal:copy-item" as="item()" 
              new-each-time="maybe"&gt;
  &lt;xsl:param name="input" as="item()"/&gt;
  &lt;xsl:copy-of select="$input" 
               copy-namespaces="yes"
               copy-accumulators="yes"
               validation="preserve"/&gt;
&lt;/xsl:function&gt;</pre>
                     </div>
                     <p>The streamability analysis, however, is different: see <a href="../xslt-streaming-40/#classifying-built-in-functions">12.8 Classifying Calls to Built-In Functions</a><sup><small>SG</small></sup>.</p>
                     <p>The use of <code>new-each-time="maybe"</code> in the above definition means that 
            if the <code>internal:copy-item</code> function is called more than once with the same node as argument 
            (whether or not these calls are part of the same call on <code>copy-of</code>), then it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether each
            call returns the same node, or whether multiple calls return different nodes.
           Returning the original node, however, is not allowed, except as an optimization when the processor
         can determine that this is equivalent.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>One case where such optimization might be possible is when the copy is immediately atomized.</p>
                     </div>
                  </dd>
                  <dt class="label">Notes</dt>
                  <dd>
                     <div class="note">
                        <p>The <a href="#func-copy-of"><code>copy-of</code></a> function is available for use (and is primarily
            intended for use) when a source document is processed using streaming. It can also be
            used when not streaming. The effect, 
            when applied to element and document nodes,
            is to take a copy of the subtree rooted at the
            current node, and to make this available as a normal tree: one that can be processed without
            any of the restrictions that apply while streaming, for example only being able to
            process children once. The copy, of course, does not include siblings or ancestors of
            the context node, so any attempt to navigate to siblings or ancestors will result in an
            empty sequence being returned.</p>
                        <p>All nodes in the result sequence will be parentless.</p>
                        <p>If atomic items or functions (including maps and arrays) are present in the input sequence,
         they will be included unchanged at the corresponding position of the result sequence.</p>
                        <p>Accumulator values are taken from the copied
            document as described in <a href="#copying-accumulators"><i>19.10 Copying Accumulator Values</i></a>.</p>
                     </div>
                  </dd>
                  <dt class="label">Examples</dt>
                  <dd>
                     <div class="example">
                        <table style="border:1px solid; padding:5px; width:100%" class="medium">
                           <tbody>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>Using <code>copy-of()</code> while streaming:</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>This example copies from the source document all employees who work in marketing and
               are based in Dubai. Because there are two accesses using the child axis, it is not
               possible to do this without buffering each employee in memory, which can be achieved
               using the <a href="#func-copy-of"><code>copy-of</code></a> function.</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <div class="exampleInner">
                                       <pre>&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:sequence select="copy-of(employees/employee)
                          [department='Marketing' and location='Dubai']"/&gt;
&lt;/xsl:source-document&gt;</pre>
                                    </div>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="func-snapshot"></a>20.4 <a href="#func-snapshot" style="text-decoration: none">fn:snapshot</a></h3>
               <dl>
                  <dt class="label">Summary</dt>
                  <dd>
                     <p>Returns a copy of a sequence, retaining copies of the ancestors and descendants of any node in the input sequence, together with their
            attributes and namespaces.</p>
                  </dd>
                  <dt class="label">Signature</dt>
                  <dd>
                     <div class="proto">
                        <table class="proto" border="0">
                           <tr class="name">
                              <td colspan="3"><code class="function">fn:snapshot</code>(</td>
                           </tr>
                           <tr class="arg">
                              <td><code>$input</code></td>
                              <td><code class="as">as&nbsp;</code><code class="type">item()*</code></td>
                              <td><code class="assign">:=&nbsp;</code><code>.</code></td>
                           </tr>
                           <tr class="return-type">
                              <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>item()*</code></td>
                           </tr>
                        </table>
                     </div>
                  </dd>
                  <dt class="label">Properties</dt>
                  <dd>
                     <p>The zero-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic">nondeterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-independent">context-independent</a><sup><small>FO</small></sup>. </p>
                     <p>The one-argument form of this function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-nondeterministic">nondeterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-independent">context-independent</a><sup><small>FO</small></sup>. </p>
                  </dd>
                  <dt class="label">Rules</dt>
                  <dd>
                     <p>The zero-argument form of this function is defined so that <code>snapshot()</code>
            returns the value of <code>internal:snaphot-item(.)</code>, where <code>internal:snapshot-item</code> (which
            exists only for the purpose of this exposition) is defined below. Informally, <code>snapshot()</code>
            takes a snapshot of the context item.</p>
                     <p>The single argument form of this function is defined in terms of the
            <code>internal:snapshot-item</code> as follows: <code>snapshot($input)</code> is equivalent
            to <code>$input ! internal:snapshot-item(.)</code>. Informally, <code>snapshot($input)</code> takes a snapshot of each item in the
            input sequence in turn.</p>
                     <p>The <code>internal:snapshot-item</code> function behaves as follows:</p>
                     <ul>
                        <li>
                           <p>If the supplied item is an atomic item or a function item (including maps
            and arrays), then it returns that item unchanged.</p>
                        </li>
                        <li>
                           <p>If the supplied item is a node, then it returns a <a title="snapshot" class="termref" href="#dt-snapshot">snapshot</a>
            of that node, as defined below.</p>
                        </li>
                     </ul>
                     <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-snapshot" title="snapshot"></a>A <b>snapshot</b> of a node <var>N</var>
               is a deep copy of <var>N</var>, as produced by the <a href="#element-copy-of"><code>xsl:copy-of</code></a>
               instruction with <code>copy-namespaces</code> set to <code>yes</code>,
               <code>copy-accumulators</code> set to <code>yes</code>, and
                  <code>validation</code> set to <code>preserve</code>, with the additional property
               that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor
               whose name, node-kind, and base URI are the same as the corresponding ancestor of
               <var>N</var>, and that has copies of the attributes, namespaces and accumulator values of the
               corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of
                  <code>xs:anyType</code>, has the properties <code>nilled</code>,
                  <code>is-id</code>, and <code>is-idref</code> set to <code>false</code>, and has no children
               other than the child that is a copy of <var>N</var> or one of its
               ancestors.<span class="definition">]</span>
         </p>
                     <p>If the function is called more than once with the same argument, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether each
            call returns the same node, or whether multiple calls return different nodes. That is,
            the result of the expression <code>snapshot($X) is snapshot($X)</code> is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
                     <p>Except for the effect on accumulators, the <code>internal:snapshot-item</code> function can be expressed
            as follows:</p>
                     <div class="exampleInner">
                        <pre>
    &lt;xsl:function name="internal:snapshot-item" as="item()"&gt;
        &lt;xsl:param name="input" as="item()"/&gt;
        &lt;xsl:apply-templates select="$input" mode="internal:snapshot"/&gt;
    &lt;/xsl:function&gt;
    
    &lt;!-- for atomic items and function items, return the item unchanged --&gt;
    
    &lt;xsl:template match="." mode="internal:snapshot" priority="1"&gt;
        &lt;xsl:sequence select="."/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for a document node, or any other root node, return a deep copy --&gt;
    
    &lt;xsl:template match="root()" mode="internal:snapshot" priority="5"&gt;
        &lt;xsl:copy-of select="."/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for an element, comment, text node, or processing instruction: --&gt;
    
    &lt;xsl:template match="node()" mode="internal:snapshot" 
                                 as="node()" priority="3"&gt;
        &lt;xsl:sequence select="internal:graft-to-parent(
                                ., .., function($n){$n/node()})"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for an attribute: --&gt;
    
    &lt;xsl:template match="@*" mode="internal:snapshot" 
                             as="attribute()" priority="3"&gt;
        &lt;xsl:variable name="name" select="node-name(.)"/&gt;
        &lt;xsl:sequence select="internal:graft-to-parent(., .., 
                                function($n){$n/@*[node-name(.) = $name]})"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- for a namespace node: --&gt;
    
    &lt;xsl:template match="namespace-node()" mode="internal:snapshot" 
                  as="namespace-node()" priority="3"&gt;
        &lt;xsl:variable name="name" select="local-name(.)"/&gt;
        &lt;xsl:sequence select="internal:graft-to-parent(., .., 
                  function($n){$n/namespace-node()[local-name(.) = $name]})"/&gt;
    &lt;/xsl:template&gt;
    
    &lt;!-- make a copy C of a supplied node N, grafting it to a shallow copy of 
         C's original parent, and returning the copy C --&gt;
    
    &lt;xsl:function name="internal:graft-to-parent" as="node()"&gt;
        &lt;xsl:param name="n" as="node()"/&gt;
        &lt;xsl:param name="original-parent" as="node()?"/&gt;
        &lt;xsl:param name="down-function" as="function(node()) as node()"/&gt;
        &lt;xsl:choose&gt;
            &lt;xsl:when test="exists($original-parent)"&gt;
                &lt;xsl:variable name="p" as="node()"&gt;
                    &lt;xsl:copy select="$original-parent"&gt;
                        &lt;xsl:copy-of select="@*"/&gt;
                        &lt;xsl:copy-of select="$n"/&gt;
                    &lt;/xsl:copy&gt;
                &lt;/xsl:variable&gt;
                &lt;xsl:variable name="copied-parent" 
                     select="internal:graft-to-parent(
                        $p, $original-parent/.., function($n){$n/node()}))"/&gt;
                &lt;xsl:sequence select="$down-function($copied-parent)"/&gt;              
            &lt;/xsl:when&gt;
            &lt;xsl:otherwise&gt;
                &lt;xsl:sequence select="$n"/&gt;
            &lt;/xsl:otherwise&gt;
        &lt;/xsl:choose&gt;
    &lt;/xsl:function&gt;</pre>
                     </div>
                  </dd>
                  <dt class="label">Notes</dt>
                  <dd>
                     <div class="note">
                        <p>The <a href="#func-snapshot"><code>snapshot</code></a> function is available for use (and is primarily
            intended for use) when a source document is processed using streaming. It can also be
            used when not streaming. The effect is to take a copy of the subtree rooted at the
            current node, along with copies of the ancestors and their attributes, and to make this
            available as a normal tree, that can be processed without any of the restrictions that
            apply while streaming, for example only being able to process children once. The copy,
            of course, does not include siblings of the context node or of its ancestors, so any
            attempt to navigate to these siblings will result in an empty sequence being
            returned.</p>
                        <p>For parentless nodes, the effect of <code>snapshot($x)</code> is identical to the effect
         of <code>copy-of($x)</code>.</p>
                     </div>
                  </dd>
                  <dt class="label">Examples</dt>
                  <dd>
                     <div class="example">
                        <table style="border:1px solid; padding:5px; width:100%" class="medium">
                           <tbody>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>Using <code>snapshot()</code> while streaming:</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <p>This example copies from the source document all employees who work in marketing and
               are based in Dubai. It assumes that employees are grouped by location. Because there
               are two accesses using the child axis (referencing <code>department</code> and
                  <code>salary</code>), it is not possible to do this without buffering each
               employee in memory. The <a href="#func-snapshot"><code>snapshot</code></a> function is used in preference
               to the simpler <a href="#func-copy-of"><code>copy-of</code></a> so that access to attributes of the
               parent <code>location</code> element remains possible.</p>
                                 </td>
                              </tr>
                              <tr>
                                 <td style="text-align:left; vertical-align:top" colspan="2">
                                    <div class="exampleInner">
                                       <pre>&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:for-each select="snapshot(locations/location[@name='Dubai']
                          /employee)[department='Marketing']"&gt;
    &lt;employee&gt;
      &lt;location code="{../@code}"/&gt;
      &lt;salary value="{salary}"/&gt;
    &lt;/employee&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:source-document&gt;</pre>
                                    </div>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="misc-func"></a>20.5 <a href="#misc-func" style="text-decoration: none">Miscellaneous Additional Functions</a></h3>
               <div class="div3">
                  
                  <h4><a id="func-current"></a>20.5.1 <a href="#func-current" style="text-decoration: none">fn:current</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#map-instructions">next</a> | <a href="#func-map-for-key">previous</a>)</p>
                     <ol>
                        <li>
                           <p>In XSLT 4.0, the function item <code>current#0</code> retains the value of the current
         item within its captured context.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the item that is the context item for the evaluation of the containing XPath
            expression</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:current</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">item()</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The <a href="#func-current"><code>current</code></a> function, used within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>, returns the item that was the <a title="context item" class="termref" href="#dt-context-item">context item</a> at the point where the expression was
            invoked from the XSLT <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This is
            referred to as the current item. For an outermost expression (an expression not
            occurring within another expression), the current item is always the same as the context
            item. Thus,</p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:value-of select="current()"/&gt;</pre>
                        </div>
                        <p>means the same as</p>
                        <div class="exampleInner">
                           <pre>&lt;xsl:value-of select="."/&gt;</pre>
                        </div>
                        <p>However, within square brackets, or on the right-hand side of the <code>/</code>
            operator, the current item is generally different from the context item.</p>
                        <p>If the <a href="#func-current"><code>current</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, its value is the item that is
            being matched against the pattern.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1360"><span class="error">[ERR XTDE1360] </span></a>If the <a href="#func-current"><code>current</code></a> function is evaluated within an expression
                  that is evaluated when the context item is absent, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">
                     dynamic error</a> occurs.
         </p>
                     </dd>
                     <dt class="label">Examples</dt>
                     <dd>
                        <div class="example">
                           <table style="border:1px solid; padding:5px; width:100%" class="medium">
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>The instruction:</p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="exampleInner">
                                          <pre>&lt;xsl:apply-templates select="//glossary/entry[@name=current()/@ref]"/&gt;</pre>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>will process all <code>entry</code> elements that have a <code>glossary</code> parent
               element and that have a <code>name</code> attribute with value equal to the value of
               the current item’s <code>ref</code> attribute. This is different from</p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="exampleInner">
                                          <pre>&lt;xsl:apply-templates select="//glossary/entry[@name=./@ref]"/&gt;</pre>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>which means the same as</p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="exampleInner">
                                          <pre>&lt;xsl:apply-templates select="//glossary/entry[@name=@ref]"/&gt;</pre>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>and so would process all <code>entry</code> elements that have a
                  <code>glossary</code> parent element and that have a <code>name</code> attribute
               and a <code>ref</code> attribute with the same value.</p>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-unparsed-entity-uri"></a>20.5.2 <a href="#func-unparsed-entity-uri" style="text-decoration: none">fn:unparsed-entity-uri</a></h4>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the URI (system identifier) of an unparsed entity</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:unparsed-entity-uri</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$entity-name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">xs:string</code>,</td>
                                 <td></td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$doc</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">node()</code></td>
                                 <td><code class="assign">:=&nbsp;</code><code>.</code></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:anyURI</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>Calling the single-argument form of this function has the same effect as calling the
         two-argument form with the context item as the second argument.</p>
                        <p>The two-argument <a href="#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a> 
            function returns the URI of the unparsed
            entity whose name is given by the value of the <code>$entity-name</code> argument, in
            the document containing the node supplied as the 
               value of the <code>$doc</code> argument. It
            returns the zero-length <code>xs:anyURI</code> if there is no such entity. This function
            maps to the <code>dm:unparsed-entity-system-id</code> accessor defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1370"><span class="error">[ERR XTDE1370] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.
         </p>
                        <p>The following errors may be raised when <code>$node</code> is omitted:</p>
                        <ul>
                           <li>
                              <p>If the context item is absent, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> 
                  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.</p>
                           </li>
                           <li>
                              <p>If the context item is not a node, <a title="type error" class="termref" href="#dt-type-error">type error</a> 
                  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPTY0004" title="XPTY0004"><span class="error">[ERR XPTY0004] </span></a><sup><small>XP40</small></sup>.</p>
                           </li>
                        </ul>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The XDM accessor <code>dm:unparsed-entity-system-id</code> is defined to return an absolute URI,
            obtained by resolving the system identifier as written against the base URI of the document. If no
            base URI is available for the document, the <a href="#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a> function
            <span class="verb">should</span> return the system identifier as written, without any attempt to make
            it absolute.</p>
                           <p>XML permits more than one unparsed entity declaration with the same name to appear,
         and says that the first declaration is the one that should be used. This rule <span class="verb">should</span> be 
         respected during construction of the data model; the data model instance should not contain more than one
         unparsed entity with the same name.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-unparsed-entity-public-id"></a>20.5.3 <a href="#func-unparsed-entity-public-id" style="text-decoration: none">fn:unparsed-entity-public-id</a></h4>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the public identifier of an unparsed entity</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:unparsed-entity-public-id</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$entity-name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">xs:string</code>,</td>
                                 <td></td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$doc</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">node()</code></td>
                                 <td><code class="assign">:=&nbsp;</code><code>.</code></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:string</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-dependent">focus-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>Calling the single-argument form of this function has the same effect as calling the
            two-argument form with the context item as the second argument.</p>
                        <p>The two-argument <a href="#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a> 
            function returns the public
            identifier of the unparsed entity whose name is given by the value of the
            <code>$entity-name</code> argument, in the document containing the node supplied as the 
               value of the <code>$doc</code> argument. It returns the zero-length string if
            there is no such entity, or if the entity has no public identifier. This function maps
            to the <code>dm:unparsed-entity-public-id</code> accessor defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1380"><span class="error">[ERR XTDE1380] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.
         </p>
                        <p>The following errors may be raised when <code>$node</code> is omitted:</p>
                        <ul>
                           <li>
                              <p>If the context item is absent, <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> 
                  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPDY0002" title="XPDY0002"><span class="error">[ERR XPDY0002] </span></a><sup><small>XP40</small></sup>.</p>
                           </li>
                           <li>
                              <p>If the context item is not a node, <a title="type error" class="termref" href="#dt-type-error">type error</a> 
                  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPTY0004" title="XPTY0004"><span class="error">[ERR XPTY0004] </span></a><sup><small>XP40</small></sup>.</p>
                           </li>
                        </ul>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>XML permits more than one unparsed entity declaration with the same name to appear,
            and says that the first declaration is the one that should be used. This rule <span class="verb">should</span> be 
            respected during construction of the data model; the data model instance should not contain more than one
            unparsed entity with the same name.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-system-property"></a>20.5.4 <a href="#func-system-property" style="text-decoration: none">fn:system-property</a></h4>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the value of a system property</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:system-property</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code></td>
                                 <td></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:string</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>.  It depends on 
		namespaces.
	</p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The value of the <code>$name</code> argument 
            <span class="verb">must</span> be <span>either an <code>xs:QName</code>, or </span>
            a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If it is a 
            <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>
            with a prefix, then it is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
               QName</a> using the namespace declarations in the static context of the
            <a title="expression" class="termref" href="#dt-expression">expression</a>. If there is no prefix, the name is
            taken as being in no namespace.</p>
                        <p>The <a href="#func-system-property"><code>system-property</code></a> function returns a string representing the
            value of the system property identified by the name. If there is no such system
            property, the zero-length string is returned.</p>
                        <p>Implementations <span class="verb">must</span> provide the following system properties, which
            are all in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>:</p>
                        <ul>
                           <li>
                              <p>
                  <code>xsl:version</code>, a number giving the version of XSLT implemented by the
                     <a title="processor" class="termref" href="#dt-processor">processor</a>; for implementations conforming
                  to the version of XSLT specified by this document, this is the string <code>"4.0"</code>. 
                  The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                     <a href="#xmlschema-2">[XML Schema Part 2]</a>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:vendor</code>, a string identifying the implementer of the <a title="processor" class="termref" href="#dt-processor">processor</a>
               </p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:vendor-url</code>, a string containing a URL identifying the implementer
                  of the <a title="processor" class="termref" href="#dt-processor">processor</a>; typically this is the host
                  page (home page) of the implementer’s Web site.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:product-name</code>, a string containing the name of the implementation,
                  as defined by the implementer. This <span class="verb">should</span> normally remain
                  constant from one release of the product to the next. It <span class="verb">should</span>
                  also be constant across platforms in cases where the same source code is used to
                  produce compatible products for multiple execution platforms.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:product-version</code>, a string identifying the version of the
                  implementation, as defined by the implementer. This <span class="verb">should</span>
                  normally vary from one release of the product to the next, and at the discretion
                  of the implementer it <span class="verb">may</span> also vary across different execution
                  platforms.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:is-schema-aware</code>, returns the string <code>"yes"</code> in the
                  case of a processor that claims conformance as a <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a>, or
                     <code>"no"</code> in the case of a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic
                     XSLT processor</a>.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:supports-serialization</code>, returns the string <code>"yes"</code> in
                  the case of a processor that offers the <a title="serialization feature" class="termref" href="#dt-serialization-feature">serialization feature</a>, or <code>"no"</code> otherwise.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:supports-backwards-compatibility</code>, returns the string
                     <code>"yes"</code> in the case of a processor that offers the <a title="XSLT 1.0 compatibility feature" class="termref" href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>, or
                     <code>"no"</code> otherwise.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:supports-namespace-axis</code>, returns the string <code>"yes"</code> in
                  the case of a processor that offers the XPath namespace axis even when not in
                  backwards compatible mode, or <code>"no"</code> otherwise. Note that a processor
                  that supports backwards compatible mode must support the namespace axis when in
                  that mode, so this property is not relevant to that case.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:supports-streaming</code>, returns the string <code>"yes"</code> in the
                  case of a processor that offers the streaming feature (see <a href="#streaming-feature"><i>27.5 Streaming Feature</i></a>), or <code>"no"</code> otherwise.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:supports-dynamic-evaluation</code>, returns the string
                     <code>"yes"</code> unless dynamic evaluation (that is,
                  use of <a href="#element-evaluate"><code>xsl:evaluate</code></a>) has been disabled, in which
                  case it returns <code>"no"</code>.</p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:supports-higher-order-functions</code>, always returns the string
                  <code>"yes"</code>.</p>
                              <div class="note">
                                 <p class="prefix"><b>Note:</b></p>In XSLT 4.0, support for higher-order functions is no
                                 longer an optional feature.</div>
                           </li>
                           <li>
                              <p>
                  <code>xsl:xpath-version</code>, a number giving the version of XPath implemented by the
                  <a title="processor" class="termref" href="#dt-processor">processor</a>; for implementations conforming
                  to the version of XSLT specified by this document, this is the string <code>"4.0"</code>. 
                  The value will always be a
                  string in the lexical space of the <code>xs:decimal</code> data type. 
                  This allows the value to be converted to a number
                  for the purpose of magnitude comparisons.
               </p>
                           </li>
                           <li>
                              <p>
                  <code>xsl:xsd-version</code>, a number giving the version of XSD (XML Schema) implemented by the
                  <a title="processor" class="termref" href="#dt-processor">processor</a>. The value will always be a
                  string in the lexical space of the decimal datatype defined in XML Schema (see
                  <a href="#xmlschema-2">[XML Schema Part 2]</a>). This allows the value to be converted to a number
                  for the purpose of magnitude comparisons. Typical values are <code>"1.0"</code> or <code>"1.1"</code>.
                  This property is relevant even when the processor is not schema-aware, since the built-in datatypes
                  for XSD 1.1 differ from those in XSD 1.0.
               </p>
                           </li>
                        </ul>
                        <p>Some of these properties relate to the conformance levels and features offered by the
               <a title="processor" class="termref" href="#dt-processor">processor</a>: these options are described in
               <a href="#conformance"><i>27 Conformance</i></a>.</p>
                        <p>Except where otherwise specified, the actual values returned for the above properties 
            are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
                        <p>The set of system properties that are supported, in addition to those listed above, is
            also <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.
            Implementations <span class="verb">must not</span> define additional system properties in the
            XSLT namespace.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1390"><span class="error">[ERR XTDE1390] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value supplied as
                  the <code>$property-name</code> argument  is not a valid
                  QName, or if there is no namespace declaration in scope for the prefix of the
                  QName. If the processor is able to detect the error statically (for example, when
                  the argument is supplied as a string literal), then the processor
                     <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. 
         </p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>An implementation must not return the value <code>
               3.0
            </code> as the value of the <code>xsl:version</code> system property unless it is
            conformant to XSLT 3.0.</p>
                           <p>It is recognized that vendors who are enhancing XSLT 1.0 or
               2.0 processors may wish to release interim implementations before all the
            mandatory features of this specification are implemented. Since such products are not
            conformant to XSLT 3.0, this specification cannot define their behavior. However,
            implementers of such products are encouraged to return a value for the
               <code>xsl:version</code> system property that is intermediate between 1.0 and 3.0,
            and to provide the <a href="#func-element-available"><code>element-available</code></a> and
               <a href="#func-function-available"><code>function-available</code></a> functions to allow users to test which
            features have been fully implemented.</p>
                           <p>In XSLT 4.0, the argument can be supplied as a QName literal, for example
         <code>system-property( #xsl:version )</code>.</p>
                           <p>TODO: add change metadata (PR 1243)</p>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-available-system-properties"></a>20.5.5 <a href="#func-available-system-properties" style="text-decoration: none">fn:available-system-properties</a></h4>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns a list of system property names that are suitable for passing to
            the <a href="#func-system-property"><code>system-property</code></a> function, as a sequence of QNames.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:available-system-properties</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:QName*</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-independent">context-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The function returns a sequence of QNames, being the names of the system properties
            recognized by the processor, in some <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> order.</p>
                        <p>The prefix part of a returned QName is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
                        <p>The function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>: that is, the
            set of available system properties does not vary during the course of a transformation.</p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The function returns a list of QNames, containing no duplicates.</p>
                           <p>The QNames in this list are suitable for passing to the
            <a href="#func-system-property"><code>system-property</code></a> function.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="map"></a>21 <a href="#map" style="text-decoration: none">Maps</a></h2>
            <p>Maps are defined in the XDM Data Model: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#map-items">8.2 Map Items</a>.</p>
            <div class="div2">
               
               <h3><a id="map-instructions"></a>21.1 <a href="#map-instructions" style="text-decoration: none">Map Instructions</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#record-instructions">next</a> | <a href="#func-current">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The <a href="#element-map"><code>xsl:map</code></a> instruction allows a <code>select</code> attribute
                  as an alternative to the contained sequence constructor.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1632">1632</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1694">1694</a>&nbsp;14 January 2025]</i></p>
                     </li>
                     <li>
                        <p>
                  The <a href="#element-map-entry"><code>xsl:map-entry</code></a> instruction, in common with other instructions,
                  now raises error XTSE3185 (rather than XTSE3280) if both a <code>select</code>
                  attribute and a sequence constructor are present.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1632">1632</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1694">1694</a>&nbsp;14 January 2025]</i></p>
                     </li>
                     <li>
                        <p>
                  Ordered maps are introduced.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1651">1651</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703</a>&nbsp;14 January 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>Three instructions are added to XSLT to facilitate the construction of maps.</p>
               <p class="element-syntax"><a id="element-map"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:map<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;duplicates? = <var>expression</var>〔fn($a, $b) { error(xs:QName(err:XTDE3365)) }〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map&gt;</code></p>
               <p>The instruction <a href="#element-map"><code>xsl:map</code></a> constructs and returns a new map.</p>
               <p>The <code>select</code> attribute and the contained sequence constructor are mutually
               exclusive: if a <code>select</code> attribute is present, then the content
                  <span class="verb">must</span> be empty except optionally for
                  <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></p>
               <p>The result of evaluating the <code>select</code> expression or the contained
            sequence constructor is referred to as the <b>input sequence</b>.</p>
               <p>The input sequence <span class="verb">must</span> be a sequence of
               maps: call this <code>$maps</code>.</p>
               <p><span>In the absence of duplicate keys,</span> the result of the instruction  
               is then given by the XPath 3.1 expression:</p>
               <div class="exampleInner">
                  <pre>map:merge($maps)</pre>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Informally: <span>in the absence of duplicate keys</span> the resulting map contains
                  the union of the map entries from the supplied sequence of maps.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The order of entries in the returned map will reflect
                  the order of items in the sequence that results from evaluation of the
                  input sequence.</p>
               </div>
               <p>The handling of duplicate keys is described in <a href="#duplicate-keys"><i>21.1.2 Handling of duplicate keys</i></a> below.</p>
               <p>There is no requirement that the supplied input maps should have the same or
               compatible types.
               The type of a map (for example <code>map(xs:integer,
                  xs:string)</code>) is descriptive of the entries it currently contains, but is not
               a constraint on how the map may be combined with other maps.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>A common coding pattern is to supply the input as a set of single-entry maps, that is,
               maps containing a single key-value pair. Moreover, it is often convenient to construct these
               using the <a href="#element-map-entry"><code>xsl:map-entry</code></a> instruction. However, it is not required that
               the input maps should be single-entry maps, nor is it required that they should be constructed
               using this instruction.</p>
               </div>
               <p><a id="err-XTTE3375"><span class="error">[ERR XTTE3375] </span></a>A type error occurs if the result of the input sequence
                         is
                     not an instance of the required type <code>map(*)*</code>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In practice, the effect of this rule is that the result of the 
                  <code>select</code> expression or sequence
                  constructor contained in the <a href="#element-map"><code>xsl:map</code></a> instruction is severely
                  constrained: it doesn’t make sense, for example, for it to contain
                  instructions such as <a href="#element-element"><code>xsl:element</code></a> that create new nodes. As with
                  other type errors, processors are free to raise the error statically if they are
                  able to determine that the sequence constructor would always fail when
                  evaluated.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>It is legitimate to construct a map using an instruction such as
               <code>&lt;xsl:map select="{'a':1, 'b':2}"/&gt;</code>. In this situation
               <a href="#element-map"><code>xsl:map</code></a> has exactly the same effect as <a href="#element-sequence"><code>xsl:sequence</code></a>,
               but users may feel that it improves readability.</p>
               </div>
               <p class="element-syntax"><a id="element-map-entry"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:map-entry<br>&nbsp;&nbsp;<b>key</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map-entry&gt;</code></p>
               <p>The instruction <a href="#element-map-entry"><code>xsl:map-entry</code></a> constructs and returns a singleton
               map: that is, a map which  contains one
               key and one value. Such a map is primarily used as a building block when constructing
               maps using the <a href="#element-map"><code>xsl:map</code></a> instruction.</p>
               <p>The <code>select</code> attribute and the contained sequence constructor are mutually
               exclusive: if a <code>select</code> attribute is present, then the content
                  <span class="verb">must</span> be empty except optionally for
                  <a href="#element-fallback"><code>xsl:fallback</code></a> instructions. <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span></p>
               <p>The key of the entry in the new map is the value obtained by evaluating the
               expression in the <code>key</code> attribute, converted to the required type
                  <code>xs:anyAtomicType</code> by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. If the supplied key (after conversion) is of
               type <code>xs:untypedAtomic</code>, it is cast to <code>xs:string</code>.</p>
               <p>The associated value is the value obtained by evaluating the expression in the
                  <code>select</code> attribute, or the contained sequence constructor, with no
               conversion. If there is no <code>select</code> attribute and the sequence constructor
               is empty, the associated value is the empty sequence.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e48475"></a>Example: Using XSLT instructions to create a fixed map</div>
                  <p>The following example binds a variable to a map whose content is statically
                     known:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:map-entry key="'Mo'" select="'Monday'"/&gt;
    &lt;xsl:map-entry key="'Tu'" select="'Tuesday'"/&gt;
    &lt;xsl:map-entry key="'We'" select="'Wednesday'"/&gt;
    &lt;xsl:map-entry key="'Th'" select="'Thursday'"/&gt;
    &lt;xsl:map-entry key="'Fr'" select="'Friday'"/&gt;
    &lt;xsl:map-entry key="'Sa'" select="'Saturday'"/&gt;
    &lt;xsl:map-entry key="'Su'" select="'Sunday'"/&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
                  <p>In simple cases like this the same effect can be achieved using the
                <a href="#element-record"><code>xsl:record</code></a> instruction:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:record
    Mo="'Monday'"
    Tu="'Tuesday'"
    We="'Wednesday'"
    Th="'Thursday'"
    Fr="'Friday'"
    Sa="'Saturday'"
    Su="'Sunday'"/&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
                  <p>A third option is to construct the map in XPath:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:variable name="week" as="map(xs:string, xs:string)"&gt;
  &lt;xsl:select&gt;
    {'Mo':'Monday', 'Tu':'Tuesday', 'We':'Wednesday',
     'Th':'Thursday', 'Fr': 'Friday', 'Sa':'Saturday',
     'Su':'Sunday'}
  &lt;/xsl:select&gt;   
&lt;/xsl:variable&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e48489"></a>Example: Using XSLT instructions to create a computed map</div>
                  <p>The following example binds a variable to a map acting as an index into a source
                     document:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:map&gt;
    &lt;xsl:for-each select="//employee"&gt;
      &lt;xsl:map-entry key="@empNr" select="."/&gt;
    &lt;/xsl:for-each&gt;
  &lt;/xsl:map&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
                  <p>Again, an alternative is to use an XPath expression:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:variable name="index" as="map(xs:string, element(employee))"&gt;
  &lt;xsl:select&gt;
    map:build(//employee, fn{@empNr})
  &lt;/xsl:select&gt;
&lt;/xsl:variable&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e48497"></a>Example: Modifying the keys in a map</div>
                  <p>The following example modifies a supplied map <code>$input</code> by changing
                     all the keys to upper case. A dynamic error occurs if this results in duplicate
                     keys:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:map&gt;
  &lt;xsl:for-each select="map:pairs($map)"&gt;
    &lt;xsl:map-entry key="upper-case(?key)" select="?value"/&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:map&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e48506"></a>Example: Modifying the values in a map</div>
                  <p>The following example modifies a supplied map <code>$input</code> by wrapping
                     each of the values in an array:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:map&gt;
  &lt;xsl:for-each select="map:pairs($map)"&gt;
    &lt;xsl:map-entry key="?key"&gt;
       &lt;xsl:array select="?value"/&gt;
    &lt;/xsl:map-entry&gt;
  &lt;/xsl:for-each&gt;
&lt;/xsl:map&gt;</pre>
                  </div>
                  <p>This could also be written:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:map select="
  map:pairs($map) ! { ?key : array{ ?value } }"/&gt;</pre>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="record-instructions"></a>21.1.1 <a href="#record-instructions" style="text-decoration: none">Record Instruction</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#duplicate-keys">next</a> | <a href="#map-instructions">previous</a>)</p>
                     <ol>
                        <li>
                           <p> The <a href="#element-record"><code>xsl:record</code></a> instruction is introduced
                     to make construction of record maps simpler. <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/322">322</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1858">1858</a>&nbsp;25 March 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p class="element-syntax"><a id="element-record"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:record<br>&nbsp;&nbsp;xsl:as? = <var>item-type</var>〔'map(*)'〕<br>&nbsp;&nbsp;xsl:duplicates? = <var>expression</var>〔fn($a, $b) { error(xs:QName(err:XTDE3365)) }〕<br>&nbsp;&nbsp;<b>*</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:record&gt;</code></p>
                  <p>(The notation <code>* = expression</code> indicates that this instruction accepts
             any number of additional attributes in no namespace.)</p>
                  <table class="ednote" caption="Editorial note">
                     <tr>
                        <td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td>
                        <td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td>
                     </tr>
                     <tr style="text-align: left; vertical-align: top;">
                        <td colspan="2">There needs to be a construct available within <code>element-catalog.xml</code>
                           to declare 'any permitted attribute of a given name type/pattern', in this case <code>xs:NCName</code>
                           
                           </td>
                     </tr>
                  </table>
                  <p>The instruction <a href="#element-record"><code>xsl:record</code></a> constructs and returns a new
                 populated map, permitting entries to be declared as attributes on the
                 instruction. It is intended to make writing maps where the entry keys are
                 NCNames simpler and more concise, avoiding larger XSLT constructs using
                 <a href="#element-map"><code>xsl:map</code></a> and <a href="#element-map-entry"><code>xsl:map-entry</code></a> or
                 <a href="#element-sequence"><code>xsl:sequence</code></a> containing map-constructing XPath
                 expressions.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Unlike all other <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>, the names of the attributes <code>xsl:as</code> and
                         <code>xsl:duplicates</code> as well as the <a title="standard attributes" class="termref" href="#dt-standard-attributes">standard
                             attributes</a> (such as <code>use-when</code> or <code>xpath-default-namespace</code>) attached to the <a href="#element-record"><code>xsl:record</code></a> instruction <span class="verb">must</span> be in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, 
                         as opposed to being in no namespace. This has been chosen to
                         avoid reserving the names of such attributes (e.g. <code>as</code>, <code>duplicates</code>, <code>use-when</code> etc.) as potential
                         entry keys, leaving any valid NCName as a candidate.</p>
                  </div>
                  <p>The <a href="#element-record"><code>xsl:record</code></a> generates a new map: call this
                 <code>$record</code>. For each of the attributes of the instruction whose name
                 is an <code>xs:NCName</code> an entry is added to <code>$record</code> whose
                 key is the name of the attribute (as <code>xs:string</code>) and whose value is
                 the result of evaluating the value of that attribute as an expression in the
                 current context.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>As the values of the attributes whose names are <code>xs:NCName</code> are considered to be XPath expressions,
                     two consequences follow for such attributes:
                     </p>
                     <ol class="enumar">
                        <li>They <span class="verb">must not</span> be considered as shadow attributes (see <a href="#shadow-attributes"><i>3.11.4 Shadow Attributes</i></a>) 
                           as a leading underscore is a valid character within an <code>xs:NCName</code>.</li>
                        <li>They are not designated as <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute
                              value templates</a>.</li>
                     </ol>
                     <p> These restrictions do not apply to attributes of <a href="#element-record"><code>xsl:record</code></a> whose names are in namespaces.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The order of attribute-generated entries in <code>$record</code> will reflect
                         the order of attributes returned along the <code>attribute::</code> axis, which is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> but stable.</p>
                  </div>
                  <p>After processing the applicable attributes of the instruction, any contained
                 sequence constructor is evaluated and the result <span class="verb">must</span> be a
                 (possibly empty) sequence of maps. The entries in these maps are merged into
                 <code>$record</code>. By this means entries can be added whose keys are not
                 NCNames, or conditionally generated entries can be included.</p>
                  <p> Each of the map entries in
                 <code>$record</code> is modified by applying the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>
                 to convert the singleton map to the type declared in the <code>xsl:as</code>
                 attribute of the <a href="#element-record"><code>xsl:record</code></a> instruction, if present. 
                 This may contain a map type declaration or 
                 a reference to one of the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-in-scope-named-item-types">in-scope named item types</a><sup><small>XP</small></sup>, which may include record types. 
                 Unless any type restriction is violated <code>$record</code> is returned as the instruction result.</p>
                  <table class="ednote" caption="Editorial note">
                     <tr>
                        <td style="text-align: left; vertical-align:top; width: 50%;"><b>Editorial note</b></td>
                        <td style="text-align: right; vertical-align:top; width: 50%;">&nbsp;</td>
                     </tr>
                     <tr style="text-align: left; vertical-align: top;">
                        <td colspan="2">This implies that <a href="#element-map"><code>xsl:map</code></a> and possibly <a href="#element-map-entry"><code>xsl:map-entry</code></a>
                           should support an <code>as</code> attribute, restricting type.</td>
                     </tr>
                  </table>
                  <p>The treatment of duplicate keys between entries defined in the attributes of
                 <a href="#element-record"><code>xsl:record</code></a> and any generated by a contained sequence
                 constructor is described in <a href="#duplicate-keys"><i>21.1.2 Handling of duplicate keys</i></a> below. Note that in
                 the absence of a sequence constructor, no duplicate keys can appear, as all
                 attributes of <a href="#element-record"><code>xsl:record</code></a> must have a unique name within the
                 element tag.</p>
                  <p>The effect of this instruction, in the absence of errors, is equivalent to execution of the XSLT <a href="#element-map"><code>xsl:map</code></a> instruction generated by the 
                     the following source transformation of the <a href="#element-record"><code>xsl:record</code></a> subtree</p>
                  <div class="exampleInner">
                     <pre>
                   &lt;xsl:namespace-alias stylesheet-prefix="t" result-prefix="xsl"/&gt;
...

&lt;xsl:mode name="record" on-no-match="shallow-copy"&gt;
   &lt;xsl:template match="xsl:record"&gt;
      &lt;xsl:variable name="xsl-attributes" select="@xsl:*"/&gt;
      &lt;xsl:variable name="ncname-attributes" select="@*[empty(prefix-from-QName(node-name()))]"/&gt;
      &lt;xsl:variable name="other-attributes"
          select="@* except ($xsl-attributes, $ncname-attributes)"/&gt;
      &lt;t:map&gt;
         &lt;xsl:sequence select="$other-attributes"/&gt;
         &lt;xsl:apply-templates select="$xsl-attributes, $ncname-attributes, node()"/&gt;
      &lt;/t:map&gt;
   &lt;/xsl:template&gt;
   &lt;xsl:template match="xsl:record/@*"&gt;
      &lt;t:map-entry key="'{name()}'" select="{.}"/&gt;
   &lt;/xsl:template&gt;
   &lt;xsl:template match="xsl:record/@xsl:*" priority="1"&gt;
      &lt;xsl:attribute name="{local-name()}" select="."/&gt;
   &lt;/xsl:template&gt;
&lt;/xsl:mode&gt;</pre>
                  </div>
                  <p>which for the instruction:</p>
                  <div class="exampleInner">
                     <pre> &lt;xsl:record xsl:as="eg:book" author="string(AUTHOR)"
               title="string(TITLE)" 
               price="xs:decimal(PRICE)" 
               publisher="string(../@name)"&gt;
      &lt;xsl:if test="@private"&gt;
         &lt;xsl:map-entry name="'private entry'" select="true()"/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:record&gt;</pre>
                  </div>
                  <p>would produce</p>
                  <div class="exampleInner">
                     <pre> &lt;xsl:map as="eg:book"&gt;
      &lt;xsl:map-entry key="'author'" select="string(AUTHOR)"/&gt;
      &lt;xsl:map-entry key="'title'" select="string(TITLE)"/&gt;
      &lt;xsl:map-entry key="'price'" select="xs:decimal(PRICE)"/&gt;
      &lt;xsl:map-entry key="'publisher'" select="string(../@name)"/&gt;
      &lt;xsl:if test="@private"&gt;
         &lt;xsl:map-entry name="'private entry'" select="true()"/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:map&gt;</pre>
                  </div>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="d5e48710"></a>Example: Generating a map with <code>xsl:record</code></div>
                     <p>The following example constructs a map using <a href="#element-record"><code>xsl:record</code></a></p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template match="book" as="map(*)"&gt;
   &lt;xsl:record author="string(AUTHOR)"
               title="string(TITLE)" 
               price="xs:decimal(PRICE)" 
               publisher="string(../@name)"&gt;
      &lt;xsl:if test="@private"&gt;
         &lt;xsl:map-entry name="'private entry'" select="true()"/&gt;
      &lt;/xsl:if&gt;
   &lt;/xsl:record&gt;
&lt;/xsl:template&gt;</pre>
                     </div>
                     <p>with the following input</p>
                     <div class="exampleInner">
                        <pre>&lt;catalog name="QT4 Community"&gt;
  &lt;book private="true"&gt;
    &lt;AUTHOR&gt;MHK&lt;/AUTHOR&gt;
    &lt;TITLE&gt;XSLT 4.0&lt;/TITLE&gt;
    &lt;PRICE&gt;123.45&lt;/PRICE&gt;
  &lt;/book&gt;
&lt;/catalog&gt;</pre>
                     </div>
                     <p>will produce a resulting map:</p>
                     <div class="exampleInner">
                        <pre>map{'author':'MHK', 'title': 'XSLT 4.0', 'price':123.45, 
                     'publisher':'QT4 Community', 'private entry': true()}</pre>
                     </div>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="duplicate-keys"></a>21.1.2 <a href="#duplicate-keys" style="text-decoration: none">Handling of duplicate keys</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#array-construction">next</a> | <a href="#record-instructions">previous</a>)</p>
                     <ol>
                        <li>
                           <p>
                     A new attribute <code>xsl:map/@duplicates</code> is available,
                  allowing control over how duplicate keys are handled by the <a href="#element-map"><code>xsl:map</code></a>
                  instruction.
                  <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/169">169</a>&nbsp;&nbsp;28 November 2023]</i></p>
                        </li>
                        <li>
                           <p>
                       Attribute <code>xsl:record/@xsl:duplicates</code> is added to control duplicate keys handling in the <a href="#element-record"><code>xsl:record</code></a>
                       instruction.
                   <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/322">322</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1858">1858</a>&nbsp;14 March 2025]</i></p>
                        </li>
                     </ol>
                  </div>
                  <p>This section describes what happens when two or more maps in the input sequence of
               an <a href="#element-map"><code>xsl:map</code></a> or <a href="#element-record"><code>xsl:record</code></a> instruction contain duplicate keys: that is, when one of these
               maps contains an entry with key <var>K</var>, and another contains an entry with key <var>L</var>,
                  and <code>fn:atomic-equal(<var>K</var>, <var>L</var>)</code> returns <code>true</code>.</p>
                  <p><a id="err-XTDE3365"><span class="error">[ERR XTDE3365] </span></a>In the absence of the <code>[xsl:]duplicates</code> attribute, 
                     a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs if the set of
                     keys in the maps making up the input sequence
                      
                     contains duplicates.</p>
                  <p>The result of evaluating the <code>[xsl:]duplicates</code> attribute, if present, <span class="verb">must</span>
               be either one of the strings <code>"use-first"</code>, <code>"use-last"</code>,
                  <code>"use-any"</code>, <code>"combine"</code>, or <code>"reject"</code>,
                  or a function with arity 2. These values correspond to the permitted
                  values of the <code>duplicates</code> option of the 
                  <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-map-merge"><code>map:merge</code></a> function.</p>
                  <p>The result of the <a href="#element-map"><code>xsl:map</code></a> or <a href="#element-record"><code>xsl:record</code></a> instruction is defined by reference to 
               the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-map-merge"><code>map:merge</code></a>. Specifically, if <code>$maps</code>
               is the input sequence to <a href="#element-map"><code>xsl:map</code></a> or <a href="#element-record"><code>xsl:record</code></a>, and <code>$duplicates</code>
               is the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>[xsl:]duplicates</code>
               attribute, then the result of the instruction is the result of the function
               call <code>map:merge($maps, { "duplicates": $duplicates })</code>.</p>
                  <p>The following table shows some possible values 
                  of the <code>duplicates</code> attribute, and explains their effect:</p>
                  <table style="border:1px solid; padding:5px; width:100%">
                     <thead>
                        <tr>
                           <th style="text-align:left; vertical-align:top">Attribute</th>
                           <th style="text-align:left; vertical-align:top">Effect</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="'use-first'"</code></td>
                           <td style="text-align:left; vertical-align:top">The first of the duplicate values is used.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="'use-last'"</code></td>
                           <td style="text-align:left; vertical-align:top">The last of the duplicate values is used.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="'combine'"</code></td>
                           <td style="text-align:left; vertical-align:top">The <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-sequence-concatenation">sequence concatenation</a><sup><small>XP</small></sup> 
                              of the duplicate values is used. This could
                              also be expressed as <code>duplicates="op(',')"</code>.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="fn($a, $b) { max(($a, $b)) }"</code></td>
                           <td style="text-align:left; vertical-align:top">The highest of the duplicate values is used.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="fn($a, $b) { min(($a, $b)) }"</code></td>
                           <td style="text-align:left; vertical-align:top">The lowest of the duplicate values is used.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="concat(?, ', ', ?) }"</code></td>
                           <td style="text-align:left; vertical-align:top">The comma-separated string concatenation of the duplicate values is used.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="op('+')"</code></td>
                           <td style="text-align:left; vertical-align:top">The sum of the duplicate values is used.</td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="fn($a, $b) { subsequence(($a, $b), 1, 4) }"</code></td>
                           <td style="text-align:left; vertical-align:top">The first four of the duplicates are retained; any further duplicates
                              are discarded.
                              </td>
                        </tr>
                        <tr>
                           <td style="text-align:left; vertical-align:top"><code>duplicates="fn($a, $b) { distinct-values(($a, $b)) }"</code></td>
                           <td style="text-align:left; vertical-align:top">When multiple entries have the same key, the corresponding values
                              are retained only if they are distinct from other values having the
                              same key.
                              </td>
                        </tr>
                     </tbody>
                  </table>
                  <div class="example">
                     
                     <div class="exampleHeader"><a id="map-with-duplicates-into-array"></a>Example: Combining Duplicates into an Array</div>
                     <p>This example takes as input an XML document such as:</p>
                     <div class="exampleInner">
                        <pre>&lt;data&gt;
   &lt;event id="A23" value="12"/&gt;
   &lt;event id="A24" value="5"/&gt;
   &lt;event id="A25" value="9"/&gt;
   &lt;event id="A23" value="2"/&gt;
 &lt;/data&gt;</pre>
                     </div>
                     <p>and constructs a map whose JSON representation is:</p>
                     <div class="exampleInner">
                        <pre>{ "A23": [ 12, 2 ], "A24": [ 5 ], "A23": [ 9 ] }</pre>
                     </div>
                     <p>The logic is:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:template match="data"&gt;
   &lt;xsl:map duplicates="fn($a, $b) { array:join(($a, $b)) }"&gt;
     &lt;xsl:for-each select="event"&gt;
        &lt;xsl:map-entry key="@id" select="[xs:integer(@value)]"/&gt;
     &lt;/xsl:for-each&gt;
   &lt;/xsl:map&gt;
   &lt;/xsl:template&gt;</pre>
                     </div>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Specifying the effect by reference to <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-map-merge"><code>map:merge</code></a> has
                  the following consequences when duplicates are combined
                  into a merged entry:</p>
                     <ul>
                        <li>
                           <p>The position of the merged entry in the result corresponds
                     to the position of the first of the duplicate keys in the input.</p>
                        </li>
                        <li>
                           <p>The key used for the merged entry in the result corresponds
                     to one of the duplicate keys in the input: it is 
                        <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> which one is chosen.
                        This is relevant when
                     the duplicate keys differ in some way, for example when they have
                     different type annotations, or when they are <code>xs:dateTime</code>
                     values in different timezones.</p>
                        </li>
                     </ul>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="map-examples"></a>21.2 <a href="#map-examples" style="text-decoration: none">Examples using Maps</a></h3>
               <p>This section gives some examples of where maps can be useful.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="maps-with-iterate"></a>Example: Using Maps with xsl:iterate</div>
                  <p>This example uses maps in conjunction with the <a href="#element-iterate"><code>xsl:iterate</code></a>
                  instruction to find the highest-earning employee in each department, in a single
                  streaming pass of an input document containing employee records.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:source-document streamable="yes" href="employees.xml"&gt;
  &lt;xsl:iterate select="*/employee"&gt;
    &lt;xsl:param name="highest-earners" 
               as="map(xs:string, element(employee))" 
               select="{}"/&gt;
    &lt;xsl:on-completion&gt;
      &lt;xsl:for-each select="map:keys($highest-earners)"&gt;
        &lt;department name="{.}"&gt;
          &lt;xsl:copy-of select="$highest-earners(.)"/&gt;
        &lt;/department&gt;
      &lt;/xsl:for-each&gt;
    &lt;/xsl:on-completion&gt;           
    &lt;xsl:variable name="this" select="copy-of(.)" as="element(employee)"/&gt; 
    &lt;xsl:next-iteration&gt;
      &lt;xsl:with-param name="highest-earners"
          select="let $existing := $highest-earners($this/department)
                  return if ($existing/salary gt $this/salary)
                         then $highest-earners
                         else map:put($highest-earners, $this/department, $this)"/&gt;
    &lt;/xsl:next-iteration&gt;
  &lt;/xsl:iterate&gt;
&lt;/xsl:source-document&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="example-complex-numbers"></a>Example: Using Maps to Implement Complex Numbers</div>
                  <p>A complex number might be represented as a map with two entries, the keys being
                  the <code>xs:boolean</code> value <code>true</code> for the real part, and the
                     <code>xs:boolean</code> value <code>false</code> for the imaginary part. A
                  library for manipulation of complex numbers might include functions such as the
                  following:</p>
                  <div class="exampleInner">
                     <pre>

&lt;xsl:variable name="REAL" static="yes" as="xs:int" select="0"/&gt; 
&lt;xsl:variable name="IMAG" static="yes" as="xs:int" select="1"/&gt; 
                     
&lt;xsl:function name="i:complex" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="real" as="xs:double"/&gt;
  &lt;xsl:param name="imaginary" as="xs:double"/&gt;
  &lt;xsl:sequence select="{ $REAL: $real, $IMAG: $imaginary }"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:real" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($REAL)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:imaginary" as="xs:double"&gt;
  &lt;xsl:param name="complex" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="$complex($IMAG)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:add" as="map(xs:int, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:int, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(i:real($arg1)+i:real($arg2), 
                                  i:imaginary($arg1)+i:imaginary($arg2)"/&gt;
&lt;/xsl:function&gt;

&lt;xsl:function name="i:multiply" as="map(xs:boolean, xs:double)"&gt;
  &lt;xsl:param name="arg1" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:param name="arg2" as="map(xs:boolean, xs:double)"/&gt;
  &lt;xsl:sequence select="i:complex(
      i:real($arg1)*i:real($arg2) - i:imaginary($arg1)*i:imaginary($arg2),
      i:real($arg1)*i:imaginary($arg2) + i:imaginary($arg1)*i:real($arg2))"/&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="map-as-index"></a>Example: Using a Map as an Index</div>
                  <p>Given a set of <code>book</code> elements, it is possible to construct an index in
                  the form of a map allowing the books to be retrieved by ISBN number.</p>
                  <p>Assume the book elements have the form:</p>
                  <div class="exampleInner">
                     <pre>
&lt;book&gt;
  &lt;isbn&gt;0470192747&lt;/isbn&gt;
  &lt;author&gt;Michael H. Kay&lt;/author&gt;
  &lt;publisher&gt;Wiley&lt;/publisher&gt;
  &lt;title&gt;XSLT 2.0 and XPath 2.0 Programmer's Reference&lt;/title&gt;
&lt;/book&gt;</pre>
                  </div>
                  <p>An index may be constructed as follows: </p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:variable name="isbn-index" as="map(xs:string, element(book))"
    select="map:merge(for $b in //book return { $b/isbn: $b })"/&gt;</pre>
                  </div>
                  <p>This index may then be used to retrieve the book for a given ISBN using either of
                  the expressions <code>map:get($isbn-index, "0470192747")</code> or
                     <code>$isbn-index("0470192747")</code>.</p>
                  <p>In this simple form, this replicates the functionality available using
                     <a href="#element-key"><code>xsl:key</code></a> and the <a href="#func-key"><code>key</code></a> function. However, it
                  also provides capabilities not directly available using the
                     <a href="#func-key"><code>key</code></a> function: for example, the index can include
                     <code>book</code> elements in multiple source documents. It also allows
                  processing of all the books using a construct such as <code>&lt;xsl:for-each
                     select="map:keys($isbn-index)"&gt;</code></p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="map-as-class"></a>Example: A Map containing Named Functions</div>
                  <p>As in JavaScript, a map whose keys are strings and whose associated values are
                  function items can be used in a similar way to a class in object-oriented
                  programming languages.</p>
                  <p>Suppose an application needs to handle customer order information that may arrive
                  in three different formats, with different hierarchic arrangements:</p>
                  <ol class="enumar">
                     <li>
                        <p>Flat structure:</p>
                        <div class="exampleInner">
                           <pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;
&lt;order customer="c123" product="p789"&gt;...&lt;/order&gt;</pre>
                        </div>
                     </li>
                     <li>
                        <p>Orders within customer elements:</p>
                        <div class="exampleInner">
                           <pre>
&lt;customer id="c123"&gt;
   &lt;order product="p789"&gt;...&lt;/order&gt;
&lt;/customer&gt;
&lt;product id="p789"&gt;...&lt;/product&gt;</pre>
                        </div>
                     </li>
                     <li>
                        <p>Orders within product elements:</p>
                        <div class="exampleInner">
                           <pre>
&lt;customer id="c123"&gt;...&lt;/customer&gt;
&lt;product id="p789"&gt;
  &lt;order customer="c123"&gt;...&lt;/order&gt;
&lt;/product&gt;</pre>
                        </div>
                     </li>
                  </ol>
                  <p>An application can isolate itself from these differences by defining a set of
                  functions to navigate the relationships between customers, orders, and products:
                     <code>orders-for-customer</code>, <code>orders-for-product</code>,
                     <code>customer-for-order</code>, <code>product-for-order</code>. These
                  functions can be implemented in different ways for the three different input
                  formats. For example, with the first format the implementation might be:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:variable name="flat-input-functions" as="map(xs:string, fn(*))*"
  select="{
            'orders-for-customer' : 
                 fn($c as element(customer)) as element(order)* 
                    { $c/../order[@customer = $c/@id] },
            'orders-for-product' : 
                 fn($p as element(product)) as element(order)* 
                    { $p/../order[@product = $p/@id] },
            'customer-for-order' : 
                 fn($o as element(order)) as element(customer) 
                    { $o/../customer[@id = $o/@customer] },
            'product-for-order' : 
                 fn($o as element(order)) as element(product) 
                    { $o/../product[@id = $o/@product] } }
         "/&gt;</pre>
                  </div>
                  <p>Having established which input format is in use, the application can bind the
                  appropriate implementation of these functions to a variable such as
                     <code>$input-navigator</code>, and can then process the input using XPath
                  expressions such as the following, which selects all products for which there is
                  no order: <code>//product[empty($input-navigator("orders-for-product")(.))]</code>
               </p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="arrays"></a>22 <a href="#arrays" style="text-decoration: none">Arrays</a></h2>
            <p>Arrays are defined in the XDM Data Model: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#array-items">8.3 Array Items</a>.</p>
            <div class="div2">
               
               <h3><a id="array-construction"></a>22.1 <a href="#array-construction" style="text-decoration: none">Array Construction</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#extension">next</a> | <a href="#duplicate-keys">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The new instruction <a href="#element-array"><code>xsl:array</code></a> is introduced
                  to allow construction of arrays.
               <i>&nbsp;&nbsp;[Issues <a href="https://github.com/qt4cg/qtspecs/issues/113">113</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/issues/2007">2007</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/406">406</a>&nbsp;30 March 2023]</i></p>
                     </li>
                  </ol>
               </div>
               <p>The instruction <a href="#element-array"><code>xsl:array</code></a> constructs and returns a new array.</p>
               <p class="element-syntax"><a id="element-array"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:array<br>&nbsp;&nbsp;for-each? = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:array&gt;</code></p>
               <p class="element-syntax"><a id="element-array-member"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:array-member<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:array-member&gt;</code></p>
               <p>There are three typical ways an array might be constructed.</p>
               <ol class="enumar">
                  <li>
                     <p>An array whose members are all single items can be constructed using
                  an instruction such as:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:array select="'Mon', 'Tues', 'Weds', 'Thurs', 'Fri'"/&gt;</pre>
                     </div>
                     <p>This constructs an array of five strings: <code>['Mon', 'Tues', "Weds', "Thurs', 'Fri']</code></p>
                     <p>The values, of course, do not need to be literals.</p>
                  </li>
                  <li>
                     <p>An array whose members can be computed by applying a mapping to a sequence of items 
                     can be constructed using
                  an instruction such as:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:array for-each="'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday'"
       select="(., substring(., 1, 3))"/&gt;</pre>
                     </div>
                     <p>This constructs an array with five members, each being a sequence of two
                     strings: <code>[('Monday', 'Mon'), ('Tuesday', 'Tue'), ('Wednesday', 'Wed'), ('Thursday', 'Thu'), ('Friday', 'Fri')]</code></p>
                     <p>A more complex example might be:</p>
                     <div class="exampleInner">
                        <pre>&lt;xsl:array for-each="unparsed-text-lines('data.txt')" select="tokenize(.)"/&gt;</pre>
                     </div>
                     <p>which creates an array with one member for each line of an input file, the relevant member
                  being a sequence of words appearing on that line.</p>
                  </li>
                  <li>An array with arbitrary content, that cannot readily be derived algorithmically
                     from the items in a sequence. For example:</li>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array&gt;
   &lt;xsl:array-member select="1"/&gt;
   &lt;xsl:array-member select="1, 2"/&gt;
   &lt;xsl:array-member select="1, 3"/&gt;
   &lt;xsl:array-member select="1, 2, 4"/&gt;
   &lt;xsl:array-member select="1, 5"/&gt;
   &lt;xsl:array-member select="1, 2, 3, 6"/&gt;
   &lt;xsl:array-member select="1, 7"/&gt;
   &lt;xsl:array-member select="1, 2, 4, 8"/&gt;
   &lt;xsl:array-member select="1, 3, 9"/&gt;
   &lt;xsl:array-member select="1, 2, 5, 10"/&gt;
   &lt;xsl:array-member select="1, 11"/&gt;
   &lt;xsl:array-member select="1, 2, 3, 4, 6, 12"/&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
                  <p>This returns an array of twelve members, each being a sequence of integers, for example the last
               member is the sequence <code>(1, 2, 3, 4, 6, 12)</code>.</p>
                  <p>Another example might be:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array&gt;
   &lt;xsl:for-each-group select="1 to 10" split-when="$next mod 5 lt $next mod 3"&gt;
     &lt;xsl:array-member select="current-group()"/&gt;
   &lt;/xsl:for-each-group&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
                  <p>This returns the array <code>[ (1, 2, 3, 4), (5, 6, 7, 8, 9), 10 ]</code>.</p>
               </ol>
               <p>The detailed rules follow.</p>
               <ol class="enumar">
                  <li>
                     <p>In these rules, the term <b>parcel</b> denotes a function item
               with arity zero having an implementation-defined 
                  <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-function-annotation">function annotation</a><sup><small>DM</small></sup> that identifies
               it as having been constructed by the <a href="#element-array-member"><code>xsl:array-member</code></a> instruction.
               The implementation-defined function annotation should use a reserved namespace such
               that functions with this annotation can be created only by using the
               <a href="#element-array-member"><code>xsl:array-member</code></a> instruction.</p>
                     <p>A parcel encapsulates a value,
               which may be any sequence; the value of the parcel is the result of calling the
               corresponding function item with no arguments.</p>
                  </li>
                  <li>
                     <p>The effect of the <a href="#element-array-member"><code>xsl:array-member</code></a> instruction is to return
               a <b>parcel</b> that encapsulates the sequence obtained by evaluating its
               <code>select</code> attribute or its contained sequence constructor.</p>
                  </li>
                  <li>
                     <p>The <a href="#element-array"><code>xsl:array</code></a> instruction is evaluated as follows.</p>
                  </li>
                  <li>
                     <p>If the <code>for-each</code> attribute is absent, then:</p>
                     <ol class="enumla">
                        <li>
                           <p>Let <var>S</var> be the sequence that results from
                     evaluation of the <code>select</code> expression or the contained
                     sequence constructor.</p>
                        </li>
                        <li>
                           <p>The result of the <a href="#element-array"><code>xsl:array</code></a> instruction is
                     an array having one member for each item <var>S<sub>i</sub></var> in <var>S</var>,
                        retaining order:
                        </p>
                           <ul>
                              <li>
                                 <p>If <var>S<sub>i</sub></var> is a <b>parcel</b>, then
                           the array member is the value encapsulated by the parcel (which may
                           be any sequence).</p>
                              </li>
                              <li>
                                 <p>Otherwise,
                           the array member is the singleton item <var>S<sub>i</sub></var>.</p>
                              </li>
                           </ul>
                           <p>
                     </p>
                        </li>
                     </ol>
                  </li>
                  <li>
                     <p>If the <code>for-each</code> attribute is present, then:</p>
                     <ol class="enumla">
                        <li>
                           <p>Let <var>F</var> = <var>F<sub>1</sub></var>, <var>F<sub>2</sub></var>, ..., <var>F<sub>n</sub></var>
                        be the sequence that results from evaluation
                     of the <code>for-each</code> attribute.</p>
                        </li>
                        <li>
                           <p>The resulting array contains one member for each item in <var>F</var>,
                     retaining order.</p>
                        </li>
                        <li>
                           <p>The member corresponding to a particular item <var>F<sub>i</sub></var> is
                     as follows:</p>
                           <ol class="enumlr">
                              <li>
                                 <p>Let <var>S</var> be the result of evaluating the <code>select</code> expression 
                           or the contained sequence constructor with a <a title="focus" class="termref" href="#dt-focus">focus</a>
                     in which the <a title="context item" class="termref" href="#dt-context-item">context item</a> is <var>F<sub>i</sub></var>, the <a title="context position" class="termref" href="#dt-context-position">context position</a>
                     is <var>i</var> (the 1-based position of <var>F<sub>i</sub></var> within <var>F</var>), 
                           and the <a title="context size" class="termref" href="#dt-context-size">context size</a>
                     is <var>n</var> (the number of items in <var>F</var>). </p>
                              </li>
                              <li>
                                 <p>If <var>S</var> contains a single item and that item is a <b>parcel</b>, 
                        then the array member is the value encapsulated by the parcel.</p>
                              </li>
                              <li>
                                 <p>If <var>S</var> contains multiple items and one of those items is a <b>parcel</b>,
                        then a dynamic error is raised:</p>
                                 <p><a id="err-XTDE4060"><span class="error">[ERR XTDE4060] </span></a>It 
                           is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-array"><code>xsl:array</code></a>
                        instruction with a <code>for-each</code> attribute includes items constructed
                        using an <a href="#element-array-member"><code>xsl:array-member</code></a> instruction mixed (in the same array member)
                        with items not so constructed.</p>
                              </li>
                              <li>Otherwise, the array member is the sequence <var>S</var>.</li>
                           </ol>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>When the <code>for-each</code> attribute is present, then it is not necessary
                        to use the <code>xsl:array-member</code> instruction, since each evaluation
                        of the <code>select</code> attribute or the containing sequence constructor
                        generates one array member. However, use of <code>xsl:array-member</code>
                        to construct the array member is permitted, provided that it constructs
                        the entire array member and not an individual item within it.</p>
                           </div>
                        </li>
                     </ol>
                  </li>
               </ol>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The content of an array is effectively a sequence of sequences, which the XDM data
            model cannot represent directly. Representing an array member as a <b>parcel</b> 
               (technically, a zero-arity function) provides
            a convenient workaround.</p>
                  <p><em>As a general rule, <a href="#element-array-member"><code>xsl:array-member</code></a> should be used
               if and only if the <code>select</code> and <code>for-each</code> attributes
               of <code>xsl:array</code> are both absent.</em></p>
               </div>
               <p>If the <a href="#element-array"><code>xsl:array</code></a> instruction has a <code>select</code> attribute then
            the sequence constructor must be empty, except for any <a href="#element-fallback"><code>xsl:fallback</code></a> instructions
            (which an XSLT 4.0 processor ignores) <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p>
               <p>If the <a href="#element-array-member"><code>xsl:array-member</code></a> instruction has a <code>select</code> attribute then
            the sequence constructor must be empty, except for any <a href="#element-fallback"><code>xsl:fallback</code></a> instructions
            (which an XSLT 4.0 processor ignores) <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49328"></a>Example: Constructing an array whose members are single items</div>
                  <p>The following example constructs the array <code>[1, 2, 3, 4, 5]</code>:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array select="1 to 5"/&gt;</pre>
                  </div>
                  <p>The following example constructs an array of text nodes:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array select=".//text()"/&gt;</pre>
                  </div>
                  <p>The following example constructs an array by tokenizing a string:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array select="tokenize('The cat sat on the mat')"/&gt;</pre>
                  </div>
                  <p>The result is the array <code>[ "The", "cat", "sat", "on", "the", "mat" ]</code>.</p>
                  <p>The following example constructs an array containing items computed using nested instructions:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array&gt;
   &lt;xsl:for-each-group select="0 to 19" group-adjacent=". idiv 4"&gt;
     &lt;xsl:sequence select="string-join(current-group(), '-')"/&gt;
   &lt;/xsl:for-each-group&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
                  <p>The result is the array <code>[ "0-1-2-3", "4-5-6-7", "8-9-10-11", "12-13-14-15", "16-17-18-19" ]</code>.</p>
                  <p>Note that in this last example, the <a href="#element-array-member"><code>xsl:array-member</code></a> instruction could be used
               in place of <code>xsl:sequence</code>.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49364"></a>Example: Constructing an array whose members are derived from the items in an input
                     sequence</div>
                  <p>The following example constructs an array whose members are sequences:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array for-each="para" select="distinct-values(tokenize(.))"/&gt;</pre>
                  </div>
                  <p>This returns an array with one member for each child paragraph, the content
               of the array member being the list of distinct words appearing in that paragraph.</p>
                  <p>The following example constructs an array in which the members are obtained
               by applying templates to the children of the context item:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array for-each="*"&gt;                 
   &lt;xsl:apply-templates select="."/&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49373"></a>Example: Constructing a heterogeneous array</div>
                  <p>The following example constructs a heterogeneous array containing a number
               of properties of a supplied node, some of which are sequence-valued:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array&gt;
     &lt;xsl:array-member select="local-name($node)"/&gt;
     &lt;xsl:array-member select="namespace-uri($node)"/&gt;
     &lt;xsl:array-member select="base-uri($node)"/&gt;
     &lt;xsl:array-member select="$node/namespace::*/string()"/&gt;
     &lt;xsl:array-member select="$node/@*/string()"/&gt;  
&lt;/xsl:array&gt;</pre>
                  </div>
                  <p>When applied to an input element such as</p>
                  <div class="exampleInner">
                     <pre>&lt;e xmlns="http://example.com/ns" xml:base="http://example.com/loc" x="2"/&gt;</pre>
                  </div>
                  <p>the result would be the array:</p>
                  <div class="exampleInner">
                     <pre>["e", 
 "http://example.com/ns", 
 "http://example.com/loc", 
 ("http://example.com/ns", "http://www.w3.org/XML/1998/namespace"),
 ("http://example.com/loc", "2")
]</pre>
                  </div>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49384"></a>Example: Constructing nested arrays</div>
                  <p>The <a href="#element-array"><code>xsl:array</code></a> instruction can be nested. For example:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array for-each="1 to 4"&gt;
   &lt;xsl:array select="(.*10 to .*10 + 2)"/&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
                  <p>The result is <code>[ [ 10, 11, 12], [ 20, 21, 22 ], [ 30, 31, 32 ], [ 40, 41, 42 ] ]</code>.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49397"></a>Example: Constructing arrays using template rules</div>
                  <p>Given a book containing chapters which in turn contain sections, the following code
               produces a nested array representing the (crude) word counts of the sections
               within each chapter:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:mode name="word-counts" on-no-match="shallow-skip"&gt;   
    &lt;xsl:template match="book"&gt;
        &lt;xsl:array&gt;
            &lt;xsl:apply-templates/&gt;
        &lt;/xsl:array&gt;
    &lt;/xsl:template&gt;
    &lt;xsl:template match="chapter"&gt;
        &lt;xsl:array&gt;
           &lt;xsl:apply-templates/&gt;
        &lt;/xsl:array&gt;   
    &lt;/xsl:template&gt;
    &lt;xsl:template match="section"&gt;
        &lt;xsl:sequence select="tokenize(.) =&gt; count()"/&gt;
    &lt;/xsl:template&gt;
&lt;/xsl:mode&gt;</pre>
                  </div>
                  <p>The result might be an array of the form <code>[[842, 316], [450, 217], ...]</code>
               indicating that the first section of the second chapter has a word count of 450.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49407"></a>Example: Constructing an array based on an existing array</div>
                  <p>The <a href="#element-array"><code>xsl:array</code></a> instruction can be used in conjunction with
               the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-members"><code>array:members</code></a> function to construct an array from the members
               of an existing array. For example, the following code combines two arrays <code>$A1</code>
                  and <code>$A2</code>, and sorts the result:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array 
   for-each="(array:members($A1), array:members($A2)) =&gt; sort(fn{count(?value)})"
   select="?value"/&gt;</pre>
                  </div>
                  <p>The following code transposes a regular nested array (such as <code>[ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ]</code>)
               so the result is organized by columns rather than rows (<code>[ [ 1, 4, 7 ], [ 2, 5, 8 ], [ 3, 6, 9 ] ]</code>):</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:array for-each="1 to array:size($input?1)"&gt;
   &lt;xsl:variable name="index" select="."/&gt;
   &lt;xsl:array select="$input/*[$index]"/&gt;
&lt;/xsl:array&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="arrays-streaming"></a>22.2 <a href="#arrays-streaming" style="text-decoration: none">Arrays and Streaming</a></h3>
               <p>As with maps (see <a href="../xslt-streaming-40/#maps-streaming">12.1 Maps and Streaming</a><sup><small>SG</small></sup>) arrays cannot contain references to 
               <a title="streamed node" class="termref" href="#dt-streamed-node">streamed nodes</a>, because all expressions, instructions,
            and functions that construct arrays are defined to have operand usage <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-navigation">navigation</a><sup><small>SG</small></sup>.</p>
               <p>Unlike maps, array constructors have no special rules allowing the members of the array
            to be constructed using multiple consuming subexpressions.</p>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="diagnostics"></a>23 <a href="#diagnostics" style="text-decoration: none">Diagnostics</a></h2>
            <div class="div2">
               
               <h3><a id="message"></a>23.1 <a href="#message" style="text-decoration: none">Messages</a></h3>
               <p class="element-syntax"><a id="element-message"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:message<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;terminate? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }〔'Q{http://www.w3.org/2005/xqt-errors}XTMM9000'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:message&gt;</code></p>
               <p>The <a href="#element-message"><code>xsl:message</code></a> instruction sends a message in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> way. The
                  <a href="#element-message"><code>xsl:message</code></a> instruction causes the creation of a new document,
               which is typically serialized and output to an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> destination. The
               result of the <a href="#element-message"><code>xsl:message</code></a> instruction is the empty sequence.</p>
               <p>The content of the message may be specified by using either or both of the optional
                  <code>select</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that forms the content of the
                  <a href="#element-message"><code>xsl:message</code></a> instruction.</p>
               <p>If the <a href="#element-message"><code>xsl:message</code></a> instruction contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, then the sequence
               obtained by evaluating this sequence constructor is used to construct the content of
               the new document node, as described in <a href="#constructing-complex-content"><i>5.7.1 Constructing Complex Content</i></a>.</p>
               <p>If the <a href="#element-message"><code>xsl:message</code></a> instruction has a <code>select</code> attribute,
               then the value of the attribute <span class="verb">must</span> be an XPath expression. The
               effect of the <a href="#element-message"><code>xsl:message</code></a> instruction is then the same as if a
               single <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction with this <code>select</code>
               attribute were added to the start of the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>.</p>
               <p>If the <a href="#element-message"><code>xsl:message</code></a> instruction has no content and no
                  <code>select</code> attribute, then an empty message is produced.</p>
               <p>The tree produced by the <a href="#element-message"><code>xsl:message</code></a> instruction is not technically
               a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. The tree has no
               URI and processors are not <span class="verb">required</span> to make the tree accessible to
               applications.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>In many cases, the XML document produced using <a href="#element-message"><code>xsl:message</code></a> will
                  consist of a document node owning a single text node. However, it may contain a
                  more complex structure.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>An implementation might implement <a href="#element-message"><code>xsl:message</code></a> by popping up an
                  alert box or by writing to a log file. Because the order of execution of
                  instructions is implementation-defined, the order in which such messages appear is
                  not predictable.</p>
               </div>
               <p>The <code>terminate</code> attribute is interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>.</p>
               <p>If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                  <code>terminate</code> attribute is <code>yes</code>, then the <a title="processor" class="termref" href="#dt-processor">processor</a>
               <span class="verb">must</span>
               raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> after
               sending the message. This error may be caught in the same
                  way as any other dynamic error using <a href="#element-catch"><code>xsl:catch</code></a>. The
               default value is <code>no</code>. Note that because the order of evaluation of
               instructions is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>, this gives no guarantee that any particular
               instruction will or will not be evaluated before processing terminates.</p>
               <p>The optional <code>error-code</code> attribute 
               (also interpreted as an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>)
               may be used to indicate the error code
               associated with the message. This may be used irrespective of the value of
                  <code>terminate</code>. The 
               <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the 
               error code attribute is expected to be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. If no error code is specified, or if
               the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> is not a valid EQName, the error code will have local part
                  <code>XTMM9000</code> and namespace URI
                  <code>http://www.w3.org/2005/xqt-errors</code>. User-defined error codes
                  <span class="verb">should</span> be in a namespace other than
                  <code>http://www.w3.org/2005/xqt-errors</code>. When the value of
                  <code>terminate</code> is <code>yes</code>, the error code may be matched in an
                  <a href="#element-catch"><code>xsl:catch</code></a> element to catch the error and cause processing to
               continue normally.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>XPath 4.0 allows an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> to include
            both a prefix and a URI, for example <code>error-code="{http://example.com/ns}my:error-code"</code>.</p>
               </div>
               <p>
               <a id="err-XTMM9000"><span class="error">[ERR XTMM9000] </span></a>When a transformation is terminated by use of <code>&lt;xsl:message
                        terminate="yes"/&gt;</code>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error">
                        dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be
                        overridden using the <code>error-code</code> attribute of the
                           <a href="#element-message"><code>xsl:message</code></a> instruction.
            </p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49651"></a>Example: Localizing Messages</div>
                  <p>One convenient way to do localization is to put the localized information (message
                  text, etc.) in an XML document, which becomes an additional input file to the
                     <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. For example, suppose
                  messages for a language <code>
                     <var>L</var>
                  </code> are stored in an XML file <code>resources/<var>L</var>.xml</code> in the
                  form:</p>
                  <div class="exampleInner">
                     <pre>&lt;messages&gt;
  &lt;message name="problem"&gt;A problem was detected.&lt;/message&gt;
  &lt;message name="error"&gt;An error was detected.&lt;/message&gt;
&lt;/messages&gt;</pre>
                  </div>
                  <p>Then a stylesheet could use the following approach to localize messages:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:param name="lang" select="'en'"/&gt;
&lt;xsl:variable name="messages"
  select="document(concat('resources/', $lang, '.xml'))/messages"/&gt;

&lt;xsl:template name="localized-message"&gt;
  &lt;xsl:param name="name"/&gt;
  &lt;xsl:message select="string($messages/message[@name=$name])"/&gt;
&lt;/xsl:template&gt;

&lt;xsl:template name="problem"&gt;
  &lt;xsl:call-template name="localized-message"&gt;
    &lt;xsl:with-param name="name"&gt;problem&lt;/xsl:with-param&gt;
  &lt;/xsl:call-template&gt;
&lt;/xsl:template&gt;</pre>
                  </div>
               </div>
               <p>Any <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> that occurs while
               evaluating the <code>select</code> expression or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and any <a title="serialization error" class="termref" href="#dt-serialization-error">serialization error</a> that occurs while
               processing the result, does not cause the transformation to
                  fail; at worst, it means that no message is output, or that the only message that
                  is output is one that relates to the error that occurred.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>An example of such an error is the serialization error that occurs when processing
                  the instruction <code>&lt;xsl:message select="@code"/&gt;</code> (on the grounds
                  that free-standing attributes cannot be serialized). Making such errors
                  recoverable means that it is implementation-defined whether or not they are
                  raised to the user and whether they cause termination of the transformation. If
                  the processor chooses to recover from the error, the content of any resulting
                  message is implementation-dependent.</p>
                  <p>One possible recovery action is to include a description of the error in the
                  generated message text.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="assertions"></a>23.2 <a href="#assertions" style="text-decoration: none">Assertions</a></h3>
               <p>The <a href="#element-assert"><code>xsl:assert</code></a> instruction is used to assert that the value of a
               particular expression is <code>true</code>; if the value of the expression is <code>false</code>, and
               assertions are enabled, then a dynamic error occurs.</p>
               <p class="element-syntax"><a id="element-assert"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:assert<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }〔'Q{http://www.w3.org/2005/xqt-errors}XTMM9001'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:assert&gt;</code></p>
               <p>By default, assertions are disabled.</p>
               <p>An implementation <span class="verb">must</span> provide an external mechanism to enable or
               disable assertion checking. This may work either statically or dynamically, and may
               be at the level of the stylesheet as a whole, or at the level of an individual
               package, or otherwise. The detail of such mechanisms is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
               <p>If assertion checking is enabled, the instruction is evaluated as follows:</p>
               <ol class="enumar">
                  <li>
                     <p>The expression in the <code>test</code> attribute is evaluated. If the
                     effective boolean value of the result is <code>true</code>, the assertion
                     succeeds, and no further action is taken. If the effective boolean value is
                     <code>false</code>, or if a dynamic error occurs during evaluation of the expression, then
                     the assertion fails.</p>
                  </li>
                  <li>
                     <p>If the assertion fails, then the effect of the instruction is governed by the
                     rules for evaluation of an <a href="#element-message"><code>xsl:message</code></a> instruction with the
                     same <code>select</code> attribute, <code>error-code</code> attribute, and
                     contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and with the value
                        <code>terminate="yes"</code>. However, the default error code if the
                        <code>error-code</code> attribute is omitted is <code>XTMM9001</code> rather
                     than <code>XTMM9000</code>.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>To the extent that the behavior of <a href="#element-message"><code>xsl:message</code></a> is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, this rule does not prevent an
                        implementation treating <a href="#element-assert"><code>xsl:assert</code></a> and
                           <a href="#element-message"><code>xsl:message</code></a> differently.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>If evaluation of the <code>test</code> expression
                        fails with a dynamic error, the effect is exactly the same as if the
                        evaluation returns <code>false</code>, including the fact that the
                        instruction fails with error code <code>XTMM9001</code>.</p>
                     </div>
                  </li>
                  <li>
                     <p>If an assertion fails, then the following sibling
                     instructions of the <a href="#element-assert"><code>xsl:assert</code></a> instruction are not
                     evaluated.</p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This means that <a href="#element-assert"><code>xsl:assert</code></a> can
                        be used (rather like <a href="#element-if"><code>xsl:if</code></a> and
                        <a href="#element-choose"><code>xsl:choose</code></a>) to prevent subsequent instructions from
                        executing if a particular precondition is not true, which might be useful if
                        the subsequent instructions have side-effects (for example, by calling
                        extension functions) or if they can fail in uncatchable ways (for example,
                        non-terminating recursion). It is worth noting that there are limits to this
                        guarantee. It does not ensure, for example, that when an assertion within a
                        template fails, the following siblings of the
                           <a href="#element-call-template"><code>xsl:call-template</code></a> instruction that invokes that template
                        will not be evaluated; nor does it ensure that if an assertion fails while
                        processing the first item of a sequence using <a href="#element-for-each"><code>xsl:for-each</code></a>,
                        then subsequent items in the sequence will not be processed. </p>
                     </div>
                  </li>
               </ol>
               <p>
               <a id="err-XTMM9001"><span class="error">[ERR XTMM9001] </span></a>When a transformation is terminated by use of <a href="#element-assert"><code>xsl:assert</code></a>, the
                     effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the
                     transformation. The default error code is <code>XTMM9001</code>; this may be
                     overridden using the <code>error-code</code> attribute of the
                        <a href="#element-assert"><code>xsl:assert</code></a> instruction.
            </p>
               <p>As with any other dynamic error, an error caused by an assertion failing may be
               trapped using <a href="#element-try"><code>xsl:try</code></a>: see <a href="#try-catch"><i>8.4 Try/Catch</i></a>.</p>
               <p>The result of the <a href="#element-assert"><code>xsl:assert</code></a> instruction is the empty sequence.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e49840"></a>Example: Using Assertions with Static Parameters</div>
                  <p>The following example shows a stylesheet function that checks that the value of
                  its supplied argument is in range. The check is performed only if the <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a>
                  <code>$DEBUG</code> is set to <code>true</code>.</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:param name="DEBUG" as="xs:boolean" select="false()" 
           static="yes" required="no"/&gt;
&lt;xsl:function name="f:days-elapsed" as="xs:integer"&gt;
  &lt;xsl:param name="date" as="xs:date"/&gt;
  &lt;xsl:assert use-when="$DEBUG" test="$date lt current-date()"/&gt;
  &lt;xsl:sequence select="(current-date() - $since) 
                            div xs:dayTimeDuration('PT1D')"/&gt;
&lt;/xsl:function&gt;</pre>
                  </div>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Implementations should avoid optimizing <a href="#element-assert"><code>xsl:assert</code></a> instructions
                  away. As a guideline, if the result of a sequence constructor is required by the
                  transformation, the implementation should ensure that all
                     <a href="#element-assert"><code>xsl:assert</code></a> instructions in that sequence constructor are
                  evaluated. Conversely, if the result of a sequence constructor is not required by
                  the transformation, its <a href="#element-assert"><code>xsl:assert</code></a> instructions should not be
                  evaluated.</p>
                  <p>This guidance is not intended to prevent optimizations such as lazy
                  evaluation, where evaluation of a sequence constructor may finish early, as soon
                  as enough information is available to evaluate the containing instruction.</p>
               </div>
               <p>An implementation <span class="verb">may</span> provide a user option allowing a processor
               to treat assertions as being true without explicit checking. This option
                  <span class="verb">must not</span> be enabled by default. If such an option is in force,
               the effect of any assertion not being true is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>For example, given the assertion <code>&lt;xsl:assert
                     test="count(//title)=1"/&gt;</code>, a processor might generate code for the
                  expression <code>&lt;xsl:value-of select="//title"/&gt;</code> that stops searching
                  for <code>title</code> elements after finding the first one. In the event that the
                  source document contains more than one <code>title</code>, execution of the
                  stylesheet may fail in arbitrary ways, or it may produce incorrect output.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="extension"></a>24 <a href="#extension" style="text-decoration: none">Extensibility and Fallback</a></h2>
            <div class="changes">
               <p class="changesHeading">
        Changes in 4.0
        (<a href="#extension-attributes">next</a> | <a href="#array-construction">previous</a>)</p>
               <ol>
                  <li>
                     <p>
               Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>,
               <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>,
               <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>,
               <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>,
               now have the option of supplying an <code>xs:QName</code> value instead.
               [This change was in the editor's draft accepted by the WG as its baseline when
               it started work.]
            <i>&nbsp;&nbsp;[&nbsp;&nbsp;1 January 2022]</i></p>
                  </li>
               </ol>
            </div>
            <p>XSLT allows three kinds of extension: extension attributes, extension instructions, 
            and extension functions.</p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-extension-attribute" title="extension attribute"></a>An <b>extension attribute</b>
               is an attribute appearing on an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, where the name
               of the attribute is in a non-null namespace other than the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>.<span class="definition">]</span>
         </p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-extension-instruction" title="extension instruction"></a>An <b>extension
                  instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension
               namespace.<span class="definition">]</span>
         </p>
            <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-extension-function" title="extension function"></a>An <b>extension
               function</b> is a named function introduced to the static or dynamic context 
               by mechanisms outside the scope of this specification.<span class="definition">]</span></p>
            <p>This specification does not define any mechanism for creating or binding implementations
            of <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>,
            <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>,
            or <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>, and it is not
               <span class="verb">required</span> that implementations support any such mechanism. Such
            mechanisms, if they exist, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. Therefore, an XSLT stylesheet that must be
            portable between XSLT implementations cannot rely on particular extensions being
            available. XSLT provides mechanisms that allow an XSLT stylesheet to determine whether
            the implementation makes particular extensions available, and to specify what happens if
            those extensions are not available. If an XSLT stylesheet is careful to make use of
            these mechanisms, it is possible for it to take advantage of extensions and still retain
            portability.</p>
            <p>
            <a id="err-XTSE0085"><span class="error">[ERR XTSE0085] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>
                  in the name of any <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attribute</a>, 
                  <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>,
                  other than a function or instruction defined in this specification or in a normatively 
                  referenced specification. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a prefix bound 
                  to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute.
               
         </p>
            <div class="div2">
               
               <h3><a id="extension-attributes"></a>24.1 <a href="#extension-attributes" style="text-decoration: none">Extension Attributes</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#extension-instruction">next</a> | <a href="#extension">previous</a>)</p>
                  <ol>
                     <li>
                        <p>The conformance requirements for extension
                  attributes have been relaxed: the requirement to maintain strict conformance
               to the specification in the presence of extension attributes is now a <span class="verb">should</span>
               rather than a <span class="verb">must</span>, and extension attributes are allowed to modify
               the form of serialized output without limitation.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2276">2276</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2283">2283</a>&nbsp;12 November 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>
               An element from the
                  XSLT namespace may have any attribute not from the XSLT namespace, provided that
                  the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> (see <a href="#xpath-40">[XPath 4.0]</a>) 
               of the attribute has a non-null namespace URI. These
                  attributes are referred to as <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>.</p>
               <p>It is not necessary to declare the namespace used for an extension attribute using
            <code>[xsl:]extension-element-prefixes</code> or otherwise.</p>
               <p>The presence of an extension attribute <span class="verb">should not</span> 
               cause the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or any <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> 
               of the transformation to be different from the results
                that a conformant XSLT 4.0
               processor might produce. They <span class="verb">should not</span> cause the processor to fail
               to raise an error that a conformant processor is required to raise. This means that
               an extension attribute <span class="verb">should not</span> change the effect of any 
               <a title="instruction" class="termref" href="#dt-instruction">instruction</a> except to the extent that the effect is
                  <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> or
                  <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>.</p>
               <p>A processor <span class="verb">may</span> make an exception to the above rule in certain cases, for
            example:</p>
               <ul>
                  <li>
                     <p>To allow the user to opt out of some provision in the specification that has
               undesirable performance implications (for example, the requirement that functions like
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> be deterministic).</p>
                  </li>
                  <li>
                     <p>To enable interoperability with third-party software that is not otherwise
               achievable.</p>
                  </li>
                  <li>
                     <p>To allow the user to disable functionality for security reasons.</p>
                  </li>
               </ul>
               <p>Extension attributes <span class="verb">may</span> change the form of serialized output
               in a way that overrides the provisions of <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>, 
               including the suppression of error conditions defined in that specification.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>
                  <a title="extension attribute" class="termref" href="#dt-extension-attribute">Extension attributes</a> may be used
                  to modify the behavior of <a title="extension function" class="termref" href="#dt-extension-function">extension
                     functions</a> and <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension
                     instructions</a>. They may be used to select processing options in cases
                  where the specification leaves the behavior 
                  <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> 
                  or <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>. They may
                  also be used for optimization hints, for diagnostics, or for documentation.</p>
                  <p>
                  <a title="extension attribute" class="termref" href="#dt-extension-attribute">Extension attributes</a> may also be
                  used to influence the behavior of the standard serialization methods <code>xml</code>,
                     <code>xhtml</code>, <code>html</code>, <code>text</code>, <code>json</code>, 
                  and <code>adaptive</code>. For example, an extension attribute might
                  be used to define the amount of indentation to be used when
                     <code>indent="yes"</code> is specified.</p>
                  <p>An implementation that does not recognize the name of an extension attribute, or
                  that does not recognize its value, must perform the transformation as if the
                  extension attribute were not present. As always, it is permissible to produce
                  warning messages.</p>
                  <p>The namespace used for an extension attribute will be copied to the <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> in the normal way if it is in scope
                  for a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.
                  This can be prevented using the <code>[xsl:]exclude-result-prefixes</code>
                  attribute.</p>
               </div>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e50104"></a>Example: An Extension Attribute for <code>xsl:message</code>
                     </div>
                  <p>The following code might be used to indicate to a particular implementation that
                  the <a href="#element-message"><code>xsl:message</code></a> instruction is to ask the user for confirmation
                  before continuing with the transformation:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:message abc:pause="yes"
    xmlns:abc="http://vendor.example.com/xslt/extensions"&gt;
       Phase 1 complete
&lt;/xsl:message&gt;</pre>
                  </div>
                  <p>Implementations that do not recognize the namespace
                     <code>http://vendor.example.com/xslt/extensions</code> will simply ignore the
                  extra attribute, and evaluate the <a href="#element-message"><code>xsl:message</code></a> instruction in the
                  normal way.</p>
               </div>
               <p>
               <a id="err-XTSE0090"><span class="error">[ERR XTSE0090] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an element
                     from the XSLT namespace to have an attribute whose namespace is either null
                     (that is, an attribute with an unprefixed name) or the XSLT namespace, other
                     than attributes defined for the element in this document.
            </p>
            </div>
            <div class="div2">
               
               <h3><a id="extension-functions"></a>24.2 <a href="#extension-functions" style="text-decoration: none">Extension Functions</a></h3>
               <p>The set of functions that can be called from a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP</small></sup> within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> may include one or more <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a>. The <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an extension function always
               has a non-null namespace URI, which <span class="verb">must not</span> be the 
                  URI of a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The definition of the term <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is written to exclude
            user-written <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>,
            constructor functions for built-in and user-defined types, functions in the <code>fn</code>, <code>math</code>,
               <code>map</code>, and <code>array</code> namespaces,
            anonymous XPath inline functions, maps and arrays,
            and partial function applications (including partial applications of extension functions). It also excludes
            functions obtained by invoking XPath-defined functions such as
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-load-xquery-module"><code>load-xquery-module</code></a>.
            The definition allows extension functions to be discovered at evaluation time (typically using
            <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>) rather than necessarily being known statically.
            </p>
                  <p>Technically, the definition of extension functions excludes anonymous functions
            obtained by calling or partially applying other extension functions. Since such functions are
            by their nature implementation-defined, they may however share some of the characteristics of
            extension functions.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-function-available"></a>24.2.1 <a href="#func-function-available" style="text-decoration: none">fn:function-available</a></h4>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Determines whether a particular function is or is not available for use. The function is
            particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>) to test whether a particular <a title="extension function" class="termref" href="#dt-extension-function">extension function</a> is available.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:function-available</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code>,</td>
                                 <td></td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$arity</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">xs:integer?</code></td>
                                 <td><code class="assign">:=&nbsp;</code><code>()</code></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:boolean</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>.  It depends on 
		namespaces, and known function signatures.
	</p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>A function is said to be available within an XPath expression if it is present in the
               <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-statically-known-function-definitions">statically known function
               definitions</a><sup><small>XP</small></sup> for that expression (see <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a>).
            <span>Function definitions</span> in the static context are uniquely identified 
            by the name of the function (a QName) in combination with its
            <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>.</p>
                        <p>The value of <code>$name</code> <span class="verb">must</span> be 
            <span>either an <code>xs:QName</code>, or </span>a
            string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. A lexical QName is
            expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the
            namespace declarations in scope for the <a title="expression" class="termref" href="#dt-expression">expression</a>. 
            If the value is an unprefixed lexical QName, then the <a title="standard function namespace" class="termref" href="#dt-standard-function-namespace">standard function namespace</a> is used in
            the expanded QName.</p>
                        <p><span>When the <code>$arity</code> argument is present and non-empty,</span>
            the <a href="#func-function-available"><code>function-available</code></a> function returns
            <code>true</code> if and only if there is an available function whose name matches the value of the
               <code>$function-name</code> argument and whose <a title="arity range" class="termref" href="#dt-arity-range">arity range</a> 
            includes the value of the <code>$arity</code> argument. </p>
                        <p><span>When the <code>$arity</code> argument is omitted or empty,</span>
            the <a href="#func-function-available"><code>function-available</code></a> function
            returns <code>true</code> if and only if there is at least one available function (with some arity)
            whose name matches the value of the <code>$name</code> argument. </p>
                        <p>When the containing expression is evaluated with <a title="XPath 1.0 compatibility mode" class="termref" href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a> set to
               <code>true</code>, the <a href="#func-function-available"><code>function-available</code></a> function returns <code>false</code> in
            respect of a function name and arity for which no implementation is available (other
            than the fallback error function that raises a dynamic error whenever it is called).
            This means that it is possible (as in XSLT 1.0) to use logic such as the following to
            test whether a function is available before calling it:</p>
                        <div class="example">
                           
                           <div class="exampleHeader"><a id="d5e50307"></a>Example: Calling an extension function with backwards compatibility enabled</div>
                           <div class="exampleInner">
                              <pre>
&lt;summary xsl:version="1.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('my:summary')"&gt;
      &lt;xsl:value-of select="my:summary()"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:text&gt;Summary not available&lt;/xsl:text&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/summary&gt;</pre>
                           </div>
                        </div>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1400"><span class="error">[ERR XTDE1400] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                  <code>$name</code> argument
                      <span>evaluates to a string that is not</span> a valid
                  <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a
                  <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <span class="verb">may</span> optionally raise this
                  as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.
         </p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The fact that a function with a given name is available gives no guarantee that any
            particular call on the function will be successful. For example, it is not possible to
            determine the types of the arguments expected.</p>
                           <p>The introduction of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a>
            function in XPath 3.0 reduces the need for <a href="#func-function-available"><code>function-available</code></a>,
            since <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> not only tests whether a function is
            available, but also returns a function item that enables it to be dynamically
            called.</p>
                           <p>If a function is present in the static context but with no useful
            functionality (for example, if the system has been configured for security reasons so
            that <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-available-environment-variables"><code>available-environment-variables</code></a> returns no information),
            then <a href="#func-function-available"><code>function-available</code></a> when applied to that function should return
            <code>false</code>.</p>
                           <p>It is not necessary that there be a direct equivalence between the
            results of <a href="#func-function-available"><code>function-available</code></a> and
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> in all cases. For example, there may be
               <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> whose side-effects
            are such that for security reasons, dynamic calls to the function are disallowed;
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-function-lookup"><code>function-lookup</code></a> might then not provide access to the function.
            The main use-case for <a href="#func-function-available"><code>function-available</code></a>, by contrast, is for use
            in <code>[xsl:]use-when</code> conditions to test whether static calls on the function
            are possible.</p>
                           <p>In XSLT 4.0, the argument can be supplied as a QName literal, for example
         <code>function-available( #fn:matches )</code>. Note that in this case the default function
         namespace is not used for unprefixed names.</p>
                        </div>
                     </dd>
                     <dt class="label">Examples</dt>
                     <dd>
                        <div class="example">
                           <table style="border:1px solid; padding:5px; width:100%" class="medium">
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="example">
                                          
                                          <div class="exampleHeader"><a id="d5e50397"></a>Example: Stylesheet portable between XSLT 1.0, XSLT 2.0, and XSLT 3.0</div>
                                          <p>A stylesheet that is designed to use XSLT 2.0 facilities when running under an
                     XSLT 2.0 or XSLT 3.0 processor, but to fall
                  back to XSLT 1.0 capabilities when not, might be written using the code:</p>
                                          <div class="exampleInner">
                                             <pre>
&lt;out xsl:version="2.0"&gt;
  &lt;xsl:choose&gt;
    &lt;xsl:when test="function-available('matches')"&gt;
      &lt;xsl:value-of select="matches(/doc/title, '[a-z]*')"/&gt;
    &lt;/xsl:when&gt;
    &lt;xsl:otherwise&gt;
      &lt;xsl:value-of select="string-length(
	        translate(/doc/title, 'abcdefghijklmnopqrstuvwxyz', '')) = 0"/&gt;
    &lt;/xsl:otherwise&gt;
  &lt;/xsl:choose&gt;
&lt;/out&gt;</pre>
                                          </div>
                                          <p>Here an XSLT 2.0 or XSLT 3.0 processor will
                  always take the <a href="#element-when"><code>xsl:when</code></a> branch, while a 1.0 processor will
                  follow the <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch. The single-argument version of
                  the <a href="#func-function-available"><code>function-available</code></a> function is used here, because that is
                  the only version available in XSLT 1.0. Under the rules of XSLT 1.0, the call on
                  the <code>matches</code> function is not an error, because it is never
                  evaluated.</p>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="example">
                                          
                                          <div class="exampleHeader"><a id="d5e50415"></a>Example: Stylesheet portable between XSLT 3.0 and a future version of XSLT</div>
                                          <p>A stylesheet that is designed to use facilities in some future XSLT version when
                  they are available, but to fall back to XSLT 2.0 or XSLT
                     3.0 capabilities when not, might be written using code such as the
                  following. This hypothesizes the availability in some future version of a function
                     <code>pad</code> which pads a string to a fixed length with spaces:</p>
                                          <div class="exampleInner">
                                             <pre>
 &lt;xsl:value-of select="pad(/doc/title, 10)" 
               use-when="function-available('pad', 2)"/&gt;
 &lt;xsl:value-of select="concat(/doc/title, string-join(
                          for $i in 1 to 10 - string-length(/doc/title) 
						  return ' ', ''))"
               use-when="not(function-available('pad', 2))"/&gt;</pre>
                                          </div>
                                          <p>In this case the two-argument version of <a href="#func-function-available"><code>function-available</code></a>
                  is used, because there is no requirement for this code to run under XSLT 1.0.</p>
                                       </div>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="calling-extension-functions"></a>24.2.2 <a href="#calling-extension-functions" style="text-decoration: none">Calling Extension Functions</a></h4>
                  <p>If the function name used in a <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP</small></sup> within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> identifies an extension function, then to evaluate the
                     <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP</small></sup>, the
                  processor will first evaluate each of the arguments in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP</small></sup>. If the processor has
                  information about the datatypes expected by the extension function, then it
                     <span class="verb">may</span> perform any necessary type conversions between the XPath
                  datatypes and those defined by the implementation language. If multiple extension
                  functions are available with the same name, the processor <span class="verb">may</span>
                  decide which one to invoke based on the number of arguments, the types of the
                  arguments, or any other criteria. The result returned by the implementation is
                  returned as the result of the function call, again after any necessary conversions
                  between the datatypes of the implementation language and those of XPath. The
                  details of such type conversions are outside the scope of this specification.</p>
                  <p>
                  <a id="err-XTDE1420"><span class="error">[ERR XTDE1420] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the arguments
                        supplied to a call on an extension function do not satisfy the rules defined
                        for that particular extension function, or if the extension function raises
                        an error, or if the result of the extension function cannot be converted to
                        an XPath value.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Implementations may also provide mechanisms allowing extension functions to
                     raise recoverable dynamic errors, or to execute within an environment that
                     treats some or all of the errors listed above as recoverable.</p>
                  </div>
                  <p>
                  <a id="err-XTDE1425"><span class="error">[ERR XTDE1425] </span></a>When the containing element is processed with
                              <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0
                           behavior</a>, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                           error</a> to evaluate an extension function call if no
                        implementation of the extension function is available.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>When XSLT 1.0 behavior is not enabled, this
                     is a static error <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#ERRXPST0017" title="XPST0017"><span class="error">[ERR XPST0017] </span></a><sup><small>XP40</small></sup>.</p>
                  </div>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>There is no prohibition on calling extension functions that have side-effects
                     (for example, an extension function that writes data to a file). However, the
                     order of execution of XSLT instructions is not defined in this specification,
                     so the effects of such functions are unpredictable.</p>
                  </div>
                  <p>Implementations are not <span class="verb">required</span> to perform full validation of
                  values returned by extension functions. It is an error for an extension function
                  to return a string containing characters that are not permitted in XML, but the
                  consequences of this error are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The implementation <span class="verb">may</span>
                  raise an error, <span class="verb">may</span> convert the string to a string containing
                  valid characters only, or <span class="verb">may</span> treat the invalid characters as
                  if they were permitted characters.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The ability to execute extension functions represents a potential security
                     weakness, since untrusted stylesheets may invoke code that has privileged
                     access to resources on the machine where the <a title="processor" class="termref" href="#dt-processor">processor</a> executes. Implementations may therefore provide
                     mechanisms that restrict the use of extension functions by untrusted
                     stylesheets.</p>
                  </div>
                  <p>All observations in this section regarding the errors that can occur when invoking
                  extension functions apply equally when invoking <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="external-objects"></a>24.2.3 <a href="#external-objects" style="text-decoration: none">External Objects</a></h4>
                  <p>An implementation <span class="verb">may</span> allow an extension function to return an
                  object that does not have any natural representation in the XDM data model,
                  whether as an atomic item, a node, or a function
                     item. For example, an extension function <code>sql:connect</code>
                  might return an object that represents a connection to a relational database; the
                  resulting connection object might be passed as an argument to calls on other
                  extension functions such as <code>sql:insert</code> and
                  <code>sql:select</code>.</p>
                  <p>The way in which such objects are represented in the type system is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. They might be
                  represented by a completely new datatype, or they might be mapped to existing
                  datatypes such as <code>integer</code>, <code>string</code>, or
                     <code>anyURI</code>.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-type-available"></a>24.2.4 <a href="#func-type-available" style="text-decoration: none">fn:type-available</a></h4>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Used to control how a stylesheet behaves if a particular schema type is or is not
            available in the static context.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:type-available</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code></td>
                                 <td></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:boolean</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>.  It depends on 
		namespaces, and schema definitions.
	</p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>A schema type (that is, a simple type or a complex type) is said to be available within
            an XPath expression if it is a type definition that is present in the 
            <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP</small></sup> for that expression
            (see <a href="#static-context"><i>5.3.1 Initializing the Static Context</i></a>). This includes built-in types, types imported
            using <a href="#element-import-schema"><code>xsl:import-schema</code></a>, and extension types defined by the
            implementation.</p>
                        <p>The value of the <code>$name</code> argument <span class="verb">must</span> be 
            <span>either an <code>xs:QName</code>, or</span> a string
            containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. The EQName is expanded into 
            an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> using the namespace declarations in
            scope for the <a title="expression" class="termref" href="#dt-expression">expression</a>. If the value is an
            unprefixed lexical QName, then the default namespace is used in the expanded QName.</p>
                        <p>The function returns <code>true</code> if and only if there is an available type whose name matches
            the value of the <code>$name</code> argument. </p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1428"><span class="error">[ERR XTDE1428] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument
                      <span>evaluates to a string that is 
                        not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the 
                  value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <span class="verb">may</span> optionally raise this
                  as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.
         </p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The <a href="#func-type-available"><code>type-available</code></a> function is of limited use within an
               <code>[xsl:]use-when</code> expression, because the static context for the expression
            does not include any user-defined types.</p>
                           <p>In XSLT 4.0, the argument can be supplied as a QName literal, for example
         <code>type-available( #xs:dateTimeStamp )</code>.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="extension-instruction"></a>24.3 <a href="#extension-instruction" style="text-decoration: none">Extension Instructions</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#creating-result-trees">next</a> | <a href="#extension-attributes">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  It is possible to invoke a named template using an extension instruction, specifically,
                  an element whose name matches the name of the named template.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/168">168</a>&nbsp;&nbsp;30 September 2022]</i></p>
                     </li>
                  </ol>
               </div>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-extension-namespace" title="extension namespace"></a>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows
                  namespaces to be designated as <b>extension namespaces</b>. When a namespace
                  is designated as an extension namespace and an element with a name from that
                  namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.<span class="definition">]</span> The
               namespace determines the semantics of the instruction.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Since an element that is a child of an <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element is
                  not occurring <em>in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a>
                  </em>, <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see
                     <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>) are not extension elements as defined
                  here, and nothing in this section applies to them.</p>
               </div>
               <p>In XSLT 4.0 it is possible to use extension instructions to invoke named templates: see
               <a href="#invoking-templates-with-extension-instructions"><i>10.1.3 Invoking Named Templates using Extension Instructions</i></a>.
            </p>
               <div class="div3">
                  
                  <h4><a id="designating-extension-namespace"></a>24.3.1 <a href="#designating-extension-namespace" style="text-decoration: none">Designating an Extension Namespace</a></h4>
                  <p>A namespace is designated as an extension namespace by using an
                     <code>[xsl:]extension-element-prefixes</code> attribute on an element in the
                  stylesheet (see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>). The attribute
                     <span class="verb">must</span> be in the XSLT namespace only if its parent element is
                     <em>not</em> in the XSLT namespace. The value of the attribute is a
                  whitespace-separated list of namespace prefixes. The namespace bound to each of
                  the prefixes is designated as an extension namespace.</p>
                  <p>The default namespace (as declared by <code>xmlns</code>) may be designated as an
                  extension namespace by including <code>#default</code> in the list of namespace
                  prefixes.</p>
                  <p>A <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> 
                  cannot be designated as an extension namespace: see <span class="error">[see <a href="#err-XTSE0085">ERR XTSE0085</a>]</span>.</p>
                  <p>
                  <a id="err-XTSE1430"><span class="error">[ERR XTSE1430] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is no
                        namespace bound to the prefix on the element bearing the
                           <code>[xsl:]extension-element-prefixes</code> attribute or, when
                           <code>#default</code> is specified, if there is no default namespace.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>The prefix must be declared in a 
                  <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace binding</a>,
                  not in a <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace binding</a>.</p>
                  </div>
                  <p>The designation of a namespace as an extension namespace is effective for the
                  element bearing the <code>[xsl:]extension-element-prefixes</code> attribute and
                  for all descendants of that element within the same stylesheet module.</p>
               </div>
               <div class="div3">
                  
                  <h4><a id="func-element-available"></a>24.3.2 <a href="#func-element-available" style="text-decoration: none">fn:element-available</a></h4>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Determines whether a particular instruction is or is not available for use. The function
            is particularly useful for calling within an <code>[xsl:]use-when</code> attribute (see
               <a href="#conditional-inclusion"><i>3.11.3 Conditional Element Inclusion</i></a>) to test whether a particular
            <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> is available.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:element-available</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">(xs:string | xs:QName)</code></td>
                                 <td></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>xs:boolean</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>.  It depends on 
		namespaces.
	</p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The value of the <code>$name</code> argument
               <span class="verb">must</span> be <span>either an <code>xs:QName</code>,
               or</span> a string containing an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. 
            If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>
            with a prefix, then it is expanded into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
               QName</a> using the namespace declarations in the static context of the
               <a title="expression" class="termref" href="#dt-expression">expression</a>. If there is a default namespace in
            scope, then it is used to expand an unprefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
               QName</a>.</p>
                        <p> If the resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
               QName</a> is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, the function returns
            <code>true</code> if and only if the local name matches the name of an XSLT element that is defined
            in this specification and implemented by the XSLT processor.</p>
                        <p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> has a null namespace
            URI, the <a href="#func-element-available"><code>element-available</code></a> function will return <code>false</code>. </p>
                        <p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> is not in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, the function returns <code>true</code> if and
            only if the processor has an <span>external</span> implementation 
            available of an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> with the given
            expanded QName. This applies whether or not the namespace has been designated as an
               <a title="extension namespace" class="termref" href="#dt-extension-namespace">extension namespace</a>.</p>
                        <p>The term <b>external implementation</b> excludes the use of a 
            <a title="named template" class="termref" href="#dt-named-template">named template</a> as the instruction’s implementation. The function does not return
         <code>true</code> simply because the name matches the name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>.</p>
                        <p>If the processor does not have an implementation of a particular extension instruction
            available, and such an extension instruction is evaluated, then the processor
               <span class="verb">must</span> perform fallback for the element as specified in <a href="#fallback"><i>24.3.3 Fallback</i></a>. An implementation <span class="verb">must not</span> raise an error
            merely because the stylesheet contains an extension instruction for which no
            implementation is available.</p>
                     </dd>
                     <dt class="label">Error Conditions</dt>
                     <dd>
                        <p>
            <a id="err-XTDE1440"><span class="error">[ERR XTDE1440] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument
                      <span>evaluates to a string that is 
                        not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value 
                  is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <span class="verb">may</span> optionally raise this
                  as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.
         </p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>For element names in the XSLT namespace:</p>
                           <ul>
                              <li>
                                 <p>This function can be useful to
                  distinguish processors that implement XSLT 3.0 from processors that implement
                  other (older or newer) versions of the specification, and to distinguish full
                  implementations from incomplete implementations. (Incomplete implementations,
                  of course, cannot be assumed to behave as described in this specification.)</p>
                              </li>
                              <li>
                                 <p>In earlier versions of this specification,
                     <a href="#func-element-available"><code>element-available</code></a> was defined to return <code>true</code> only for
                  elements classified as instructions. The distinction between instructions and
                  other elements, however, is sometimes rather technical, and in XSLT 3.0 the effect
                  of the function has therefore been aligned to do what its name might suggest.</p>
                              </li>
                              <li>
                                 <p>If an instruction is recognized but offers no useful
                  functionality (for example, if the system has been configured for security reasons
                  so that <a href="#element-evaluate"><code>xsl:evaluate</code></a> always raises an error), then
                     <a href="#func-element-available"><code>element-available</code></a> when applied to that instruction
                     <span class="verb">should</span> return <code>false</code>.</p>
                              </li>
                           </ul>
                           <p>For element names in other namespaces:</p>
                           <ul>
                              <li>
                                 <p>The result of the <a href="#func-element-available"><code>element-available</code></a> does not depend on
                  whether or not the namespace of the supplied instruction name has been designated
                  as an extension element namespace; it tests whether the instruction would be
                  available if the namespace were designated as such.</p>
                              </li>
                           </ul>
                           <p>In XSLT 4.0, the argument can be supplied as a QName literal, for example
         <code>element-available( #xsl:switch )</code>. Note that in this case the default element
         namespace is not used for unprefixed names.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
               <div class="div3">
                  
                  <h4><a id="fallback"></a>24.3.3 <a href="#fallback" style="text-decoration: none">Fallback</a></h4>
                  <p class="element-syntax"><a id="element-fallback"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:fallback&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:fallback&gt;</code></p>
                  <p>The content of an <a href="#element-fallback"><code>xsl:fallback</code></a> element is a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, and when
                  performing fallback, the value returned by the <a href="#element-fallback"><code>xsl:fallback</code></a>
                  element is the result of evaluating this sequence constructor.</p>
                  <p>When not performing fallback, evaluating an <a href="#element-fallback"><code>xsl:fallback</code></a> element
                  returns the empty sequence: the content of the <a href="#element-fallback"><code>xsl:fallback</code></a>
                  element is not evaluated.</p>
                  <p>There are two situations where a <a title="processor" class="termref" href="#dt-processor">processor</a>
                  performs fallback: when an extension instruction that is not available is
                  evaluated, and when an instruction in the XSLT namespace, that is not defined in
                  XSLT 3.0, is evaluated within a region of the
                  stylesheet for which <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is
                  enabled.</p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>Fallback processing is not invoked in other situations, for example it is not
                     invoked when an XPath expression uses unrecognized syntax or contains a call to
                     an unknown function. To handle such situations dynamically, the stylesheet
                     should call functions such as <a href="#func-system-property"><code>system-property</code></a> and
                        <a href="#func-function-available"><code>function-available</code></a> to decide what capabilities are
                     available.</p>
                  </div>
                  <p>
                  <a id="err-XTDE1450"><span class="error">[ERR XTDE1450] </span></a>When a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback for
                        an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>
                        that is not recognized, if the instruction element has one or more
                           <a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the
                           <a href="#element-fallback"><code>xsl:fallback</code></a> children <span class="verb">must</span> be
                        evaluated; it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if it has no
                           <a href="#element-fallback"><code>xsl:fallback</code></a> children.
               </p>
                  <div class="note">
                     <p class="prefix"><b>Note:</b></p>
                     <p>This is different from the situation with unrecognized <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT elements</a>. As explained in <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>, an unrecognized XSLT element appearing within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is a static
                     error unless (a) <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> is enabled,
                     and (b) the instruction has an <a href="#element-fallback"><code>xsl:fallback</code></a> child.</p>
                  </div>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="result-trees"></a>25 <a href="#result-trees" style="text-decoration: none">Transformation Results</a></h2>
            <p>The output of a transformation includes a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> and zero or more <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>.</p>
            <p>The way in which these results are
             delivered to an application is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
            <p>Serialization of results
             is described further in <a href="#serialization"><i>26 Serialization</i></a>
         </p>
            <div class="div2">
               
               <h3><a id="creating-result-trees"></a>25.1 <a href="#creating-result-trees" style="text-decoration: none">Creating Secondary Results</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-current-output-uri">next</a> | <a href="#extension-instruction">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  A new serialization parameter <code>escape-solidus</code> is provided to control
                  whether the character <code>/</code> is escaped as <code>\/</code> by the
                  JSON serialization method.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/530">530</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/534">534</a>&nbsp;9 June 2023]</i></p>
                     </li>
                     <li>
                        <p>
                  The input to the serializer can be defined using the <code>select</code> attribute
                  of <a href="#element-result-document"><code>xsl:result-document</code></a> as an alternative to using a sequence constructor.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1534">1534</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1549">1549</a>&nbsp;12 November 2024]</i></p>
                     </li>
                     <li>
                        <p>
                  A new serialization parameter <code>canonical</code> is available to give control
                  over serialization of XML, XHTML, and JSON.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/938">938</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259</a>&nbsp;2 November 2025]</i></p>
                     </li>
                     <li>
                        <p>
                  A new serialization parameter <code>json-lines</code> is available to enable
                  output as one JSON value per line.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1538">1538</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1497">1497</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1546">1546</a>&nbsp;13 November 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-result-document"></a><code>&lt;!-- Category: instruction --&gt;<br>&lt;xsl:result-document<br>&nbsp;&nbsp;format? = { <var>eqname</var> }<br>&nbsp;&nbsp;href? = { <var>uri</var> }<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;method? = { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var> }<br>&nbsp;&nbsp;allow-duplicate-names? = { <var>boolean</var> }<br>&nbsp;&nbsp;build-tree? = { <var>boolean</var> }<br>&nbsp;&nbsp;byte-order-mark? = { <var>boolean</var> }<br>&nbsp;&nbsp;canonical? = { <var>boolean</var> }<br>&nbsp;&nbsp;cdata-section-elements? = { <var>eqnames</var> }<br>&nbsp;&nbsp;doctype-public? = { <var>string</var> }<br>&nbsp;&nbsp;doctype-system? = { <var>string</var> }<br>&nbsp;&nbsp;encoding? = { <var>string</var> }<br>&nbsp;&nbsp;escape-solidus? = { <var>boolean</var> }<br>&nbsp;&nbsp;escape-uri-attributes? = { <var>boolean</var> }<br>&nbsp;&nbsp;html-version? = { <var>decimal</var> }<br>&nbsp;&nbsp;include-content-type? = { <var>boolean</var> }<br>&nbsp;&nbsp;indent? = { <var>boolean</var> }<br>&nbsp;&nbsp;item-separator? = { <var>string</var> }<br>&nbsp;&nbsp;json-lines? = { <var>boolean</var> }<br>&nbsp;&nbsp;json-node-output-method? = { "xml" | "html" | "xhtml" | "text" | <var>eqname</var> }<br>&nbsp;&nbsp;media-type? = { <var>string</var> }<br>&nbsp;&nbsp;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var> }<br>&nbsp;&nbsp;omit-xml-declaration? = { <var>boolean</var> }<br>&nbsp;&nbsp;parameter-document? = { <var>uri</var> }<br>&nbsp;&nbsp;standalone? = { <var>boolean</var> | "omit" }<br>&nbsp;&nbsp;suppress-indentation? = { <var>eqnames</var> }<br>&nbsp;&nbsp;undeclare-prefixes? = { <var>boolean</var> }<br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;output-version? = { <var>nmtoken</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:result-document&gt;</code></p>
               <p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction is
               used to create a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>.</p>
               <p>The <code>select</code> attribute and the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> are
               mutually exclusive; if the <code>select</code> attribute is present then the
               sequence constructor must be empty, and if the sequence constructor is non-empty
               then the <code>select</code> attribute must be absent <span class="error">[see <a href="#err-XTSE3185">ERR XTSE3185</a>]</span>. 
               The value of the <code>select</code> attribute or the <a title="immediate result" class="termref" href="#dt-immediate-result">immediate result</a>
               of the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
               is referred to as the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>.</p>
               <p>As with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> of the
            transformation, a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> may be delivered to the calling
            application in three ways (see <a href="#post-processing"><i>2.3.6 Post-processing the Raw Result</i></a>):</p>
               <ol class="enumar">
                  <li>
                     <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be delivered <em>as is</em>.</p>
                  </li>
                  <li>
                     <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be used to construct a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>
               by invoking the process of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>.</p>
                  </li>
                  <li>
                     <p>The <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> may be serialized to a sequence of octets (which
               may then, optionally, be saved to a persistent storage location).</p>
                  </li>
               </ol>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The name of the instruction, <a href="#element-result-document"><code>xsl:result-document</code></a>, is a little
            misleading. The instruction does not necessarily deliver either an XML document tree
            nor a serialized XML document. Instead, for example, it might deliver an array, a map,
            serialized JSON, or a sequence of atomic items.</p>
               </div>
               <p>The decision whether or not to serialize the raw result depends on the 
               <a title="processor" class="termref" href="#dt-processor">processor</a> and on the way it is invoked. This
               is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, and it is not controlled by anything
               in the stylesheet.</p>
               <p>If the result is not serialized, then the decision whether to
               return the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> or to construct a tree depends on the effective
               value of the <code>build-tree</code> attribute. If the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of
               the <code>build-tree</code> attribute is <code>yes</code>, then 
                  a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is created
               by invoking the process of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>. 
               Conversely, if the result <em>is</em> serialized, then 
                  the decision whether or not to construct a tree depends on the choice of 
                  serialization method, and the <code>build-tree</code> attribute is then ignored. 
                  For example, with <code>method="xml"</code> a tree is always constructed, whereas 
                  with <code>method="json"</code> a tree is never constructed.
               </p>
               <p>The <a href="#element-result-document"><code>xsl:result-document</code></a> instruction
               defines a URI that may be used to identify the <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>.
               The instruction may optionally specify the output format to be used for serializing the result.</p>
               <p>Technically, the result of evaluating the <a href="#element-result-document"><code>xsl:result-document</code></a>
               instruction is the empty sequence. This means it does not contribute anything to the
               result of the sequence constructor it is part of.</p>
               <p>The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                  <code>format</code> attribute, if specified, <span class="verb">must</span> be an <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. The value is
               expanded using the namespace declarations in scope for the
                  <a href="#element-result-document"><code>xsl:result-document</code></a> element. The resulting <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>
               <span class="verb">must</span> match the expanded QName of a named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>. This identifies the
                  <a href="#element-output"><code>xsl:output</code></a> declaration that will control the serialization of the
                  <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> (see <a href="#serialization"><i>26 Serialization</i></a>), if the result tree is serialized. If the
                  <code>format</code> attribute is omitted, the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> is used to control
               serialization of the result tree.</p>
               <p>
               <a id="err-XTDE1460"><span class="error">[ERR XTDE1460] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                        <code>format</code> attribute  is not a valid
                        <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if it does not match the
                        <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect
                     the error statically (for example, when the <code>format</code> attribute
                     contains no curly brackets), then the processor <span class="verb">may</span>
                     optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static
                        error</a>.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The only way to select the unnamed <a title="output definition" class="termref" href="#dt-output-definition">output
                     definition</a> is to omit the <code>format</code> attribute.</p>
               </div>
               <p>The <code>parameter-document</code> attribute allows serialization
               parameters to be supplied in an external document. The external document must contain
               an <code>output:serialization-parameters</code> element with the format described in
                  <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> section <a href="../xslt-xquery-serialization-40/#serparams-in-xdm-instance">3.1 Setting Serialization Parameters by Means of a Parameter Document</a>, and the parameters are
               interpreted as described in that specification.</p>
               <p>If present, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the URI supplied in the
                  <code>parameter-document</code> attribute is dereferenced, after resolution
               against the base URI of the <a href="#element-result-document"><code>xsl:result-document</code></a> element if it is a
               relative reference. 
               The parameter document <span class="verb">should</span> be read during run-time evaluation of the stylesheet. 
               If the location of the stylesheet at development time is
               different from the deployed location, any relative reference should be resolved
               against the deployed location. A serialization error occurs if the result of
               dereferencing the URI is ill-formed or invalid; but if no document can be found at
               the specified location, the attribute <code>should</code> be ignored.</p>
               <p>A serialization parameter specified in the
                  <code>parameter-document</code> takes precedence over a value supplied directly as
               an attribute of <a href="#element-result-document"><code>xsl:result-document</code></a>, which in turn takes precedence
               over a value supplied in the selected output definition, except that the values of
               the <code>cdata-section-elements</code> and <code>suppress-indentation</code>
               attributes are merged in the same way as when multiple <a href="#element-output"><code>xsl:output</code></a>
               declarations are merged.</p>
               <p>The attributes <code>method</code>, <code>allow-duplicate-names</code>, <code>build-tree</code>, <code>byte-order-mark</code>
               <code>canonical</code>, <code>cdata-section-elements</code>, <code>doctype-public</code>,
                  <code>doctype-system</code>, <code>encoding</code>,
               <code>escape-solidus</code>
                  <code>escape-uri-attributes</code>, <code>html-version</code>, <code>indent</code>, <code>item-separator</code>,
               <code>json-lines</code>,
               <code>json-node-output-method</code>,
                  <code>media-type</code>, <code>normalization-form</code>,
                  <code>omit-xml-declaration</code>, <code>standalone</code>, <code>suppress-indentation</code>,
               
               <code>undeclare-prefixes</code>, <code>use-character-maps</code>, and
                  <code>output-version</code> may be used to override attributes defined in the
               selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>.</p>
               <p>With the exception of <code>use-character-maps</code>, these attributes are all
               defined as <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value
                  templates</a>, so their values may be set dynamically. For any of these
               attributes that is present on the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction,
               the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute
               overrides or supplements the corresponding value from the output definition. This
               works in the same way as when one <a href="#element-output"><code>xsl:output</code></a> declaration overrides
               another. Some of the attributes have more specific
                  rules:</p>
               <ul>
                  <li>
                     <p>In the case of <code>cdata-section-elements</code>
                     and <code>suppress-indentation</code>, the
                     value of the serialization parameter is the union of the expanded names of the
                     elements named in this instruction and the elements named in the selected
                     output definition.</p>
                  </li>
                  <li>
                     <p>In the case of <code>use-character-maps</code>, the character maps referenced
                     in this instruction supplement and take precedence over those defined in the
                     selected output definition.</p>
                  </li>
                  <li>
                     <p>In the case of <code>doctype-public</code> and <code>doctype-system</code>,
                     setting the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute to a zero-length string has the
                     effect of overriding any value for these attributes obtained from the output
                     definition. The corresponding serialization parameter is not set (is
                     “absent”).</p>
                  </li>
                  <li>
                     <p>In the case of <code>item-separator</code>, setting the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                     attribute to the special value <code>"#absent"</code> has the effect of
                     overriding any value for this attribute obtained from the output definition.
                     The corresponding serialization parameter is not set (is “absent”). It is not
                     possible to set the value of the serialization parameter to the literal
                     7-character string <code>"#absent"</code>. </p>
                  </li>
                  <li>
                     <p>In all other cases, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute actually present on
                     this instruction takes precedence over the value defined in the selected output
                     definition.</p>
                  </li>
               </ul>
               <p>In the case of the attributes <code>method</code>, <code>json-node-output-method</code>
                     <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and
                     <code>use-character-maps</code>, the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the attribute
                  contains an <a title="EQName" class="termref" href="#dt-eqname">EQName</a> or a space-separated list of
                     <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>. Where lexical QNames are used in these attributes (whether prefixed
               or unprefixed), the namespace context is established in the same way as for the corresponding
               attributes of <a href="#element-output"><code>xsl:output</code></a>: see <a href="#id-default-serialization-parameters"><i>26.2 Serialization parameters</i></a>.</p>
               <p>The <code>output-version</code> attribute on the <a href="#element-result-document"><code>xsl:result-document</code></a>
               instruction overrides the <code>version</code> attribute on
                  <a href="#element-output"><code>xsl:output</code></a> (it has been renamed because <code>version</code> is
               available with a different meaning as a standard attribute: see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>). In all other cases, attributes correspond if they
               have the same name.</p>
               <p>There are some serialization parameters that apply to some output methods but not to
               others. For example, the <code>indent</code> attribute has no effect on the
                  <code>text</code> output method. If a value is supplied for an attribute that is
               inapplicable to the output method, its value is not passed to the serializer. The
               processor <span class="verb">may</span> validate the value of such an attribute, but is not
                  <span class="verb">required</span> to do so.</p>
               <p>The <code>item-separator</code> serialization parameter
               is used when the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a> is used to construct a result tree
               by applying sequence normalization, and it is also used when the result tree is
               serialized. For example, if the sequence constructor delivers a sequence of
               integers, and the <code>text</code> serialization method is used, then the result of serialization
               will be a string obtained by converting each integer to a string, and separating the
               strings using the defined <code>item-separator</code>.</p>
               <p>The <code>href</code> attribute is optional. The default value is the zero-length
               string. The <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
               attribute <span class="verb">must</span> be a <a title="URI Reference" class="termref" href="#dt-uri-reference">URI
                  Reference</a>, which may be absolute or relative. If it is relative, then it is resolved against the <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>. There <span class="verb">may</span> be <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> restrictions on
               the form of absolute URI that may be used, but the implementation is not
                  <span class="verb">required</span> to enforce any restrictions. Any valid relative URI
                  reference
               <span class="verb">must</span> be accepted. Note that the zero-length string is a valid
               relative URI reference.</p>
               <p>If the implementation provides an API to access <a title="secondary result" class="termref" href="#dt-secondary-result">secondary results</a>, then it
                  <span class="verb">must</span> allow a secondary result to be identified by means of the
               absolutized value of the <code>href</code> attribute. In addition, if a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is constructed
               (that is, if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of
                  <code>build-tree</code> is <code>yes</code>), then this value is used as the base
               URI of the document node at the root of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final
                  result tree</a>. </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The base URI of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                     tree</a> is not necessarily the same thing as the URI of its serialized
                  representation on disk, if any. For example, a server (or browser client) might
                  store final result trees only in memory, or in an internal disk cache. As long as
                  the processor satisfies requests for those URIs, it is irrelevant where they are
                  actually written on disk, if at all.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>It will often be the case that one <a title="final result tree" class="termref" href="#dt-final-result-tree">final
                     result tree</a> contains links to another final result tree produced
                  during the same transformation, in the form of a relative URI reference. The mechanism of associating a URI with a final
                  result tree has been chosen to allow the integrity of such links to be preserved
                  when the trees are serialized.</p>
                  <p>As well as being potentially significant in any API that provides access to final
                  result trees, the base URI of the new document node is relevant if the final
                  result tree, rather than being serialized, is supplied as input to a further
                  transformation.</p>
               </div>
               <p>The optional attributes <code>type</code> and <code>validation</code> may be used on
               the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction to validate the contents of
                  a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>, and to determine the <a title="type annotation" class="termref" href="#dt-type-annotation">type
                  annotation</a> that elements and attributes within the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> will carry. The permitted
               values and their semantics are described in <a href="#validating-document-nodes"><i>25.4.2 Validating Document Nodes</i></a>. Any such validation is applied to the
               document node produced as the result of <a href="https://qt4cg.org/specifications/xslt-xquery-serialization-40/#sequence-normalization">sequence normalization</a><sup><small>SE</small></sup>.
               If sequence normalization does not take place (typically because the <a title="raw result" class="termref" href="#dt-raw-result">raw result</a>
               is delivered to the application directly, or because the selected serialization method
               does not involve sequence normalization) then the <code>validation</code> and
               <code>type</code> attributes are ignored.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Validation applies after inserting item separators as determined by the
            <code>item-separator</code> serialization parameter, and an inappropriate choice
            of <code>item-separator</code> may cause the result to become invalid.</p>
               </div>
               <p>A <a title="processor" class="termref" href="#dt-processor">processor</a>
               <span class="verb">may</span> allow a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                  tree</a> to be serialized. Serialization is described in <a href="#serialization"><i>26 Serialization</i></a>. However, an implementation (for example, a <a title="processor" class="termref" href="#dt-processor">processor</a> running in an environment with no access to
               writable filestore) is not <span class="verb">required</span> to support the serialization
               of <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a>. An
               implementation that does not support the serialization of final result trees
                  <span class="verb">may</span> ignore the <code>format</code> attribute and the
               serialization attributes. Such an implementation <span class="verb">must</span> provide the
               application with some means of access to the (un-serialized) result tree, using its
               URI to identify it.</p>
               <p>Implementations may provide additional mechanisms, outside the scope of this
               specification, for defining the way in which <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> are processed. Such mechanisms
                  <span class="verb">may</span> make use of the XSLT-defined attributes on the
                  <a href="#element-result-document"><code>xsl:result-document</code></a> and/or <a href="#element-output"><code>xsl:output</code></a> elements,
               or they <span class="verb">may</span> use additional elements or attributes in an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> namespace.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e51818"></a>Example: Multiple Result Documents</div>
                  <p> The following example takes an XHTML document as input, and breaks it up so that
                  the text following each &lt;h1&gt; element is included in a separate document. A
                  new document <code>toc.html</code> is constructed to act as an index:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:stylesheet
	version="3.0"
	xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
	xmlns:xhtml="http://www.w3.org/1999/xhtml"&gt;
	
&lt;xsl:output name="toc-format" method="xhtml" indent="yes"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Strict//EN"/&gt;
            
&lt;xsl:output name="section-format" method="xhtml" indent="no"
     doctype-system="http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"
     doctype-public="-//W3C//DTD XHTML 1.0 Transitional//EN"/&gt;	
	 
&lt;xsl:template match="/"&gt;
  &lt;xsl:result-document href="toc.html" 
                       format="toc-format" 
                       validation="strict"&gt;
    &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
      &lt;head&gt;&lt;title&gt;Table of Contents&lt;/title&gt;&lt;/head&gt;
      &lt;body&gt;
        &lt;h1&gt;Table of Contents&lt;/h1&gt;
        &lt;xsl:for-each select="/*/xhtml:body/(*[1] | xhtml:h1)"&gt;
          &lt;p&gt;
            &lt;a href="section{position()}.html"&gt;
              &lt;xsl:value-of select="."/&gt;
            &lt;/a&gt;
          &lt;/p&gt;
        &lt;/xsl:for-each&gt;
      &lt;/body&gt;
    &lt;/html&gt;
  &lt;/xsl:result-document&gt;
  &lt;xsl:for-each-group select="/*/xhtml:body/*" group-starting-with="xhtml:h1"&gt;
    &lt;xsl:result-document href="section{position()}.html" 
                         format="section-format" validation="strip"&gt;  	
      &lt;html xmlns="http://www.w3.org/1999/xhtml"&gt;
        &lt;head&gt;&lt;title&gt;&lt;xsl:value-of select="."/&gt;&lt;/title&gt;&lt;/head&gt;
        &lt;body&gt;
          &lt;xsl:copy-of select="current-group()"/&gt;
        &lt;/body&gt;
      &lt;/html&gt;
    &lt;/xsl:result-document&gt;
  &lt;/xsl:for-each-group&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</pre>
                  </div>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="result-document-restrictions"></a>25.2 <a href="#result-document-restrictions" style="text-decoration: none">Restrictions on the use of <code>xsl:result-document</code></a></h3>
               <p>There are restrictions on the use of the <a href="#element-result-document"><code>xsl:result-document</code></a>
               instruction, designed to ensure that the results are fully interoperable even when
               processors optimize the sequence in which instructions are evaluated. Informally, the
               restriction is that the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction can only be
               used while writing a final result tree, not while writing to a temporary tree or a
               sequence. This restriction is defined formally as follows.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-output-state" title="output state"></a>Each instruction in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated in one of two possible
                     <b>output states</b>: <a title="final output state" class="termref" href="#dt-final-output-state">final output
                     state</a> or <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output
                     state</a>.<span class="definition">]</span></p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-final-output-state" title="final output state"></a>The first of the two
                     <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>final
                     output</b> state. This state applies when instructions are writing to a
                     <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.<span class="definition">]</span>
            </p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-temporary-output-state" title="temporary output state"></a>The second of
                  the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called
                     <b>temporary output</b> state. This state applies when instructions are
                  writing to a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> or any
                  other non-final destination.<span class="definition">]</span>
            </p>
               <p>The instructions in the <a title="initial named template" class="termref" href="#dt-initial-named-template">initial named template</a> are evaluated in
                  <a title="final output state" class="termref" href="#dt-final-output-state">final output state</a>. An instruction
               is evaluated in the same <a title="output state" class="termref" href="#dt-output-state">output state</a> as its
               calling instruction, except that <a href="#element-variable"><code>xsl:variable</code></a>,
                  <a href="#element-param"><code>xsl:param</code></a>, <a href="#element-with-param"><code>xsl:with-param</code></a>, 
               <a href="#element-function"><code>xsl:function</code></a>, <a href="#element-key"><code>xsl:key</code></a>, <a href="#element-sort"><code>xsl:sort</code></a>,
                  <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a>, and
                     <a href="#element-merge-key"><code>xsl:merge-key</code></a>
                always evaluate the instructions in their
               contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> in
                  <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p>
               <p>
               <a id="err-XTDE1480"><span class="error">[ERR XTDE1480] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate the
                        <a href="#element-result-document"><code>xsl:result-document</code></a> instruction in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.
            </p>
               <p>
               <a id="err-XTDE1490"><span class="error">[ERR XTDE1490] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a transformation to
                     generate two or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                        trees</a> with the same URI.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Note, this means that it is an error to evaluate more than one
                     <a href="#element-result-document"><code>xsl:result-document</code></a> instruction that omits the
                     <code>href</code> attribute, or to evaluate any
                     <a href="#element-result-document"><code>xsl:result-document</code></a> instruction that omits the
                     <code>href</code> attribute if an initial <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is created implicitly.</p>
               </div>
               <p>In addition, an implementation <span class="verb">may</span> raise this
               error if it is able to detect that two or more final result trees are generated with
               different URIs that refer to the same physical resource.</p>
               <p>
               <a id="err-XTDE1500"><span class="error">[ERR XTDE1500] </span></a>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to write to an external resource
                     and read from the same resource during a single transformation, if the same absolute URI is used to access the resource in
                        both cases. 
            </p>
               <p>In addition, an implementation <span class="verb">may</span> raise this
               error if it is able to detect that a transformation writes to a resource and reads
               from the same resource using different URIs that refer to the same physical resource.
               Note that if the error is not detected, it is <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a> whether the document that is read from the
               resource reflects its state before or after the result tree is written.</p>
            </div>
            <div class="div2">
               
               <h3><a id="current-output-uri"></a>25.3 <a href="#current-output-uri" style="text-decoration: none">The Current Output URI</a></h3>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-current-output-uri" title="current output URI"></a>The <b>current output URI</b> is the URI
                  associated with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> that is currently being written.<span class="definition">]</span></p>
               <div class="div3">
                  
                  <h4><a id="func-current-output-uri"></a>25.3.1 <a href="#func-current-output-uri" style="text-decoration: none">fn:current-output-uri</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#validation">next</a> | <a href="#creating-result-trees">previous</a>)</p>
                     <ol>
                        <li>
                           <p>In XSLT 4.0, the function item <code>current-output-uri#0</code> retains the value of the current
         output URI within its captured context.<i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/407">407</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274</a>&nbsp;6 January 2026]</i></p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Returns the value of the <a title="current output URI" class="termref" href="#dt-current-output-uri">current output URI</a>.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name return-type">
                                 <td colspan="3"><code class="function">fn:current-output-uri</code>()<code class="as">&nbsp;as&nbsp;</code><code class="return-type">xs:anyURI?</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>. </p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>On initial invocation of a stylesheet component, the current output uri is set to the
         <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p>
                        <p>During execution of an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction with an <code>href</code>
         attribute, the current output URI changes to the absolute URI obtained by resolving the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
         of the <code>href</code> attribute against the base output URI.</p>
                        <p>The current output URI is cleared (set to <a title="absent" class="termref" href="#dt-absent">absent</a>) while evaluating stylesheet functions, 
            dynamic function calls, evaluation of global variables, stylesheet parameters, and patterns. 
            If the function is called when the current output URI is absent, the function returns the empty sequence.
         </p>
                        <p>The current output URI may also be <a title="absent" class="termref" href="#dt-absent">absent</a> in the event that a stylesheet is invoked without supplying a
         <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>.</p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The current output URI is not cleared when evaluating a local variable, even though <a href="#element-result-document"><code>xsl:result-document</code></a>
            cannot be used while evaluating a local variable. 
            The reason for this is to allow the value of <code>current-output-uri</code> to be set as the value of a 
            tunnel parameter, so that the original
            base output URI is accessible even when writing nested result documents.</p>
                        </div>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="validation"></a>25.4 <a href="#validation" style="text-decoration: none">Validation</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#id-xsl-output-declaration">next</a> | <a href="#func-current-output-uri">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The rules concerning the compatibility of schemas imported by different packages have 
                  been clarified. It is now explicitly stated that instructions that trigger validation 
                  must use the imported schema of the package in which validation is invoked. 
                  This differs from the current practice of some XSLT 3.0 processors, which may 
                  use (for example) a schema formed from the union of the imported schemas in all 
                  packages.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/451">451</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635</a>&nbsp;24 October 2023]</i></p>
                     </li>
                     <li>
                        <p>
                  The rules concerning the interpretation of <code>xsi:schemaLocation</code>
                  and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/729">729</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254</a>&nbsp;8 June 2024]</i></p>
                     </li>
                     <li>
                        <p>
                  The rules concerning the interpretation of <code>xsi:schemaLocation</code>
                  and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/729">729</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254</a>&nbsp;8 June 2024]</i></p>
                     </li>
                     <li>
                        <p>
                  In order to reduce duplication between the XSLT and XQuery specifications, description
                  of the validation process has been moved to the <em>Functions and Operators</em>
                  specification.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2029">2029</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2030">2030</a>&nbsp;28 May 2025]</i></p>
                     </li>
                  </ol>
               </div>
               <p>It is possible to control the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> applied to
               individual element and attribute nodes as they are constructed. This is done using
               the <code>type</code> and <code>validation</code> attributes of the
                  <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                  <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
                  <a href="#element-document"><code>xsl:document</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a>
               instructions, or the <code>xsl:type</code> and <code>xsl:validation</code> attributes
               of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.
                  The same attributes are used on
                     <a href="#element-source-document"><code>xsl:source-document</code></a> and <a href="#element-merge-source"><code>xsl:merge-source</code></a> to control
                  validation of input documents.</p>
               <p>The <code>[xsl:]type</code> attribute is used to request validation of an element or
               attribute against a specific simple or complex type defined in a schema. The
                  <code>[xsl:]validation</code> attribute is used to request validation against the
               global element or attribute declaration whose name matches the name of the element or
               attribute being validated.</p>
               <p>The <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are mutually
               exclusive. Both are optional, but if one is present then the other
                  <span class="verb">must</span> be omitted. If both attributes are omitted, the effect is
               the same as specifying the <code>validation</code> attribute with the value specified
               in the <code>[xsl:]default-validation</code> attribute of
                  the innermost containing element having such an attribute; if this is not
               specified, the effect is the same as specifying <code>validation="strip"</code>.</p>
               <p>The <code>[xsl:]default-validation</code> attribute defines the
               default value of the <code>validation</code> attribute of all
                  <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                  <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
                  <a href="#element-document"><code>xsl:document</code></a>, and <a href="#element-result-document"><code>xsl:result-document</code></a>
               instructions, and of the <code>xsl:validation</code> attribute of all
               <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>,
               <span>appearing as descendants of the element 
                  on which the attribute appears, unless there is an inner element that defines 
                  a different default</span>.  This default  does not extend to included or imported stylesheet
               modules or used packages. If the attribute is omitted, the default is
                  <code>strip</code>. The permitted values are <code>preserve</code> and
                  <code>strip</code>.</p>
               <p>
               The <code>default-validation</code> attribute on the outermost element of the principal
               stylesheet module of the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> also determines the validation 
               applied to the implicit final result tree created in the absence of an 
               <a href="#element-result-document"><code>xsl:result-document</code></a> instruction. 
            </p>
               <p>The <code>[xsl:]default-validation</code> attribute has no
               effect on the <a href="#element-source-document"><code>xsl:source-document</code></a> and <a href="#element-merge-source"><code>xsl:merge-source</code></a>
               elements, which perform no validation unless explicitly requested.</p>
               <p>
               <a id="err-XTSE1505"><span class="error">[ERR XTSE1505] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if both the
                        <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are
                     present on the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                        <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
                        <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, or
                           <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, or on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.
            </p>
               <p>Validation always uses the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-issd">in-scope schema definitions</a><sup><small>XP</small></sup>
               from the static context of the instruction that invokes validation.
               The relevant schema may be selected using the <code>[xsl:]schema-role</code> attribute of the instruction itself,
               or of a containing element. See also <a href="#multiple-schemas"><i>3.13.1 Multiple Schemas</i></a>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>A stylesheet might take as its primary input a document conforming to schema <var>X</var>,
                  and produce as its primary output a document conforming to schema <var>Y</var>.
                  To be sure that the output is indeed valid against schema <var>Y</var>, the safest
                  course of action is to evaluate an <a href="#element-result-document"><code>xsl:result-document</code></a> instruction using
                  an <code>[xsl:]schema-role</code> attribute that selects schema <var>Y</var> and nothing else. 
                  Otherwise, if the validation occurs within a module that imports both <var>X</var>
                  and <code>Y</code>, the outcome of validation might differ because of the
                  differences between the two schemas.</p>
               </div>
               <p>The detailed rules for validation vary depending on the kind of node being validated.
               The rules for element and attribute nodes are given in <a href="#validating-constructed-nodes"><i>25.4.1 Validating Constructed Elements and Attributes</i></a>, while those for document nodes are given in
                  <a href="#validating-document-nodes"><i>25.4.2 Validating Document Nodes</i></a>.</p>
               <div class="div3">
                  
                  <h4><a id="validating-constructed-nodes"></a>25.4.1 <a href="#validating-constructed-nodes" style="text-decoration: none">Validating Constructed Elements and Attributes</a></h4>
                  <div class="div4">
                     
                     <h5><a id="validating-using-validation-attribute"></a>25.4.1.1 <a href="#validating-using-validation-attribute" style="text-decoration: none">Validation using the <code>[xsl:]validation</code> Attribute</a></h5>
                     <p>The <code>[xsl:]validation</code> attribute defines the validation action to be
                     taken. It determines not only the <a title="type annotation" class="termref" href="#dt-type-annotation">type
                        annotation</a> of the node that is constructed by the relevant
                     instruction itself, but also the type annotations of all element and attribute
                     nodes that have the constructed node as an ancestor. Conceptually, the
                     validation requested for a child element or attribute node is applied before
                     the validation requested for its parent element. For example, if the
                     instruction that constructs a child element specifies
                        <code>validation="strict"</code>, this will cause the child element to be
                     checked against an element declaration, but if the instruction that constructs
                     its parent element specifies <code>validation="strip"</code>, then the final
                     effect will be that the child node is annotated as <code>xs:untyped</code>.</p>
                     <p>In the paragraphs below, the term <em>contained nodes</em> means the
                     elements and attributes that have the newly constructed node as an
                     ancestor.</p>
                     <ol class="enumar">
                        <li>
                           <p>The value <code>strip</code> indicates that the new node and each of the
                           contained nodes will have the <a title="type annotation" class="termref" href="#dt-type-annotation">type
                              annotation</a>
                           <code>xs:untyped</code> if it is an element, or
                              <code>xs:untypedAtomic</code> if it is an attribute. Any previous type
                           annotation present on a contained element or attribute node (for example,
                           a type annotation that is present on an element copied from a source
                           document) is also replaced by <code>xs:untyped</code> or
                              <code>xs:untypedAtomic</code> as appropriate. The typed value of the
                           node is changed to be the same as its string value, as an instance of
                              <code>xs:untypedAtomic</code>. In the case of elements the
                              <code>nilled</code> property is set to <code>false</code>. The values
                           of the <code>is-id</code> and <code>is-idrefs</code> properties are
                           unchanged. Schema validation is not invoked.</p>
                        </li>
                        <li>
                           <p>The value <code>preserve</code> indicates that nodes that are copied will
                           retain their <a title="type annotation" class="termref" href="#dt-type-annotation">type
                           annotations</a>, but nodes whose content is newly constructed will
                           be annotated as <code>xs:anyType</code> in the case of elements, or
                              <code>xs:untypedAtomic</code> in the case of attributes. Schema
                           validation is not invoked. The detailed effect depends on the
                           instruction:</p>
                           <ol class="enumla">
                              <li>
                                 <p>In the case of <a href="#element-element"><code>xsl:element</code></a> and literal result
                                 elements, the new element has a <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a> of <code>xs:anyType</code>, and the
                                 type annotations of contained nodes are retained unchanged.</p>
                                 <p>The <code>nilled</code>,
                                    <code>is-id</code> and <code>is-idrefs</code> properties on the
                                 new element are set to <code>false</code>.</p>
                              </li>
                              <li>
                                 <p>In the case of <a href="#element-attribute"><code>xsl:attribute</code></a>, the effect is
                                 exactly the same as specifying <code>validation="strip"</code>:
                                 that is, the new attribute will have the type annotation
                                    <code>xs:untypedAtomic</code>.</p>
                                 <p>The <code>is-id</code> and
                                    <code>is-idrefs</code> properties on the new attribute are set
                                 to <code>false</code>.</p>
                              </li>
                              <li>
                                 <p>In the case of <a href="#element-copy-of"><code>xsl:copy-of</code></a>, all the nodes that are
                                 copied will retain their type annotations unchanged. The values of their
                                       <code>nilled</code>, <code>is-id</code> and
                                       <code>is-idrefs</code> properties are also
                                 unchanged.</p>
                              </li>
                              <li>
                                 <p>In the case of <a href="#element-copy"><code>xsl:copy</code></a>, the effect depends on the
                                 kind of node being copied.</p>
                                 <ol class="enumlr">
                                    <li>
                                       <p>Where the node being copied is an attribute, the copied
                                       attribute will retain its <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>
                                       and the values of its
                                             <code>is-id</code> and <code>is-idrefs</code>
                                          properties.</p>
                                    </li>
                                    <li>
                                       <p>Where the node being copied is an element, the copied element
                                       will have a <a title="type annotation" class="termref" href="#dt-type-annotation">type
                                          annotation</a> of <code>xs:anyType</code> (because
                                       this instruction does not copy the content of the element, it
                                       would be wrong to assume that the type is unchanged); but any
                                       contained nodes will have their type annotations retained in
                                       the same way as with <a href="#element-element"><code>xsl:element</code></a>. The values of the
                                             <code>nilled</code>, <code>is-id</code>, and
                                             <code>is-idrefs</code> properties are handled in the
                                          same way as <a href="#element-element"><code>xsl:element</code></a>.
                                    </p>
                                    </li>
                                 </ol>
                              </li>
                           </ol>
                        </li>
                        <li>
                           <p>The value <code>strict</code> indicates that 
                           schema validation is carried out according to the process described
                           in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#xsd-validation">17.2.4 XSD validation</a>. The operand node
                           is the node being constructed, and the effective schema is
                           the in-scope schema definitions in the static context of the containing
                           instruction. The effect of constructing a node with
                           <code>[xsl:]validation="strict"</code> is equivalent to constructing
                           an untyped node <var>N</var>, and then validating it using the
                           expression;</p>
                           <div class="exampleInner">
                              <pre><code>fn:xsd-validator({'validation-mode':'strict'})(<var>N</var>) -&gt;
    if (?is-valid) then ?typed-node else error()</code></pre>
                           </div>
                           <p>More details on the error conditions appear below.</p>
                        </li>
                        <li>
                           <p>The value <code>lax</code> indicates that 
                           lax validation is carried out according to the process described
                           in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#xsd-validation">17.2.4 XSD validation</a>. The operand node
                           is the node being constructed, and the effective schema is
                           the in-scope schema definitions in the static context of the containing
                           instruction. The effect of constructing a node with
                           <code>[xsl:]validation="lax"</code> is equivalent to constructing
                           an untyped node <var>N</var>, and then validating it using the
                           expression;</p>
                           <div class="exampleInner">
                              <pre><code>fn:xsd-validator({'validation-mode':'lax'})(<var>N</var>) -&gt;
    if (?is-valid) then ?typed-node else error()</code></pre>
                           </div>
                           <p>More details on the error conditions appear below.</p>
                        </li>
                     </ol>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The effect of these rules is that when validation succeeds, the <code>validate</code>
         expression returns a copy of the operand node, augmented with type annotations and expanded
         default values. When validation fails (more accurately, when the outcome of validity assessment
         is that the operand node is found to be invalid), the expression raises a dynamic error.</p>
                     </div>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>If an element that is being validated has an <code>xsi:type</code>
                        attribute, then the value of the <code>xsi:type</code> attribute will
                        be taken into account when performing the validation. However, the
                        presence of an <code>xsi:type</code> attribute will not of itself
                        cause an element to be validated: if validation against a named type
                        is required, as distinct from validation against a top-level element
                        declaration, then it must be requested using the XSLT
                           <code>[xsl:]type</code> attribute on the instruction that invokes
                        the validation, as described in section <a href="#validation-xsl-type"><i>25.4.1.2 Validation using the [xsl:]type Attribute</i></a>
                     </p>
                     </div>
                     <p>For reasons of backwards compatibility, the error conditions raised
                  by XSLT validation have their own error codes:</p>
                     <ul>
                        <li>
                           <p>
                        <a id="err-XTTE1510"><span class="error">[ERR XTTE1510] </span></a>If the <code>validation</code> attribute of an
                                 <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                                 <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or
                                 <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the
                                 <code>xsl:validation</code> attribute of a literal result element, has
                              the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>strict</code>, and schema validity assessment
                              concludes that the validity of the element or attribute is invalid or
                              unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As
                              with other type errors, the error <span class="verb">may</span> be raised
                              statically if it can be detected statically. 
                     </p>
                        </li>
                        <li>
                           <p>
                        <a id="err-XTTE1512"><span class="error">[ERR XTTE1512] </span></a>If the <code>validation</code> attribute of an
                                 <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                                 <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or
                                 <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the
                                 <code>xsl:validation</code> attribute of a literal result element, has
                              the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>strict</code>, and there is no matching
                              top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error
                                 <span class="verb">may</span> be raised statically if it can be detected
                              statically. 
                     </p>
                        </li>
                        <li>
                           <p>
                        <a id="err-XTTE1515"><span class="error">[ERR XTTE1515] </span></a>If the <code>validation</code> attribute of an
                                 <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                                 <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or
                                 <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the
                                 <code>xsl:validation</code> attribute of a literal result element, has
                              the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>lax</code>, and schema validity assessment
                              concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type
                              errors, the error <span class="verb">may</span> be raised statically if it can
                              be detected statically. 
                     </p>
                        </li>
                        <li>
                           <p>
                     <a id="err-XTTE1545"><span class="error">[ERR XTTE1545] </span></a>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs if a
                              <code>type</code> or <code>validation</code> attribute is defined
                           (explicitly or implicitly) for an instruction that constructs a new
                           attribute node, if the effect of this is to cause the attribute value to
                           be validated against a type that is derived from, or constructed by list
                           or union from, the primitive types <code>xs:QName</code> or
                              <code>xs:NOTATION</code>.
                  </p>
                        </li>
                     </ul>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="validation-xsl-type"></a>25.4.1.2 <a href="#validation-xsl-type" style="text-decoration: none">Validation using the <code>[xsl:]type</code> Attribute</a></h5>
                     <p>The <code>[xsl:]type</code> attribute takes as its value an 
                     <span><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></span>.
                     If it is a lexical QName with no prefix, it is
                     expanded using the default namespace for elements and types.
                     This <span class="verb">must</span> be the name of a type definition included in the
                        <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema
                        components</a> for the stylesheet. </p>
                     <p>If the <code>[xsl:]type</code> attribute is present, then the newly constructed
                     element or attribute is validated against the type definition identified by
                     this attribute. Schema validation is carried out according to the process described
                           in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#xsd-validation">17.2.4 XSD validation</a>. The operand node
                           is the node being constructed, and the effective schema is
                           the in-scope schema definitions in the static context of the containing
                           instruction. The effect is equivalent to constructing
                           an untyped node <var>N</var>, and then validating it using the
                           expression, where <var>T</var> is the QName obtained by expanding the
                  value of the <code>[xsl:]type</code> attribute:</p>
                     <div class="exampleInner">
                        <pre><code>fn:xsd-validator(<var>N</var>, {'type':<var>T</var>})(<var>N</var>) -&gt;
    if (?is-valid) then ?typed-node else error()</code></pre>
                     </div>
                     <p>For reasons of backwards compatibility, the error conditions raised
                  by XSLT validation have their own error codes:</p>
                     <ul>
                        <li>
                           <p>If the element or attribute is not considered valid, as defined above,
                           the transformation fails <span class="error">[see <a href="#err-XTTE1540">ERR XTTE1540</a>]</span>.</p>
                        </li>
                        <li>
                           <p>If an element node is validated against the type
                        <code>xs:untyped</code>, the effect is the same as specifying
                        <code>validation="strip"</code>: that is, the elements and attributes in the
                     subtree rooted at the target element are copied with a type annotation of
                        <code>xs:untyped</code> or <code>xs:untypedAtomic</code> respectively.</p>
                        </li>
                        <li>
                           <p>If an element or attribute node is validated against the type
                        <code>xs:untypedAtomic</code>, the effect is the same as specifying
                        <code>[xsl:]type="xs:string"</code> except that when validation succeeds,
                     the returned element or attribute has a type annotation of
                        <code>xs:untypedAtomic</code>. Validation fails in the case of an element
                     with element children.</p>
                        </li>
                        <li>
                           <p>
                     <a id="err-XTSE1520"><span class="error">[ERR XTSE1520] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           value of the <code>type</code> attribute of an
                              <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                              <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
                              <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>,
                           <span><a href="#element-source-document"><code>xsl:source-document</code></a>, or 
                              <a href="#element-merge-source"><code>xsl:merge-source</code></a></span>
                           instruction, or the <code>xsl:type</code> attribute of a literal result
                           element, is not a valid <code>QName</code>, or if it uses a prefix that
                           is not defined in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a>
                           of the containing instruction</span>, or if the QName is
                           not the name of a type definition included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema
                              components</a> for the <a title="package" class="termref" href="#dt-package">package</a>.
                        
                  </p>
                        </li>
                        <li>
                           <p>
                     <a id="err-XTSE1530"><span class="error">[ERR XTSE1530] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           value of the <code>type</code> attribute of an
                              <a href="#element-attribute"><code>xsl:attribute</code></a> instruction refers to a complex type
                           definition.</p>
                        </li>
                        <li>
                           <p>
                     
                     <a id="err-XTTE1535"><span class="error">[ERR XTTE1535] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the value of
                           the <code>type</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a> or
                              <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction refers to a complex type
                           definition and one or more of the items being copied is an attribute
                           node.</p>
                        </li>
                        <li>
                           <p>
                     <a id="err-XTTE1540"><span class="error">[ERR XTTE1540] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an
                              <code>[xsl:]type</code> attribute is defined for a constructed element
                           or attribute, and the outcome of schema validity assessment against that
                           type is that the <code>validity</code> property of that element or
                           attribute information item is other than <code>valid</code>.
                  </p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>Like other type errors, this error may be raised statically if it can be
                        detected statically. For example, the instruction <code>&lt;xsl:attribute
                           name="dob" type="xs:date"&gt;1999-02-29&lt;/xsl:attribute&gt;</code> may
                        result in a static error being raised. If the error is not raised
                        statically, it will be raised when the instruction is evaluated.</p>
                           </div>
                        </li>
                     </ul>
                  </div>
                  <div class="div4">
                     
                     <h5><a id="id-xsi-schema-location"></a>25.4.1.3 <a href="#id-xsi-schema-location" style="text-decoration: none">The <code>xsi:schemaLocation</code> and <code>xsi:noNamespaceSchemaLocation</code> attributes</a></h5>
                     <p>It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether the validity assessment
                  process takes account of any <code>xsi:schemaLocation</code> or <code>xsi:noNamespaceSchemaLocation</code>
                  attributes in the tree being validated. If it does so, then it <span class="verb">should</span>
                  adhere to the following rules:</p>
                     <ol class="enumar">
                        <li>
                           <p>Any schema loaded using these attributes must be 
                        <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible">compatible</a><sup><small>DM</small></sup> 
                     with the schema in the static context from which validation is invoked.</p>
                        </li>
                        <li>
                           <p>Any schema loaded using these attributes must not override
                     or redefine any schema components in the static context.</p>
                        </li>
                        <li>
                           <p>Any schema components loaded using this mechanism must be
                     used for this validity assessment only, and must not 
                     affect the outcome of any subsequent validity assessments of other documents.</p>
                           <div class="note">
                              <p class="prefix"><b>Note:</b></p>
                              <p>A processor may choose to cache such schema components but the existence
                     of such a cache should only affect performance, not the validation outcome.</p>
                           </div>
                        </li>
                     </ol>
                     <p>A consequence of validating a document using schema components that are not 
                     in the static context is that nodes may be annotated with types 
                     that are not in the static context. But the rules for
                     <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-schema-compatible">schema compatibility</a><sup><small>DM</small></sup>
                     mean that this is not a problem.</p>
                  </div>
               </div>
               <div class="div3">
                  
                  <h4><a id="validating-document-nodes"></a>25.4.2 <a href="#validating-document-nodes" style="text-decoration: none">Validating Document Nodes</a></h4>
                  <p>It is possible to apply validation to a document node. This happens when a new
                  document node is constructed by one of the XSLT elements <a href="#element-source-document"><code>xsl:source-document</code></a>, <a href="#element-merge-source"><code>xsl:merge-source</code></a>, <a href="#element-document"><code>xsl:document</code></a>,
                     <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-copy"><code>xsl:copy</code></a>, or
                     <a href="#element-copy-of"><code>xsl:copy-of</code></a>, and this element has a <code>type</code>
                  attribute, or a <code>validation</code> attribute with the value
                     <code>strict</code> or <code>lax</code>.</p>
                  <p>Document-level validation is not applied to the document node that is created
                  implicitly when a variable-binding element has no <code>select</code> attribute
                  and no <code>as</code> attribute (see <a href="#temporary-trees"><i>9.4 Creating Implicit Document Nodes</i></a>). This is
                  equivalent to using <code>validation="preserve"</code> on
                     <a href="#element-document"><code>xsl:document</code></a>: nodes within such trees retain their <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>. Similarly, validation is
                  not applied to document nodes created using <a href="#element-message"><code>xsl:message</code></a>
                  or <a href="#element-assert"><code>xsl:assert</code></a>. </p>
                  <p>The values <code>validation="preserve"</code> and <code>validation="strip"</code>
                  do not request validation. In the first case, all element and attribute nodes
                  within the tree rooted at the new document node retain their <a title="type annotation" class="termref" href="#dt-type-annotation">type annotations</a>. In the second case,
                  elements within the tree have their type annotation set to
                  <code>xs:untyped</code>, while attributes have their type annotation set to
                     <code>xs:untypedAtomic</code>.</p>
                  <p>When validation is requested for a document node (that is, when
                     <code>validation</code> is set to <code>strict</code> or <code>lax</code>, or
                  when a <code>type</code> attribute is present), the following processing takes
                  place:</p>
                  <ul>
                     <li>
                        <p>
                        <a id="err-XTTE1550"><span class="error">[ERR XTTE1550] </span></a>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs
                                  unless
                              the children of the document node comprise exactly one element node,
                              no text nodes, and zero or more comment and processing instruction
                              nodes, in any order.
                     </p>
                     </li>
                     <li>
                        <p>The single element node child is validated, using the supplied values of the
                           <code>validation</code> and <code>type</code> attributes, as described in
                           <a href="#validating-constructed-nodes"><i>25.4.1 Validating Constructed Elements and Attributes</i></a>.</p>
                        <div class="note">
                           <p class="prefix"><b>Note:</b></p>
                           <p>The <code>type</code> attribute on <a href="#element-source-document"><code>xsl:source-document</code></a>,
                              <a href="#element-document"><code>xsl:document</code></a> and
                           <a href="#element-result-document"><code>xsl:result-document</code></a>, and on <a href="#element-copy"><code>xsl:copy</code></a>
                           and <a href="#element-copy-of"><code>xsl:copy-of</code></a> when copying a document node, thus
                           refers to the required type of the element node that is the only element
                           child of the document node. It does not refer to the type of the document
                           node itself.</p>
                        </div>
                     </li>
                     <li>
                        <p>The validation rule “Validation Root Valid (ID/IDREF)” is
                        applied to the single element node child of the document node. This means
                        that validation will fail if there are non-unique ID values or dangling
                        IDREF values in the document tree.</p>
                     </li>
                     <li>
                        <p>Identity constraints, as defined in section 3.11 of <a href="#xmlschema-1">[XML Schema Part 1]</a>, are checked. (This refers to constraints defined
                        using <code>xs:unique</code>, <code>xs:key</code>, and
                           <code>xs:keyref</code>.)</p>
                     </li>
                     <li>
                        <p>There is no check that the tree contains unparsed entities whose names match
                        the values of nodes of type <code>xs:ENTITY</code> or
                           <code>xs:ENTITIES</code>. This is because there is no facility in XSLT
                           3.0 to create unparsed entities in a
                           <a title="result tree" class="termref" href="#dt-result-tree">result tree</a>. It is possible to
                        add unparsed entity declarations to the result document by referencing a
                        suitable DOCTYPE during serialization.</p>
                     </li>
                     <li>
                        <p>All other children of the document node (comments and processing
                        instructions) are copied unchanged.</p>
                     </li>
                  </ul>
                  <p>
                  <a id="err-XTTE1555"><span class="error">[ERR XTTE1555] </span></a>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if, when
                        validating a document node, document-level constraints (such as ID/IDREF
                        constraints) are not satisfied. 
                        
               </p>
               </div>
               <div class="div3">
                  
                  <h4><a id="validating-xml-id"></a>25.4.3 <a href="#validating-xml-id" style="text-decoration: none">Validating <code>xml:id</code> attributes</a></h4>
                  <p>This section provides a non-normative summary of the effect of validation on
               attributes named <code>xml:id</code>. The normative rules can be inferred from rules
               given elsewhere in this section.</p>
                  <ol class="enumar">
                     <li>
                        <p>When an attribute named <code>xml:id</code> is encountered
                  in the course of validation:</p>
                        <ol class="enumla">
                           <li>
                              <p>A validation error occurs if it the attribute is not lexically valid against type <code>xs:ID</code>.</p>
                           </li>
                           <li>
                              <p>The typed value of the attribute is whitespace-normalized.</p>
                           </li>
                           <li>
                              <p>The attribute is labeled with type annotation <code>xs:ID</code>.</p>
                           </li>
                           <li>
                              <p>The attribute acquires the <code>is-id</code> property.</p>
                           </li>
                        </ol>
                     </li>
                     <li>
                        <p>The previous rule applies whether validation is strict, lax, or by type; 
                     validation will never fail (or be skipped) on the grounds
                  that no global attribute declaration named <code>xsl:id</code> is available.</p>
                     </li>
                     <li>
                        <p>Checking <code>xml:id</code> attributes for uniqueness happens if and only if
                  validation is applied at the level of a document node.</p>
                     </li>
                  </ol>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="serialization"></a>26 <a href="#serialization" style="text-decoration: none">Serialization</a></h2>
            <p>A <a title="processor" class="termref" href="#dt-processor">processor</a>
            <span class="verb">may</span> output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
               tree</a> as a sequence of octets, although it is not
               <span class="verb">required</span> to be able to do so (see <a href="#conformance"><i>27 Conformance</i></a>).
            This process is described as <b>serialization</b>.
            Stylesheet authors can use <a href="#element-output"><code>xsl:output</code></a> declarations to specify how they
            wish result trees to be serialized. If a processor serializes a final result tree, it
               <span class="verb">must</span> do so as specified by these declarations.</p>
            <p>The rules governing the output of the serializer are defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>. 
            The serialization is controlled using a number
            of serialization parameters. The values of these serialization parameters may be set
            within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, using the
               <a href="#element-output"><code>xsl:output</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, and
               <a href="#element-character-map"><code>xsl:character-map</code></a> declarations.</p>
            <div class="div2">
               
               <h3><a id="id-xsl-output-declaration"></a>26.1 <a href="#id-xsl-output-declaration" style="text-decoration: none">The <code>xsl:output</code> declaration</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#id-default-serialization-parameters">next</a> | <a href="#validation">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  A new serialization parameter <code>escape-solidus</code> is provided to control
                  whether the character <code>/</code> is escaped as <code>\/</code> by the
                  JSON serialization method.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/530">530</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/534">534</a>&nbsp;9 June 2023]</i></p>
                     </li>
                     <li>
                        <p>
                  A new serialization parameter <code>canonical</code> is available to give control
                  over serialization of XML, XHTML, and JSON.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/938">938</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259</a>&nbsp;2 November 2025]</i></p>
                     </li>
                     <li>
                        <p>
                  A new serialization parameter <code>json-lines</code> is available to enable
                  output as one JSON value per line.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1538">1538</a>&nbsp;PRs <a href="https://github.com/qt4cg/qtspecs/pull/1497">1497</a>&nbsp;<a href="https://github.com/qt4cg/qtspecs/pull/1546">1546</a>&nbsp;13 November 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p class="element-syntax"><a id="element-output"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:output<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;method? = "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var><br>&nbsp;&nbsp;allow-duplicate-names? = <var>boolean</var><br>&nbsp;&nbsp;build-tree? = <var>boolean</var><br>&nbsp;&nbsp;byte-order-mark? = <var>boolean</var><br>&nbsp;&nbsp;canonical? = <var>boolean</var><br>&nbsp;&nbsp;cdata-section-elements? = <var>eqnames</var><br>&nbsp;&nbsp;doctype-public? = <var>string</var><br>&nbsp;&nbsp;doctype-system? = <var>string</var><br>&nbsp;&nbsp;encoding? = <var>string</var><br>&nbsp;&nbsp;escape-solidus? = <var>boolean</var><br>&nbsp;&nbsp;escape-uri-attributes? = <var>boolean</var><br>&nbsp;&nbsp;html-version? = <var>decimal</var><br>&nbsp;&nbsp;include-content-type? = <var>boolean</var><br>&nbsp;&nbsp;indent? = <var>boolean</var><br>&nbsp;&nbsp;item-separator? = <var>string</var><br>&nbsp;&nbsp;json-lines? = <var>boolean</var><br>&nbsp;&nbsp;json-node-output-method? = "xml" | "html" | "xhtml" | "text" | <var>eqname</var><br>&nbsp;&nbsp;media-type? = <var>string</var><br>&nbsp;&nbsp;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var><br>&nbsp;&nbsp;omit-xml-declaration? = <var>boolean</var><br>&nbsp;&nbsp;parameter-document? = <var>uri</var><br>&nbsp;&nbsp;standalone? = <var>boolean</var> | "omit"<br>&nbsp;&nbsp;suppress-indentation? = <var>eqnames</var><br>&nbsp;&nbsp;undeclare-prefixes? = <var>boolean</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;version? = <var>nmtoken</var>&nbsp;/&gt;</code></p>
               <p>The <a href="#element-output"><code>xsl:output</code></a> declaration is optional; if used, it
               <span class="verb">must</span> always appear as a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element within a stylesheet module.</p>
               <p>A <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> may contain multiple
               <a href="#element-output"><code>xsl:output</code></a> declarations and may include or import stylesheet modules
            that also contain <a href="#element-output"><code>xsl:output</code></a> declarations. The name of an
               <a href="#element-output"><code>xsl:output</code></a> declaration is the value of its <code>name</code>
            attribute, if any.</p>
               <p>
            <span class="definition">[Definition:&nbsp;</span><a id="dt-output-definition" title="output definition"></a>All the
                  <a href="#element-output"><code>xsl:output</code></a> declarations within a
                     <a title="package" class="termref" href="#dt-package">package</a> that share the same name
               are grouped into a named <b>output definition</b>; those that have no name are
               grouped into a single unnamed output definition.<span class="definition">]</span>
         </p>
               <p>An output definition is scoped to a package. If this is a <a title="library package" class="termref" href="#dt-library-package">library package</a> the output definition applies only
            to <a href="#element-result-document"><code>xsl:result-document</code></a> instructions within the same package. If it is
            the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, the output
            definition applies to <a href="#element-result-document"><code>xsl:result-document</code></a> instructions within the same
            package and also to the implicit <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
               tree</a>.</p>
               <p>A stylesheet always includes an unnamed <a title="output definition" class="termref" href="#dt-output-definition">output
               definition</a>; in the absence of an unnamed <a href="#element-output"><code>xsl:output</code></a>
            declaration, the unnamed output definition is equivalent to the one that would be used
            if the stylesheet contained an <a href="#element-output"><code>xsl:output</code></a> declaration having no
            attributes.</p>
               <p>A named <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> is used when its
            name matches the <code>format</code> attribute used in an
               <a href="#element-result-document"><code>xsl:result-document</code></a> element. The unnamed output definition is used
            when an <a href="#element-result-document"><code>xsl:result-document</code></a> element omits the <code>format</code>
            attribute. It is also used when serializing the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a>.
            .</p>
               <p>All the <a href="#element-output"><code>xsl:output</code></a> elements making up an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> are effectively merged. For
            those attributes whose values are namespace-sensitive, the merging is done after
               <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QNames</a> have been converted into
               <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a>. For the
               <code>cdata-section-elements</code>
            and <code>suppress-indentation</code> attributes, the
            output definition uses the union of the values from all the constituent
            <a href="#element-output"><code>xsl:output</code></a> declarations. For the <code>use-character-maps</code>
            attribute, the output definition uses the concatenation of the sequences of <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QNames</a> values from all the constituent
               <a href="#element-output"><code>xsl:output</code></a> declarations, taking them in order of increasing <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, or where several have the
            same import precedence, in <a title="declaration order" class="termref" href="#dt-declaration-order">declaration
               order</a>. For other attributes, the <a title="output definition" class="termref" href="#dt-output-definition">output
               definition</a> uses the value of that attribute from the
               <a href="#element-output"><code>xsl:output</code></a> declaration with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
               <p>The <code>parameter-document</code> attribute allows serialization
            parameters to be supplied in an external document. The external document must contain an
               <code>output:serialization-parameters</code> element with the format described in
               <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> section <a href="../xslt-xquery-serialization-40/#serparams-in-xdm-instance">3.1 Setting Serialization Parameters by Means of a Parameter Document</a>, and the parameters are
            interpreted as described in that specification.</p>
               <p>If present, the URI supplied in the <code>parameter-document</code>
            attribute is dereferenced, after resolution against the base URI of the
               <a href="#element-output"><code>xsl:output</code></a> element if it is a relative reference. 
            The parameter document <span class="verb">should</span> be read during static analysis of the stylesheet. 
            A serialization error occurs
            if the result of dereferencing the URI is ill-formed or invalid; but if no document can
            be found at the specified location, the attribute <span class="verb">should</span> be ignored.</p>
               <p>A serialization parameter specified in the
               <code>parameter-document</code> takes precedence over a value supplied directly in
            the output declaration, except that the values of the
               <code>cdata-section-elements</code> and <code>suppress-indentation</code> attributes
            are merged in the same way as when multiple <a href="#element-output"><code>xsl:output</code></a> declarations are
            merged.</p>
               <p>
            <a id="err-XTSE1560"><span class="error">[ERR XTSE1560] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two
                     <a href="#element-output"><code>xsl:output</code></a> declarations within an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> specify explicit values
                  for the same attribute (other than <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and
                     <code>use-character-maps</code>), with the values of the attributes being not
                  equal, unless there is another <a href="#element-output"><code>xsl:output</code></a> declaration within the
                  same <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> that has
                  higher import precedence and that specifies an explicit value for the same
                  attribute. 
         </p>
               <p>
            If the result is not serialized, then the decision whether to return the raw result 
            or to construct a tree depends on the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>build-tree</code> attribute. 
            If the effective value of the <code>build-tree</code> attribute is <code>yes</code>, then a 
            final result tree is created by invoking the process of sequence normalization. Conversely, 
            if the result is serialized, then the decision whether or not to construct a tree depends 
            on the choice of serialization method, and the <code>build-tree</code> attribute is 
            then ignored. For example, with <code>method="xml"</code> a tree is always constructed, 
            whereas with <code>method="json"</code> a tree is never constructed.
         </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The default for <code>build-tree</code> may differ for user-defined serialization
               methods or for serialization methods introduced in future versions of this
               specification.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="id-default-serialization-parameters"></a>26.2 <a href="#id-default-serialization-parameters" style="text-decoration: none">Serialization parameters</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#character-map-function">next</a> | <a href="#id-xsl-output-declaration">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The default value for the <code>indent</code> parameter is now defined to be
                  <code>no</code> for all output methods other than <code>html</code> and <code>xhtml</code>.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1548">1548</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1560">1560</a>&nbsp;9 November 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p>If none of the <a href="#element-output"><code>xsl:output</code></a> declarations within an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> specifies a value for a
            particular attribute, then the corresponding serialization parameter takes a default
            value. The default value depends on the chosen output method.</p>
               <p>There are some serialization parameters that apply to some output methods but not to
            others. For example, the <code>indent</code> attribute has no effect on the
               <code>text</code> output method. If a value is supplied for an attribute that is
            inapplicable to the output method, its value is not passed to the serializer. The
            processor <span class="verb">may</span> validate the value of such an attribute, but is not
               <span class="verb">required</span> to do so.</p>
               <p>An implementation <span class="verb">may</span> allow the attributes of the
               <a href="#element-output"><code>xsl:output</code></a> declaration to be overridden, or the default values to be
            changed, using the API that controls the transformation.</p>
               <p>The location to which <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a>
            are serialized (whether in filestore or elsewhere) is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> (which in practice
               <span class="verb">may</span> mean that it is controlled using an implementation-defined
            API). However, these locations <span class="verb">must</span> satisfy the constraint that when
            two <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a> are both created
            (implicitly or explicitly) using relative URI references in the <code>href</code> attribute of the
               <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, then these relative URI references may be used to construct references from one
            tree to the other, and such references <span class="verb">must</span> remain valid when both
            result trees are serialized. </p>
               <p>The <code>method</code> attribute on the <a href="#element-output"><code>xsl:output</code></a> element identifies
            the overall method that is to be used for outputting the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p>
               <p>
            <a id="err-XTSE1570"><span class="error">[ERR XTSE1570] </span></a>The value 
                  <span class="verb">must</span> (if present) be a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. 
                  If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                     QName</a> in no namespace, then it identifies a method specified in
                     <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> and <span class="verb">must</span> be one
                  of <code>xml</code>, <code>html</code>, <code>xhtml</code>, 
                  <code>text</code>, <code>json</code>, or <code>adaptive</code>. If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a
            prefix, then the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> is expanded
            into an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> as described in
               <a href="#qname"><i>5.1.1 Qualified Names</i></a>. An <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>
            with a non-absent namespace identifies an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> output method 
            whose the behavior is not specified by this document.</p>
               <p>The default for the <code>method</code> attribute depends on the contents of the tree
            being serialized, and is chosen as follows. If the document node of the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> has an element child, and any
            text nodes preceding the first element child of the document node of the result tree
            contain only whitespace characters, then:</p>
               <ul>
                  <li>
                     <p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of this first
                  element child has local part <code>html</code> (in lower case), and namespace URI
                     <code>http://www.w3.org/1999/xhtml</code>, then the default output method is
                  normally <code>xhtml</code>. However, if the
                        <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of the outermost element of the
                        <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet
                        module</a> in the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> has the value
                        <code>1.0</code>, and if the result tree is generated implicitly
                  (rather than by an explicit <a href="#element-result-document"><code>xsl:result-document</code></a> instruction),
                  then the default output method in this situation is <code>xml</code>.</p>
                  </li>
                  <li>
                     <p>If the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of this first
                  element child has local part <code>html</code> (in any combination of upper and
                  lower case) and a null namespace URI, then the default output method is
                     <code>html</code>.</p>
                  </li>
               </ul>
               <p>In all other cases, the default output method is <code>xml</code>.</p>
               <p>The default output method is used if the selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> does not include a <code>method</code> attribute.</p>
               <p>The other attributes on <a href="#element-output"><code>xsl:output</code></a> provide parameters for the output
            method. The following attributes are allowed:</p>
               <ul>
                  <li>
                     <p> The value of the <code>encoding</code> attribute provides the value of the
                     <code>encoding</code> parameter to the serialization method. The default value
                  is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but in the case of the
                     <code>xml</code> and <code>xhtml</code> methods it <span class="verb">must</span> be
                  either <code>UTF-8</code> or <code>UTF-16</code>. </p>
                  </li>
                  <li>
                     <p>The <code>byte-order-mark</code> attribute defines whether a byte order mark is
                  written at the start of the file. If the value <code>yes</code> is specified, a
                  byte order mark is written; if <code>no</code> is specified, no byte order mark is
                  written. The default value depends on the encoding used. If the encoding is
                     <code>UTF-16</code>, the default is <code>yes</code>; for <code>UTF-8</code> it
                  is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, and for all other encodings it is
                     <code>no</code>. The value of the byte order mark indicates whether high order
                  bytes are written before or after low order bytes; the actual byte order used is
                     <a title="implementation-dependent" class="termref" href="#dt-implementation-dependent">implementation-dependent</a>,
                  unless it is defined by the selected encoding. </p>
                  </li>
                  <li>
                     <p> The value of the <code>canonical</code> attribute provides the value of the
                     <code>canonical</code> parameter to the serialization method. 
                  The default value is <code>no</code>.
               </p>
                  </li>
                  <li>
                     <p> The <code>cdata-section-elements</code> attribute is a whitespace-separated list
                  of QNames. The default value is an empty list. After expansion of these names
                  using the <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the <a href="#element-output"><code>xsl:output</code></a>
                  declaration in which they appear, this list of names provides the value of the
                     <code>cdata-section-elements</code> parameter to the serialization method. In
                  the case of an unprefixed name, the default namespace (that is, the namespace
                  declared using <code>xmlns="uri"</code>) is used. </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a>.</p>
                     </div>
                  </li>
                  <li>
                     <p> The value of the <code>doctype-system</code> attribute provides the value of the
                     <code>doctype-system</code> parameter to the serialization method. If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).
               </p>
                  </li>
                  <li>
                     <p> The value of the <code>doctype-public</code> attribute provides the value of the
                     <code>doctype-public</code> parameter to the serialization method. If the attribute is absent or has a zero-length
                     string as its value, then the serialization parameter is not set (is
                     “absent”).
               </p>
                     <p>The value of <code>doctype-public</code> must conform to the rules for a <a href="https://www.w3.org/TR/REC-xml/#NT-PubidLiteral">PubidLiteral</a><sup><small>XML</small></sup> (see <a href="#REC-xml">[XML 1.0]</a>).</p>
                  </li>
                  <li>
                     <p> The value of the <code>escape-solidus</code> attribute provides the value
                  of the <code>escape-solidus</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
                  </li>
                  <li>
                     <p> The value of the <code>escape-uri-attributes</code> attribute provides the value
                  of the <code>escape-uri-attributes</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
                  </li>
                  <li>
                     <p> The value of the <code>html-version</code> attribute provides
                  the value of the <code>html-version</code> parameter to the serialization method.
                  The set of permitted values, and the default value, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. 
                  A <a title="serialization error" class="termref" href="#dt-serialization-error">serialization error</a> will be raised if
                  the requested version is not supported by the implementation. </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This serialization parameter is new in version 3.0. If it is
                     absent, the html output method uses the value of the <code>version</code>
                     parameter in its place. For XHTML serialization, the <code>html-version</code>
                     parameter indicates the version of XHTML to be used, while the
                        <code>version</code> parameter indicates the version of XML.</p>
                     </div>
                  </li>
                  <li>
                     <p> The value of the <code>include-content-type</code> attribute provides the value
                  of the <code>include-content-type</code> parameter to the serialization method.
                  The default value is <code>yes</code>. </p>
                  </li>
                  <li>
                     <p> The value of the <code>indent</code> attribute provides the value of the
                     <code>indent</code> parameter to the serialization method. The default value is
                     <code>yes</code> in the case of the <code>html</code> and <code>xhtml</code>
                  output methods, <code>no</code> in the case of all other output methods.
               </p>
                  </li>
                  <li>
                     <p> The value of the <code>item-separator</code> attribute provides the value of the
                     <code>item-separator</code> parameter to the serialization method. The value of
                  the serialization parameter can be any string (including a zero-length string), or
                  absent. To set the parameter to absent, the <code>item-separator</code> attribute
                  can either be omitted, or set to the special value
                     <code>item-separator="#absent"</code>; it is not possible to set the value of
                  the serialization parameter to the literal 7-character string <code>"#absent"</code>. </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>The <code>item-separator</code> attribute has no
                     effect if the sequence being serialized contains only one item. </p>
                     </div>
                  </li>
                  <li>
                     <p>The value of the <code>json-lines</code> attribute determines whether the JSON
                  output method should output multiple JSON values in json-lines format (one
                  value per line). The default value is <code>no</code>.
               </p>
                  </li>
                  <li>
                     <p>The value of the <code>json-node-output-method</code> attribute determines how
                  any nodes appearing within maps or arrays are serialized by the <code>json</code>
                  output method. The default value is <code>xml</code>. The syntax and semantics of
                  the value follow the same rules as the <code>method</code> attribute.
               </p>
                  </li>
                  <li>
                     <p> The value of the <code>media-type</code> attribute provides the value of the
                     <code>media-type</code> parameter to the serialization method. The default
                  value is <code>text/xml</code> in the case of the <code>xml</code> output method,
                     <code>text/html</code> in the case of the <code>html</code> and
                     <code>xhtml</code> output methods, and <code>text/plain</code> in the case of
                  the <code>text</code> output method. <span>The default for 
                     the <code>json</code> output method is <code>application/json</code>; the default 
                     for the adaptive output method is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.
                  </span></p>
                  </li>
                  <li>
                     <p> The value of the <code>normalization-form</code> attribute provides the value of
                  the <code>normalization-form</code> parameter to the serialization method. A value
                  that is an <code>NMTOKEN</code> other than one of those enumerated for the
                     <code>normalization-form</code> attribute specifies an implementation-defined
                  normalization form; the behavior in this case is not specified by this document.
                  The default value is <code>none</code>. </p>
                  </li>
                  <li>
                     <p> The value of the <code>omit-xml-declaration</code> attribute provides the value
                  of the <code>omit-xml-declaration</code> parameter to the serialization method.
                  The default value is <code>no</code>. </p>
                  </li>
                  <li>
                     <p> The value of the <code>standalone</code> attribute provides the value of the
                     <code>standalone</code> parameter to the serialization method. The default
                  value is <code>omit</code>; this means that no <code>standalone</code> attribute
                  is to be included in the XML declaration. </p>
                  </li>
                  <li>
                     <p> The <code>suppress-indentation</code> attribute is a whitespace-separated list of
                  QNames. The default value is an empty list. After expansion of these names using
                  the <span><a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> 
                  for the <a href="#element-output"><code>xsl:output</code></a>
                  declaration in which they appear, this list of names provides the value of the
                     <code>suppress-indentation</code> parameter to the serialization method. In the
                  case of an unprefixed name, the default namespace (that is, the namespace declared
                  using <code>xmlns="uri"</code>) is used. </p>
                     <div class="note">
                        <p class="prefix"><b>Note:</b></p>
                        <p>This differs from the rule for most other QNames used in a stylesheet. The
                     reason is that these names refer to elements in the result document, and
                     therefore follow the same convention as the name of a literal result element or
                     the <code>name</code> attribute of <a href="#element-element"><code>xsl:element</code></a>.</p>
                     </div>
                  </li>
                  <li>
                     <p> The value of the <code>undeclare-prefixes</code> attribute provides the value of the
                  <code>undeclare-prefixes</code> parameter to the serialization method. The default
                  value is <code>no</code>.</p>
                  </li>
                  <li>
                     <p>The <code>use-character-maps</code> attribute provides a list of named character
                  maps that are used in conjunction with this <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>. The way this attribute is used is described in
                     <a href="#character-maps"><i>26.3 Character Maps</i></a>. The default value is an empty list.</p>
                  </li>
                  <li>
                     <p> The value of the <code>version</code> attribute provides the value of the
                     <code>version</code> parameter to the serialization method. The set of
                  permitted values, and the default value, are <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. 
                  A <a title="serialization error" class="termref" href="#dt-serialization-error">serialization error</a> will be raised if
                  the requested version is not supported by the implementation.
                  
               </p>
                  </li>
               </ul>
               <p>If the processor performs serialization, then it must raise any  serialization errors that occur. These have the same
            effect as <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic errors</a>: that is, the processor must
            raise the error and must not finish as if the transformation had been successful.</p>
            </div>
            <div class="div2">
               
               <h3><a id="character-maps"></a>26.3 <a href="#character-maps" style="text-decoration: none">Character Maps</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-character-map" title="character map"></a>A <b>character map</b>
                  allows a specific character appearing in a text or attribute node in the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be substituted by a
                  specified string of characters during serialization.<span class="definition">]</span> The effect of
               character maps is defined in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>.</p>
               <p>The character map that is supplied as a parameter to the serializer is determined
               from the <a href="#element-character-map"><code>xsl:character-map</code></a> elements referenced from the
                  <a href="#element-output"><code>xsl:output</code></a> declaration for the selected <a title="output definition" class="termref" href="#dt-output-definition">output definition</a>.</p>
               <p>The <a href="#element-character-map"><code>xsl:character-map</code></a> element is a declaration that may appear as a
               child of the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element.</p>
               <p class="element-syntax"><a id="element-character-map"></a><code>&lt;!-- Category: declaration --&gt;<br>&lt;xsl:character-map<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-output-character">xsl:output-character</a>*) --&gt;<br>&lt;/xsl:character-map&gt;</code></p>
               <p>The <a href="#element-character-map"><code>xsl:character-map</code></a> declaration declares a character map with a
               name and a set of character mappings. The character mappings are specified by means
               of <a href="#element-output-character"><code>xsl:output-character</code></a> elements contained either directly within
               the <a href="#element-character-map"><code>xsl:character-map</code></a> element, or in further character maps
               referenced in the <code>use-character-maps</code> attribute.</p>
               <p>The <span class="verb">required</span>
               <code>name</code> attribute provides a name for the character map. When a character
               map is used by an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> or
               another character map, the character map with the highest <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> is used.</p>
               <p>The name of a character map is local to the <a title="package" class="termref" href="#dt-package">package</a> in which its declaration appears; it may be
               referenced only from within the same package.</p>
               <p>
               <a id="err-XTSE1580"><span class="error">[ERR XTSE1580] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains two
                     or more character maps with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also
                     contains another character map with the same name and higher import
                     precedence.
            </p>
               <p>The optional <code>use-character-maps</code> attribute lists the names of further
               character maps that are included into this character map.</p>
               <p>
               <a id="err-XTSE1590"><span class="error">[ERR XTSE1590] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a name in the
                        <code>use-character-maps</code> attribute of the <a href="#element-output"><code>xsl:output</code></a>
                     or <a href="#element-character-map"><code>xsl:character-map</code></a> elements does not match the
                        <code>name</code> attribute of any <a href="#element-character-map"><code>xsl:character-map</code></a> in the
                        containing <a title="package" class="termref" href="#dt-package">package</a>.
            </p>
               <p>
               <a id="err-XTSE1600"><span class="error">[ERR XTSE1600] </span></a>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a character
                     map references itself, directly or indirectly, via a name in the
                        <code>use-character-maps</code> attribute.
            </p>
               <p>It is not an error if the same character map is referenced more than once, directly
               or indirectly.</p>
               <p>For every <a href="#element-character-map"><code>xsl:character-map</code></a> declaration in a <a title="package" class="termref" href="#dt-package">package</a>,
            other than one that is overridden by another of higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>,
            the static context of the package includes a named character map derived from the 
            <a href="#element-character-map"><code>xsl:character-map</code></a> declaration. The name of the named character map is the
            QName formed by expanding the value of the <code>name</code> attribute, and the content is
            a map of type <code>map{xs:string, xs:string}</code> that maps characters (represented as 
            <code>xs:string</code> instances of length 1) to their replacement strings.</p>
               <p>Recursive expansion of character maps using <code>use-character-maps</code>
               attributes may produce several mappings for the same character. In this situation,
               the last character mapping takes precedence. To establish the ordering, the following
               rules are used:</p>
               <ul>
                  <li>
                     <p>Within a single <a href="#element-character-map"><code>xsl:character-map</code></a> element, the characters
                     defined in character maps referenced in the <code>use-character-maps</code>
                     attribute are considered before the characters defined in the child
                        <a href="#element-output-character"><code>xsl:output-character</code></a> elements.</p>
                  </li>
                  <li>
                     <p>The character maps referenced in a single <code>use-character-maps</code>
                     attribute are considered in the order in which they are listed in that
                     attribute. The expansion is depth-first: each referenced character map is fully
                     expanded before the next one is considered.</p>
                  </li>
                  <li>
                     <p>Two <a href="#element-output-character"><code>xsl:output-character</code></a> elements appearing as children of the
                     same <a href="#element-character-map"><code>xsl:character-map</code></a> element are considered in document
                     order.</p>
                  </li>
               </ul>
               <p>The <a href="#element-output-character"><code>xsl:output-character</code></a> element is defined as follows:</p>
               <p class="element-syntax"><a id="element-output-character"></a><code>&lt;xsl:output-character<br>&nbsp;&nbsp;<b>character</b> = <var>char</var><br>&nbsp;&nbsp;<b>string</b> = <var>string</var>&nbsp;/&gt;</code></p>
               <p>The character map that is passed as a parameter to the serializer contains a mapping
               for the character specified in the <code>character</code> attribute to the string
               specified in the <code>string</code> attribute. </p>
               <p>Character mapping is not applied to characters for which output escaping has been
               disabled as described in <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a>.</p>
               <p>If a character is mapped, then it is not subjected to XML or HTML escaping.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e54324"></a>Example: Using Character Maps to Generate Non-XML Output</div>
                  <p>Character maps can be useful when producing serialized output in a format that
                  resembles, but is not strictly conformant to, HTML or XML. For example, when the
                  output is a JSP page, there might be a need to generate the output:</p>
                  <div class="exampleInner">
                     <pre>&lt;jsp:setProperty name="user" property="id" value='&lt;%= "id" + idValue %&gt;'/&gt;</pre>
                  </div>
                  <p>Although this output is not well-formed XML or HTML, it is valid in Java Server
                  Pages. This can be achieved by allocating three Unicode characters (which are not
                  needed for any other purpose) to represent the strings <code>&lt;%</code>,
                     <code>%&gt;</code>, and <code>"</code>, for example:</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;</pre>
                  </div>
                  <p>When this character map is referenced in the <a href="#element-output"><code>xsl:output</code></a>
                  declaration, the required output can be produced by writing the following in the
                  stylesheet:</p>
                  <div class="exampleInner">
                     <pre>&lt;jsp:setProperty name="user" property="id" value='«= §id§ + idValue »'/&gt;</pre>
                  </div>
                  <p>This works on the assumption that when an apostrophe or quotation mark is
                  generated as part of an attribute value by the use of character maps, the
                  serializer will (where possible) use the other choice of delimiter around the
                  attribute value.</p>
               </div>
               <p>&nbsp;</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e54350"></a>Example: Constructing a Composite Character Map</div>
                  <p>The following example illustrates a composite character map constructed in a
                  modular fashion:</p>
                  <div class="exampleInner">
                     <pre>
&lt;xsl:output name="htmlDoc" use-character-maps="htmlDoc" /&gt;

&lt;xsl:character-map name="htmlDoc"
  use-character-maps="html-chars doc-entities windows-format" /&gt;
  
&lt;xsl:character-map name="html-chars"
  use-character-maps="latin1 ..." /&gt;

&lt;xsl:character-map name="latin1"&gt;
  &lt;xsl:output-character character="&amp;#160;" string="&amp;amp;nbsp;" /&gt;
  &lt;xsl:output-character character="&amp;#161;" string="&amp;amp;iexcl;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="doc-entities"&gt;
  &lt;xsl:output-character character="&amp;#xE400;" string="&amp;amp;t-and-c;" /&gt;
  &lt;xsl:output-character character="&amp;#xE401;" string="&amp;amp;chap1;" /&gt;
  &lt;xsl:output-character character="&amp;#xE402;" string="&amp;amp;chap2;" /&gt;
  ...
&lt;/xsl:character-map&gt;

&lt;xsl:character-map name="windows-format"&gt;
  &lt;!-- newlines as CRLF --&gt;
  &lt;xsl:output-character character="&amp;#xA;" string="&amp;#xD;&amp;#xA;" /&gt;

  &lt;!-- tabs as three spaces --&gt;
  &lt;xsl:output-character character="&amp;#x9;" string="   " /&gt;

  &lt;!-- images for special characters --&gt;
  &lt;xsl:output-character character="&amp;#xF001;"
    string="&amp;lt;img src='special1.gif' /&amp;gt;" /&gt;
  &lt;xsl:output-character character="&amp;#xF002;"
    string="&amp;lt;img src='special2.gif' /&amp;gt;" /&gt;
  ...
&lt;/xsl:character-map&gt;</pre>
                  </div>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>When character maps are used, there is no guarantee that the serialized output
                  will be well-formed XML (or HTML). Furthermore, the fact that the result tree was
                  validated against a schema gives no guarantee that the serialized output will
                  still be valid against the same schema. Conversely, it is possible to use
                  character maps to produce schema-valid output from a result tree that would fail
                  validation.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The value of the <code>string</code> attribute must be a literal string; this
               means it must consist entirely of characters that are valid in XML 1.0 or XML 1.1,
               depending on the version of XML used for the containing stylesheet module. The string
               can however be expressed as a shadow attribute (see <a href="#shadow-attributes"><i>3.11.4 Shadow Attributes</i></a>), 
                  and this allows
               it to be defined using a <a title="static expression" class="termref" href="#dt-static-expression">static expression</a>. For example, the 
               character <span class="unicode-codepoint">U+2398</span> (<span class="unicode-name">NEXT PAGE</span>, <code>⎘</code>)  might be mapped to the control character <span class="unicode-codepoint">U+000C</span> (<span class="unicode-name">FORM FEED</span>) 
               by writing <code>&lt;xsl:output-character char="&amp;#x2398;" _string="{char(0x0C)}"/&gt;</code>.
               This depends on the processor allowing the form-feed character to appear in strings:
               the data model allows this, but processors are not <span class="verb">required</span>
               to support it: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#xml-and-xsd-versions">4.1.5 XML and XSD Versions</a>.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="character-map-function"></a>26.4 <a href="#character-map-function" style="text-decoration: none">The <code>character-map</code> function</a></h3>
               <div class="changes">
                  <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-character-map">next</a> | <a href="#id-default-serialization-parameters">previous</a>)</p>
                  <ol>
                     <li>
                        <p>
                  The contents of a character map declared using <a href="#element-character-map"><code>xsl:character-map</code></a> are now
                  available dynamically via a new <a href="#func-character-map"><code>character-map</code></a> function.
               <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/1500">1500</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/1530">1530</a>&nbsp;30 October 2024]</i></p>
                     </li>
                  </ol>
               </div>
               <p>The contents of a character map declared using <a href="#element-character-map"><code>xsl:character-map</code></a> are 
                  available dynamically via the <a href="#func-character-map"><code>character-map</code></a> function.</p>
               <div class="div3">
                  
                  <h4><a id="func-character-map"></a>26.4.1 <a href="#func-character-map" style="text-decoration: none">fn:character-map</a></h4>
                  <div class="changes">
                     <p class="changesHeading">
        Changes in 4.0
        (<a href="#conformance">next</a> | <a href="#character-map-function">previous</a>)</p>
                     <ol>
                        <li>
                           <p>New in 4.0</p>
                        </li>
                     </ol>
                  </div>
                  <dl>
                     <dt class="label">Summary</dt>
                     <dd>
                        <p>Delivers the content of a character map declared using <a href="#element-character-map"><code>xsl:character-map</code></a>.</p>
                     </dd>
                     <dt class="label">Signature</dt>
                     <dd>
                        <div class="proto">
                           <table class="proto" border="0">
                              <tr class="name">
                                 <td colspan="3"><code class="function">fn:character-map</code>(</td>
                              </tr>
                              <tr class="arg">
                                 <td><code>$name</code></td>
                                 <td><code class="as">as&nbsp;</code><code class="type">xs:QName</code></td>
                                 <td></td>
                              </tr>
                              <tr class="return-type">
                                 <td colspan="3">)<code class="as">&nbsp;as&nbsp;</code><code>map(xs:string, xs:string)?</code></td>
                              </tr>
                           </table>
                        </div>
                     </dd>
                     <dt class="label">Properties</dt>
                     <dd>
                        <p>This function is <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-deterministic">deterministic</a><sup><small>FO</small></sup>, <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-context-dependent">context-dependent</a><sup><small>FO</small></sup>,  and <a href="https://qt4cg.org/specifications/xpath-functions-40/#dt-focus-independent">focus-independent</a><sup><small>FO</small></sup>.  It depends on 
		character maps.
	</p>
                     </dd>
                     <dt class="label">Rules</dt>
                     <dd>
                        <p>The static context for a stylesheet package includes a set of named character maps. This function
         delivers the content of a character map if a character map with the given name is present in the
         static context of the containing package, or an empty sequence otherwise.</p>
                     </dd>
                     <dt class="label">Notes</dt>
                     <dd>
                        <div class="note">
                           <p>The returned character map is in a format suitable for use within the <code>$options</code>
         parameter of the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-serialize"><code>serialize</code></a> function.</p>
                        </div>
                     </dd>
                     <dt class="label">Examples</dt>
                     <dd>
                        <div class="example">
                           <table style="border:1px solid; padding:5px; width:100%" class="medium">
                              <tbody>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>Consider the following character map declaration:</p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="exampleInner">
                                          <pre>
 &lt;xsl:character-map name="jsp"&gt;
  &lt;xsl:output-character character="«" string="&amp;lt;%"/&gt;   
  &lt;xsl:output-character character="»" string="%&amp;gt;"/&gt;
  &lt;xsl:output-character character="§" string='"'/&gt;
&lt;/xsl:character-map&gt;</pre>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>Then the result of the function call <code>character-map( #jsp )</code> is the map:</p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="exampleInner">
                                          <pre>
{
  "«": "&lt;%",
  "»": "%&gt;",
  "§": '"'
}</pre>
                                       </div>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <p>This might be used in a call to the function <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-serialize"><code>serialize</code></a>, for example:</p>
                                    </td>
                                 </tr>
                                 <tr>
                                    <td style="text-align:left; vertical-align:top" colspan="2">
                                       <div class="exampleInner">
                                          <pre>
serialize($input, {
  'method': 'xml',
  'use-character-maps': character-map( #jsp )
})</pre>
                                       </div>
                                    </td>
                                 </tr>
                              </tbody>
                           </table>
                        </div>
                     </dd>
                  </dl>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="disable-output-escaping"></a>26.5 <a href="#disable-output-escaping" style="text-decoration: none">Disabling Output Escaping</a></h3>
               <p>Normally, when using the XML, HTML, or XHTML output method, the serializer will
               escape special characters such as <code>&amp;</code> and <code>&lt;</code> when
               outputting text nodes. This ensures that the output is well-formed. However, it is
               sometimes convenient to be able to produce output that is almost, but not quite
               well-formed XML; for example, the output may include ill-formed sections which are
               intended to be transformed into well-formed XML by a subsequent non-XML-aware
               process. For this reason, XSLT defines a mechanism for disabling output escaping.</p>
               <p>This feature is <a title="deprecated" class="termref" href="#dt-deprecated">deprecated</a>.</p>
               <p>This is an optional feature: it is not <span class="verb">required</span> that an XSLT
               processor that implements the serialization option <span class="verb">should</span> offer
               the ability to disable output escaping, and there is no conformance level that
               requires this feature.</p>
               <p>This feature requires the serializer (described in <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>) 
               to be extended as follows. Conceptually, the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> provides an additional
               boolean property <code>disable-escaping</code> associated with every character in a
               text node. When this property is set, the normal action of the serializer to escape
               special characters such as <code>&amp;</code> and <code>&lt;</code> is
               suppressed.</p>
               <p>An <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> element may have a
                  <code>disable-output-escaping</code> attribute; the allowed values are
                  <code>yes</code> or <code>no</code>. The default is <code>no</code>; if the value
               is <code>yes</code>, then every character in the text node generated by evaluating
               the <a href="#element-value-of"><code>xsl:value-of</code></a> or <a href="#element-text"><code>xsl:text</code></a> element
                  <span class="verb">should</span> have the <code>disable-escaping</code> property set.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e54545"></a>Example: Disable Output Escaping</div>
                  <p>For example,</p>
                  <div class="exampleInner">
                     <pre>&lt;xsl:text disable-output-escaping="yes"&gt;&amp;lt;&lt;/xsl:text&gt;</pre>
                  </div>
                  <p>should generate the single character <code>&lt;</code>.</p>
               </div>
               <p>If output escaping is disabled for an <a href="#element-value-of"><code>xsl:value-of</code></a> or
                  <a href="#element-text"><code>xsl:text</code></a> instruction evaluated when <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a> is in effect, the
               request to disable output escaping is ignored.</p>
               <p>Similarly, if an <a href="#element-value-of"><code>xsl:value-of</code></a> or
                  <a href="#element-text"><code>xsl:text</code></a> instruction specifies that output escaping is to be
               disabled when writing to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                  tree</a> that is not being serialized, the request to disable output
               escaping is ignored.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>Furthermore, a request to disable output escaping has no effect when the newly
               constructed text node is used to form the value of an attribute, comment, processing instruction,
               or namespace node. This is because the rules for constructing such nodes (see <a href="#constructing-simple-content"><i>5.7.2 Constructing Simple Content</i></a>)
               cause the text node to be atomized, and the process of atomizing a text node takes no
               account of the disable-escaping property.</p>
               </div>
               <p>If output escaping is disabled for text within an element that would normally be
               output using a CDATA section, because the element is listed in the
                  <code>cdata-section-elements</code>, then the relevant text will not be included
               in a CDATA section. In effect, CDATA is treated as an alternative escaping mechanism,
               which is disabled by the <code>disable-output-escaping</code> option.</p>
               <div class="example">
                  
                  <div class="exampleHeader"><a id="d5e54587"></a>Example: Interaction of Output Escaping and CDATA</div>
                  <p>For example, if <code>&lt;xsl:output cdata-section-elements="title"/&gt;</code> is
                  specified, then the following instructions:</p>
                  <div class="exampleInner">
                     <pre>&lt;title&gt;
  &lt;xsl:text disable-output-escaping="yes"&gt;This is not &amp;lt;hr/&amp;gt; 
                                          good coding practice&lt;/xsl:text&gt;
&lt;/title&gt;</pre>
                  </div>
                  <p>should generate the output:</p>
                  <div class="exampleInner">
                     <pre>&lt;title&gt;&lt;![CDATA[This is not ]]&gt;&lt;hr/&gt;&lt;![CDATA[ good coding practice]]&gt;&lt;/title&gt;</pre>
                  </div>
               </div>
               <p>The <code>disable-output-escaping</code> attribute may be used with the
                  <code>html</code> output method as well as with the <code>xml</code> output
               method. The <code>text</code> output method ignores the
                  <code>disable-output-escaping</code> attribute, since this method does not perform
               any output escaping.</p>
               <p>A <a title="processor" class="termref" href="#dt-processor">processor</a> will only be able to disable output
               escaping if it controls how the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                  tree</a> is output. This might not always be the case. For example, the
               result tree might be used as a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a>
               for another XSLT transformation instead of being output. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether (and
               under what circumstances) disabling output escaping is supported. If disabling output escaping is not supported, any request to disable
                  output escaping is ignored.</p>
               <p>If output escaping is disabled for a character that is not representable in the
               encoding that the <a title="processor" class="termref" href="#dt-processor">processor</a> is using for
               output, the request to disable output escaping is ignored in respect of that
               character.</p>
               <p>Since disabling output escaping might not work with all implementations and can
               result in XML that is not well-formed, it <span class="verb">should</span> be used only when
               there is no alternative.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>When disable-output-escaping is used, there is no guarantee that the serialized
                  output will be well-formed XML (or HTML). Furthermore, the fact that the result
                  tree was validated against a schema gives no guarantee that the serialized output
                  will still be valid against the same schema. Conversely, it is possible to use
                  disable-output-escaping to produce schema-valid output from a result tree that
                  would fail validation.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The facility to define character maps for use during serialization, as described
                  in <a href="#character-maps"><i>26.3 Character Maps</i></a>, has been produced as an alternative mechanism
                  that can be used in many situations where disabling of output escaping was
                  previously necessary, without the same difficulties.</p>
               </div>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="conformance"></a>27 <a href="#conformance" style="text-decoration: none">Conformance</a></h2>
            <div class="changes">
               <p class="changesHeading">
        Changes in 4.0
        (<a href="#func-character-map">previous</a>)</p>
               <ol>
                  <li>
                     <p>
               The higher-order-function feature no longer exists; higher-order functions
               are now a core part of XSLT, no longer an optional extra.
            <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/205">205</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326</a>&nbsp;1 February 2023]</i></p>
                  </li>
                  <li>
                     <p>
               The dynamic evaluation feature no longer exists; processor are now required
               to support the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.
            <i>&nbsp;&nbsp;[Issue <a href="https://github.com/qt4cg/qtspecs/issues/2047">2047</a>&nbsp;PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213</a>&nbsp;23 October 2025]</i></p>
                  </li>
               </ol>
            </div>
            <p>A <a title="processor" class="termref" href="#dt-processor">processor</a> that claims
            conformance with this specification <span class="verb">must</span> satisfy the conformance
            requirements for a <a title="basic XSLT processor" class="termref" href="#dt-basic-xslt-processor">basic XSLT processor</a>
            and for each of the optional features with which it claims conformance.</p>
            <p>The following optional features are defined:</p>
            <ol class="enumar">
               <li>
                  <p>The schema-awareness feature, defined in <a href="#schema-aware-conformance"><i>27.2 Schema-Awareness Conformance Feature</i></a></p>
               </li>
               <li>
                  <p>The serialization feature, defined in <a href="#serialization-feature"><i>27.3 Serialization Feature</i></a></p>
               </li>
               <li>
                  <p>The backwards compatibility feature, defined in <a href="#backwards-compatibility-feature"><i>27.4 Compatibility Features</i></a></p>
               </li>
               <li>
                  <p>The streaming feature, defined in <a href="#streaming-feature"><i>27.5 Streaming Feature</i></a>.</p>
               </li>
            </ol>
            <p>A processor that does not claim conformance with an optional feature
               <span class="verb">must</span> satisfy the requirements for processors that do not implement
            that feature.</p>
            <p>An XSLT processor takes as its inputs a stylesheet and zero or more XDM trees conforming to the data model defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. It is not <span class="verb">required</span> that the processor
            supports any particular method of constructing XDM trees, but conformance can only be
            tested if it provides a mechanism that enables XDM trees representing the stylesheet and
            primary source document to be constructed and supplied as input to the processor.</p>
            <p>The output of the XSLT processor consists of zero or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result trees</a>. It is not
               <span class="verb">required</span> that the processor supports any particular method of
            accessing a final result tree, but if it does not support the serialization feature, conformance can only be tested if it provides
            some alternative mechanism that enables access to the results of the transformation.</p>
            <p>Certain facilities in this specification are described as producing <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> results. A claim
            that asserts conformance with this specification <span class="verb">must</span> be accompanied
            by documentation stating the effect of each implementation-defined feature. For
            convenience, a non-normative checklist of implementation-defined features is provided at
               <a href="#implementation-defined-features"><i>F Checklist of Implementation-Defined Features</i></a>.</p>
            <p>A conforming <a title="processor" class="termref" href="#dt-processor">processor</a>
            <span class="verb">must</span> raise any <a title="static error" class="termref" href="#dt-static-error">static error</a>
            occurring in the stylesheet, or in any XPath <a title="expression" class="termref" href="#dt-expression">expression</a>, except where specified otherwise either for individual error
            conditions or under the general provisions for <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> (see <a href="#forwards"><i>3.9 Forwards Compatible Processing</i></a>). After
            raising such an error, the processor <span class="verb">may</span> continue for the purpose
            of raising additional errors, but <span class="verb">must</span> terminate abnormally without
            performing any transformation.</p>
            <p>When a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs during the course
            of a transformation, and is not caught using
                  <a href="#element-catch"><code>xsl:catch</code></a>,
             the processor
               <span class="verb">must</span> raise it and <span class="verb">must</span> eventually terminate
            abnormally. </p>
            <p>Some errors, notably <a title="type error" class="termref" href="#dt-type-error">type errors</a>,
               <span class="verb">may</span> be treated as <a title="static error" class="termref" href="#dt-static-error">static
               errors</a> or <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic errors</a> at the
            discretion of the processor.</p>
            <p>A conforming processor <span class="verb">may</span> impose limits on the processing resources
            consumed by the processing of a stylesheet.</p>
            <p>A requirement is mandatory unless the specification includes wording (such as the use of
            the words <span class="verb">should</span> or <span class="verb">may</span>) that clearly indicates
            that it is optional.</p>
            <p>Some of the optional features are defined in such a way that
         if the feature is not provided, the data model is constrained to exclude certain kinds of
         item. For example:</p>
            <ul>
               <li>
                  <p>A processor that does not provide the <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-awareness</a>
            feature restricts the data model so that it does not contain atomic items of types other than the built-in types,
            or nodes with non-trivial type annotations.</p>
               </li>
            </ul>
            <p><a id="err-XTDE1665"><span class="error">[ERR XTDE1665] </span></a>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> <span class="verb">may</span> be raised if the
               input to the processor includes an item that requires availability
               of an optional feature that the processor does not provide.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>It is not necessarily possible to trigger this error. A processor that does
         not provide an optional feature might not define or recognize any representation of the items
         that are disallowed. The error code is provided for use in cases where a processor is able
         to interoperate with other software that does not have the same constraints — for example,
         where a package compiled with a non-schema-aware processor is able to invoke functions in a package
         that was compiled with a schema-aware processor. Even in that case,
         processors have the option of filtering or converting the input so that it meets the relevant
         constraints: for example, a non-schema-aware processor when presented with a schema-validated
         document in the form of a PSVI might simply ignore the properties it does not understand.</p>
               <p>The dynamic error is optional: for example a processor might report no error
            if the offending item is not actually used.</p>
               <p>The phrase <em>input to the processor</em> is deliberately wide: it includes (inter alia)
               the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>, items present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>, items passed as <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, items returned by functions such as 
                <a href="#func-document"><code>document</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, and
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a>, items returned by <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> and <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>,
            items supplied in function or template parameters or results across package boundaries, and nodes
            reachable from any of the above by axis navigation.</p>
            </div>
            <div class="div2">
               
               <h3><a id="basic-conformance"></a>27.1 <a href="#basic-conformance" style="text-decoration: none">Basic XSLT Processor</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-basic-xslt-processor" title="basic XSLT processor"></a>A <b>basic XSLT
                     processor</b> is an XSLT processor that implements all the mandatory
                  requirements of this specification with the exception of constructs explicitly
                  associated with an optional feature.<span class="definition">]</span> These constructs are listed
               below.</p>
            </div>
            <div class="div2">
               
               <h3><a id="schema-aware-conformance"></a>27.2 <a href="#schema-aware-conformance" style="text-decoration: none">Schema-Awareness Conformance Feature</a></h3>
               <p>A conformant processor <span class="verb">must</span> either be a conformant <a title="schema-aware XSLT processor" class="termref" href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a> or a conformant <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a>.</p>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-schema-aware-xslt-processor" title="schema-aware XSLT processor"></a>A
                     <b>schema-aware XSLT processor</b> is an XSLT processor that implements
                  the mandatory requirements of this specification connected with the
                     <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, the
                     <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the
                  ability to handle input documents whose nodes have type annotations other than
                     <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory
                  requirements of this specification are taken to include the mandatory requirements
                  of XPath 4.0, as described in <a href="#xpath-40">[XPath 4.0]</a>. A requirement is mandatory unless the specification includes
                  wording (such as the use of the words <span class="verb">should</span> or
                     <span class="verb">may</span>) that clearly indicates that it is optional.<span class="definition">]</span>
            </p>
               <p><span class="definition">[Definition:&nbsp;</span><a id="dt-non-schema-aware-processor" title="non-schema-aware processor"></a>A <b>non-schema-aware processor</b> is a
                  processor that does not claim conformance with the schema-aware conformance
                  feature. Such a processor <span class="verb">must</span> handle constructs associated
                  with schema-aware processing as described in this section.<span class="definition">]</span></p>
               <p>
               <a id="err-XTSE1650"><span class="error">[ERR XTSE1650] </span></a>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware
                        processor</a>
                     <span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static
                        error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an
                        <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.
            </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>A processor that rejects an <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration will
                  also reject any reference to a user-defined type defined in a schema, or to a
                  user-defined element or attribute declaration; it will not, however, reject
                  references to the built-in types listed in <a href="#built-in-types"><i>3.12 Built-in Types</i></a>.</p>
               </div>
               <p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware
                  processor</a> is not able to validate input documents, and is not able to
               handle input documents containing type annotations other than <code>xs:untyped</code>
               or <code>xs:untypedAtomic</code>. Therefore, such a processor <span class="verb">must</span>
               treat any <code>[xsl:]validation</code> attribute
                  with a value of <code>preserve</code> or <code>lax</code>, or a
                     <code>[xsl:]default-validation</code> attribute with a value of
                     <code>preserve</code> as if the value were <code>strip</code>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The values <code>lax</code> and <code>preserve</code> indicate that the validation
                  to be applied depends on the calling application, so it is appropriate for the
                  request to be treated differently by different kinds of processor. By contrast,
                  requesting <code>strict</code> validation, either through the
                     <code>[xsl:]validation</code> attribute or the <code>type</code> attribute,
                  indicates that the stylesheet is expecting to deal with typed data, and therefore
                  cannot be processed without performing the validation.</p>
               </div>
               <p>
               <a id="err-XTSE1660"><span class="error">[ERR XTSE1660] </span></a>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware
                        processor</a>
                     <span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static
                        error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an
                        <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or
                        <code>[xsl:]default-validation</code> attribute with a value other than
                        <code>strip</code>, <code>preserve</code>, or
                           <code>lax</code>; or an
                           <a href="#element-mode"><code>xsl:mode</code></a> element whose <code>typed</code> attribute is
                        equal to <code>yes</code> or <code>strict</code>; or an <code>as</code>
                              attribute whose value is a 
                              <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> that can only match
                        nodes with a type annotation other than <code>xs:untyped</code> or
                           <code>xs:untypedAtomic</code> (for example, <code>as="element(*,
                           xs:integer)"</code>).
            </p>
               <p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware processor</a>
               constrains the data model as follows, and raises a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> (<span class="error">[see <a href="#err-XTDE1665">ERR XTDE1665</a>]</span>) if the
                  constraints are not satisfied:</p>
               <ul>
                  <li>
                     <p>Atomic items <span class="verb">must</span> belong to one of the atomic types listed
                     in <a href="#built-in-types"><i>3.12 Built-in Types</i></a> (except as noted below).</p>
                     <p>An atomic item may also belong to an implementation-defined type that has been
                     added to the context for use with <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a>.</p>
                     <p>The set of constructor functions available are limited to those that construct
                     values of the above atomic types.</p>
                     <p>The static context, which defines the full set of type names recognized by an
                     XSLT processor and also by the XPath processor, includes these atomic types,
                     plus <code>xs:anyType</code>, <code>xs:anySimpleType</code>,
                        <code>xs:untyped</code>, and <code>xs:anyAtomicType</code>.</p>
                  </li>
                  <li>
                     <p>Element nodes <span class="verb">must</span> be annotated with the <a title="type annotation" class="termref" href="#dt-type-annotation">type annotation</a>
                     <code>xs:untyped</code>, and attribute nodes with the type annotation
                        <code>xs:untypedAtomic</code>.</p>
                  </li>
               </ul>
            </div>
            <div class="div2">
               
               <h3><a id="serialization-feature"></a>27.3 <a href="#serialization-feature" style="text-decoration: none">Serialization Feature</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-serialization-feature" title="serialization feature"></a>A processor that
                  claims conformance with the <b>serialization feature</b>
                  <span class="verb">must</span> support the conversion of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to a sequence of octets
                  following the rules defined in <a href="#serialization"><i>26 Serialization</i></a>.<span class="definition">]</span> It
                  <span class="verb">must</span> respect all the attributes of the
                  <a href="#element-output"><code>xsl:output</code></a> and <a href="#element-character-map"><code>xsl:character-map</code></a> declarations,
               and <span class="verb">must</span> provide all four output methods, <code>xml</code>,
                  <code>xhtml</code>, <code>html</code>, and <code>text</code>. Where the
               specification uses words such as <span class="verb">must</span> and
                  <span class="verb">required</span>, then it <span class="verb">must</span> serialize the result
               tree in precisely the way described; in other cases it <span class="verb">may</span> use an
               alternative, equivalent representation.</p>
               <p>A processor may claim conformance with the serialization feature whether or not it
               supports the setting <code>disable-output-escaping="yes"</code> on
                  <a href="#element-text"><code>xsl:text</code></a>, or <a href="#element-value-of"><code>xsl:value-of</code></a>. </p>
               <p>A processor that does not claim conformance with the serialization feature
                  <span class="verb">must not</span> raise an error merely because the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> contains <a href="#element-output"><code>xsl:output</code></a> or
                  <a href="#element-character-map"><code>xsl:character-map</code></a> declarations, or serialization attributes on
               the <a href="#element-result-document"><code>xsl:result-document</code></a> instruction. Such a processor
                  <span class="verb">may</span> check that these declarations and attributes have valid
               values, but is not <span class="verb">required</span> to do so. Apart from optional
               validation, these declarations <span class="verb">should</span> be ignored.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>A processor that does not claim conformance with the serialization feature
               <span class="verb">may</span> offer alternative serialization capabilities, and these
               <span class="verb">may</span> make use of the serialization parameters defined on
               <a href="#element-output"><code>xsl:output</code></a> and/or <a href="#element-result-document"><code>xsl:result-document</code></a>.
                  <span>Such a processor <span class="verb">may</span> implement 
                     selected parts of the serialization capabilities defined in this specification. 
                     For example, it may implement selected output methods, or selected serialization 
                     properties. It may implement sequence normalization using the <code>item-separator</code> 
                     property even if it has no other serialization capabilities. </span></p>
               </div>
               <p>If the processor claims conformance with 
               the serialization feature then it <span class="verb">must</span> fully implement the 
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-serialize"><code>serialize</code></a> function defined in <span><a href="#xpath-functions-40">[Functions and Operators 4.0]</a></span>,
               and <span class="verb">must not</span>
               raise error <a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFODC0010" title="FODC0010"><span class="error">[ERR FODC0010] </span></a><sup><small>FO40</small></sup> as the result of such a call.</p>
               <p>If the processor does not claim conformance with
               the serialization feature, then it <span class="verb">may</span> raise 
               error <a href="https://qt4cg.org/specifications/xpath-functions-40/#ERRFODC0010" title="FODC0010"><span class="error">[ERR FODC0010] </span></a><sup><small>FO40</small></sup> in respect of some or
               all calls on the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-serialize"><code>serialize</code></a> function; it <span class="verb">must not</span>
               return a result from a call on this function unless the result is conformant with
               the specification, given the parameters actually supplied. 
            </p>
               <p>A processor that claims conformance with the Serialization
               Feature must satisfy the mandatory requirements of <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a>. It <span class="verb">must</span> provide a mode of
               operation which conforms to the 3.0 version of that specification. It
                  <span class="verb">may</span> also provide a mode of operation which conforms to a later
               version of that specification; in such cases the detail of how XSLT 3.0 interacts
               with new features introduced by such a version (for example, support for new
               serialization properties) is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>.</p>
            </div>
            <div class="div2">
               
               <h3><a id="backwards-compatibility-feature"></a>27.4 <a href="#backwards-compatibility-feature" style="text-decoration: none">Compatibility Features</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-1.0-compatibility-feature" title="XSLT 1.0 compatibility feature"></a>A
                  processor that claims conformance with the <b>XSLT 1.0 compatibility
                     feature</b>
                  <span class="verb">must</span> support the processing of stylesheet instructions and
                  XPath expressions with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT
                     1.0 behavior</a>, as defined in <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>.<span class="definition">]</span>
            </p>
               <p>Note that a processor that does not claim conformance with the <a title="XSLT 1.0 compatibility feature" class="termref" href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>
               <span class="verb">must</span> raise a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if an instruction is
               evaluated whose <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is 1.0. <span class="error">[see <a href="#err-XTDE0160">ERR XTDE0160</a>]</span>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The reason this is a dynamic error rather than a static error is to allow
                  stylesheets to contain conditional logic, following different paths depending on
                  whether the XSLT processor implements XSLT 1.0, 2.0, or
                     3.0. The selection of which path to use can be controlled by using the
                     <a href="#func-system-property"><code>system-property</code></a> function to test the
                     <code>xsl:version</code> system property.</p>
               </div>
               <p>A processor that claims conformance with the <a title="XSLT 1.0 compatibility feature" class="termref" href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a>
               <span class="verb">must</span> permit the use of the namespace axis in XPath expressions
               when backwards compatible behavior is enabled. In all other circumstances, support
               for the namespace axis is optional.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>There are no incompatibilities between 3.0 and 2.0 that would
                  justify a 2.0-compatibility mode. When a 3.0 processor encounters a stylesheet
                  that specifies <code>version="2.0"</code>, evaluation therefore proceeds exactly
                  as if it specified <code>version="3.0"</code>. However, a software product may
                  invoke an XSLT 2.0 processor in preference to an XSLT 3.0 processor when the
                  stylesheet specifies <code>version="2.0"</code>, in which case any use of new 3.0
                  constructs will be rejected.</p>
                  <p>There are cases where setting <code>[xsl:]version</code> to a value less than
               4.0 affects the behavior of an XSLT 4.0 stylesheet: see <a href="#incompatibilities"><i>J Incompatibilities with XSLT 3.0</i></a>.
               However these are sufficiently minor that they do not warrant the introduction of a
               separate conformance option.</p>
               </div>
            </div>
            <div class="div2">
               
               <h3><a id="streaming-feature"></a>27.5 <a href="#streaming-feature" style="text-decoration: none">Streaming Feature</a></h3>
               <p>
               <span class="definition">[Definition:&nbsp;</span><a id="dt-streaming-feature" title="streaming feature"></a>A processor that claims
                  conformance with the <b>streaming feature</b>
                  <span class="verb">must</span> use streamed processing in cases where (a) streaming is
                  requested (for example by using the attribute <code>streamable="yes"</code> on
                  <a href="#element-mode"><code>xsl:mode</code></a>, or on
                  the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction) and
                  (b) the constructs in question are <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>
                  according to this specification.<span class="definition">]</span>
            </p>
               <p>A processor that does not claim conformance with the streaming feature is not
               required to use streamed processing and is not required to determine whether any
               construct is guaranteed streamable. Such a processor must, however, implement the
               semantics of all constructs in the language provided that enough memory is available
               to perform the processing without streaming.</p>
               <p>A processor that conforms with the feature <span class="verb">must</span>
               return the value <code>"yes"</code> in response to the function call
                  <code>system-property('xsl:supports-streaming')</code>; a processor that does not
               conform with the feature <span class="verb">must</span> return the value
               <code>"no"</code>.</p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The term <em>streamed processing</em> as used here means the ability to
                  process arbitrarily large input documents without ever-increasing memory
                  requirements.</p>
               </div>
            </div>
         </div>
      </div>
      <div class="back">
         <div class="div1">
            
            <h2><a id="references"></a>A <a href="#references" style="text-decoration: none">References</a></h2>
            <div class="div2">
               
               <h3><a id="normative-references"></a>A.1 <a href="#normative-references" style="text-decoration: none">Normative References</a></h3>
               <dl>
                  <dt class="label"><span><a id="xpath-datamodel-40"></a>XDM 4.0</span></dt>
                  <dd>
                     <div>
                        <a href="../xpath-datamodel-40/Overview.html"><cite>XQuery and XPath Data Model (XDM) 4.0</cite></a>,
                        XSLT Extensions Community Group,
                        World Wide Web Consortium.</div>
                  </dd>
                  <dt class="label"><span><a id="xpath-functions-40"></a>Functions and Operators 4.0</span></dt>
                  <dd>
                     <div>
                        <em>CITATION: T.B.D.</em>
                        </div>
                  </dd>
                  <dt class="label"><span><a id="xml-infoset"></a>XML Information Set</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xml-infoset/"><cite>XML Information Set (Second Edition)</cite></a>, John Cowan and Richard Tobin, Editors. World Wide Web Consortium, 04&nbsp;Feb&nbsp;2004. This
                        version is http://www.w3.org/TR/2004/REC-xml-infoset-20040204. The <a href="http://www.w3.org/TR/xml-infoset">latest version</a> is available at http://www.w3.org/TR/xml-infoset.</div>
                  </dd>
                  <dt class="label"><span><a id="ISO15924"></a>ISO 15924</span></dt>
                  <dd>
                     <div>ISO (International Organization for
                        Standardization) <em>Information and documentation — Codes for the
                           representation of names of scripts</em> ISO 15924:2004, January 2004. See <a href="https://www.iso.org/obp/ui/#!iso:std:iso:15924:ed-1:v1:en">https://www.iso.org/obp/ui/#!iso:std:iso:15924:ed-1:v1:en</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="ISO15924_register"></a>ISO 15924 Register</span></dt>
                  <dd>
                     <div>Unicode Consortium. <em>Codes
                           for the representation of names of scripts — Alphabetical list of
                           four-letter script codes.</em> See <a href="http://www.unicode.org/iso15924/iso15924-codes.html">http://www.unicode.org/iso15924/iso15924-codes.html</a>. Retrieved
                        February 2013; continually updated.</div>
                  </dd>
                  <dt class="label"><span><a id="ISO21320"></a>ISO 21320</span></dt>
                  <dd>
                     <div>ISO (International Organization for
                        Standardization) <em>Information technology — Document Container File, Part 1: Core</em> 
                        ISO 21320-1:2015, October 2015. See <a href="https://www.iso.org/obp/ui/#iso:std:iso-iec:21320:-1:ed-1:v1:en">https://www.iso.org/obp/ui/#iso:std:iso-iec:21320:-1:ed-1:v1:en</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="xslt-xquery-serialization-40"></a>Serialization 4.0</span></dt>
                  <dd>
                     <div>
                        <a href="../xslt-xquery-serialization-40/Overview.html"><cite>XSLT and XQuery Serialization 4.0</cite></a>,
                        XSLT Extensions Community Group,
                        World Wide Web Consortium.</div>
                  </dd>
                  <dt class="label"><span><a id="rfc7595"></a>RFC 7595</span></dt>
                  <dd>
                     <div>IETF. <em>Guidelines and Registration Procedures for URI Schemes.</em>
                        June 2015. See <a href="http://www.ietf.org/rfc/rfc7595.txt">http://www.ietf.org/rfc/rfc7595.txt</a>
                        </div>
                  </dd>
                  <dt class="label"><span><a id="rfc7159"></a>RFC 7159</span></dt>
                  <dd>
                     <div>IETF. <em>The JavaScript Object Notation (JSON)
                           Data Interchange Format.</em>
                        March 2014. See <a href="http://www.ietf.org/rfc/rfc7159.txt">http://www.ietf.org/rfc/rfc7159.txt</a>
                        </div>
                  </dd>
                  <dt class="label"><span><a id="UNICODE"></a>UNICODE</span></dt>
                  <dd>
                     <div>Unicode Consortium. <em>The Unicode
                           Standard</em> as updated from time to time by the publication of new
                        versions. See <a href="http://www.unicode.org/standard/versions/">http://www.unicode.org/standard/versions/</a> for the
                        latest version and additional information on versions of the standard and of the
                        Unicode Character Database. The version of Unicode to be used is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but
                        implementations are recommended to use the latest Unicode version.</div>
                  </dd>
                  <dt class="label"><span><a id="UNICODE-TR10"></a>UNICODE TR10</span></dt>
                  <dd>
                     <div>Unicode Consortium. <em>Unicode
                           Technical Standard #10. Unicode Collation Algorithm</em>. Unicode Technical
                        Report. See <a href="http://www.unicode.org/reports/tr10/">http://www.unicode.org/reports/tr10/</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="UNICODE-TR35"></a>UNICODE TR35</span></dt>
                  <dd>
                     <div>Unicode Consortium. <em>Unicode
                           Technical Standard #35. Unicode Locale Data Markup Language</em>. Unicode
                        Technical Report. See <a href="http://www.unicode.org/reports/tr35/">http://www.unicode.org/reports/tr35/</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="REC-xml"></a>XML 1.0</span></dt>
                  <dd>
                     <div> World Wide Web Consortium. <em>Extensible Markup
                           Language (XML) 1.0. W3C Recommendation.</em> See <a href="https://www.w3.org/TR/REC-xml">http://www.w3.org/TR/REC-xml/</a>. The
                        edition of XML 1.0 must be no earlier than the Third Edition; the edition used is
                        <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>, but we recommend that
                        implementations use the latest version. </div>
                  </dd>
                  <dt class="label"><span><a id="xml11"></a>XML 1.1</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xml11/"><cite>Extensible Markup Language (XML) 1.1 (Second Edition)</cite></a>, Tim Bray, Jean Paoli, Michael Sperberg-McQueen, <em>et. al.</em>, Editors. World Wide Web Consortium, 16&nbsp;Aug&nbsp;2006. This version is http://www.w3.org/TR/2006/REC-xml11-20060816.
                        The <a href="http://www.w3.org/TR/xml11/">latest version</a> is available at http://www.w3.org/TR/xml11/.</div>
                  </dd>
                  <dt class="label"><span><a id="xmlbase"></a>XML Base</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xmlbase/"><cite>XML Base (Second Edition)</cite></a>, Jonathan Marsh and Richard Tobin, Editors. World Wide Web Consortium, 28&nbsp;Jan&nbsp;2009.
                        This version is http://www.w3.org/TR/2009/REC-xmlbase-20090128/. The <a href="http://www.w3.org/TR/xmlbase/">latest version</a> is available at http://www.w3.org/TR/xmlbase/.</div>
                  </dd>
                  <dt class="label"><span><a id="xml-id"></a>xml:id</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xml-id/"><cite>xml:id Version 1.0</cite></a>, Jonathan Marsh, Daniel Veillard, and Norman Walsh, Editors. World Wide Web Consortium,
                        09&nbsp;Sep&nbsp;2005. This version is http://www.w3.org/TR/2005/REC-xml-id-20050909/. The <a href="http://www.w3.org/TR/xml-id/">latest version</a> is available at http://www.w3.org/TR/xml-id/.</div>
                  </dd>
                  <dt class="label"><span><a id="xml-names"></a>Namespaces in XML</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xml-names/"><cite>Namespaces in XML 1.0 (Third Edition)</cite></a>, Tim Bray, Dave Hollander, Andrew Layman, <em>et. al.</em>, Editors. World Wide Web Consortium, 08&nbsp;Dec&nbsp;2009. This version is http://www.w3.org/TR/2009/REC-xml-names-20091208/.
                        The <a href="http://www.w3.org/TR/xml-names/">latest version</a> is available at http://www.w3.org/TR/xml-names/.</div>
                  </dd>
                  <dt class="label"><span><a id="xml-names11"></a>Namespaces in XML 1.1</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xml-names11/"><cite>Namespaces in XML 1.1 (Second Edition)</cite></a>, Tim Bray, Dave Hollander, Andrew Layman, and Richard Tobin, Editors. World Wide
                        Web Consortium, 16&nbsp;Aug&nbsp;2006. This version is http://www.w3.org/TR/2006/REC-xml-names11-20060816.
                        The <a href="http://www.w3.org/TR/xml-names11/">latest version</a> is available at http://www.w3.org/TR/xml-names11/.</div>
                  </dd>
                  <dt class="label"><span><a id="xmlschema-1"></a>XML Schema Part 1</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xmlschema-1/"><cite>XML Schema Part 1: Structures Second Edition</cite></a>, Henry Thompson, David Beech, Murray Maloney, and Noah Mendelsohn, Editors. World
                        Wide Web Consortium, 28&nbsp;Oct&nbsp;2004. This version is http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/.
                        The <a href="http://www.w3.org/TR/xmlschema-1/">latest version</a> is available at http://www.w3.org/TR/xmlschema-1/.</div>
                  </dd>
                  <dt class="label"><span><a id="xmlschema-2"></a>XML Schema Part 2</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xmlschema-2/"><cite>XML Schema Part 2: Datatypes Second Edition</cite></a>, Paul V. Biron and Ashok Malhotra, Editors. World Wide Web Consortium, 28&nbsp;Oct&nbsp;2004.
                        This version is http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/. The <a href="http://www.w3.org/TR/xmlschema-2/">latest version</a> is available at http://www.w3.org/TR/xmlschema-2/.</div>
                  </dd>
                  <dt class="label"><span><a id="xmlschema11-1"></a>XML Schema 1.1 Part 1</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xmlschema11-1/"><cite>W3C XML Schema Definition Language (XSD) 1.1 Part 1: Structures</cite></a>, Sandy Gao, Michael Sperberg-McQueen, Henry Thompson, <em>et. al.</em>, Editors. World Wide Web Consortium, 05&nbsp;Apr&nbsp;2012. This version is http://www.w3.org/TR/2012/REC-xmlschema11-1-20120405/.
                        The <a href="http://www.w3.org/TR/xmlschema11-1/">latest version</a> is available at http://www.w3.org/TR/xmlschema11-1/.</div>
                  </dd>
                  <dt class="label"><span><a id="xmlschema11-2"></a>XML Schema 1.1 Part 2</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xmlschema11-2/"><cite>W3C XML Schema Definition Language (XSD) 1.1 Part 2: Datatypes</cite></a>, David Peterson, Sandy Gao, Ashok Malhotra, <em>et. al.</em>, Editors. World Wide Web Consortium, 05&nbsp;Apr&nbsp;2012. This version is http://www.w3.org/TR/2012/REC-xmlschema11-2-20120405/.
                        The <a href="http://www.w3.org/TR/xmlschema11-2/">latest version</a> is available at http://www.w3.org/TR/xmlschema11-2/.</div>
                  </dd>
                  <dt class="label"><span><a id="xpath-40"></a>XPath 4.0</span></dt>
                  <dd>
                     <div>
                        <em>CITATION: T.B.D.</em>
                        </div>
                  </dd>
                  <dt class="label"><span><a id="XSLT-Mime-Type"></a>XSLT Media Type</span></dt>
                  <dd>
                     <div>World Wide Web Consortium.
                        <em>Registration of MIME Media Type application/xslt+xml</em>. In <a href="https://www.w3.org/TR/2007/REC-xslt20-20070123/#media-type-registration">Appendix B.1 of the XSLT 2.0 specification.</a></div>
                  </dd>
                  <dt class="label"><span><a id="xslt40streaming"></a>XSLT 4.0 Streaming</span></dt>
                  <dd>
                     <div><span class="markup-error">ERROR: NO xslt40streaming KNOWN!</span></div>
                  </dd>
               </dl>
            </div>
            <div class="div2">
               
               <h3><a id="other-references"></a>A.2 <a href="#other-references" style="text-decoration: none">Other References</a></h3>
               <dl>
                  <dt class="label"><span><a id="CLDR"></a>Unicode CLDR</span></dt>
                  <dd>
                     <div>CLDR - Unicode Common Locale Data Repository.
                        Available at: <a href="http://cldr.unicode.org">http://cldr.unicode.org</a></div>
                  </dd>
                  <dt class="label"><span><a id="DOM-Level-2-Core"></a>DOM Level 2</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/DOM-Level-2-Core/"><cite>Document Object Model (DOM) Level 2 Core Specification</cite></a>, Arnaud Le Hors, Philippe Le Hégaret, Lauren Wood, <em>et. al.</em>, Editors. World Wide Web Consortium, 13&nbsp;Nov&nbsp;2000. This version is http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113.
                        The <a href="http://www.w3.org/TR/DOM-Level-2-Core/">latest version</a> is available at http://www.w3.org/TR/DOM-Level-2-Core/.</div>
                  </dd>
                  <dt class="label"><span><a id="ECMA-404"></a>ECMA-404</span></dt>
                  <dd>
                     <div> ECMA International. <em>The JSON Data
                           Interchange Format</em> October 2013. See <a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf">http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf</a>. </div>
                  </dd>
                  <dt class="label"><span><a id="ICU"></a>ICU</span></dt>
                  <dd>
                     <div>ICU - International Components for Unicode. Available at
                        <a href="http://site.icu-project.org">http://site.icu-project.org</a>
                        </div>
                  </dd>
                  <dt class="label"><span><a id="rfc2119"></a>RFC2119</span></dt>
                  <dd>
                     <div>S. Bradner. <em>Key words for use in RFCs to
                           Indicate Requirement Levels</em>. IETF RFC 2119. See <a href="http://www.ietf.org/rfc/rfc2119.txt">http://www.ietf.org/rfc/rfc2119.txt</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="RFC3986"></a>RFC3986</span></dt>
                  <dd>
                     <div> T. Berners-Lee, R. Fielding, and L. Masinter.
                        <em>Uniform Resource Identifiers (URI): Generic Syntax</em>. IETF RFC 3986.
                        See <a href="http://www.ietf.org/rfc/rfc3986.txt">http://www.ietf.org/rfc/rfc3986.txt</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="RFC3987"></a>RFC3987</span></dt>
                  <dd>
                     <div>M. Duerst, M. Suignard. <em>Internationalized
                           Resource Identifiers (IRIs)</em>. IETF RFC 3987. See <a href="http://www.ietf.org/rfc/rfc3987.txt">http://www.ietf.org/rfc/rfc3987.txt</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="RFC4647"></a>RFC4647</span></dt>
                  <dd>
                     <div>A. Phillips and M. Davis. <em>Matching of Language Tags</em>. IETF RFC 4647. See <a href="http://www.ietf.org/rfc/rfc4647.txt">http://www.ietf.org/rfc/rfc4647.txt</a>.</div>
                  </dd>
                  <dt class="label"><span><a id="rfc7303"></a>RFC7303</span></dt>
                  <dd>
                     <div>H. Thompson and C. Lilley. <em>XML Media
                           Types</em>. IETF RFC 7303. See <a href="http://www.ietf.org/rfc/rfc7303.txt">http://www.ietf.org/rfc/rfc7303.txt</a></div>
                  </dd>
                  <dt class="label"><span><a id="SemVer"></a>SemVer</span></dt>
                  <dd>
                     <div>Tom Preston-Werner, <em>Semantic Versioning
                           2.0.0</em>. See <a href="http://semver.org/">http://semver.org/</a>. Undated (retrieved 1 August
                        2014).</div>
                  </dd>
                  <dt class="label"><span><a id="STX"></a>STX</span></dt>
                  <dd>
                     <div>Petr Cimprich <em>et al</em>, <em>Streaming
                           Transformations for XML (STX) Version 1.0</em>. Working Draft 27 April 2007.
                        See <a href="http://stx.sourceforge.net/documents/spec-stx-20070427.html">http://stx.sourceforge.net/documents/spec-stx-20070427.html</a>
                        </div>
                  </dd>
                  <dt class="label"><span><a id="xlink"></a>XLink</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xlink/"><cite>XML Linking Language (XLink) Version 1.0</cite></a>, Steven DeRose, Eve Maler, and David Orchard, Editors. World Wide Web Consortium,
                        27&nbsp;Jun&nbsp;2001. This version is http://www.w3.org/TR/2001/REC-xlink-20010627/. The <a href="http://www.w3.org/TR/xlink/">latest version</a> is available at http://www.w3.org/TR/xlink/.</div>
                  </dd>
                  <dt class="label"><span><a id="SCHEMA-AND-XML-1.1"></a>XML Schema 1.0 and XML 1.1</span></dt>
                  <dd>
                     <div>World Wide Web
                        Consortium. <em>Processing XML 1.1 documents with XML Schema 1.0
                           processors</em>. W3C Working Group Note 11 May 2005. See <a href="https://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/">https://www.w3.org/TR/2005/NOTE-xml11schema10-20050511/</a>
                        </div>
                  </dd>
                  <dt class="label"><span><a id="xml-stylesheet"></a>XML Stylesheet</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xml-stylesheet"><cite>Associating Style Sheets with XML documents 1.0 (Second Edition)</cite></a>, James Clark, Simon Pieters, and Henry Thompson, Editors. World Wide Web Consortium,
                        28&nbsp;Oct&nbsp;2010. This version is http://www.w3.org/TR/2010/REC-xml-stylesheet-20101028.
                        The <a href="http://www.w3.org/TR/xml-stylesheet">latest version</a> is available at http://www.w3.org/TR/xml-stylesheet.</div>
                  </dd>
                  <dt class="label"><span><a id="xptr-framework"></a>XPointer Framework</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xptr-framework/"><cite>XPointer Framework</cite></a>, Paul Grosso, Eve Maler, Jonathan Marsh, and Norman Walsh, Editors. World Wide Web
                        Consortium, 25&nbsp;Mar&nbsp;2003. This version is http://www.w3.org/TR/2003/REC-xptr-framework-20030325/.
                        The <a href="http://www.w3.org/TR/xptr-framework/">latest version</a> is available at http://www.w3.org/TR/xptr-framework/.</div>
                  </dd>
                  <dt class="label"><span><a id="xsl11"></a>XSL-FO</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xsl11/"><cite>Extensible Stylesheet Language (XSL) Version 1.1</cite></a>, Anders Berglund, Editor. World Wide Web Consortium, 05&nbsp;Dec&nbsp;2006. This version is
                        http://www.w3.org/TR/2006/REC-xsl11-20061205/. The <a href="http://www.w3.org/TR/xsl11/">latest version</a> is available at http://www.w3.org/TR/xsl11/.</div>
                  </dd>
                  <dt class="label"><span><a id="xslt"></a>XSLT 1.0</span></dt>
                  <dd>
                     <div>
                        <a href="http://www.w3.org/TR/xslt"><cite>XSL Transformations (XSLT) Version 1.0</cite></a>, James Clark, Editor. World Wide Web Consortium, 16&nbsp;Nov&nbsp;1999. This version is http://www.w3.org/TR/1999/REC-xslt-19991116.
                        The <a href="http://www.w3.org/TR/xslt">latest version</a> is available at http://www.w3.org/TR/xslt.</div>
                  </dd>
                  <dt class="label"><span><a id="xslt20"></a>XSLT 2.0</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xslt20/"><cite>XSL Transformations (XSLT) Version 2.0 (Second Edition)</cite></a>,
                        Michael Kay, Editor.
                        World Wide Web Consortium,
                        23 January 2007.
                        This version is https://www.w3.org/TR/2007/REC-xslt20-20070123/.
                        The <a href="https://www.w3.org/TR/xslt20/">latest version</a>
                        is available at https://www.w3.org/TR/xslt20/.</div>
                  </dd>
                  <dt class="label"><span><a id="xslt-30"></a>XSLT 3.0</span></dt>
                  <dd>
                     <div>
                        <a href="https://www.w3.org/TR/xslt-30/"><cite>XSL Transformations (XSLT) Version 3.0</cite></a>,
                        Michael Kay, Editor.
                        World Wide Web Consortium,
                        7 February 2017. 
                        This version is https://www.w3.org/TR/2017/CR-xslt-30-20170207/.
                        The <a href="https://www.w3.org/TR/xslt-30/">latest version</a>
                        is available at https://www.w3.org/TR/xslt-30/.</div>
                  </dd>
               </dl>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="glossary"></a>B <a href="#glossary" style="text-decoration: none">Glossary</a> (Non-Normative)</h2>
            <dl>
               <dt><a href="#dt-sequence-comparator"></a></dt>
               <dd>
                  <p>A <b>sequence
                           comparator</b> is an expression that evaluates two sequences of items
                        and results in a true or false value. </p>
               </dd>
               <dt><a href="#dt-absent">absent</a></dt>
               <dd>
                  <p>A component of the context
                     that has no value is said to be <b>absent</b>.</p>
               </dd>
               <dt><a href="#dt-accumulator">accumulator</a></dt>
               <dd>
                  <p>An
                     <b>accumulator</b> defines a series of
                     values associated with the nodes of the tree. If an accumulator is
                  applicable to a particular tree, then for each node in the tree, other than
                  attribute and namespace nodes, there will be two values available, called the
                  pre-descent and post-descent values. These two values are available via a pair of
                  functions, <a href="#func-accumulator-before"><code>accumulator-before</code></a> and
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a>.</p>
               </dd>
               <dt><a href="#dt-accumulator-function">accumulator function</a></dt>
               <dd>
                  <p>The functions
                        <a href="#func-accumulator-before"><code>accumulator-before</code></a> and
                        <a href="#func-accumulator-after"><code>accumulator-after</code></a> are referred to as the
                        <b>accumulator functions</b>.</p>
               </dd>
               <dt><a href="#dt-alias">alias</a></dt>
               <dd>
                  <p>A stylesheet can use the
                        <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element to declare that a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is being used
                     as an <b>alias</b> for a <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target
                        namespace URI</a>.</p>
               </dd>
               <dt><a href="#dt-applicable">applicable</a></dt>
               <dd>
                  <p>A <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is <b>applicable</b> to one or more modes.
                     The modes to which it is applicable are defined by the <code>mode</code>
                     attribute of the <a href="#element-template"><code>xsl:template</code></a> element. If the attribute is
                     omitted, then the template rule is applicable to the <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> 
                  specified in the <code>[xsl:]default-mode</code> attribute of the innermost containing
                           element that has such an attribute, which in turn defaults to
                        the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>. If the
                        <code>mode</code> attribute is present, then its value
                        <span class="verb">must</span> be a non-empty whitespace-separated list of tokens,
                     each of which defines a mode to which the template rule is
                     applicable.</p>
               </dd>
               <dt><a href="#dt-applicable-static-namespaces">applicable static namespaces</a></dt>
               <dd>
                  <p>
               The <b>applicable static namespaces</b> for an element in a stylesheet module are the
               <a title="fixed namespace bindings" class="termref" href="#dt-fixed-namespace-bindings">fixed namespace bindings</a> for the module if the root element
               of the module has a <code>fixed-namespaces</code> attribute, or the <a title="native namespace bindings" class="termref" href="#dt-native-namespace-bindings">native namespace bindings</a>
               of the element otherwise.
            </p>
               </dd>
               <dt><a href="#dt-arity-range">arity range</a></dt>
               <dd>
                  <p>A <a title="function definition" class="termref" href="#dt-function-definition">function definition</a>
                        has an <b>arity range</b>, which defines the minimum and maximum number of arguments
                        that must be supplied in a call to the function. The static context can contain multiple
                        <a title="function definition" class="termref" href="#dt-function-definition">function definitions</a> with the same name, 
                        provided that their <b>arity ranges</b> do not overlap.</p>
               </dd>
               <dt><a href="#dt-atomization">atomize</a></dt>
               <dd>
                  <p>The term <b>atomization</b>
                        is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-atomization">2.6.3 Atomization</a>. It is a process that takes as input a sequence of
                        items, and returns a sequence of
                        atomic items, in which the nodes are replaced by their typed values as
                        defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>. 
                         Arrays (see <a href="#arrays"><i>22 Arrays</i></a>) are atomized by atomizing their
                        members, recursively.</p>
               </dd>
               <dt><a href="#dt-attribute-set">attribute set</a></dt>
               <dd>
                  <p>An <b>attribute set</b> is
                  defined as a set of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declarations in the same
                     <a title="package" class="termref" href="#dt-package">package</a> that share the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p>
               </dd>
               <dt><a href="#dt-attribute-set-invocation">attribute set invocation</a></dt>
               <dd>
                  <p>An
                              <b>attribute set invocation</b> is a pseudo-instruction
                           corresponding to a single EQName appearing within an
                              <code>[xsl:]use-attribute-sets</code> attribute; the effect of the
                           pseudo-instruction is to cause the referenced <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a> to be evaluated.</p>
               </dd>
               <dt><a href="#dt-attribute-value-template">attribute value template</a></dt>
               <dd>
                  <p>In an
                     attribute that is designated as an <b>attribute value template</b>, such
                     as an attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result
                        element</a>, an <a title="expression" class="termref" href="#dt-expression">expression</a> can
                     be used by surrounding the expression with curly brackets (<code>{}</code>),
                     following the general rules for <a title="value template" class="termref" href="#dt-value-template">value
                        templates</a></p>
               </dd>
               <dt><a href="#dt-backwards-compatible-behavior">backwards compatible behavior</a></dt>
               <dd>
                  <p>An element is 
                  processed with <b>backwards compatible behavior</b> if its
                     <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is less than
                  <span>4.0</span>.</p>
               </dd>
               <dt><a href="#dt-base-output-uri">base output URI</a></dt>
               <dd>
                  <p> The <b>base output URI</b> is a URI to be used as the base URI when
                     resolving a relative URI reference allocated
                     to a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>. If the
                     transformation generates more than one final result tree, then typically each
                     one will be allocated a URI relative to this base URI.</p>
               </dd>
               <dt><a href="#dt-basic-xslt-processor">basic XSLT processor</a></dt>
               <dd>
                  <p>A <b>basic XSLT
                     processor</b> is an XSLT processor that implements all the mandatory
                  requirements of this specification with the exception of constructs explicitly
                  associated with an optional feature.</p>
               </dd>
               <dt><a href="#dt-character-map">character map</a></dt>
               <dd>
                  <p>A <b>character map</b>
                  allows a specific character appearing in a text or attribute node in the <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to be substituted by a
                  specified string of characters during serialization.</p>
               </dd>
               <dt><a href="#dt-circularity">circularity</a></dt>
               <dd>
                  <p>A <b>circularity</b> is said to
                  exist if a construct such as a <a title="global variable" class="termref" href="#dt-global-variable">global
                     variable</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>,
                  or a <a title="key" class="termref" href="#dt-key">key</a>, cannot be evaluated without reference to its own value. For
                  example, if the <a title="expression" class="termref" href="#dt-expression">expression</a> or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> specifying the
                  value of a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>
                  <var>X</var> references a global variable <var>Y</var>, then the value for
                     <var>Y</var>
                  <span class="verb">must</span> be computed before the value of <var>X</var>. A
                  circularity exists if it is impossible to do this for all global variable
                  definitions.</p>
               </dd>
               <dt><a href="#dt-coercion-rules">coercion rules</a></dt>
               <dd>
                  <p> The term <b>coercion rules</b> 
                  means the coercion rules defined in <a href="#xpath-40">[XPath 4.0]</a>, applied 
                  unless otherwise specified with XPath 1.0 
                  compatibility mode set to <code>false</code>.</p>
               </dd>
               <dt><a href="#dt-collation">collation</a></dt>
               <dd>
                  <p>Facilities in XSLT 3.0 and XPath 3.0 that
                     require strings to be ordered rely on the concept of a named
                        <b>collation</b>. A collation is a set of rules that determine whether
                     two strings are equal, and if not, which of them is to be sorted before the
                     other.</p>
               </dd>
               <dt><a href="#dt-combined-merge-key-value">combined merge key value</a></dt>
               <dd>
                  <p> The
                  ordered collection of <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key values</a>
                  computed for one item in a <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input
                     sequence</a> (one for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge
                     key component</a> within the 
                     <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>) 
                     is referred to as a <b>combined merge key value</b>.</p>
               </dd>
               <dt><a href="#dt-compatible">compatible</a></dt>
               <dd>
                  <p>The signatures of two <a title="component" class="termref" href="#dt-component">components</a> are <b>compatible</b> if
                        they present the same interface to the user of the component. The additional
                        rules depend on the kind of component.</p>
               </dd>
               <dt><a href="#dt-component">component</a></dt>
               <dd>
                  <p>The term <b>component</b> is
                     used to refer to any of the following: a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, a <a title="named template" class="termref" href="#dt-named-template">named
                        template</a>, a <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="accumulator function" class="termref" href="#dt-accumulator-function">accumulator</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, <a title="global variable" class="termref" href="#dt-global-variable">global variable</a>, or a <a title="mode" class="termref" href="#dt-mode">mode</a>.</p>
               </dd>
               <dt><a href="#dt-containing-package">containing package</a></dt>
               <dd>
                  <p>A
                     component declaration results in multiple components, one in the package in
                     which the declaration appears, and potentially one in each package that uses
                     the declaring package, directly or indirectly, subject to the visibility of the
                     component. Each of these multiple components has the same <a title="declaring package" class="termref" href="#dt-declaring-package">declaring package</a>, but each has a different <b>containing
                        package</b>. For the original component, the declaring package and the
                     containing package are the same; for a copy of a component made as a result of
                     an <a href="#element-use-package"><code>xsl:use-package</code></a> declaration, the declaring package will be
                     the original package, and the containing package will be the package in which
                     the <a href="#element-use-package"><code>xsl:use-package</code></a> declaration appears.</p>
               </dd>
               <dt><a href="#dt-context-item">context item</a></dt>
               <dd>
                  <p>The <b>context
                                 item</b> is the item currently being processed. An item (see
                                 <a href="#xpath-datamodel-40">[XDM 4.0]</a>) is either an atomic item (such
                              as an integer, date, or string), a node, or
                                 a function item. It changes whenever instructions such as
                                 <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and
                                 <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of
                              items; each item in such a sequence becomes the context item while
                              that item is being processed.</p>
               </dd>
               <dt><a href="#dt-context-node">context node</a></dt>
               <dd>
                  <p>If the <a title="context item" class="termref" href="#dt-context-item">context item</a> is a node (as distinct from
                        an atomic item such as an integer), then it is also referred to as the
                           <b>context node</b>. The context node is not an independent
                        variable, it changes whenever the context item changes. When the context
                        item is an atomic item or a function
                           item, there is no context node.</p>
               </dd>
               <dt><a href="#dt-context-position">context position</a></dt>
               <dd>
                  <p>The
                                 <b>context position</b> is the position of the context item
                              within the sequence of items currently being processed. It changes
                              whenever the context item changes. When an instruction such as
                                 <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> or
                                 <a href="#element-for-each"><code>xsl:for-each</code></a> is used to process a sequence of
                              items, the first item in the sequence is processed with a context
                              position of 1, the second item with a context position of 2, and so
                              on.</p>
               </dd>
               <dt><a href="#dt-context-size">context size</a></dt>
               <dd>
                  <p>The <b>context
                                 size</b> is the number of items in the sequence of items
                              currently being processed. It changes whenever instructions such as
                                 <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> and
                                 <a href="#element-for-each"><code>xsl:for-each</code></a> are used to process a sequence of
                              items; during the processing of each one of those items, the context
                              size is set to the count of the number of items in the sequence (or
                              equivalently, the position of the last item in the
                              sequence).</p>
               </dd>
               <dt><a href="#dt-current-captured-groups">current captured groups</a></dt>
               <dd>
                  <p>While
               the <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> instruction is active, a set of
                  <b>current captured groups</b> is available, corresponding to the
               capturing subexpressions of the regular expression.</p>
               </dd>
               <dt><a href="#dt-current-group">current group</a></dt>
               <dd>
                  <p>The <b>current
                           group</b> is the <a title="group" class="termref" href="#dt-group">group</a> itself, as a
                        sequence of items</p>
               </dd>
               <dt><a href="#dt-current-grouping-key">current grouping key</a></dt>
               <dd>
                  <p>The
                           <b>current grouping key</b> is a single atomic item, or in the
                        case of a composite key, a sequence of atomic items, containing the
                           <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of the items in the <a title="current group" class="termref" href="#dt-current-group">current group</a>.</p>
               </dd>
               <dt><a href="#dt-current-merge-group">current merge group</a></dt>
               <dd>
                  <p>The
                           <b>current merge group</b> is a map. During
                        evaluation of an <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of
                        items with equal <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge
                           key values</a> is processed, the current merge group is set to a
                        map whose keys are the names of the various merge sources, and whose
                        associated values are the items from each merge source having the relevant
                        composite merge key value.</p>
               </dd>
               <dt><a href="#dt-current-merge-key">current merge key</a></dt>
               <dd>
                  <p>The <b>current
                           merge key</b> is a an array, whose members are sequences of atomic items.
                     There is one member in the array for each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element
                     in the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>.
                     During evaluation of an
                           <a href="#element-merge"><code>xsl:merge</code></a> instruction, as each group of items with equal
                           <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key
                           values</a> is processed, the current merge key is set to the
                        combined merge key value that these items have in common.</p>
               </dd>
               <dt><a href="#dt-current-mode">current mode</a></dt>
               <dd>
                  <p>At any point in the processing
                     of a stylesheet, there is a <b>current mode</b>. When the transformation
                     is initiated, the current mode is the <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>, as described in <a href="#initiating"><i>2.3 Initiating a Transformation</i></a>. Whenever an <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                     instruction is evaluated, the current mode becomes the mode selected by this
                     instruction.</p>
               </dd>
               <dt><a href="#dt-current-output-uri">current output URI</a></dt>
               <dd>
                  <p>The <b>current output URI</b> is the URI
                  associated with the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a> that is currently being written.</p>
               </dd>
               <dt><a href="#dt-current-template-rule">current template rule</a></dt>
               <dd>
                  <p>At any point in
                  the processing of a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, there may
                  be a <b>current template rule</b>. Whenever a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> is chosen as a result of
                  evaluating <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>,
                     <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, or <a href="#element-next-match"><code>xsl:next-match</code></a>, the
                  template rule becomes the current template rule for the evaluation of the rule’s
                  sequence constructor.</p>
               </dd>
               <dt><a href="#dt-decimal-format">decimal format</a></dt>
               <dd>
                  <p>All the
                  <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations in a package that share the same name are grouped into a named
                  <b>decimal format</b>; those that have no name are grouped into a single
                  unnamed decimal format.</p>
               </dd>
               <dt><a href="#dt-declaration">declaration</a></dt>
               <dd>
                  <p>Top-level elements fall into two
                  categories: declarations, and user-defined data elements. Top-level elements whose
                  names are in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> are
                     <b>declarations</b>. Top-level elements in any other namespace are
                     <a title="user-defined data element" class="termref" href="#dt-data-element">user-defined data elements</a> (see
                     <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)</p>
               </dd>
               <dt><a href="#dt-declaration-order">declaration order</a></dt>
               <dd>
                  <p>The <a title="declaration" class="termref" href="#dt-declaration">declarations</a> within a <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> have a total ordering
                     known as <b>declaration order</b>. The order of declarations within a
                     stylesheet level is the same as the document order that would result if each
                     stylesheet module were inserted textually in place of the
                        <a href="#element-include"><code>xsl:include</code></a> element that references it.</p>
               </dd>
               <dt><a href="#dt-declaring-package">declaring package</a></dt>
               <dd>
                  <p>The <b>declaring
                        package</b> of a <a title="component" class="termref" href="#dt-component">component</a> is the
                     package that contains the declaration (or,
                        in the case of <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> and
                           <a href="#element-key"><code>xsl:key</code></a>, multiple declarations) of the
                     component.</p>
               </dd>
               <dt><a href="#dt-default-collation">default collation</a></dt>
               <dd>
                  <p>In this
                              specification the term <b>default collation</b> means the collation
                              that is used by XPath operators such as <code>eq</code> and
                              <code>lt</code> appearing in XPath expressions within the
                              stylesheet.</p>
               </dd>
               <dt><a href="#dt-default-mode">default mode</a></dt>
               <dd>
                  <p>The 
                  <code>[xsl:]default-mode</code> attribute defines the <b>default mode</b>,
                  which is used as the default value for the
                     <a title="mode" class="termref" href="#dt-mode">mode</a> attribute of all
                     <a href="#element-template"><code>xsl:template</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> elements
                     within its scope.</p>
               </dd>
               <dt><a href="#dt-default-priority">default priority</a></dt>
               <dd>
                  <p>If no <code>priority</code>
                  attribute is specified on an <a href="#element-template"><code>xsl:template</code></a> element, a
                     <b>default priority</b> is computed, based on the syntactic form of 
                  the <a title="pattern" class="termref" href="#dt-pattern">pattern</a> 
               supplied in the <code>match</code> attribute.</p>
               </dd>
               <dt><a href="#dt-defining-element">defining element</a></dt>
               <dd>
                  <p>A string in the
                           form of a lexical QName may occur as the value of an attribute node in a
                           stylesheet module, or within an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in an attribute or text node within a stylesheet module, or as the
                           result of evaluating an XPath expression contained in such a node. The
                           element containing this attribute or
                              text node is referred to as the <b>defining element</b>
                           of the lexical QName.</p>
               </dd>
               <dt><a href="#dt-deprecated">deprecated</a></dt>
               <dd>
                  <p>Some constructs defined in this
                  specification are described as being <b>deprecated</b>. The use of this term
                  implies that stylesheet authors <span class="verb">should not</span> use the construct,
                  and that the construct may be removed in a later version of this
                  specification.</p>
               </dd>
               <dt><a href="#dt-disqualifying-element">disqualifying element</a></dt>
               <dd>
                  <p>The <b>disqualifying elements</b>
            are <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, 
            <a href="#element-array-member"><code>xsl:array-member</code></a>, <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>. If a sequence
            constructor includes one of these elements, then construction of the implicit document node does
            not take place.</p>
               </dd>
               <dt><a href="#dt-dynamic-error">dynamic error</a></dt>
               <dd>
                  <p>An error that is not 
                  capable of detection
                  until a source document is being transformed is referred to as a <b>dynamic
                     error</b>.</p>
               </dd>
               <dt><a href="#dt-eclipsed">eclipsed</a></dt>
               <dd>
                  <p>An <a href="#element-function"><code>xsl:function</code></a> declaration
                     <var>F</var> is said to be <b>eclipsed</b> if the containing package includes 
                     an <a href="#element-function"><code>xsl:function</code></a> declaration
                     <var>G</var> such that <var>F</var> and <var>G</var> have the same name, <var>F</var> has lower
                     <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                     of <var>G</var> includes the totality of the arity range of <var>F</var>.</p>
               </dd>
               <dt><a href="#dt-effective-value">effective value</a></dt>
               <dd>
                  <p>The <b>effective value</b>
            of an attribute or text node in the stylesheet is the value after any required expansion or normalization.</p>
               </dd>
               <dt><a href="#dt-effective-version">effective version</a></dt>
               <dd>
                  <p>The <b>effective
                     version</b> of an element in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> or <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> is the decimal value of the <code>[xsl:]version</code> attribute
                  (see <a href="#standard-attributes"><i>3.3 Standard Attributes</i></a>) on that element or on the innermost
                  ancestor element that has such an attribute, <span>subject
                  to special rules for the <a href="#element-output"><code>xsl:output</code></a> and <a href="#element-fallback"><code>xsl:fallback</code></a>
                     elements.</span></p>
               </dd>
               <dt><a href="#dt-embedded-stylesheet-module">embedded stylesheet module</a></dt>
               <dd>
                  <p>A stylesheet module whose outermost element is
                  the child of a non-XSLT element in a host document is referred to as an
                     <b>embedded stylesheet module</b>.</p>
               </dd>
               <dt><a href="#dt-enclosing-mode">enclosing mode</a></dt>
               <dd>
                  <p>A mode declared by
                  an <a href="#element-mode"><code>xsl:mode</code></a> declaration that has one or more contained <a href="#element-template"><code>xsl:template</code></a>
                  declarations is referred to as an <b>enclosing mode</b>.</p>
               </dd>
               <dt><a href="#dt-eqname">EQName</a></dt>
               <dd>
                  <p>An <b>EQName</b> is a string
                     representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> where
                     the string, after removing leading and trailing whitespace, is in the form
                     defined by the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>
                     production in the XPath specification.</p>
               </dd>
               <dt><a href="#dt-expanded-qname">expanded QName</a></dt>
               <dd>
                  <p>An <b>expanded
                        QName</b> is a value in the value space of the <code>xs:QName</code>
                     datatype as defined in the XDM data model (see <a href="#xpath-datamodel-40">[XDM 4.0]</a>): that is, a triple containing namespace prefix (optional), namespace URI
                     (optional), and local name. Two expanded QNames are equal if the namespace URIs
                     are the same (or both absent) and the local names are the same. The prefix
                     plays no part in the comparison, but is used only if the expanded QName needs
                     to be converted back to a string.</p>
               </dd>
               <dt><a href="#dt-explicit-default">explicit default</a></dt>
               <dd>
                  <p>An <b>explicit
                        default</b> for a parameter is indicated by the presence of either a
                        <code>select</code> attribute or a non-empty sequence
                  constructor.</p>
               </dd>
               <dt><a href="#dt-explicitly-mandatory">explicitly mandatory</a></dt>
               <dd>
                  <p>A parameter is
                        <b>explicitly mandatory</b> if it is a 
                  <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a> 
                  <span>with no <code>required</code> attribute</span>, or if the
                        <code>required</code> attribute is present and has the value
                        <code>yes</code>.</p>
               </dd>
               <dt><a href="#dt-expression">expression</a></dt>
               <dd>
                  <p>Within this specification, the term
                     <b>XPath expression</b>, or simply <b>expression</b>, means a
                  string that matches the production <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup> 
                  defined in <a href="#xpath-40">[XPath 4.0]</a>.</p>
               </dd>
               <dt><a href="#dt-extension-attribute">extension attribute</a></dt>
               <dd>
                  <p>An <b>extension attribute</b>
               is an attribute appearing on an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>, where the name
               of the attribute is in a non-null namespace other than the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>.</p>
               </dd>
               <dt><a href="#dt-extension-function">extension function</a></dt>
               <dd>
                  <p>An <b>extension
               function</b> is a named function introduced to the static or dynamic context 
               by mechanisms outside the scope of this specification.</p>
               </dd>
               <dt><a href="#dt-extension-instruction">extension instruction</a></dt>
               <dd>
                  <p>An <b>extension
                  instruction</b> is an element within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> that is in a namespace (not the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>) designated as an extension
               namespace.</p>
               </dd>
               <dt><a href="#dt-extension-namespace">extension namespace</a></dt>
               <dd>
                  <p>The <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> mechanism allows
                  namespaces to be designated as <b>extension namespaces</b>. When a namespace
                  is designated as an extension namespace and an element with a name from that
                  namespace occurs in a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                     constructor</a>, then the element is treated as an <a title="instruction" class="termref" href="#dt-instruction">instruction</a> rather than as a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p>
               </dd>
               <dt><a href="#dt-final-output-state">final output state</a></dt>
               <dd>
                  <p>The first of the two
                     <a title="output state" class="termref" href="#dt-output-state">output states</a> is called <b>final
                     output</b> state. This state applies when instructions are writing to a
                     <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a>.</p>
               </dd>
               <dt><a href="#dt-final-result-tree">final result tree</a></dt>
               <dd>
                  <p>A <b>final result
                     tree</b> is a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> that forms
                  part of the output of a transformation: specifically, a tree built by post-processing the items in the <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or in a <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>. Once created, the contents of a final result tree are not
                  accessible within the stylesheet itself.</p>
               </dd>
               <dt><a href="#dt-fixed-namespace-bindings">fixed namespace bindings</a></dt>
               <dd>
                  <p>
                     The <b>fixed namespace bindings</b> for a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> are
                     established using the <code>fixed-namespaces</code> attribute on the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>,
                     <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a> element enclosing the stylesheet
                     module.</p>
               </dd>
               <dt><a href="#dt-focus">focus</a></dt>
               <dd>
                  <p>When a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is
                        evaluated, the <a title="processor" class="termref" href="#dt-processor">processor</a> keeps track
                        of which items are being processed by means of a set of implicit variables
                        referred to collectively as the <b>focus</b>.</p>
               </dd>
               <dt><a href="#dt-forwards-compatible-behavior">forwards compatible behavior</a></dt>
               <dd>
                  <p>An
                  element is processed with <b>forwards compatible behavior</b> if its
                     <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is greater than
                     <span>4.0</span>.</p>
               </dd>
               <dt><a href="#dt-function-definition">function definition</a></dt>
               <dd>
                  <p>The term
                        <b>function definition</b> is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. 
                        It is the definition of a function that can be called statically from within an XPath
                        expression: in the case of XSLT it typically means either a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>,
                        or a built-in function such as those defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a></p>
               </dd>
               <dt><a href="#dt-function-parameter">function parameter</a></dt>
               <dd>
                  <p> An
                           <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an
                           <a href="#element-function"><code>xsl:function</code></a> element, before any
                           non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
                        is known as a <b>function parameter</b>. A function parameter is a
                           <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the
                        additional property that its value can be set when the function is called,
                        using a function call in an XPath <a title="expression" class="termref" href="#dt-expression">expression</a>.</p>
               </dd>
               <dt><a href="#dt-global-context-item">global context item</a></dt>
               <dd>
                  <p>An item that is the <b>global
                                 context item</b> for the transformation acts
                           as the <a title="context item" class="termref" href="#dt-context-item">context item</a> when evaluating
                            the <code>select</code> expression or <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of a
                                 <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> <span>whose declaration is</span>
                           within the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, as described in <a href="#focus"><i>5.3.3.1 Maintaining Position: the Focus</i></a>. The global context item may also be available in a <a title="named template" class="termref" href="#dt-named-template">named template</a>
                        when the stylesheet is invoked as described in <a href="#invoking-initial-template"><i>2.3.4 Call-Template Invocation</i></a></p>
               </dd>
               <dt><a href="#dt-global-variable">global variable</a></dt>
               <dd>
                  <p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a> <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> declares a
                     <b>global variable</b> that is visible everywhere 
                  except within any region where it is <a title="shadows" class="termref" href="#dt-shadows">shadowed</a> 
                     by another variable binding.</p>
               </dd>
               <dt><a href="#dt-gnode-pattern">GNode pattern</a></dt>
               <dd>
                  <p>An <b>GNode pattern</b> uses a subset of
                        the syntax for path expressions, and is defined to match a GNode if the
                        corresponding path expression would select the GNode.</p>
               </dd>
               <dt><a href="#dt-group">group</a></dt>
               <dd>
                  <p>The <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
                  instruction allocates the items in an input sequence into <b>groups</b> of
                  items (that is, it establishes a collection of sequences) based either on common
                  values of a grouping key, or on a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that
                  the initial or final item in a group must
                  match.</p>
               </dd>
               <dt><a href="#dt-grouping-key">grouping key</a></dt>
               <dd>
                  <p>If the
                     <code>group-by</code> or <code>group-adjacent</code> attributes is present,
                  then for each item in the <a title="population" class="termref" href="#dt-population">population</a> a set
                  of <b>grouping keys</b> is calculated, as follows: the expression contained
                  in the <code>group-by</code> or <code>group-adjacent</code> attribute is
                  evaluated; the result is atomized; and any <code>xs:untypedAtomic</code> items
                  are cast to <code>xs:string</code>. If
                        <code>composite="yes"</code> is specified, there is a single grouping key
                     whose value is the resulting sequence; otherwise, there is a set of grouping
                     keys, consisting of the distinct atomic items present in the result
                     sequence.</p>
               </dd>
               <dt><a href="#dt-high-priority-package-location">high priority package location</a></dt>
               <dd>
                  <p>A 
                         <code>xsl:package-location</code> without the attribute <code>is-priority</code>, 
                         or with <code>is-priority</code> set to <code>true</code> is a <b>high priority package 
                            location</b>.</p>
               </dd>
               <dt><a href="#dt-homonymous">homonymous</a></dt>
               <dd>
                  <p>Two <a title="component" class="termref" href="#dt-component">components</a> are said to be <b>homonymous</b> if they have
                     the same <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic
                     identifier</a>.</p>
               </dd>
               <dt><a href="#dt-identical-types">identical (types)</a></dt>
               <dd>
                  <p>Types <var>S</var> 
                     and <var>T</var> are considered <b>identical</b> for the purpose of
                        these rules if and only if <code>subtype(S, T)</code> and <code>subtype(T,
                           S)</code> both hold, where the subtype relation is defined in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.</p>
               </dd>
               <dt><a href="#dt-immediate-result">immediate result</a></dt>
               <dd>
                  <p>The result of evaluating
               a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> is the sequence
               of items formed by concatenating the results of evaluating each of the nodes in the
               sequence constructor, retaining order. This is 
                  referred to as the <b>immediate result</b>
            of the sequence constructor.</p>
               </dd>
               <dt><a href="#dt-implementation">implementation</a></dt>
               <dd>
                  <p>A specific product that
                  performs the functions of an <a title="processor" class="termref" href="#dt-processor">XSLT processor</a>
                  is referred to as an <b>implementation</b>.</p>
               </dd>
               <dt><a href="#dt-implementation-defined">implementation-defined</a></dt>
               <dd>
                  <p>In this
                  specification, the term <b>implementation-defined</b> refers to a feature
                  where the implementation is allowed some flexibility, and where the choices made
                  by the implementation <span class="verb">must</span> be described in documentation that
                  accompanies any conformance claim.</p>
               </dd>
               <dt><a href="#dt-implementation-dependent">implementation-dependent</a></dt>
               <dd>
                  <p>The term
                     <b>implementation-dependent</b> refers to a feature where the behavior
                     <span class="verb">may</span> vary from one implementation to another, and where the
                  vendor is not expected to provide a full specification of the behavior.</p>
               </dd>
               <dt><a href="#dt-implicit-default">implicit default</a></dt>
               <dd>
                  <p>If a parameter that is
                     not <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> has no <a title="explicit default" class="termref" href="#dt-explicit-default">explicit default</a> value, then it has an <b>implicit
                        default</b> value, which is the empty sequence if there is an
                        <code>as</code> attribute, or a zero-length string if not.</p>
               </dd>
               <dt><a href="#dt-implicitly-mandatory">implicitly mandatory</a></dt>
               <dd>
                  <p>If a parameter
                     has an <a title="implicit default" class="termref" href="#dt-implicit-default">implicit default</a> value which cannot be converted to
                     the <a title="required type" class="termref" href="#dt-required-type">required type</a> (that is, if it has an <code>as</code>
                     attribute which does not permit the empty sequence), then the parameter is
                        <b>implicitly mandatory</b>.</p>
               </dd>
               <dt><a href="#dt-import-precedence">import precedence</a></dt>
               <dd>
                  <p>A <a title="declaration" class="termref" href="#dt-declaration">declaration</a>
                     <var>D</var> in the stylesheet is defined to have lower <b>import
                        precedence</b> than another declaration <var>E</var> if the stylesheet
                     level containing <var>D</var> would be visited before the stylesheet level
                     containing <var>E</var> in a post-order traversal of the import tree (that is,
                     a traversal of the import tree in which a stylesheet level is visited after its
                     children). Two declarations within the same stylesheet level have the same
                     import precedence.</p>
               </dd>
               <dt><a href="#dt-import-tree">import tree</a></dt>
               <dd>
                  <p>The <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet levels</a> making up a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> are treated as forming an
                        <b>import tree</b>. In the import tree, each stylesheet level has one
                     child for each <a href="#element-import"><code>xsl:import</code></a> declaration that it
                     contains.</p>
               </dd>
               <dt><a href="#dt-initial-function">initial function</a></dt>
               <dd>
                  <p>A stylesheet may be evaluated by calling a named
                        <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a>, referred to as the <b>initial
                        function</b>.</p>
               </dd>
               <dt><a href="#dt-initial-item">initial item</a></dt>
               <dd>
                  <p>For each <a title="group" class="termref" href="#dt-group">group</a>, the item within the group that is first in <a title="population order" class="termref" href="#dt-population-order">population order</a> is known as the
                     <b>initial item</b> of the group.</p>
               </dd>
               <dt><a href="#dt-initial-match-selection">initial match selection</a></dt>
               <dd>
                  <p>A stylesheet may be evaluated by supplying a
                     value to be processed, together with an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a>. The
                     value (which can be any sequence of items) is referred to as the <b>initial
                        match selection</b>. The processing then corresponds to the effect of the
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction.</p>
               </dd>
               <dt><a href="#dt-initial-mode">initial mode</a></dt>
               <dd>
                  <p>The <b>initial mode</b>
                        is the <a title="mode" class="termref" href="#dt-mode">mode</a> used to select <a title="template rule" class="termref" href="#dt-template-rule">template rules</a>
                     for processing items in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> when
                     apply-templates invocation is used to initiate a transformation.</p>
               </dd>
               <dt><a href="#dt-initial-named-template">initial named template</a></dt>
               <dd>
                  <p>A stylesheet may be evaluated by selecting a
                     named template to be evaluated; this is referred to as the <b>initial named
                        template</b>.</p>
               </dd>
               <dt><a href="#dt-initial-sequence">initial sequence</a></dt>
               <dd>
                  <p>The sequence to be
                     sorted is referred to as the <b>initial sequence</b>.</p>
               </dd>
               <dt><a href="#dt-initial-setting">initial setting</a></dt>
               <dd>
                  <p>The <b>initial setting</b> of a component of the dynamic context is used
                     when evaluating <a title="global variable" class="termref" href="#dt-global-variable">global variables</a>
                     and <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>,
                     when evaluating the <code>use</code> and <code>match</code> attributes of
                        <a href="#element-key"><code>xsl:key</code></a>, and when evaluating the <code>initial-value</code> of
                        <a href="#element-accumulator"><code>xsl:accumulator</code></a> and the <code>select</code> expressions or
                     contained sequence constructors of
                     <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a></p>
               </dd>
               <dt><a href="#dt-in-scope-schema-component">in-scope schema component</a></dt>
               <dd>
                  <p>The
                     <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> that may be
                  referenced by name in a <a title="package" class="termref" href="#dt-package">package</a> are referred to as the
                     <b>in-scope schema components</b>.</p>
               </dd>
               <dt><a href="#dt-instruction">instruction</a></dt>
               <dd>
                  <p>An <b>instruction</b> is either
                  an <a title="XSLT instruction" class="termref" href="#dt-xslt-instruction">XSLT instruction</a> or an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>.</p>
               </dd>
               <dt><a href="#dt-invocation-construct">invocation construct</a></dt>
               <dd>
                  <p>The following 
               constructs are classified as <b>invocation constructs</b>: the
               instructions <a href="#element-call-template"><code>xsl:call-template</code></a>,
               <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>, and
                  <a href="#element-next-match"><code>xsl:next-match</code></a>; XPath function calls that bind to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; XPath dynamic
               function calls; the functions <a href="#func-accumulator-before"><code>accumulator-before</code></a> and
                  <a href="#func-accumulator-after"><code>accumulator-after</code></a>; the <code>[xsl:]use-attribute-sets</code>
               attribute. These all have the characteristic that they can cause evaluation of
               constructs that are not lexically contained within the calling
            construct.</p>
               </dd>
               <dt><a href="#dt-key">key</a></dt>
               <dd>
                  <p>A <b>key</b> is defined as a set of
                        <a href="#element-key"><code>xsl:key</code></a> declarations in the same
                           <a title="package" class="termref" href="#dt-package">package</a> that share the same
                     name.</p>
               </dd>
               <dt><a href="#dt-key-specifier">key specifier</a></dt>
               <dd>
                  <p>The expression in the
                        <code>use</code> attribute and the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> 
                     within an <a href="#element-key"><code>xsl:key</code></a>
                     declaration are referred to collectively as the <b>key specifier</b>. The
                     key specifier determines the values that may be used to find a node using this
                        <a title="key" class="termref" href="#dt-key">key</a>.</p>
               </dd>
               <dt><a href="#dt-leading-step">leading step</a></dt>
               <dd>
                  <p>An <a href="#prod-xslt40-AxisStepP">AxisStepP</a>
               within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> is a <b>leading step</b> if
               (a) it is not the right-hand operand of a <code>/</code> or <code>//</code>
               operator, and (b) it is not contained (directly or indirectly) within a
               <a href="#prod-xslt40-ParenthesizedPattern">ParenthesizedPattern</a> that is the right-hand operand of a 
               <code>/</code> or <code>//</code> operator</p>
               </dd>
               <dt><a href="#dt-lexical-qname">lexical QName</a></dt>
               <dd>
                  <p>A <b>lexical QName</b>
                     is a string representing an <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                        QName</a> where the string, after removing leading and trailing
                     whitespace, is within the lexical space of the <code>xs:QName</code> datatype
                     as defined in XML Schema (see <a href="#xmlschema-2">[XML Schema Part 2]</a>): that is, a local
                     name optionally preceded by a namespace prefix and a colon.</p>
               </dd>
               <dt><a href="#dt-library-package">library package</a></dt>
               <dd>
                  <p>Every <a title="package" class="termref" href="#dt-package">package</a> within a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, other than the <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a>, is referred to as a
                     <b>library package</b>.</p>
               </dd>
               <dt><a href="#dt-literal-namespace-uri">literal namespace URI</a></dt>
               <dd>
                  <p>A namespace
                     URI in the stylesheet tree that is being used to specify a namespace URI in the
                        <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> is called a
                        <b>literal namespace URI</b>.</p>
               </dd>
               <dt><a href="#dt-literal-result-element">literal result element</a></dt>
               <dd>
                  <p>In a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, an element in the
                     <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that does not belong to the
                     <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> and that is not an
                     <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a> (see
                     <a href="#extension-instruction"><i>24.3 Extension Instructions</i></a>) is classified as a <b>literal result
                     element</b>.</p>
               </dd>
               <dt><a href="#dt-local-variable">local variable</a></dt>
               <dd>
                  <p>As well as being allowed as a
                     <a title="declaration" class="termref" href="#dt-declaration">declaration</a>, the
                     <a href="#element-variable"><code>xsl:variable</code></a> element is also allowed in <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructors</a>. Such a variable
                  is known as a <b>local variable</b>.</p>
               </dd>
               <dt><a href="#dt-low-priority-package-location">low priority package location</a></dt>
               <dd>
                  <p>A 
                         <code>xsl:package-location</code> with <code>is-priority</code> set to <code>false</code> is a 
                         <b>low priority package location</b>.</p>
               </dd>
               <dt><a href="#dt-merge-activation">merge activation</a></dt>
               <dd>
                  <p>A <b>merge
                     activation</b> is a single evaluation of the sequence constructor contained
                  within the <a href="#element-merge-action"><code>xsl:merge-action</code></a> element, which occurs once for each
                  distinct <a title="combined merge key value" class="termref" href="#dt-combined-merge-key-value">combined merge key value</a>.</p>
               </dd>
               <dt><a href="#dt-merge-input-sequence">merge input sequence</a></dt>
               <dd>
                  <p>A <b>merge input
                     sequence</b> is an arbitrary <a href="https://qt4cg.org/specifications/xpath-datamodel-40/#dt-sequence">sequence</a><sup><small>DM</small></sup> of items which is already sorted according to the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> for the
                  corresponding <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source
                     definition</a>.</p>
               </dd>
               <dt><a href="#dt-merge-key-component">merge key component</a></dt>
               <dd>
                  <p>A <b>merge key
                     component</b> specifies one component of a <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a>; it
                  corresponds to a single <a href="#element-merge-key"><code>xsl:merge-key</code></a> element in the
                  stylesheet.</p>
               </dd>
               <dt><a href="#dt-merge-key-specification">merge key specification</a></dt>
               <dd>
                  <p>A <b>merge
                     key specification</b> consists of one or more adjacent
                     <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements which together define how the 
               <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequences</a> selected by a
                     <a title="merge source definition" class="termref" href="#dt-merge-source-definition">merge source definition</a> are
                  sorted. Each <a href="#element-merge-key"><code>xsl:merge-key</code></a> element defines one 
               <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a>.</p>
               </dd>
               <dt><a href="#dt-merge-key-value">merge key value</a></dt>
               <dd>
                  <p> For each item in a 
               <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge input sequence</a>, a value is
                  computed for each <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key
                     component</a> within the <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge
                     key specification</a>. The value computed for an item by using the
                     <var>N</var>th <a title="merge key component" class="termref" href="#dt-merge-key-component">merge key component</a> is referred to as the
                     <var>N</var>th <b>merge key value</b> of that item.</p>
               </dd>
               <dt><a href="#dt-merge-source-definition">merge source definition</a></dt>
               <dd>
                  <p>A <b>merge
                     source definition</b> is the definition of one kind of input to the merge
                  operation. It selects zero or more <a title="merge input sequence" class="termref" href="#dt-merge-input-sequence">merge
                     input sequences</a>, and it includes a 
               <a title="merge key specification" class="termref" href="#dt-merge-key-specification">merge key specification</a> to define
                  how the <a title="merge key value" class="termref" href="#dt-merge-key-value">merge key
                        values</a> are computed for each such merge input
                  sequence.</p>
               </dd>
               <dt><a href="#dt-mode">mode</a></dt>
               <dd>
                  <p> A <b>mode</b> is a set of template rules;
                  when the <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction selects a set of items
                  for processing, it identifies the rules to be used for processing those items by
                  nominating a mode, explicitly or implicitly.</p>
               </dd>
               <dt><a href="#dt-mode-definition">mode definition</a></dt>
               <dd>
                  <p>All the
                        <a href="#element-mode"><code>xsl:mode</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> that share the same
                     name are grouped into a named <b>mode definition</b>; those that have no
                     name are grouped into a single unnamed mode definition.</p>
               </dd>
               <dt><a href="#dt-named-template">named template</a></dt>
               <dd>
                  <p>Templates can be invoked by
                  name. An <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute
                  defines a <b>named template</b>.</p>
               </dd>
               <dt><a href="#dt-namespace-fixup">namespace fixup</a></dt>
               <dd>
                  <p>The rules for the
                     individual XSLT instructions that construct a <a title="result tree" class="termref" href="#dt-result-tree">result tree</a> (see <a href="#creating-new-nodes"><i>11 Creating Nodes</i></a>) prescribe
                     some of the situations in which namespace nodes are written to the tree. These
                     rules, however, are not sufficient to ensure that the prescribed constraints
                     are always satisfied. The XSLT processor <span class="verb">must</span> therefore add
                     additional namespace nodes to satisfy these constraints. This process is
                     referred to as <b>namespace fixup</b>.</p>
               </dd>
               <dt><a href="#dt-native-namespace-bindings">native namespace bindings</a></dt>
               <dd>
                  <p>
                     The <b>native namespace bindings</b> for any element in an XSLT <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>
                     are the prefix-uri mappings defined by the namespace nodes of that element, according to the rules in
                     <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p>
               </dd>
               <dt><a href="#dt-non-contextual-function-call">non-contextual function call</a></dt>
               <dd>
                  <p>The term <b>non-contextual function
                        call</b> is used to refer to function calls that do not pass the dynamic
                     context to the called function. This includes all calls on <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a> and all
                        <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-dynamic-function-call">dynamic function
                        calls</a><sup><small>XP</small></sup>, (that is calls to function items). It excludes calls to some
                        functions in the namespace
                           <code>http://www.w3.org/2005/xpath-functions</code>, in
                     particular those that explicitly depend on the context, such as the
                        <a href="#func-current-group"><code>current-group</code></a> and <a href="#func-regex-group"><code>regex-group</code></a>
                     functions. It is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> whether, and under what circumstances,
                     calls to <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are
                     non-contextual.</p>
               </dd>
               <dt><a href="#dt-non-schema-aware-processor">non-schema-aware processor</a></dt>
               <dd>
                  <p>A <b>non-schema-aware processor</b> is a
                  processor that does not claim conformance with the schema-aware conformance
                  feature. Such a processor <span class="verb">must</span> handle constructs associated
                  with schema-aware processing as described in this section.</p>
               </dd>
               <dt><a href="#dt-first-appearance">order of first appearance</a></dt>
               <dd>
                  <p>There is a total ordering among <a title="group" class="termref" href="#dt-group">groups</a> referred to as the <b>order of first appearance</b>. A
                  group <var>G</var> is defined to precede a group <var>H</var> in order of first
                  appearance if the <a title="initial item" class="termref" href="#dt-initial-item">initial item</a> of
                     <var>G</var> precedes the initial item of <var>H</var> in population order. If
                  two groups <var>G</var> and <var>H</var> have the same initial item (because the
                  item is in both groups) then <var>G</var> precedes <var>H</var> if the <a title="grouping key" class="termref" href="#dt-grouping-key">grouping key</a> of <var>G</var> precedes the
                  grouping key of <var>H</var> in the sequence that results from evaluating the
                     <code>group-by</code> expression of this initial item.</p>
               </dd>
               <dt><a href="#dt-output-definition">output definition</a></dt>
               <dd>
                  <p>All the
                  <a href="#element-output"><code>xsl:output</code></a> declarations within a
                     <a title="package" class="termref" href="#dt-package">package</a> that share the same name
               are grouped into a named <b>output definition</b>; those that have no name are
               grouped into a single unnamed output definition.</p>
               </dd>
               <dt><a href="#dt-output-state">output state</a></dt>
               <dd>
                  <p>Each instruction in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is evaluated in one of two possible
                     <b>output states</b>: <a title="final output state" class="termref" href="#dt-final-output-state">final output
                     state</a> or <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output
                     state</a>.</p>
               </dd>
               <dt><a href="#dt-override">override</a></dt>
               <dd>
                  <p>A component in a using package may
                           <b>override</b> a component in a used package, provided that the
                           <a title="visibility" class="termref" href="#dt-visibility">visibility</a> of the component in the
                        used package is either <code>abstract</code> or <code>public</code>. The
                        overriding declaration is written as a child of the
                           <a href="#element-override"><code>xsl:override</code></a> element, which in turn appears as a child
                        of <a href="#element-use-package"><code>xsl:use-package</code></a>.</p>
               </dd>
               <dt><a href="#dt-package">package</a></dt>
               <dd>
                  <p>An explicit <b>package</b> is
                  represented by an <a href="#element-package"><code>xsl:package</code></a> element, which will generally be
                  the outermost element of an XML document. When the
                        <a href="#element-package"><code>xsl:package</code></a> element is not used explicitly, the entire
                     stylesheet comprises a single implicit package.</p>
               </dd>
               <dt><a href="#dt-package-manifest">package manifest</a></dt>
               <dd>
                  <p>The content of the
                     <a href="#element-package"><code>xsl:package</code></a> element is referred to as the <b>package
                     manifest</b></p>
               </dd>
               <dt><a href="#dt-parameter">parameter</a></dt>
               <dd>
                  <p>The <a href="#element-param"><code>xsl:param</code></a> element
               declares a <b>parameter</b>, which may be a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>, a <a title="template parameter" class="termref" href="#dt-template-parameter">template parameter</a>, a <a title="function parameter" class="termref" href="#dt-function-parameter">function parameter</a>, or an <a href="#element-iterate"><code>xsl:iterate</code></a> parameter. A parameter is a
                  <a title="variable" class="termref" href="#dt-variable">variable</a> with the additional property that
               its value can be set by the caller.</p>
               </dd>
               <dt><a href="#dt-pattern">pattern</a></dt>
               <dd>
                  <p>A <b>pattern</b> specifies a set of
                  conditions on an item. An item that satisfies the conditions matches the pattern; an
                     item that does not satisfy the conditions
                  does not match the pattern.</p>
               </dd>
               <dt><a href="#dt-picture-string">picture string</a></dt>
               <dd>
                  <p>The <b>picture string</b>
               is the string supplied as the second argument of the
               <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-format-number"><code>format-number</code></a> function.</p>
               </dd>
               <dt><a href="#dt-place-marker">place marker</a></dt>
               <dd>
                  <p>The <a href="#element-number"><code>xsl:number</code></a>
               instruction performs two tasks: firstly, determining a <b>place marker</b>
               (this is a sequence of integers, to allow for hierarchic numbering schemes such as
                  <code>1.12.2</code> or <code>3(c)ii</code>), and secondly, formatting the place
               marker for output as a text node in the result sequence.</p>
               </dd>
               <dt><a href="#dt-population">population</a></dt>
               <dd>
                  <p>The sequence of items to be grouped,
                  which is referred to as the <b>population</b>, is determined by evaluating
                  the XPath <a title="expression" class="termref" href="#dt-expression">expression</a> contained in the
                  <code>select</code> attribute.</p>
               </dd>
               <dt><a href="#dt-population-order">population order</a></dt>
               <dd>
                  <p>The population is treated
                  as a sequence; the order of items in this sequence is referred to as
                     <b>population order</b>.</p>
               </dd>
               <dt><a href="#dt-portion">portion</a></dt>
               <dd>
                  <p>The integer literals and the optional
                        <code>NamePart</code> within the version number are referred to as the
                        <b>portions</b> of the version number.</p>
               </dd>
               <dt><a href="#dt-predicate-pattern">predicate pattern</a></dt>
               <dd>
                  <p>A <b>predicate pattern</b> is written as
                           <code>.</code> (dot) followed by zero or more predicates in square
                        brackets, and it matches any item for which each of the predicates evaluates
                        to <code>true</code>.</p>
               </dd>
               <dt><a href="#dt-principal-result">principal result</a></dt>
               <dd>
                  <p>A <b>principal
                           result</b>: this can be any sequence of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).</p>
               </dd>
               <dt><a href="#dt-principal-stylesheet-module">principal stylesheet module</a></dt>
               <dd>
                  <p>Within a <a title="package" class="termref" href="#dt-package">package</a>, one <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> functions as the
                     <b>principal stylesheet module</b>. The complete package is assembled by
                  finding the stylesheet modules referenced directly or indirectly from the
                  principal stylesheet module using <a href="#element-include"><code>xsl:include</code></a> and
                     <a href="#element-import"><code>xsl:import</code></a> elements: see <a href="#include"><i>3.10.2 Stylesheet Inclusion</i></a> and <a href="#import"><i>3.10.3 Stylesheet Import</i></a>.</p>
               </dd>
               <dt><a href="#dt-priority">priority</a></dt>
               <dd>
                  <p>The <b>priority</b> of a
                        template rule is specified by the <code>priority</code> attribute on the
                           <a href="#element-template"><code>xsl:template</code></a> declaration. If no priority is specified
                        explicitly for a template rule, its <a title="default priority" class="termref" href="#dt-default-priority">default priority</a> 
                        is used, as defined in <a href="#default-priority"><i>6.3.3 Default Priority for Patterns</i></a>.</p>
               </dd>
               <dt><a href="#dt-optimal-package-location">priority package location</a></dt>
               <dd>
                  <p>The
                            first package location whose value of <code>href</code>, when resolved
                            as described in <a href="#uri-references"><i>5.8 URI References</i></a>, allows the system to
                            find the specified resource, and its entry if the resource is an archive, is
                            the <b>optimal package location</b>.</p>
               </dd>
               <dt><a href="#dt-processing-order">processing order</a></dt>
               <dd>
                  <p>There is another total ordering among groups referred to as
                     <b>processing order</b>. If group <var>R</var> precedes group
                     <var>S</var> in processing order, then in the result sequence returned by the
                     <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> instruction the items generated by
                  processing group <var>R</var> will precede the items generated by processing group
                     <var>S</var>.</p>
               </dd>
               <dt><a href="#dt-processor">processor</a></dt>
               <dd>
                  <p>The software responsible for transforming
                  source trees into result trees using an XSLT stylesheet is referred to as the
                     <b>processor</b>. This is sometimes expanded to <em>XSLT
                     processor</em> to avoid any confusion with other processors, for example an
                  XML processor.</p>
               </dd>
               <dt><a href="#dt-raw-result">raw result</a></dt>
               <dd>
                  <p>The result of invoking the
                        selected component, after any required conversion to the declared result
                        type of the component, is referred to as the <b>raw
                        result</b>.</p>
               </dd>
               <dt><a href="#dt-reference-binding">reference binding</a></dt>
               <dd>
                  <p>The process of
                        identifying the <a title="component" class="termref" href="#dt-component">component</a> to which a
                           <a title="symbolic reference" class="termref" href="#dt-symbolic-reference">symbolic reference</a> applies
                        (possibly chosen from several <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> alternatives) is called <b>reference
                           binding</b>.</p>
               </dd>
               <dt><a href="#dt-required-type">required type</a></dt>
               <dd>
                  <p>The context within a 
                  <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> where an XPath 
                  <a title="expression" class="termref" href="#dt-expression">expression</a> appears may specify the <b>required
                     type</b> of the expression. The required type indicates the type of the
                  value that the expression is expected to return.</p>
               </dd>
               <dt><a href="#dt-reserved-namespace">reserved namespace</a></dt>
               <dd>
                  <p>The XSLT namespace,
                     together with certain other namespaces recognized by an XSLT processor, are
                     classified as <b>reserved namespaces</b> and <span class="verb">must</span> be
                     used only as specified in this and related specifications.</p>
               </dd>
               <dt><a href="#dt-result-tree">result tree</a></dt>
               <dd>
                  <p>The term <b>result tree</b> is
                  used to refer to any <a title="tree" class="termref" href="#dt-tree">tree</a> constructed by <a title="instruction" class="termref" href="#dt-instruction">instructions</a> in the stylesheet. A result tree is
                  either a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> or a
                     <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a>.</p>
               </dd>
               <dt><a href="#dt-schema-aware-xslt-processor">schema-aware XSLT processor</a></dt>
               <dd>
                  <p>A
                     <b>schema-aware XSLT processor</b> is an XSLT processor that implements
                  the mandatory requirements of this specification connected with the
                     <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration, the
                     <code>[xsl:]validation</code> and <code>[xsl:]type attributes</code>, and the
                  ability to handle input documents whose nodes have type annotations other than
                     <code>xs:untyped</code> and <code>xs:untypedAtomic</code>. The mandatory
                  requirements of this specification are taken to include the mandatory requirements
                  of XPath 4.0, as described in <a href="#xpath-40">[XPath 4.0]</a>. A requirement is mandatory unless the specification includes
                  wording (such as the use of the words <span class="verb">should</span> or
                     <span class="verb">may</span>) that clearly indicates that it is optional.</p>
               </dd>
               <dt><a href="#dt-schema-component">schema component</a></dt>
               <dd>
                  <p>Type definitions and
                  element and attribute declarations are referred to collectively as <b>schema
                     components</b>.</p>
               </dd>
               <dt><a href="#dt-schema-instance-namespace">schema instance namespace</a></dt>
               <dd>
                  <p>The <b>schema instance namespace</b>
                           <code>http://www.w3.org/2001/XMLSchema-instance</code>,
                        <span>with conventional prefix <code>xsi</code></span>,
                        is used as defined
                           in <a href="#xmlschema-1">[XML Schema Part 1]</a></p>
               </dd>
               <dt><a href="#dt-schema-namespace">schema namespace</a></dt>
               <dd>
                  <p>The <b>schema
                              namespace</b>
                           <code>http://www.w3.org/2001/XMLSchema</code>,
                        <span>with conventional prefix <code>xs</code></span>,
                        is used as defined in
                              <a href="#xmlschema-1">[XML Schema Part 1]</a></p>
               </dd>
               <dt><a href="#dt-secondary-result">secondary result</a></dt>
               <dd>
                  <p>Zero or more
                           <b>secondary results</b>: each secondary result can be any sequence
                        of items (as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>).</p>
               </dd>
               <dt><a href="#dt-sequence-constructor">sequence constructor</a></dt>
               <dd>
                  <p>A <b>sequence
                     constructor</b> is a sequence of zero or more sibling nodes in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> that can be evaluated to return a
                  sequence of nodes, atomic items, and function
                     items. The way that the resulting sequence is used depends on the
                  containing instruction.</p>
               </dd>
               <dt><a href="#dt-sequence-type">SequenceType</a></dt>
               <dd>
                  <p>A <b>SequenceType</b>
            constrains the type and number of items in a sequence. The term is used both to denote the
            concept, and to refer to the syntactic form in which sequence types are expressed in the
            XPath grammar: specifically <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup> in
                <a href="#xpath-40">[XPath 4.0]</a>.</p>
               </dd>
               <dt><a href="#dt-serialization">serialization</a></dt>
               <dd>
                  <p>A frequent requirement is to
                  output a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> as an XML
                  document (or in other formats such as HTML). This process is referred to as
                     <b>serialization</b>.</p>
               </dd>
               <dt><a href="#dt-serialization-error">serialization error</a></dt>
               <dd>
                  <p>If a transformation
                  has successfully produced a <a title="principal result" class="termref" href="#dt-principal-result">principal result</a> or <a title="secondary result" class="termref" href="#dt-secondary-result">secondary result</a>, it is
                     still possible that errors may occur in serializing that result
                  . For example, it may be impossible to
                  serialize the result  using the
                  encoding selected by the user. Such an error is referred to as a
                     <b>serialization error</b>.</p>
               </dd>
               <dt><a href="#dt-serialization-feature">serialization feature</a></dt>
               <dd>
                  <p>A processor that
                  claims conformance with the <b>serialization feature</b>
                  <span class="verb">must</span> support the conversion of a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> to a sequence of octets
                  following the rules defined in <a href="#serialization"><i>26 Serialization</i></a>.</p>
               </dd>
               <dt><a href="#dt-shadows">shadows</a></dt>
               <dd>
                  <p>Within a region of the 
               stylesheet where a binding <var>B</var>1 is visible, <var>B<sub>1</sub></var> shadows another 
               binding <var>B<sub>2</sub></var> having the same name as <var>B<sub>1</sub></var> if <var>B<sub>1</sub></var> occurs at 
               a point where <var>B<sub>2</sub></var> is visible.</p>
               </dd>
               <dt><a href="#dt-simplified-stylesheet-module">simplified stylesheet</a></dt>
               <dd>
                  <p>A
                           <b>simplified stylesheet</b>, which is a subtree rooted at a
                           <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result
                        element</a>, as described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>.
                        This is first converted to a <a title="standard stylesheet module" class="termref" href="#dt-standard-stylesheet-module">standard stylesheet module</a> by wrapping it in an xsl:stylesheet
                        element using the transformation described in <a href="#simplified-stylesheet"><i>3.7 Simplified Stylesheet Modules</i></a>.</p>
               </dd>
               <dt><a href="#dt-singleton-focus">singleton focus</a></dt>
               <dd>
                  <p>A <b>singleton
                           focus</b> based on an item <var>J</var> has the <a title="context item" class="termref" href="#dt-context-item">context item</a> (and
                           therefore the <a title="context node" class="termref" href="#dt-context-node">context node</a>, if
                              <var>J</var> is a node) set to <var>J</var>, and the <a title="context position" class="termref" href="#dt-context-position">context position</a> and <a title="context size" class="termref" href="#dt-context-size">context size</a> both set to 1
                        (one).</p>
               </dd>
               <dt><a href="#dt-snapshot">snapshot</a></dt>
               <dd>
                  <p>A <b>snapshot</b> of a node <var>N</var>
               is a deep copy of <var>N</var>, as produced by the <a href="#element-copy-of"><code>xsl:copy-of</code></a>
               instruction with <code>copy-namespaces</code> set to <code>yes</code>,
               <code>copy-accumulators</code> set to <code>yes</code>, and
                  <code>validation</code> set to <code>preserve</code>, with the additional property
               that for every ancestor of <var>N</var>, the copy also has a corresponding ancestor
               whose name, node-kind, and base URI are the same as the corresponding ancestor of
               <var>N</var>, and that has copies of the attributes, namespaces and accumulator values of the
               corresponding ancestor of <var>N</var>. But the ancestor has a type annotation of
                  <code>xs:anyType</code>, has the properties <code>nilled</code>,
                  <code>is-id</code>, and <code>is-idref</code> set to <code>false</code>, and has no children
               other than the child that is a copy of <var>N</var> or one of its
               ancestors.</p>
               </dd>
               <dt><a href="#dt-sorted-sequence">sorted sequence</a></dt>
               <dd>
                  <p>The sequence after sorting
                     as defined by the <a href="#element-sort"><code>xsl:sort</code></a> elements is referred to as the
                        <b>sorted sequence</b>.</p>
               </dd>
               <dt><a href="#dt-sort-key-component">sort key component</a></dt>
               <dd>
                  <p>Within a <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort key specification</a>, each
                  <a href="#element-sort"><code>xsl:sort</code></a> element defines one <b>sort key
               component</b>.</p>
               </dd>
               <dt><a href="#dt-sort-key-specification">sort key specification</a></dt>
               <dd>
                  <p>A <b>sort key
                  specification</b> is a sequence of one or more adjacent
                  <a href="#element-sort"><code>xsl:sort</code></a> elements which together define rules for sorting the
               items in an input sequence to form a sorted sequence.</p>
               </dd>
               <dt><a href="#dt-sort-key-value">sort key value</a></dt>
               <dd>
                  <p> For each item in the
                        <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial sequence</a>, a value is
                     computed for each <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key
                        component</a> within the <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort
                        key specification</a>. The value computed for an item by using the
                        <var>N</var>th sort key component is referred to as the <var>N</var>th
                        <b>sort key value</b> of that item.</p>
               </dd>
               <dt><a href="#dt-source-tree">source tree</a></dt>
               <dd>
                  <p>The term <b>source tree</b>
                  means any tree provided as input to the transformation. This includes the document
                  containing the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a> if any, documents containing
                     nodes present in the <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a>,
                  documents containing nodes supplied as the values of <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, documents
                  obtained from the results of functions such as <a href="#func-document"><code>document</code></a>,
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a>, and <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a>, documents read using the <a href="#element-source-document"><code>xsl:source-document</code></a>
                     instruction, and documents returned by extension functions or
                  extension instructions. In the context of a particular XSLT instruction, the term
                     <b>source tree</b> means any tree provided as input to that instruction;
                  this may be a source tree of the transformation as a whole, or it may be a
                     <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> produced during the
                  course of the transformation.</p>
               </dd>
               <dt><a href="#dt-stable">stable</a></dt>
               <dd>
                  <p>A <a title="sort key specification" class="termref" href="#dt-sort-key-specification">sort
                     key specification</a> is said to be <b>stable</b> if its first
                     <a href="#element-sort"><code>xsl:sort</code></a> element has no <code>stable</code> attribute, or has
                  a <code>stable</code> attribute whose <a title="effective value" class="termref" href="#dt-effective-value">effective
                     value</a> is <code>yes</code>.</p>
               </dd>
               <dt><a href="#dt-standard-attributes">standard attributes</a></dt>
               <dd>
                  <p>There are a number of
                     <b>standard attributes</b> that may appear on any <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>: specifically
                     <code>default-collation</code>, 
                     <code>default-mode</code>,
                     <code>default-validation</code>,
                     <code>exclude-result-prefixes</code>, 
                     <code>expand-text</code>, 
                     <code>extension-element-prefixes</code>,
                     <code>schema-role</code>,
                     <code>use-when</code>, 
                     <code>version</code>, and
                     <code>xpath-default-namespace</code>.</p>
               </dd>
               <dt><a href="#dt-standard-error-namespace">standard error namespace</a></dt>
               <dd>
                  <p>The <b>standard error namespace</b>
                           <code>http://www.w3.org/2005/xqt-errors</code>,
                        <span>with conventional prefix <code>err</code></span>,
                        is used for error codes
                           defined in this specification and related specifications. It is also used
                           for the names of certain predefined variables accessible within the scope
                           of an <a href="#element-catch"><code>xsl:catch</code></a> element.</p>
               </dd>
               <dt><a href="#dt-standard-function-namespace">standard function namespace</a></dt>
               <dd>
                  <p>The <b>standard function
                              namespace</b>
                           <code>http://www.w3.org/2005/xpath-functions</code>,
                           <span>with conventional prefix <code>fn</code></span>,
                           is used for functions
                           in the function library defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a> and
                           for standard functions defined in this specification.</p>
               </dd>
               <dt><a href="#dt-standard-stylesheet-module">standard stylesheet module</a></dt>
               <dd>
                  <p>A
                           <b>standard stylesheet module</b>, which is a subtree rooted at an
                           <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> or <a href="#element-transform"><code>xsl:transform</code></a>
                        element.</p>
               </dd>
               <dt><a href="#dt-static-error">static error</a></dt>
               <dd>
                  <p>An error that can be detected by
                  examining a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> before execution
                  starts (that is, before the source document and values of stylesheet parameters
                  are available) is referred to as a <b>static error</b>.</p>
               </dd>
               <dt><a href="#dt-static-expression">static expression</a></dt>
               <dd>
                  <p>A <b>static
                     expression</b> is an XPath <a title="expression" class="termref" href="#dt-expression">expression</a> whose value must
                  be computed during static analysis of the stylesheet.</p>
               </dd>
               <dt><a href="#dt-static-parameter">static parameter</a></dt>
               <dd>
                  <p>A <a title="static variable" class="termref" href="#dt-static-variable">static variable</a> declared using an <a href="#element-param"><code>xsl:param</code></a> element
                  is referred to as a <b>static parameter</b>.</p>
               </dd>
               <dt><a href="#dt-static-variable">static variable</a></dt>
               <dd>
                  <p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a>
                  <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a>
                  having the attribute <code>static="yes"</code> declares a <b>static
                     variable</b>: that is, a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> whose value is
                  known during static analysis of the stylesheet.</p>
               </dd>
               <dt><a href="#dt-streamable-mode">streamable mode</a></dt>
               <dd>
                  <p>A <b>streamable
                        mode</b> is a <a title="mode" class="termref" href="#dt-mode">mode</a> that is declared in
                     an <a href="#element-mode"><code>xsl:mode</code></a> declaration with the attribute
                        <code>streamable="yes"</code>.</p>
               </dd>
               <dt><a href="#dt-streamed-document">streamed document</a></dt>
               <dd>
                  <p>A <b>streamed
                     document</b> is a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> that
                  is processed using streaming, that is, without constructing a complete tree of
                  nodes in memory.</p>
               </dd>
               <dt><a href="#dt-streamed-node">streamed node</a></dt>
               <dd>
                  <p>A <b>streamed
                     node</b> is a node in a <a title="streamed document" class="termref" href="#dt-streamed-document">streamed
                     document</a>.</p>
               </dd>
               <dt><a href="#dt-streaming">streaming</a></dt>
               <dd>
                  <p>The term <b>streaming</b> refers to
                  a manner of processing in which XML documents (such as source and result documents)
                  are not represented by a complete tree of nodes occupying memory proportional to
                  document size, but instead are processed “on the fly” as a sequence of events,
                  similar in concept to the stream of events notified by an XML parser to represent
                  markup in lexical XML.</p>
               </dd>
               <dt><a href="#dt-streaming-feature">streaming feature</a></dt>
               <dd>
                  <p>A processor that claims
                  conformance with the <b>streaming feature</b>
                  <span class="verb">must</span> use streamed processing in cases where (a) streaming is
                  requested (for example by using the attribute <code>streamable="yes"</code> on
                  <a href="#element-mode"><code>xsl:mode</code></a>, or on
                  the <a href="#element-source-document"><code>xsl:source-document</code></a> instruction) and
                  (b) the constructs in question are <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-guaranteed-streamable">guaranteed-streamable</a><sup><small>SG</small></sup>
                  according to this specification.</p>
               </dd>
               <dt><a href="#dt-string-value">string value</a></dt>
               <dd>
                  <p>The term <b>string
                           value</b> is defined in
                           <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-string-value">7.6.12 string-value Accessor</a>. Every node has a <a title="string value" class="termref" href="#dt-string-value">string value</a>. For example, the <a title="string value" class="termref" href="#dt-string-value">string value</a> of an element is the concatenation of the
                           <a title="string value" class="termref" href="#dt-string-value">string values</a> of all its
                        descendant text nodes.</p>
               </dd>
               <dt><a href="#dt-stylesheet">stylesheet</a></dt>
               <dd>
                  <p>A
                     <b>stylesheet</b> consists of one or more packages: specifically, one
                     <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> and zero or
                  more <a title="library package" class="termref" href="#dt-library-package">library packages</a>.</p>
               </dd>
               <dt><a href="#dt-stylesheet-function">stylesheet function</a></dt>
               <dd>
                  <p>An
                     <a href="#element-function"><code>xsl:function</code></a> declaration declares the name, parameters, and
                  implementation of a family of <b>stylesheet functions</b> that can be called from any
                  XPath <a title="expression" class="termref" href="#dt-expression">expression</a> within the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                  (subject to visibility rules).</p>
               </dd>
               <dt><a href="#dt-stylesheet-level">stylesheet level</a></dt>
               <dd>
                  <p>A <b>stylesheet
                        level</b> is a collection of <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet modules</a> connected using <a href="#element-include"><code>xsl:include</code></a>
                     declarations: specifically, two stylesheet modules <var>A</var> and
                        <var>B</var> are part of the same stylesheet level if one of them includes
                     the other by means of an <a href="#element-include"><code>xsl:include</code></a> declaration, or if there
                     is a third stylesheet module <var>C</var> that is in the same stylesheet level
                     as both <var>A</var> and <var>B</var>.</p>
               </dd>
               <dt><a href="#dt-stylesheet-module">stylesheet module</a></dt>
               <dd>
                  <p>A <a title="package" class="termref" href="#dt-package">package</a> consists of one or
                  more <b>stylesheet modules</b>, each one forming all or part of an XML
                  document.</p>
               </dd>
               <dt><a href="#dt-stylesheet-parameter">stylesheet parameter</a></dt>
               <dd>
                  <p>A <a title="top-level" class="termref" href="#dt-top-level">top-level</a>
                     <a href="#element-param"><code>xsl:param</code></a> element declares a <b>stylesheet
                  parameter</b>. A stylesheet parameter is a global variable with the additional
                  property that its value can be supplied by the caller when a transformation is
                  initiated.</p>
               </dd>
               <dt><a href="#dt-supplied-value">supplied value</a></dt>
               <dd>
                  <p>The value of the variable is
                  computed using the <a title="expression" class="termref" href="#dt-expression">expression</a> given in the
                     <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>, as described in
                     <a href="#variable-values"><i>9.3 Values of Variables and Parameters</i></a>. This value is referred to as the
                     <b>supplied value</b> of the variable.</p>
               </dd>
               <dt><a href="#dt-symbolic-identifier">symbolic identifier</a></dt>
               <dd>
                  <p>The <b>symbolic
                        identifier</b> of a <a title="component" class="termref" href="#dt-component">component</a> is a
                     composite name used to identify the component uniquely within a package. The
                     symbolic identifier comprises the kind of component (stylesheet function, named
                     template, accumulator, attribute set, global
                     variable, key, or mode), the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                        QName</a> of the component (namespace URI plus local name), and in the
                     case of stylesheet functions, <span>the upper
                     bound of the <a title="arity range" class="termref" href="#dt-arity-range">arity range</a></span>.</p>
               </dd>
               <dt><a href="#dt-symbolic-reference">symbolic reference</a></dt>
               <dd>
                  <p>The <a title="declaration" class="termref" href="#dt-declaration">declaration</a> of a component includes
                     constructs that can be interpreted as references to other <a title="component" class="termref" href="#dt-component">components</a> by means of their <a title="symbolic identifier" class="termref" href="#dt-symbolic-identifier">symbolic identifiers</a>. These
                     constructs are generically referred to as <b>symbolic references</b>.
                     Examples of constructs that give rise to symbolic references are the
                        <code>name</code> attribute of <a href="#element-call-template"><code>xsl:call-template</code></a>; the
                        <code>[xsl:]use-attribute-sets</code> attribute of
                     <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, and <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result elements</a>; the
                        explicit or implicit
                     <code>mode</code> attribute of <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>; XPath
                     variable references referring to global variables; XPath static function calls (including partial function
                        applications) referring to <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet functions</a>; and
                        named function references (example: <code>my:f#1</code>) referring to
                        stylesheet functions.
                     </p>
               </dd>
               <dt><a href="#dt-tail-position">tail position</a></dt>
               <dd>
                  <p>An <a title="instruction" class="termref" href="#dt-instruction">instruction</a>
                  <var>J</var> is in a <b>tail position</b> within a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>
                  <var>SC</var> if it satisfies one of the following conditions:</p>
                  <ul>
                     <li>
                        <p><var>J</var> is the last instruction in <var>SC</var>, ignoring any
                        <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p>
                     </li>
                     <li>
                        <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-if"><code>xsl:if</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p>
                     </li>
                     <li>
                        <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-when"><code>xsl:when</code></a> or <a href="#element-otherwise"><code>xsl:otherwise</code></a> branch of an
                        <a href="#element-choose"><code>xsl:choose</code></a> <span>or <a href="#element-switch"><code>xsl:switch</code></a></span> 
                     instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var>.</p>
                     </li>
                     <li>
                        <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-try"><code>xsl:try</code></a> instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a> within <var>SC</var> (that
                     is, it is immediately followed by an <a href="#element-catch"><code>xsl:catch</code></a> element,
                     ignoring any <a href="#element-fallback"><code>xsl:fallback</code></a> elements).</p>
                     </li>
                     <li>
                        <p><var>J</var> is in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the sequence constructor that forms the body of an
                        <a href="#element-catch"><code>xsl:catch</code></a> element within an <a href="#element-try"><code>xsl:try</code></a>
                     instruction that is itself in a <a title="tail position" class="termref" href="#dt-tail-position">tail
                        position</a> within <var>SC</var>.</p>
                     </li>
                  </ul>
               </dd>
               <dt><a href="#dt-target-expression">target expression</a></dt>
               <dd>
                  <p>The string that results
                  from evaluating the expression in the <code>xpath</code> attribute is referred to
                  as the <b>target expression</b>.</p>
               </dd>
               <dt><a href="#dt-target-namespace-uri">target namespace URI</a></dt>
               <dd>
                  <p>The namespace
                     URI that is to be used in the <a title="result tree" class="termref" href="#dt-result-tree">result
                        tree</a> as a substitute for a <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> is called the <b>target namespace
                        URI</b>.</p>
               </dd>
               <dt><a href="#dt-template">template</a></dt>
               <dd>
                  <p>An <a href="#element-template"><code>xsl:template</code></a>
                  declaration defines a <b>template</b>, which contains a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a>;
                  this sequence constructor is evaluated to determine
                     the result of the template. A template can serve either as a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>, invoked by matching items against a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, or as a <a title="named template" class="termref" href="#dt-named-template">named
                     template</a>, invoked explicitly by name. It is also possible for the
                  same template to serve in both capacities.</p>
               </dd>
               <dt><a href="#dt-template-parameter">template parameter</a></dt>
               <dd>
                  <p> An
                           <a href="#element-param"><code>xsl:param</code></a> element may appear as a child of an
                           <a href="#element-template"><code>xsl:template</code></a> element, before any
                           non-<a href="#element-param"><code>xsl:param</code></a> children of that element. Such a parameter
                        is known as a <b>template parameter</b>. A template parameter is a
                           <a title="local variable" class="termref" href="#dt-local-variable">local variable</a> with the
                        additional property that its value can be set when the template is called,
                        using any of the instructions <a href="#element-call-template"><code>xsl:call-template</code></a>,
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>,
                        or <a href="#element-next-match"><code>xsl:next-match</code></a>.</p>
               </dd>
               <dt><a href="#dt-template-rule">template rule</a></dt>
               <dd>
                  <p>A stylesheet contains a set of
                  <b>template rules</b> (see <a href="#rules"><i>6 Template Rules</i></a>). A template rule has
                  three parts: a <a title="pattern" class="termref" href="#dt-pattern">pattern</a> that is matched against
                  selected items (often but not necessarily nodes), a (possibly empty) set of <a title="template parameter" class="termref" href="#dt-template-parameter">template
                     parameters</a>, and a <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a> that is evaluated to produce a sequence of
                  items.</p>
               </dd>
               <dt><a href="#dt-temporary-output-state">temporary output state</a></dt>
               <dd>
                  <p>The second of
                  the two <a title="output state" class="termref" href="#dt-output-state">output states</a> is called
                     <b>temporary output</b> state. This state applies when instructions are
                  writing to a <a title="temporary tree" class="termref" href="#dt-temporary-tree">temporary tree</a> or any
                  other non-final destination.</p>
               </dd>
               <dt><a href="#dt-temporary-tree">temporary tree</a></dt>
               <dd>
                  <p>The term <b>temporary
                     tree</b> means any tree that is neither a <a title="source tree" class="termref" href="#dt-source-tree">source tree</a> nor a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                     tree</a>.</p>
               </dd>
               <dt><a href="#dt-text-value-template">text value template</a></dt>
               <dd>
                  <p>In a text node
                     that is designated as a <b>text value template</b>, <a title="expression" class="termref" href="#dt-expression">expressions</a> can be used by surrounding each
                     expression with curly brackets (<code>{}</code>).</p>
               </dd>
               <dt><a href="#dt-top-level">top-level</a></dt>
               <dd>
                  <p>An element occurring as a child of an
                     <a href="#element-package"><code>xsl:package</code></a>,
                     <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>,
                        <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-override"><code>xsl:override</code></a>
                  element is called a <b>top-level</b> element.</p>
               </dd>
               <dt><a href="#dt-top-level-package">top-level package</a></dt>
               <dd>
                  <p>For a given transformation, one <a title="package" class="termref" href="#dt-package">package</a> functions as the <b>top-level package</b>. The
                  complete <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is assembled by finding
                  the packages referenced directly or indirectly from the top-level package using
                     <a href="#element-use-package"><code>xsl:use-package</code></a> declarations: see <a href="#package-dependencies"><i>3.4.2 Dependencies between Packages</i></a>.</p>
               </dd>
               <dt><a href="#dt-traversal">traversal</a></dt>
               <dd>
                  <p>A <b>traversal</b> of a tree is
                     a sequence of <a title="traversal-event" class="termref" href="#dt-traversal-event">traversal
                     events</a>.</p>
               </dd>
               <dt><a href="#dt-traversal-event">traversal-event</a></dt>
               <dd>
                  <p>a <b>traversal
                        event</b> (shortened to <b>event</b> in this section) is a pair
                     comprising a phase (start or end) and a node.</p>
               </dd>
               <dt><a href="#dt-tree">tree</a></dt>
               <dd>
                  <p>The term <b>tree</b> is used (as in <a href="#xpath-datamodel-40">[XDM 4.0]</a>) to refer to the aggregate consisting of a
                  parentless node together with all its descendant nodes, plus all their attributes
                  and namespaces.</p>
               </dd>
               <dt><a href="#dt-tunnel-parameter">tunnel parameter</a></dt>
               <dd>
                  <p>A parameter passed to a
                     template may be defined as a <b>tunnel parameter</b>. Tunnel parameters
                     have the property that they are automatically passed on by the called template
                     to any further templates that it calls, and so on recursively.</p>
               </dd>
               <dt><a href="#dt-type-annotation">type annotation</a></dt>
               <dd>
                  <p>The term <b>type
                     annotation</b> is used in this specification to refer to the value returned
                  by the <code>dm:type-name</code> accessor of a node: see <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-type-name">7.6.13 type-name Accessor</a>.</p>
               </dd>
               <dt><a href="#dt-typed-value">typed value</a></dt>
               <dd>
                  <p>The term <b>typed
                           value</b> is defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a> section <a href="../xpath-datamodel-40/#dm-typed-value">7.6.14 typed-value Accessor</a>.
                        Every node, other than an element whose type
                           annotation identifies it as having element-only content, has a
                           <a title="string value" class="termref" href="#dt-string-value">typed value</a>. For example, the
                           <a title="typed value" class="termref" href="#dt-typed-value">typed value</a> of an attribute of
                        type <code>xs:IDREFS</code> is a sequence of zero or more
                           <code>xs:IDREF</code> values.</p>
               </dd>
               <dt><a href="#dt-type-error">type error</a></dt>
               <dd>
                  <p>Certain errors are classified as
                     <b>type errors</b>. A type error occurs when the value supplied as input
                  to an operation is of the wrong type for that operation, for example when an
                  integer is supplied to an operation that expects a node.</p>
               </dd>
               <dt><a href="#dt-type-pattern">type pattern</a></dt>
               <dd>
                  <p>A <b>type pattern</b> is written as
                     <code>~T</code> (where <var>T</var> is an <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>)
                     followed by zero or more predicates in square
                     brackets, and it matches any item that is coercible to type <var>T</var> for which each of the predicates evaluates
                     to <code>true</code>.</p>
               </dd>
               <dt><a href="#dt-unnamed-mode">unnamed mode</a></dt>
               <dd>
                  <p>The <b>unnamed mode</b> is the default mode used when no
                        <code>mode</code> attribute is specified on an
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction or
                        <a href="#element-template"><code>xsl:template</code></a> declaration, unless a different <a title="default mode" class="termref" href="#dt-default-mode">default mode</a>
                     has been specified using the <code>[xsl:]default-mode</code> attribute of a containing
                        element.</p>
               </dd>
               <dt><a href="#dt-uri-reference">URI Reference</a></dt>
               <dd>
                  <p>Within this specification, the
                  term <b>URI Reference</b>, unless otherwise stated, refers to a string in
                  the lexical space of the <code>xs:anyURI</code> datatype as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p>
               </dd>
               <dt><a href="#dt-use">use</a></dt>
               <dd>
                  <p>If a package <var>Q</var> contains an
                        <a href="#element-use-package"><code>xsl:use-package</code></a> element that references package
                        <var>P</var>, then package <var>Q</var> is said to <b>use</b> package
                        <var>P</var>. In this relationship package <var>Q</var> is referred to as
                     the <b>using</b> package, package <var>P</var> as the <b>used</b>
                     package.</p>
               </dd>
               <dt><a href="#dt-data-element">user-defined data element</a></dt>
               <dd>
                  <p>In addition to
                        <a title="declaration" class="termref" href="#dt-declaration">declarations</a>, the
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a> element may contain among its children any
                     element not from the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>,
                     provided that the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of
                     the element has a non-null namespace URI. Such elements are referred to as
                        <b>user-defined data elements</b>.</p>
               </dd>
               <dt><a href="#dt-vacuous">vacuous</a></dt>
               <dd>
                  <p>An item is <b>vacuous</b> if
               it is one of the following: a zero-length text node; a document node with no children; an atomic item which, 
               on casting to <code>xs:string</code>, produces a zero-length string; or  an array 
                  which on flattening using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-array-flatten"><code>array:flatten</code></a> function produces either the empty sequence 
                  or a sequence consisting entirely of <a title="vacuous" class="termref" href="#dt-vacuous">vacuous</a> items.</p>
               </dd>
               <dt><a href="#dt-value">value</a></dt>
               <dd>
                  <p>A variable is a binding between a name and a value.
               The <b>value</b> of a variable is any sequence (of nodes, atomic items,
                  and/or function items), as defined in <a href="#xpath-datamodel-40">[XDM 4.0]</a>.</p>
               </dd>
               <dt><a href="#dt-value-template">value template</a></dt>
               <dd>
                  <p>Collectively,
                  attribute value templates and text value templates are referred to as <b>value
                     templates</b>.</p>
               </dd>
               <dt><a href="#dt-variable">variable</a></dt>
               <dd>
                  <p>The <a href="#element-variable"><code>xsl:variable</code></a> element
               declares a <b>variable</b>, which may be a <a title="global variable" class="termref" href="#dt-global-variable">global variable</a> or a <a title="local variable" class="termref" href="#dt-local-variable">local
                  variable</a>.</p>
               </dd>
               <dt><a href="#dt-variable-binding-element">variable-binding element</a></dt>
               <dd>
                  <p>The two
               elements <a href="#element-variable"><code>xsl:variable</code></a> and <a href="#element-param"><code>xsl:param</code></a> are referred to
               as <b>variable-binding elements</b>.</p>
               </dd>
               <dt><a href="#dt-visibility">visibility</a></dt>
               <dd>
                  <p>The <b>visibility</b> of a
                           <a title="component" class="termref" href="#dt-component">component</a> is one of:
                           <code>private</code>, <code>public</code>, <code>abstract</code>,
                           <code>final</code>, or <code>hidden</code>.</p>
               </dd>
               <dt><a href="#dt-whitespace-text-node">whitespace text node</a></dt>
               <dd>
                  <p>A <b>whitespace
                  text node</b> is a text node whose content consists entirely of whitespace
               characters (that is, <span class="unicode-codepoint">U+0009</span> (<span class="unicode-name">TAB</span>) , <span class="unicode-codepoint">U+000A</span> (<span class="unicode-name">NEWLINE</span>) ,
               <span class="unicode-codepoint">U+000D</span> (<span class="unicode-name">CARRIAGE RETURN</span>) , or <span class="unicode-codepoint">U+0020</span> (<span class="unicode-name">SPACE</span>) ).</p>
               </dd>
               <dt><a href="#xml-namespace">XML namespace</a></dt>
               <dd>
                  <p>The <b>XML
                              namespace</b>, defined in <a href="#xml-names">[Namespaces in XML]</a> as
                              <code>http://www.w3.org/XML/1998/namespace</code>, is used for
                           attributes such as <code>xml:lang</code>, <code>xml:space</code>, and
                              <code>xml:id</code>.</p>
               </dd>
               <dt><a href="#dt-xpath-compat-mode">XPath 1.0 compatibility mode</a></dt>
               <dd>
                  <p>The term
                           <b>XPath 1.0 compatibility mode</b> is defined in 
                        <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#static_context">2.2.1 Static Context</a>. This is a setting in the static
                        context of an XPath expression; it has two values, <code>true</code> and
                           <code>false</code>. When the value is set to <code>true</code>, the semantics of
                        function calls and certain other operations are adjusted to give a greater
                        degree of backwards compatibility between XPath
                        <span>4.0</span> and XPath 1.0.</p>
               </dd>
               <dt><a href="#dt-xslt-10-behavior">XSLT 1.0 behavior</a></dt>
               <dd>
                  <p>An element in the
                     stylesheet is processed with <b>XSLT 1.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to
                     1.0.</p>
               </dd>
               <dt><a href="#dt-1.0-compatibility-feature">XSLT 1.0 compatibility feature</a></dt>
               <dd>
                  <p>A
                  processor that claims conformance with the <b>XSLT 1.0 compatibility
                     feature</b>
                  <span class="verb">must</span> support the processing of stylesheet instructions and
                  XPath expressions with <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT
                     1.0 behavior</a>, as defined in <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>.</p>
               </dd>
               <dt><a href="#dt-xslt-20-behavior">XSLT 2.0 behavior</a></dt>
               <dd>
                  <p>An element is processed
                     with <b>XSLT 2.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> is equal to 2.0.</p>
               </dd>
               <dt><a href="#dt-xslt-30-behavior">XSLT 3.0 behavior</a></dt>
               <dd>
                  <p>An element is processed
                  with <b>XSLT 3.0 behavior</b> if its <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> 
                  is equal to 3.0.</p>
               </dd>
               <dt><a href="#dt-xslt-element">XSLT element</a></dt>
               <dd>
                  <p>An <b>XSLT element</b> is an
                  element in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a> whose
                  syntax and semantics are defined in this specification.</p>
               </dd>
               <dt><a href="#dt-xslt-instruction">XSLT instruction</a></dt>
               <dd>
                  <p>An <b>XSLT
                  instruction</b> is an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a>
                  whose syntax summary in this specification contains the annotation <code>&lt;!--
                     category: instruction --&gt;</code>.</p>
               </dd>
               <dt><a href="#dt-xslt-namespace">XSLT namespace</a></dt>
               <dd>
                  <p>The <b>XSLT namespace</b>
                     has the URI <code>http://www.w3.org/1999/XSL/Transform</code>. It is used to
                     identify elements, attributes, and other names that have a special meaning defined
                     in this specification.</p>
               </dd>
            </dl>
         </div>
         <div class="div1">
            
            <h2><a id="element-syntax-summary"></a>C <a href="#element-syntax-summary" style="text-decoration: none">Element Syntax Summary</a> (Non-Normative)</h2>
            <p>The syntax of each XSLT element is summarized below, together with the
context in the stylesheet where the element may appear. Some elements (specifically,
instructions) are allowed as a child of any element that is allowed to contain a sequence
constructor. These elements are:</p>
            <ul>
               <li>Literal result elements</li>
               <li>Extension instructions, if so defined</li>
            </ul>
            <p><b><a href="#element-accept">xsl:accept</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:accept</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:accept<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "item-type" | "record-type" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract" | "hidden"&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-use-package">xsl:use-package</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-accumulator">xsl:accumulator</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:accumulator</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:accumulator<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>initial-value</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-accumulator-rule">xsl:accumulator-rule</a>+ --&gt;<br>&lt;/xsl:accumulator&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-accumulator-rule">xsl:accumulator-rule</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:accumulator-rule</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:accumulator-rule<br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;phase? = "start" | "end"〔'start'〕<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;capture? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:accumulator-rule&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-accumulator">xsl:accumulator</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-analyze-string">xsl:analyze-string</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:analyze-string</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:analyze-string<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;<b>regex</b> = { <var>string</var> }<br>&nbsp;&nbsp;flags? = { <var>string</var> }〔''〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-matching-substring">xsl:matching-substring</a>?, <a href="#element-non-matching-substring">xsl:non-matching-substring</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:analyze-string&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-apply-imports">xsl:apply-imports</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:apply-imports</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:apply-imports&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:apply-imports&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-apply-templates">xsl:apply-templates</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:apply-templates</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:apply-templates<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;mode? = <var>token</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a> | <a href="#element-with-param">xsl:with-param</a>)* --&gt;<br>&lt;/xsl:apply-templates&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-array">xsl:array</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:array</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:array<br>&nbsp;&nbsp;for-each? = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:array&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-array-member">xsl:array-member</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:array-member</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:array-member<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:array-member&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-assert">xsl:assert</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:assert</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:assert<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }〔'Q{http://www.w3.org/2005/xqt-errors}XTMM9001'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:assert&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-attribute">xsl:attribute</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:attribute</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:attribute<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:attribute&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-attribute-set">xsl:attribute-set</a></li>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-attribute-set">xsl:attribute-set</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:attribute-set</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:attribute-set<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var>〔''〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"〔'private'〕<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-attribute">xsl:attribute</a>* --&gt;<br>&lt;/xsl:attribute-set&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                        <li><a href="#element-override">xsl:override</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-break">xsl:break</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:break</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:break<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:break&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-call-template">xsl:call-template</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:call-template</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:call-template<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-with-param">xsl:with-param</a>* --&gt;<br>&lt;/xsl:call-template&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-catch">xsl:catch</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:catch</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:catch<br>&nbsp;&nbsp;errors? = <var>tokens</var>〔'*'〕<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:catch&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-try">xsl:try</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-character-map">xsl:character-map</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:character-map</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:character-map<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-output-character">xsl:output-character</a>*) --&gt;<br>&lt;/xsl:character-map&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-choose">xsl:choose</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:choose</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:choose&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?) --&gt;<br>&lt;/xsl:choose&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-comment">xsl:comment</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:comment</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:comment<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:comment&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-context-item">xsl:context-item</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:context-item</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"〔'optional'〕&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-template">xsl:template</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-copy">xsl:copy</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:copy</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:copy<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var>〔''〕<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:copy&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-copy-of">xsl:copy-of</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:copy-of</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:copy-of<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;copy-accumulators? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-decimal-format">xsl:decimal-format</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:decimal-format</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:decimal-format<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;decimal-separator? = <var>string</var>〔'.'〕<br>&nbsp;&nbsp;grouping-separator? = <var>string</var>〔','〕<br>&nbsp;&nbsp;infinity? = <var>string</var>〔'Infinity'〕<br>&nbsp;&nbsp;minus-sign? = <var>string</var>〔'-'〕<br>&nbsp;&nbsp;exponent-separator? = <var>string</var>〔'e'〕<br>&nbsp;&nbsp;NaN? = <var>string</var>〔'NaN'〕<br>&nbsp;&nbsp;percent? = <var>string</var>〔'%'〕<br>&nbsp;&nbsp;per-mille? = <var>string</var>〔'‰'〕<br>&nbsp;&nbsp;zero-digit? = <var>char</var>〔'0'〕<br>&nbsp;&nbsp;digit? = <var>char</var>〔'#'〕<br>&nbsp;&nbsp;pattern-separator? = <var>char</var>〔';'〕&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-document">xsl:document</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:document</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:document<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:document&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-element">xsl:element</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:element</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:element<br>&nbsp;&nbsp;<b>name</b> = { <var>qname</var> }<br>&nbsp;&nbsp;namespace? = { <var>uri</var> }<br>&nbsp;&nbsp;inherit-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;use-attribute-sets? = <var>eqnames</var>〔''〕<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:element&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-evaluate">xsl:evaluate</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:evaluate</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:evaluate<br>&nbsp;&nbsp;<b>xpath</b> = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;base-uri? = { <var>uri</var> }<br>&nbsp;&nbsp;with-params? = <var>expression</var><br>&nbsp;&nbsp;context-item? = <var>expression</var><br>&nbsp;&nbsp;namespace-context? = <var>expression</var><br>&nbsp;&nbsp;schema-aware? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;trusted? = { <var>boolean</var> }〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:evaluate&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-expose">xsl:expose</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:expose</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:expose<br>&nbsp;&nbsp;<b>component</b> = "template" | "function" | "attribute-set" | "variable" | "mode" | "item-type" | "record-type" | "*"<br>&nbsp;&nbsp;<b>names</b> = <var>tokens</var><br>&nbsp;&nbsp;<b>visibility</b> = "public" | "private" | "final" | "abstract"&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-fallback">xsl:fallback</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:fallback</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:fallback&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:fallback&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-analyze-string">xsl:analyze-string</a></li>
                        <li><a href="#element-evaluate">xsl:evaluate</a></li>
                        <li><a href="#element-fork">xsl:fork</a></li>
                        <li><a href="#element-merge">xsl:merge</a></li>
                        <li><a href="#element-next-match">xsl:next-match</a></li>
                        <li><a href="#element-try">xsl:try</a></li>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-field">xsl:field</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:field</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:field<br>&nbsp;&nbsp;<b>name</b> = <var>ncname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;required? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;default? = <var>expression</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-record-type">xsl:record-type</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-for-each">xsl:for-each</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:for-each</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:for-each<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-for-each-group">xsl:for-each-group</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:for-each-group</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:for-each-group<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;group-by? = <var>expression</var><br>&nbsp;&nbsp;group-adjacent? = <var>expression</var><br>&nbsp;&nbsp;group-starting-with? = <var>pattern</var><br>&nbsp;&nbsp;group-ending-with? = <var>pattern</var><br>&nbsp;&nbsp;split-when? = <var>expression</var><br>&nbsp;&nbsp;merge-when? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:for-each-group&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-fork">xsl:fork</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:fork</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:fork&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-fallback">xsl:fallback</a>*, ((<a href="#element-sequence">xsl:sequence</a>, <a href="#element-fallback">xsl:fallback</a>*)* | (<a href="#element-for-each-group">xsl:for-each-group</a>, <a href="#element-fallback">xsl:fallback</a>*))) --&gt;<br>&lt;/xsl:fork&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-function">xsl:function</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:function</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:function<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"〔'private'〕<br>&nbsp;&nbsp;streamability? = "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | <var>eqname</var>〔'unclassified'〕<br>&nbsp;&nbsp;override-extension-function? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;<span class="grayed">[override]?</span> = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;new-each-time? = "yes" | "true" | "1" | "no" | "false" | "0" | "maybe"<br>&nbsp;&nbsp;cache? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:function&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                        <li><a href="#element-override">xsl:override</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-global-context-item">xsl:global-context-item</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:global-context-item</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:global-context-item<br>&nbsp;&nbsp;as? = <var>item-type</var><br>&nbsp;&nbsp;use? = "required" | "optional" | "absent"〔'optional'〕&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-if">xsl:if</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:if</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:if<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;then? = <var>expression</var><br>&nbsp;&nbsp;else? = <var>expression</var>〔()〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:if&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-import">xsl:import</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:import</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:import<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-import-schema">xsl:import-schema</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:import-schema</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:import-schema<br>&nbsp;&nbsp;role? = <var>ncname</var><br>&nbsp;&nbsp;namespace? = <var>uri</var><br>&nbsp;&nbsp;schema-location? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: xs:schema? --&gt;<br>&lt;/xsl:import-schema&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-include">xsl:include</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:include</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:include<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-item-type">xsl:item-type</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:item-type</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:item-type<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>item-type</var>〔'item()*'〕<br>&nbsp;&nbsp;visibility? = "private" | "public"〔'private'〕&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-iterate">xsl:iterate</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:iterate</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:iterate<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-param">xsl:param</a>*, <a href="#element-on-completion">xsl:on-completion</a>?, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:iterate&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-key">xsl:key</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:key</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:key<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;<b>match</b> = <var>pattern</var><br>&nbsp;&nbsp;use? = <var>expression</var><br>&nbsp;&nbsp;composite? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;collation? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:key&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-map">xsl:map</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:map</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:map<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;duplicates? = <var>expression</var>〔fn($a, $b) { error(xs:QName(err:XTDE3365)) }〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-map-entry">xsl:map-entry</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:map-entry</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:map-entry<br>&nbsp;&nbsp;<b>key</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:map-entry&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-matching-substring">xsl:matching-substring</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:matching-substring</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:matching-substring<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:matching-substring&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-analyze-string">xsl:analyze-string</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-merge">xsl:merge</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:merge</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:merge&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-merge-source">xsl:merge-source</a>+, <a href="#element-merge-action">xsl:merge-action</a>, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:merge&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-merge-action">xsl:merge-action</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:merge-action</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:merge-action&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-action&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-merge">xsl:merge</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-merge-key">xsl:merge-key</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:merge-key</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:merge-key<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }〔'ascending'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:merge-key&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-merge-source">xsl:merge-source</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-merge-source">xsl:merge-source</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:merge-source</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:merge-source<br>&nbsp;&nbsp;name? = <var>ncname</var><br>&nbsp;&nbsp;for-each-item? = <var>expression</var><br>&nbsp;&nbsp;for-each-source? = <var>expression</var><br>&nbsp;&nbsp;<b>select</b> = <var>expression</var><br>&nbsp;&nbsp;streamable? = <var>boolean</var><br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var>〔''〕<br>&nbsp;&nbsp;sort-before-merge? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <a href="#element-merge-key">xsl:merge-key</a>+ --&gt;<br>&lt;/xsl:merge-source&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-merge">xsl:merge</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-message">xsl:message</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:message</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:message<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;terminate? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;error-code? = { <var>eqname</var> }〔'Q{http://www.w3.org/2005/xqt-errors}XTMM9000'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:message&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-mode">xsl:mode</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:mode</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:mode<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var>〔''〕<br>&nbsp;&nbsp;on-no-match? = "deep-copy" | "shallow-copy" | "shallow-copy-all" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail"〔'text-only-copy'〕<br>&nbsp;&nbsp;on-multiple-match? = "use-last" | "fail"〔'use-last'〕<br>&nbsp;&nbsp;warning-on-no-match? = <var>boolean</var><br>&nbsp;&nbsp;warning-on-multiple-match? = <var>boolean</var><br>&nbsp;&nbsp;typed? = <var>string</var>〔'unspecified'〕<br>&nbsp;&nbsp;copy-namespaces? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final"〔'private'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a>*) --&gt;<br>&lt;/xsl:mode&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-namespace">xsl:namespace</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:namespace</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:namespace<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:namespace&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-namespace-alias">xsl:namespace-alias</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:namespace-alias</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:namespace-alias<br>&nbsp;&nbsp;<b>stylesheet-prefix</b> = <var>prefix</var> | "#default"<br>&nbsp;&nbsp;<b>result-prefix</b> = <var>prefix</var> | "#default"&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-next-iteration">xsl:next-iteration</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:next-iteration</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:next-iteration&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a>*) --&gt;<br>&lt;/xsl:next-iteration&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-next-match">xsl:next-match</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:next-match</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:next-match&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-with-param">xsl:with-param</a> | <a href="#element-fallback">xsl:fallback</a>)* --&gt;<br>&lt;/xsl:next-match&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-non-matching-substring">xsl:non-matching-substring</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:non-matching-substring</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:non-matching-substring<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:non-matching-substring&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-analyze-string">xsl:analyze-string</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-note">xsl:note</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:note</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:note<br>&nbsp;&nbsp;#any#? = <var>string</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>any</var> --&gt;<br>&lt;/xsl:note&gt;</code></p>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-number">xsl:number</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:number</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:number<br>&nbsp;&nbsp;value? = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;level? = "single" | "multiple" | "any"〔'single'〕<br>&nbsp;&nbsp;count? = <var>pattern</var><br>&nbsp;&nbsp;from? = <var>pattern</var><br>&nbsp;&nbsp;format? = { <var>string</var> }〔'1'〕<br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;letter-value? = { "alphabetic" | "traditional" }<br>&nbsp;&nbsp;ordinal? = { <var>string</var> }〔'no'〕<br>&nbsp;&nbsp;start-at? = { <var>string</var> }<br>&nbsp;&nbsp;grouping-separator? = { <var>char</var> }<br>&nbsp;&nbsp;grouping-size? = { <var>integer</var> }&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-on-completion">xsl:on-completion</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:on-completion</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:on-completion<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-completion&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-iterate">xsl:iterate</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-on-empty">xsl:on-empty</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:on-empty</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:on-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-empty&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-on-non-empty">xsl:on-non-empty</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:on-non-empty</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:on-non-empty<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:on-non-empty&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-otherwise">xsl:otherwise</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:otherwise</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-choose">xsl:choose</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-otherwise">xsl:otherwise</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:otherwise</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:otherwise<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:otherwise&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-choose">xsl:choose</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-output">xsl:output</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:output</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:output<br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;method? = "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var><br>&nbsp;&nbsp;allow-duplicate-names? = <var>boolean</var><br>&nbsp;&nbsp;build-tree? = <var>boolean</var><br>&nbsp;&nbsp;byte-order-mark? = <var>boolean</var><br>&nbsp;&nbsp;canonical? = <var>boolean</var><br>&nbsp;&nbsp;cdata-section-elements? = <var>eqnames</var><br>&nbsp;&nbsp;doctype-public? = <var>string</var><br>&nbsp;&nbsp;doctype-system? = <var>string</var><br>&nbsp;&nbsp;encoding? = <var>string</var><br>&nbsp;&nbsp;escape-solidus? = <var>boolean</var><br>&nbsp;&nbsp;escape-uri-attributes? = <var>boolean</var><br>&nbsp;&nbsp;html-version? = <var>decimal</var><br>&nbsp;&nbsp;include-content-type? = <var>boolean</var><br>&nbsp;&nbsp;indent? = <var>boolean</var><br>&nbsp;&nbsp;item-separator? = <var>string</var><br>&nbsp;&nbsp;json-lines? = <var>boolean</var><br>&nbsp;&nbsp;json-node-output-method? = "xml" | "html" | "xhtml" | "text" | <var>eqname</var><br>&nbsp;&nbsp;media-type? = <var>string</var><br>&nbsp;&nbsp;normalization-form? = "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var><br>&nbsp;&nbsp;omit-xml-declaration? = <var>boolean</var><br>&nbsp;&nbsp;parameter-document? = <var>uri</var><br>&nbsp;&nbsp;standalone? = <var>boolean</var> | "omit"<br>&nbsp;&nbsp;suppress-indentation? = <var>eqnames</var><br>&nbsp;&nbsp;undeclare-prefixes? = <var>boolean</var><br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;version? = <var>nmtoken</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-output-character">xsl:output-character</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:output-character</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:output-character<br>&nbsp;&nbsp;<b>character</b> = <var>char</var><br>&nbsp;&nbsp;<b>string</b> = <var>string</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-character-map">xsl:character-map</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-override">xsl:override</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:override</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:override&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-template">xsl:template</a> | <a href="#element-function">xsl:function</a> | <a href="#element-variable">xsl:variable</a> | <a href="#element-param">xsl:param</a> | <a href="#element-attribute-set">xsl:attribute-set</a>)* --&gt;<br>&lt;/xsl:override&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-use-package">xsl:use-package</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-package">xsl:package</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:package</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:package<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;name? = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var>〔'1'〕<br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;declared-modes? = <var>boolean</var>〔'yes'〕<br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: ((<a href="#element-expose">xsl:expose</a> | <var>declarations</var>)*) --&gt;<br>&lt;/xsl:package&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>None</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-package-location">xsl:package-location</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:package-location</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:package-location<br>&nbsp;&nbsp;<b>href</b> = <var>uri</var><br>&nbsp;&nbsp;path-in-archive? = <var>string</var><br>&nbsp;&nbsp;archive-type? = <var>string</var><br>&nbsp;&nbsp;is-priority? = <var>boolean</var>〔true()〕<br>&nbsp;&nbsp;format? = <var>string</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-use-package">xsl:use-package</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-param">xsl:param</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:param</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;required? = <var>boolean</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;static? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:param&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                        <li><a href="#element-override">xsl:override</a></li>
                        <li><a href="#element-function">xsl:function</a></li>
                        <li><a href="#element-template">xsl:template</a></li>
                        <li><a href="#element-iterate">xsl:iterate</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-perform-sort">xsl:perform-sort</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:perform-sort</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:perform-sort<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-sort">xsl:sort</a>+, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:perform-sort&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-preserve-space">xsl:preserve-space</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:preserve-space</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:preserve-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-processing-instruction">xsl:processing-instruction</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:processing-instruction</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:processing-instruction<br>&nbsp;&nbsp;<b>name</b> = { <var>ncname</var> }<br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:processing-instruction&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-record">xsl:record</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:record</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:record<br>&nbsp;&nbsp;xsl:as? = <var>item-type</var>〔'map(*)'〕<br>&nbsp;&nbsp;xsl:duplicates? = <var>expression</var>〔fn($a, $b) { error(xs:QName(err:XTDE3365)) }〕<br>&nbsp;&nbsp;<b>*</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:record&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-record-type">xsl:record-type</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:record-type</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:record-type<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;constructor? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;extensible? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;visibility? = "private" | "public"〔'private'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-field">xsl:field</a>*) --&gt;<br>&lt;/xsl:record-type&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-result-document">xsl:result-document</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:result-document</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:result-document<br>&nbsp;&nbsp;format? = { <var>eqname</var> }<br>&nbsp;&nbsp;href? = { <var>uri</var> }<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var><br>&nbsp;&nbsp;method? = { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | <var>eqname</var> }<br>&nbsp;&nbsp;allow-duplicate-names? = { <var>boolean</var> }<br>&nbsp;&nbsp;build-tree? = { <var>boolean</var> }<br>&nbsp;&nbsp;byte-order-mark? = { <var>boolean</var> }<br>&nbsp;&nbsp;canonical? = { <var>boolean</var> }<br>&nbsp;&nbsp;cdata-section-elements? = { <var>eqnames</var> }<br>&nbsp;&nbsp;doctype-public? = { <var>string</var> }<br>&nbsp;&nbsp;doctype-system? = { <var>string</var> }<br>&nbsp;&nbsp;encoding? = { <var>string</var> }<br>&nbsp;&nbsp;escape-solidus? = { <var>boolean</var> }<br>&nbsp;&nbsp;escape-uri-attributes? = { <var>boolean</var> }<br>&nbsp;&nbsp;html-version? = { <var>decimal</var> }<br>&nbsp;&nbsp;include-content-type? = { <var>boolean</var> }<br>&nbsp;&nbsp;indent? = { <var>boolean</var> }<br>&nbsp;&nbsp;item-separator? = { <var>string</var> }<br>&nbsp;&nbsp;json-lines? = { <var>boolean</var> }<br>&nbsp;&nbsp;json-node-output-method? = { "xml" | "html" | "xhtml" | "text" | <var>eqname</var> }<br>&nbsp;&nbsp;media-type? = { <var>string</var> }<br>&nbsp;&nbsp;normalization-form? = { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | <var>nmtoken</var> }<br>&nbsp;&nbsp;omit-xml-declaration? = { <var>boolean</var> }<br>&nbsp;&nbsp;parameter-document? = { <var>uri</var> }<br>&nbsp;&nbsp;standalone? = { <var>boolean</var> | "omit" }<br>&nbsp;&nbsp;suppress-indentation? = { <var>eqnames</var> }<br>&nbsp;&nbsp;undeclare-prefixes? = { <var>boolean</var> }<br>&nbsp;&nbsp;use-character-maps? = <var>eqnames</var><br>&nbsp;&nbsp;output-version? = { <var>nmtoken</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:result-document&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-select">xsl:select</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:select</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:select<br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-fallback">xsl:fallback</a>*#PCDATA) --&gt;<br>&lt;/xsl:select&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-sequence">xsl:sequence</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:sequence</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:sequence<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sequence&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-sort">xsl:sort</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:sort</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:sort<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;lang? = { <var>language</var> }<br>&nbsp;&nbsp;order? = { "ascending" | "descending" }〔'ascending'〕<br>&nbsp;&nbsp;collation? = { <var>uri</var> }<br>&nbsp;&nbsp;stable? = { <var>boolean</var> }〔'yes'〕<br>&nbsp;&nbsp;case-order? = { "upper-first" | "lower-first" }<br>&nbsp;&nbsp;data-type? = { "text" | "number" | <var>eqname</var> }&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:sort&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-apply-templates">xsl:apply-templates</a></li>
                        <li><a href="#element-for-each">xsl:for-each</a></li>
                        <li><a href="#element-for-each-group">xsl:for-each-group</a></li>
                        <li><a href="#element-perform-sort">xsl:perform-sort</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-source-document">xsl:source-document</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:source-document</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:source-document<br>&nbsp;&nbsp;<b>href</b> = { <var>uri</var> }<br>&nbsp;&nbsp;streamable? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;use-accumulators? = <var>tokens</var>〔''〕<br>&nbsp;&nbsp;validation? = "strict" | "lax" | "preserve" | "strip"<br>&nbsp;&nbsp;type? = <var>eqname</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:source-document&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-strip-space">xsl:strip-space</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:strip-space</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:strip-space<br>&nbsp;&nbsp;<b>elements</b> = <var>tokens</var>&nbsp;/&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-stylesheet">xsl:stylesheet</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:stylesheet</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:stylesheet<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var><br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:stylesheet&gt;</code></p>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-switch">xsl:switch</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:switch</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:switch<br>&nbsp;&nbsp;<b>select</b> = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-when">xsl:when</a>+, <a href="#element-otherwise">xsl:otherwise</a>?, <a href="#element-fallback">xsl:fallback</a>*) --&gt;<br>&lt;/xsl:switch&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-template">xsl:template</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:template</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:template<br>&nbsp;&nbsp;match? = <var>pattern</var><br>&nbsp;&nbsp;name? = <var>eqname</var><br>&nbsp;&nbsp;priority? = <var>decimal</var><br>&nbsp;&nbsp;mode? = <var>tokens</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var>〔'item()*'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-context-item">xsl:context-item</a>?, <a href="#element-param">xsl:param</a>*, <var>sequence-constructor</var>) --&gt;<br>&lt;/xsl:template&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                        <li><a href="#element-override">xsl:override</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-text">xsl:text</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:text</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:text<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;cdata? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:text&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-transform">xsl:transform</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:transform</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:transform<br>&nbsp;&nbsp;id? = <var>id</var><br>&nbsp;&nbsp;<b>version</b> = <var>decimal</var><br>&nbsp;&nbsp;default-mode? = <var>eqname</var> | "#unnamed"〔'#unnamed'〕<br>&nbsp;&nbsp;default-validation? = "preserve" | "strip"〔'strip'〕<br>&nbsp;&nbsp;input-type-annotations? = "preserve" | "strip" | "unspecified"〔'unspecified'〕<br>&nbsp;&nbsp;default-collation? = <var>uris</var><br>&nbsp;&nbsp;extension-element-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;exclude-result-prefixes? = <var>prefixes</var><br>&nbsp;&nbsp;expand-text? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;fixed-namespaces? = <var>string</var><br>&nbsp;&nbsp;main-module? = <var>uri</var><br>&nbsp;&nbsp;schema-role? = <var>ncname</var><br>&nbsp;&nbsp;use-when? = <var>expression</var>〔true()〕<br>&nbsp;&nbsp;xpath-default-namespace? = <var>uri</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>declarations</var>) --&gt;<br>&lt;/xsl:transform&gt;</code></p>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-try">xsl:try</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:try</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:try<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;rollback-output? = <var>boolean</var>〔'yes'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<var>sequence-constructor</var>, <a href="#element-catch">xsl:catch</a>, (<a href="#element-catch">xsl:catch</a> | <a href="#element-fallback">xsl:fallback</a>)*) --&gt;<br>&lt;/xsl:try&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-use-package">xsl:use-package</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:use-package</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:use-package<br>&nbsp;&nbsp;<b>name</b> = <var>uri</var><br>&nbsp;&nbsp;package-version? = <var>string</var>〔'*'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: (<a href="#element-package-location">xsl:package-location</a> | <a href="#element-accept">xsl:accept</a> | <a href="#element-override">xsl:override</a>)* --&gt;<br>&lt;/xsl:use-package&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-value-of">xsl:value-of</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:value-of</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:value-of<br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;separator? = { <var>string</var> }<br>&nbsp;&nbsp;cdata? = { <var>boolean</var> }〔'no'〕<br>&nbsp;&nbsp;<span class="grayed">[disable-output-escaping]?</span> = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:value-of&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-variable">xsl:variable</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:variable</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>declaration instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:variable<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;static? = <var>boolean</var>〔'no'〕<br>&nbsp;&nbsp;visibility? = "public" | "private" | "final" | "abstract"&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:variable&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-package">xsl:package</a></li>
                        <li><a href="#element-stylesheet">xsl:stylesheet</a></li>
                        <li><a href="#element-transform">xsl:transform</a></li>
                        <li><a href="#element-override">xsl:override</a></li>
                        <li><a href="#element-function">xsl:function</a></li>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-when">xsl:when</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:when</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-choose">xsl:choose</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-when">xsl:when</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:when</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:when<br>&nbsp;&nbsp;<b>test</b> = <var>expression</var><br>&nbsp;&nbsp;select? = <var>expression</var>&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:when&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-choose">xsl:choose</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-where-populated">xsl:where-populated</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:where-populated</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Category: </i>instruction</p>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:where-populated&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:where-populated&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li>any XSLT element whose content model is <i>sequence constructor</i></li>
                        <li>any literal result element</li>
                     </ul>
                  </td>
               </tr>
            </table>
            <p><b><a href="#element-with-param">xsl:with-param</a></b></p>
            <table style="width:100%">
               <caption>Syntax summary for element xsl:with-param</caption>
               <tr>
                  <td style="width:10%">&nbsp;</td>
                  <td>
                     <p><i>Model:</i></p>
                     <p class="element-syntax-summary"><code>&lt;xsl:with-param<br>&nbsp;&nbsp;<b>name</b> = <var>eqname</var><br>&nbsp;&nbsp;select? = <var>expression</var><br>&nbsp;&nbsp;as? = <var>sequence-type</var><br>&nbsp;&nbsp;tunnel? = <var>boolean</var>〔'no'〕&nbsp;&gt;<br>&nbsp;&nbsp;&lt;!-- Content: <var>sequence-constructor</var> --&gt;<br>&lt;/xsl:with-param&gt;</code></p>
                     <p><i>Permitted parent elements:</i></p>
                     <ul>
                        <li><a href="#element-apply-templates">xsl:apply-templates</a></li>
                        <li><a href="#element-apply-imports">xsl:apply-imports</a></li>
                        <li><a href="#element-call-template">xsl:call-template</a></li>
                        <li><a href="#element-evaluate">xsl:evaluate</a></li>
                        <li><a href="#element-next-match">xsl:next-match</a></li>
                        <li><a href="#element-next-iteration">xsl:next-iteration</a></li>
                     </ul>
                  </td>
               </tr>
            </table>
         </div>
         <div class="div1">
            
            <h2><a id="error-summary"></a>D <a href="#error-summary" style="text-decoration: none">Summary of Error Conditions</a> (Non-Normative)</h2>
            <p>This appendix provides a summary of error conditions that a processor
            may raise. This list includes all error codes defined in this specification, but this
            is not an exhaustive list of all errors that can occur. Implementations
               <span class="verb">must</span> raise errors using these error codes, and applications can
            test for these codes; however, when more than one rule in the specification is violated,
            different processors will not necessarily raise the same error code. Implementations
            are not <span class="verb">required</span> to raise errors using the descriptive text used
            here.</p>
            <div class="note">
               <p class="prefix"><b>Note:</b></p>
               <p>The appendix is non-normative because the same information is given normatively
               elsewhere.</p>
            </div>
            <p><b>Static errors</b></p>
            <dl>
               <dt><a href="#err-XTSE0010"><span class="error">ERR XTSE0010</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                     XSLT-defined element is used in a context where it is not permitted, if a
                        <span class="verb">required</span> attribute is omitted, or if the content of the
                     element does not correspond to the content that is allowed for the element.</p>
               </dd>
               <dt><a href="#err-XTSE0020"><span class="error">ERR XTSE0020</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                           attribute (other than an attribute written using curly brackets in a
                           position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute
                              value template</a> is permitted) contains a value that is not
                           one of the permitted values for that attribute.</p>
               </dd>
               <dt><a href="#err-XTSE0080"><span class="error">ERR XTSE0080</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a
                           <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a> in the
                        name of a <a title="named template" class="termref" href="#dt-named-template">named template</a>, a
                           <a title="mode" class="termref" href="#dt-mode">mode</a>, an <a title="attribute set" class="termref" href="#dt-attribute-set">attribute set</a>, a <a title="key" class="termref" href="#dt-key">key</a>, a
                           <a title="decimal format" class="termref" href="#dt-decimal-format">decimal-format</a>, a <a title="variable" class="termref" href="#dt-variable">variable</a> or <a title="parameter" class="termref" href="#dt-parameter">parameter</a>, a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet
                           function</a>, a named <a title="output definition" class="termref" href="#dt-output-definition">output
                           definition</a>, an <a title="accumulator" class="termref" href="#dt-accumulator">accumulator</a>, or a <a title="character map" class="termref" href="#dt-character-map">character map</a><span>; except that the name
                              <code>xsl:initial-template</code> is permitted as a template
                           name.</span></p>
               </dd>
               <dt><a href="#err-XTSE0085"><span class="error">ERR XTSE0085</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>
                  in the name of any <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attribute</a>, 
                  <a title="extension function" class="termref" href="#dt-extension-function">extension function</a>, or <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>,
                  other than a function or instruction defined in this specification or in a normatively 
                  referenced specification. It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use a prefix bound 
                  to a reserved namespace in the <code>[xsl:]extension-element-prefixes</code> attribute.
               </p>
               </dd>
               <dt><a href="#err-XTSE0090"><span class="error">ERR XTSE0090</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an element
                     from the XSLT namespace to have an attribute whose namespace is either null
                     (that is, an attribute with an unprefixed name) or the XSLT namespace, other
                     than attributes defined for the element in this document.</p>
               </dd>
               <dt><a href="#err-XTSE0110"><span class="error">ERR XTSE0110</span></a></dt>
               <dd>
                  <p>The value of the <code>version</code> attribute <span class="verb">must</span> be a number:
                     specifically, it <span class="verb">must</span> be a valid instance of the type
                        <code>xs:decimal</code> as defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0120"><span class="error">ERR XTSE0120</span></a></dt>
               <dd>
                  <p>An <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>,
                  or <a href="#element-package"><code>xsl:package</code></a> element <span class="verb">must not</span> have any
                     text node children.</p>
               </dd>
               <dt><a href="#err-XTSE0122"><span class="error">ERR XTSE0122</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token
                        appearing in the <code>fixed-namespaces</code> attribute takes a form
                        that is not one of the permitted forms, or if it is interpreted as a URI
                     but cannot be dereferenced to locate a namespace well-formed XML document.
                     It is not permitted to bind the prefix <code>xmlns</code>. It is not permitted to bind the
                        prefix <code>xml</code> or the XML namespace URI <code>http://www.w3.org/XML/1998/namespace</code>, other than
                     to each other.</p>
               </dd>
               <dt><a href="#err-XTSE0125"><span class="error">ERR XTSE0125</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value
                        of an <code>[xsl:]default-collation</code> attribute, after resolving
                        against the base URI, contains no URI that the implementation recognizes as
                        a collation URI.</p>
               </dd>
               <dt><a href="#err-XTSE0130"><span class="error">ERR XTSE0130</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>,
                           or <a href="#element-package"><code>xsl:package</code></a> element has a child element whose name
                        has a null namespace URI.</p>
               </dd>
               <dt><a href="#err-XTSE0165"><span class="error">ERR XTSE0165</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        processor is not able to retrieve the resource identified by the URI
                           reference [ in the <code>href</code> attribute of
                              <a href="#element-include"><code>xsl:include</code></a> or <a href="#element-import"><code>xsl:import</code></a>
                        ] , or if the resource that is retrieved does not contain a
                        stylesheet module.</p>
               </dd>
               <dt><a href="#err-XTSE0170"><span class="error">ERR XTSE0170</span></a></dt>
               <dd>
                  <p>An <a href="#element-include"><code>xsl:include</code></a> element <span class="verb">must</span> be a
                           <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p>
               </dd>
               <dt><a href="#err-XTSE0190"><span class="error">ERR XTSE0190</span></a></dt>
               <dd>
                  <p>An <a href="#element-import"><code>xsl:import</code></a> element <span class="verb">must</span> be a <a title="top-level" class="termref" href="#dt-top-level">top-level</a> element.</p>
               </dd>
               <dt><a href="#err-XTSE0210"><span class="error">ERR XTSE0210</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                        stylesheet module directly or indirectly references itself via a chain
                        of <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a>
                        declarations that contains at least one <a href="#element-import"><code>xsl:import</code></a>.</p>
               </dd>
               <dt><a href="#err-XTSE0215"><span class="error">ERR XTSE0215</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-import-schema"><code>xsl:import-schema</code></a> element that contains an
                        <code>xs:schema</code> element has a <code>schema-location</code> attribute,
                     or if it has a <code>namespace</code> attribute that conflicts with the target
                     namespace of the contained schema.</p>
               </dd>
               <dt><a href="#err-XTSE0220"><span class="error">ERR XTSE0220</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the synthetic
                     schema document does not satisfy the constraints described in <a href="#xmlschema-1">[XML Schema Part 1]</a> (section 5.1, <em>Errors in Schema Construction and
                        Structure</em>). This includes, without loss of generality, conflicts such
                     as multiple definitions of the same name.</p>
               </dd>
               <dt><a href="#err-XTSE0260"><span class="error">ERR XTSE0260</span></a></dt>
               <dd>
                  <p>Within an <a title="XSLT element" class="termref" href="#dt-xslt-element">XSLT element</a> that is
                        <span class="verb">required</span> to be empty, any content other than comments or
                        processing instructions, including any <a title="whitespace text node" class="termref" href="#dt-whitespace-text-node">whitespace text node</a> preserved using the
                        <code>xml:space="preserve"</code> attribute, is a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0265"><span class="error">ERR XTSE0265</span></a></dt>
               <dd>
                  <p> It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is a
                        <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> in a
                        <a title="package" class="termref" href="#dt-package">package</a> that specifies
                        <code>input-type-annotations="strip"</code> and another <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that specifies
                        <code>input-type-annotations="preserve"</code>, or if a stylesheet module specifies the value
                           <code>strip</code> or <code>preserve</code> and the same value is not
                        specified on the <a href="#element-package"><code>xsl:package</code></a> element of the containing
                        package.</p>
               </dd>
               <dt><a href="#err-XTSE0270"><span class="error">ERR XTSE0270</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within any <a title="package" class="termref" href="#dt-package">package</a> the same <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> appears in both an
                        <a href="#element-strip-space"><code>xsl:strip-space</code></a> and an <a href="#element-preserve-space"><code>xsl:preserve-space</code></a>
                     declaration if both have the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                        precedence</a>. Two NameTests are considered the same if they match
                     the same set of names (which can be determined by comparing them after
                     expanding namespace prefixes to URIs).</p>
               </dd>
               <dt><a href="#err-XTSE0280"><span class="error">ERR XTSE0280</span></a></dt>
               <dd>
                  <p>In the case of a prefixed <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                                 QName</a> used as the value (or as
                                 part of the value) of an attribute in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, or appearing within an
                              XPath <a title="expression" class="termref" href="#dt-expression">expression</a> in the
                              stylesheet, it is a <a title="static error" class="termref" href="#dt-static-error">static
                                 error</a> if the <a title="defining element" class="termref" href="#dt-defining-element">defining
                                 element</a> has no namespace node whose name matches the
                              prefix of the <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                              QName</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0340"><span class="error">ERR XTSE0340</span></a></dt>
               <dd>
                  <p>Where an attribute is defined to contain a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>, it is a <a title="static error" class="termref" href="#dt-static-error">static
                           error</a> if the pattern does not match the production <a href="#doc-xslt40-Pattern">Pattern</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0350"><span class="error">ERR XTSE0350</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped
                     left curly bracket appears in a fixed part of a value template without a
                     matching right curly bracket.</p>
               </dd>
               <dt><a href="#err-XTSE0370"><span class="error">ERR XTSE0370</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an unescaped
                     right curly bracket occurs in a fixed part of a value template.</p>
               </dd>
               <dt><a href="#err-XTSE0500"><span class="error">ERR XTSE0500</span></a></dt>
               <dd>
                  <p>An <a href="#element-template"><code>xsl:template</code></a> element <span class="verb">must</span> have either a
                        <code>match</code> attribute or a <code>name</code> attribute, or both. An
                        <a href="#element-template"><code>xsl:template</code></a> element that has no <code>match</code>
                     attribute <span class="verb">must</span> have no <code>mode</code> attribute and no
                        <code>priority</code> attribute. An
                           <a href="#element-template"><code>xsl:template</code></a> element that has no <code>name</code>
                        attribute <span class="verb">must</span> have no <code>visibility</code>
                        attribute.</p>
               </dd>
               <dt><a href="#err-XTSE0530"><span class="error">ERR XTSE0530</span></a></dt>
               <dd>
                  <p>The value of the <code>priority</code> attribute  [ of the
                                 <a href="#element-template"><code>xsl:template</code></a> element] 
                           <span class="verb">must</span> conform to the rules for the
                              <code>xs:decimal</code> type defined in <a href="#xmlschema-2">[XML Schema Part 2]</a>.
                           Negative values are permitted.</p>
               </dd>
               <dt><a href="#err-XTSE0545"><span class="error">ERR XTSE0545</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if for any
                        named or unnamed <a title="mode" class="termref" href="#dt-mode">mode</a>, a package explicitly specifies two conflicting
                        values for the same attribute in different <a href="#element-mode"><code>xsl:mode</code></a>
                        declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                           precedence</a>, unless there is another definition of the same
                        attribute with higher import precedence. The attributes in question are the
                        attributes other than <code>name</code> on the <a href="#element-mode"><code>xsl:mode</code></a>
                           element.</p>
               </dd>
               <dt><a href="#err-XTSE0550"><span class="error">ERR XTSE0550</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of
                        modes  [in the <code>mode</code> attribute of
                              <a href="#element-template"><code>xsl:template</code></a>
                        ]  is empty, if the same token is included more than once in the
                        list, if the list contains an invalid token, or if the token
                           <code>#all</code> appears together with any other value.</p>
               </dd>
               <dt><a href="#err-XTSE0580"><span class="error">ERR XTSE0580</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the values of
                     the <code>name</code> attribute of two sibling
                           <a href="#element-param"><code>xsl:param</code></a> elements represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0620"><span class="error">ERR XTSE0620</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if a <a title="variable-binding element" class="termref" href="#dt-variable-binding-element">variable-binding element</a> has a
                        <code>select</code> attribute and has non-empty content.</p>
               </dd>
               <dt><a href="#err-XTSE0630"><span class="error">ERR XTSE0630</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains more
                     than one non-hidden binding of a global
                     variable with the same name and same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                        precedence</a>, unless it also contains another binding with the same
                     name and higher import precedence.</p>
               </dd>
               <dt><a href="#err-XTSE0650"><span class="error">ERR XTSE0650</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains an
                        <a href="#element-call-template"><code>xsl:call-template</code></a> instruction whose <code>name</code>
                        attribute does not match the <code>name</code> attribute of any <a title="named template" class="termref" href="#dt-named-template">named template</a>
                        visible in the containing <a title="package" class="termref" href="#dt-package">package</a> (this
                        includes any template defined in this package, as well as templates accepted
                        from used packages whose visibility in this package is not
                        <code>hidden</code>). For more details of the process of binding the
                        called template, see <a href="#component-references"><i>3.4.4.5 Binding References to Components</i></a>.</p>
               </dd>
               <dt><a href="#err-XTSE0660"><span class="error">ERR XTSE0660</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a 
                     
                        <a title="package" class="termref" href="#dt-package">package</a> contains more than one
                        non-hidden
                     <a title="template" class="termref" href="#dt-template">template</a> with the same name and the same
                        <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it
                     also contains a <a title="template" class="termref" href="#dt-template">template</a> with the same
                     name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import
                     precedence</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0670"><span class="error">ERR XTSE0670</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>
                     if two or more sibling <a href="#element-with-param"><code>xsl:with-param</code></a> elements have
                        <code>name</code> attributes that represent the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0680"><span class="error">ERR XTSE0680</span></a></dt>
               <dd>
                  <p>In the case of <a href="#element-call-template"><code>xsl:call-template</code></a>, it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to pass a non-tunnel
                        parameter named <var>x</var> to a template that does not have a non-tunnel
                        <a title="template parameter" class="termref" href="#dt-template-parameter">template
                           parameter</a> named <var>x</var>, unless the <a href="#element-call-template"><code>xsl:call-template</code></a> instruction is processed with
                              <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0
                           behavior</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0690"><span class="error">ERR XTSE0690</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                                 <a title="package" class="termref" href="#dt-package">package</a> contains both (a) a
                              named template named <var>T</var> that is not overridden by another
                              named template of higher import precedence and that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> non-tunnel parameter named
                                 <var>P</var>, and (b) an <a href="#element-call-template"><code>xsl:call-template</code></a>
                              instruction whose <code>name</code> attribute equals <var>T</var> and
                              that has no non-tunnel <a href="#element-with-param"><code>xsl:with-param</code></a> child element
                              whose <code>name</code> attribute equals <var>P</var>. (All names are
                              compared as QNames.)</p>
               </dd>
               <dt><a href="#err-XTSE0710"><span class="error">ERR XTSE0710</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value
                        of the <code>use-attribute-sets</code> attribute of an
                           <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-element"><code>xsl:element</code></a>, or
                           <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> element, or the
                           <code>xsl:use-attribute-sets</code> attribute of a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>, is not
                        a whitespace-separated sequence of <a title="EQName" class="termref" href="#dt-eqname">EQNames</a>, or if it contains an
                        EQName that does not match the <code>name</code> attribute of any
                           <a href="#element-attribute-set"><code>xsl:attribute-set</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>.</p>
               </dd>
               <dt><a href="#err-XTSE0740"><span class="error">ERR XTSE0740</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> has a name
                        that is in no namespace, unless the <a title="visibility" class="termref" href="#dt-visibility">visibility</a>
                     of the function is <code>private</code>.</p>
               </dd>
               <dt><a href="#err-XTSE0760"><span class="error">ERR XTSE0760</span></a></dt>
               <dd>
                  <p>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of
                        an <a href="#element-function"><code>xsl:function</code></a> element has either a <code>select</code>
                        attribute or non-empty content<span>, unless it
                        specifies <code>required="no"</code>.</span></p>
               </dd>
               <dt><a href="#err-XTSE0761"><span class="error">ERR XTSE0761</span></a></dt>
               <dd>
                  <p>It is a static error if an <a href="#element-param"><code>xsl:param</code></a> child of
                        an <a href="#element-function"><code>xsl:function</code></a> element specifies
                     <code>required="no"</code>, unless all following-sibling
                        <a href="#element-param"><code>xsl:param</code></a> elements also specify <code>required="no"</code>.</p>
               </dd>
               <dt><a href="#err-XTSE0769"><span class="error">ERR XTSE0769</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to
                           contain an <a href="#element-function"><code>xsl:function</code></a>
                           declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration
                           <var>G</var> such that <var>F</var> and <var>G</var> have the same 
                           <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, <var>F</var> has lower
                           <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> than <var>G</var>, and the 
                           <a title="arity range" class="termref" href="#dt-arity-range">arity range</a>
                           of <var>G</var> includes part but not all of the arity range of <var>F</var>,
                           unless <var>G</var> is itself <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another 
                           <a href="#element-function"><code>xsl:function</code></a> declaration.</p>
               </dd>
               <dt><a href="#err-XTSE0770"><span class="error">ERR XTSE0770</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for a <a title="package" class="termref" href="#dt-package">package</a> to
                           contain an <a href="#element-function"><code>xsl:function</code></a>
                           declaration <var>F</var> and an <a href="#element-function"><code>xsl:function</code></a> declaration
                           <var>G</var> such that <var>F</var> and <var>G</var> have the same 
                           <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> and the same
                           <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, if the 
                           <a title="arity range" class="termref" href="#dt-arity-range">arity ranges</a>
                           of <var>F</var> and <var>G</var> overlap in whole or in part, 
                           unless <var>F</var> and <var>G</var> are both <a title="eclipsed" class="termref" href="#dt-eclipsed">eclipsed</a> by another 
                           <a href="#element-function"><code>xsl:function</code></a> declaration.</p>
               </dd>
               <dt><a href="#err-XTSE0805"><span class="error">ERR XTSE0805</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        attribute on a literal result element is in the <a title="XSLT namespace" class="termref" href="#dt-xslt-namespace">XSLT namespace</a>, unless it is one of the
                        attributes explicitly defined in this specification.</p>
               </dd>
               <dt><a href="#err-XTSE0808"><span class="error">ERR XTSE0808</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                              namespace prefix is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and there is
                              no namespace binding in scope for that prefix.</p>
               </dd>
               <dt><a href="#err-XTSE0809"><span class="error">ERR XTSE0809</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                              value <code>#default</code> is used within the
                                 <code>[xsl:]exclude-result-prefixes</code> attribute and the parent
                              element of the <code>[xsl:]exclude-result-prefixes</code> attribute
                              has no default namespace.</p>
               </dd>
               <dt><a href="#err-XTSE0810"><span class="error">ERR XTSE0810</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if within a <a title="package" class="termref" href="#dt-package">package</a> there is more than one such declaration
                            [more than one <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a>
                           declaration]  with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and the
                        same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a> and
                        different values for the <a title="target namespace URI" class="termref" href="#dt-target-namespace-uri">target
                           namespace URI</a>, unless there is also an
                           <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> declaration with the same <a title="literal namespace URI" class="termref" href="#dt-literal-namespace-uri">literal namespace URI</a> and a
                        higher import precedence. </p>
               </dd>
               <dt><a href="#err-XTSE0812"><span class="error">ERR XTSE0812</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a value
                        other than <code>#default</code> is specified for either the
                           <code>stylesheet-prefix</code> or the <code>result-prefix</code>
                        attributes of the <a href="#element-namespace-alias"><code>xsl:namespace-alias</code></a> element when there is
                        no in-scope binding for that namespace prefix.</p>
               </dd>
               <dt><a href="#err-XTSE0840"><span class="error">ERR XTSE0840</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-attribute"><code>xsl:attribute</code></a> element
                     is present unless the element has empty content.</p>
               </dd>
               <dt><a href="#err-XTSE0870"><span class="error">ERR XTSE0870</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           <code>select</code> attribute of the <a href="#element-text"><code>xsl:text</code></a> or 
                        <a href="#element-value-of"><code>xsl:value-of</code></a>
                        element is present when the content of the element is non-empty.</p>
               </dd>
               <dt><a href="#err-XTSE0880"><span class="error">ERR XTSE0880</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the
                        <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a> element is present unless the
                     element has empty content.</p>
               </dd>
               <dt><a href="#err-XTSE0910"><span class="error">ERR XTSE0910</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-namespace"><code>xsl:namespace</code></a> element
                     is present when the element has content other than one or more
                        <a href="#element-fallback"><code>xsl:fallback</code></a> instructions, or if the <code>select</code>
                     attribute is absent when the element has empty content.</p>
               </dd>
               <dt><a href="#err-XTSE0940"><span class="error">ERR XTSE0940</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-comment"><code>xsl:comment</code></a> element is
                     present unless the element has empty content.</p>
               </dd>
               <dt><a href="#err-XTSE0975"><span class="error">ERR XTSE0975</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <code>value</code> attribute of <a href="#element-number"><code>xsl:number</code></a> is present unless
                  the <code>select</code>, <code>level</code>, <code>count</code>, and
                     <code>from</code> attributes are all absent.</p>
               </dd>
               <dt><a href="#err-XTSE1015"><span class="error">ERR XTSE1015</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-sort"><code>xsl:sort</code></a> element with a <code>select</code> attribute has
                     non-empty content.</p>
               </dd>
               <dt><a href="#err-XTSE1017"><span class="error">ERR XTSE1017</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-sort"><code>xsl:sort</code></a> element other than the first in a sequence of
                     sibling <a href="#element-sort"><code>xsl:sort</code></a> elements has a <code>stable</code>
                     attribute.</p>
               </dd>
               <dt><a href="#err-XTSE1040"><span class="error">ERR XTSE1040</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-perform-sort"><code>xsl:perform-sort</code></a> instruction with a <code>select</code>
                     attribute has any content other than <a href="#element-sort"><code>xsl:sort</code></a> and
                        <a href="#element-fallback"><code>xsl:fallback</code></a> instructions.</p>
               </dd>
               <dt><a href="#err-XTSE1060"><span class="error">ERR XTSE1060</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-group"><code>current-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p>
               </dd>
               <dt><a href="#err-XTSE1070"><span class="error">ERR XTSE1070</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p>
               </dd>
               <dt><a href="#err-XTSE1080"><span class="error">ERR XTSE1080</span></a></dt>
               <dd>
                  <p>These <span>six</span> attributes  [the <code>group-by</code>,
                     <code>group-adjacent</code>, <code>group-starting-with</code>, 
                     <code>group-ending-with</code>, 
                     <span><code>split-when</code>,</span>
                     <span>and <code>merge-when</code></span> attributes of
                           <a href="#element-for-each-group"><code>xsl:for-each-group</code></a>
                     ]  are mutually exclusive: it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if none of these attributes is present or if
                     more than one of them is present.</p>
               </dd>
               <dt><a href="#err-XTSE1090"><span class="error">ERR XTSE1090</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to specify the
                        <code>collation</code> attribute or the
                           <code>composite</code> attribute if neither the
                        <code>group-by</code> attribute nor the <code>group-adjacent</code> attribute is
                     specified.</p>
               </dd>
               <dt><a href="#err-XTSE1130"><span class="error">ERR XTSE1130</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> instruction contains neither an
                        <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> nor an
                        <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a> element.</p>
               </dd>
               <dt><a href="#err-XTSE1205"><span class="error">ERR XTSE1205</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                           <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>use</code> attribute and
                        has non-empty content, or if it has empty content and no <code>use</code>
                        attribute.</p>
               </dd>
               <dt><a href="#err-XTSE1210"><span class="error">ERR XTSE1210</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           <a href="#element-key"><code>xsl:key</code></a> declaration has a <code>collation</code>
                        attribute whose value (after resolving against the base URI) is not a URI
                        recognized by the implementation as referring to a collation.</p>
               </dd>
               <dt><a href="#err-XTSE1220"><span class="error">ERR XTSE1220</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are
                        several <a href="#element-key"><code>xsl:key</code></a> declarations in the same <a title="package" class="termref" href="#dt-package">package</a> with the
                        same key name and different effective collations. Two collations are the
                        same if their URIs are equal under the rules for comparing
                           <code>xs:anyURI</code> values, or if the implementation can determine
                        that they are different URIs referring to the same collation.</p>
               </dd>
               <dt><a href="#err-XTSE1222"><span class="error">ERR XTSE1222</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there are
                        several <a href="#element-key"><code>xsl:key</code></a> declarations in a <a title="package" class="termref" href="#dt-package">package</a> 
                        with the same key name and
                        different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> 
                        for the <code>composite</code> attribute.</p>
               </dd>
               <dt><a href="#err-XTSE1290"><span class="error">ERR XTSE1290</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a named or
                     unnamed <a title="decimal format" class="termref" href="#dt-decimal-format">decimal format</a> contains two
                     conflicting values for the same attribute in different
                     <a href="#element-decimal-format"><code>xsl:decimal-format</code></a> declarations having the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless there is
                     another definition of the same attribute with higher import precedence.</p>
               </dd>
               <dt><a href="#err-XTSE1295"><span class="error">ERR XTSE1295</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the character
                     specified in the <code>zero-digit</code> attribute is not a digit or is a digit
                     that does not have the numeric value zero. </p>
               </dd>
               <dt><a href="#err-XTSE1300"><span class="error">ERR XTSE1300</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if, for any named
                     or unnamed decimal format, the properties identifying <b>marker</b> 
                     characters to be used in a
                     <a title="picture string" class="termref" href="#dt-picture-string">picture string</a> do not identify
                     distinct values. These properties are <var>decimal-separator</var>,
                     <var>grouping-separator</var>, <var>exponent-separator</var>, <var>percent</var>,
                     <var>per-mille</var>, <var>zero-digit</var>, <var>digit</var>,
                     and <var>pattern-separator</var>.</p>
               </dd>
               <dt><a href="#err-XTSE1430"><span class="error">ERR XTSE1430</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if there is no
                        namespace bound to the prefix on the element bearing the
                           <code>[xsl:]extension-element-prefixes</code> attribute or, when
                           <code>#default</code> is specified, if there is no default namespace.</p>
               </dd>
               <dt><a href="#err-XTSE1505"><span class="error">ERR XTSE1505</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if both the
                        <code>[xsl:]type</code> and <code>[xsl:]validation</code> attributes are
                     present on the <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                        <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
                        <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>, <a href="#element-source-document"><code>xsl:source-document</code></a>, or
                           <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements, or on a <a title="literal result element" class="termref" href="#dt-literal-result-element">literal result element</a>.</p>
               </dd>
               <dt><a href="#err-XTSE1520"><span class="error">ERR XTSE1520</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           value of the <code>type</code> attribute of an
                              <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                              <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>,
                              <a href="#element-document"><code>xsl:document</code></a>, <a href="#element-result-document"><code>xsl:result-document</code></a>,
                           <span><a href="#element-source-document"><code>xsl:source-document</code></a>, or 
                              <a href="#element-merge-source"><code>xsl:merge-source</code></a></span>
                           instruction, or the <code>xsl:type</code> attribute of a literal result
                           element, is not a valid <code>QName</code>, or if it uses a prefix that
                           is not defined in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a>
                           of the containing instruction</span>, or if the QName is
                           not the name of a type definition included in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema
                              components</a> for the <a title="package" class="termref" href="#dt-package">package</a>.
                        </p>
               </dd>
               <dt><a href="#err-XTSE1530"><span class="error">ERR XTSE1530</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           value of the <code>type</code> attribute of an
                              <a href="#element-attribute"><code>xsl:attribute</code></a> instruction refers to a complex type
                           definition</p>
               </dd>
               <dt><a href="#err-XTSE1560"><span class="error">ERR XTSE1560</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two
                     <a href="#element-output"><code>xsl:output</code></a> declarations within an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> specify explicit values
                  for the same attribute (other than <code>cdata-section-elements</code>, <code>suppress-indentation</code>, and
                     <code>use-character-maps</code>), with the values of the attributes being not
                  equal, unless there is another <a href="#element-output"><code>xsl:output</code></a> declaration within the
                  same <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> that has
                  higher import precedence and that specifies an explicit value for the same
                  attribute. </p>
               </dd>
               <dt><a href="#err-XTSE1570"><span class="error">ERR XTSE1570</span></a></dt>
               <dd>
                  <p>The value  [of the <code>method</code> attribute on
                        <a href="#element-output"><code>xsl:output</code></a>
                  ] 
                  <span class="verb">must</span> (if present) be a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>. 
                  If it is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                     QName</a> in no namespace, then it identifies a method specified in
                     <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> and <span class="verb">must</span> be one
                  of <code>xml</code>, <code>html</code>, <code>xhtml</code>, 
                  <code>text</code>, <code>json</code>, or <code>adaptive</code>.</p>
               </dd>
               <dt><a href="#err-XTSE1580"><span class="error">ERR XTSE1580</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="package" class="termref" href="#dt-package">package</a> contains two
                     or more character maps with the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>, unless it also
                     contains another character map with the same name and higher import
                     precedence.</p>
               </dd>
               <dt><a href="#err-XTSE1590"><span class="error">ERR XTSE1590</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a name in the
                        <code>use-character-maps</code> attribute of the <a href="#element-output"><code>xsl:output</code></a>
                     or <a href="#element-character-map"><code>xsl:character-map</code></a> elements does not match the
                        <code>name</code> attribute of any <a href="#element-character-map"><code>xsl:character-map</code></a> in the
                        containing <a title="package" class="termref" href="#dt-package">package</a>.</p>
               </dd>
               <dt><a href="#err-XTSE1600"><span class="error">ERR XTSE1600</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a character
                     map references itself, directly or indirectly, via a name in the
                        <code>use-character-maps</code> attribute.</p>
               </dd>
               <dt><a href="#err-XTSE1650"><span class="error">ERR XTSE1650</span></a></dt>
               <dd>
                  <p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware
                        processor</a>
                     <span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static
                        error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an
                        <a href="#element-import-schema"><code>xsl:import-schema</code></a> declaration.</p>
               </dd>
               <dt><a href="#err-XTSE1660"><span class="error">ERR XTSE1660</span></a></dt>
               <dd>
                  <p>A <a title="non-schema-aware processor" class="termref" href="#dt-non-schema-aware-processor">non-schema-aware
                        processor</a>
                     <span class="verb">must</span> raise a <a title="static error" class="termref" href="#dt-static-error">static
                        error</a> if a <a title="package" class="termref" href="#dt-package">package</a> includes an
                        <code>[xsl:]type</code> attribute; or an <code>[xsl:]validation</code> or
                        <code>[xsl:]default-validation</code> attribute with a value other than
                        <code>strip</code>, <code>preserve</code>, or
                           <code>lax</code>; or an
                           <a href="#element-mode"><code>xsl:mode</code></a> element whose <code>typed</code> attribute is
                        equal to <code>yes</code> or <code>strict</code>; or an <code>as</code>
                              attribute whose value is a 
                              <a title="SequenceType" class="termref" href="#dt-sequence-type">SequenceType</a> that can only match
                        nodes with a type annotation other than <code>xs:untyped</code> or
                           <code>xs:untypedAtomic</code> (for example, <code>as="element(*,
                           xs:integer)"</code>).</p>
               </dd>
               <dt><a href="#err-XTSE2200"><span class="error">ERR XTSE2200</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the number of
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of a
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> element is not equal to the number of
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of another
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> child of the same
                        <a href="#element-merge"><code>xsl:merge</code></a> instruction.</p>
               </dd>
               <dt><a href="#err-XTSE3000"><span class="error">ERR XTSE3000</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if after evaluating each
                                    <a href="#element-package-location"><code>xsl:package-location</code></a> declaration and <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> package location, no 
                               <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> is found.</p>
               </dd>
               <dt><a href="#err-XTSE3002"><span class="error">ERR XTSE3002</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> returned by the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> does not conform to the
                                rules of the implicit or explicit value of attribute
                                    <code>format</code>.</p>
               </dd>
               <dt><a href="#err-XTSE3003"><span class="error">ERR XTSE3003</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> returned by the <a title="priority package location" class="termref" href="#dt-optimal-package-location">priority package location</a> does not conform to the
                                name and version specified in an <a href="#element-use-package"><code>xsl:use-package</code></a>
                                declaration.</p>
               </dd>
               <dt><a href="#err-XTSE3004"><span class="error">ERR XTSE3004</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the attribute <code>archive-type</code>
                               is present without the attribute <code>path-in-archive</code>, or if it does not have the
                               value <code>zip</code> or an <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a> value.</p>
               </dd>
               <dt><a href="#err-XTSE3005"><span class="error">ERR XTSE3005</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package is dependent on
                        itself, where package <var>A</var> is defined as being dependent on package
                           <var>B</var> if <var>A</var> contains an <a href="#element-use-package"><code>xsl:use-package</code></a>
                        declaration that references <var>B</var>, or if <var>A</var> contains an
                           <a href="#element-use-package"><code>xsl:use-package</code></a> declaration that references a package
                           <var>C</var> that is itself dependent on <var>B</var>.</p>
               </dd>
               <dt><a href="#err-XTSE3008"><span class="error">ERR XTSE3008</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-use-package"><code>xsl:use-package</code></a>
                  declaration appears in a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a> that is not in the
                  same <a title="stylesheet level" class="termref" href="#dt-stylesheet-level">stylesheet level</a> as the <a title="principal stylesheet module" class="termref" href="#dt-principal-stylesheet-module">principal stylesheet module</a>
                  of the <a title="package" class="termref" href="#dt-package">package</a>.</p>
               </dd>
               <dt><a href="#err-XTSE3010"><span class="error">ERR XTSE3010</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           explicit exposed visibility of a component is inconsistent with its
                           declared visibility, as defined in the above table. (This error occurs
                           only when the component declaration has an explicit
                              <code>visibility</code> attribute, and the component is also listed
                           explicitly by name in an <a href="#element-expose"><code>xsl:expose</code></a> declaration.)</p>
               </dd>
               <dt><a href="#err-XTSE3020"><span class="error">ERR XTSE3020</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token
                           in the <code>names</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a>, other
                           than a wildcard, matches no component in the containing package.</p>
               </dd>
               <dt><a href="#err-XTSE3022"><span class="error">ERR XTSE3022</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the 
                           <code>component</code> attribute of <a href="#element-expose"><code>xsl:expose</code></a> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p>
               </dd>
               <dt><a href="#err-XTSE3025"><span class="error">ERR XTSE3025</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           effect of an <a href="#element-expose"><code>xsl:expose</code></a> declaration would be to make a component
                           <code>abstract</code>, unless the component is already <code>abstract</code>
                           in the absence of the <a href="#element-expose"><code>xsl:expose</code></a> declaration.
                        </p>
               </dd>
               <dt><a href="#err-XTSE3030"><span class="error">ERR XTSE3030</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a token
                           in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>, other
                           than a wildcard, matches no component in the used package.</p>
               </dd>
               <dt><a href="#err-XTSE3032"><span class="error">ERR XTSE3032</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the 
                           <code>component</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a> specifies <code>*</code>
                           (meaning all component kinds) and the <code>names</code> attribute is not a wildcard.</p>
               </dd>
               <dt><a href="#err-XTSE3040"><span class="error">ERR XTSE3040</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           visibility assigned to a component by an <a href="#element-accept"><code>xsl:accept</code></a>
                           element is incompatible with the visibility of the corresponding
                           component in the used package, as defined by the above table, unless the
                           token that matches the component name is a wildcard, in which case the
                              <a href="#element-accept"><code>xsl:accept</code></a> element is treated as not matching that
                           component.</p>
               </dd>
               <dt><a href="#err-XTSE3050"><span class="error">ERR XTSE3050</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                              <a href="#element-use-package"><code>xsl:use-package</code></a> elements in a <a title="package manifest" class="termref" href="#dt-package-manifest">package manifest</a> cause two or more
                              <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> components to be
                           accepted with a visibility other than <code>hidden</code>.</p>
               </dd>
               <dt><a href="#err-XTSE3051"><span class="error">ERR XTSE3051</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if
                                 a token in the <code>names</code> attribute of <a href="#element-accept"><code>xsl:accept</code></a>,
                                 other than a wildcard, matches the symbolic name of a component declared
                                 within an <a href="#element-override"><code>xsl:override</code></a> child of the same
                                 <a href="#element-use-package"><code>xsl:use-package</code></a> element.</p>
               </dd>
               <dt><a href="#err-XTSE3055"><span class="error">ERR XTSE3055</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                           component declaration appearing as a child of
                              <a href="#element-override"><code>xsl:override</code></a> is <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with any other declaration in the using package,
                           regardless of <a title="import precedence" class="termref" href="#dt-import-precedence">import
                              precedence</a>, including any other overriding declaration in
                           the package manifest of the using package.</p>
               </dd>
               <dt><a href="#err-XTSE3058"><span class="error">ERR XTSE3058</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                           component declaration appearing as a child of
                              <a href="#element-override"><code>xsl:override</code></a> does not match (is not <a title="homonymous" class="termref" href="#dt-homonymous">homonymous</a> with) some component in the
                           used package.</p>
               </dd>
               <dt><a href="#err-XTSE3060"><span class="error">ERR XTSE3060</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           component referenced by an <a href="#element-override"><code>xsl:override</code></a> declaration has
                              <a title="visibility" class="termref" href="#dt-visibility">visibility</a> other than
                              <code>public</code> or <code>abstract</code></p>
               </dd>
               <dt><a href="#err-XTSE3070"><span class="error">ERR XTSE3070</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                           signature of an overriding component is not <a title="compatible" class="termref" href="#dt-compatible">compatible</a> with the signature of the component that it is
                           overriding.</p>
               </dd>
               <dt><a href="#err-XTSE3075"><span class="error">ERR XTSE3075</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> to use the
                           component reference <code>xsl:original</code> when the overridden
                           component has <code>visibility="abstract"</code>.</p>
               </dd>
               <dt><a href="#err-XTSE3080"><span class="error">ERR XTSE3080</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                              <a title="top-level package" class="termref" href="#dt-top-level-package">top-level package</a> (as
                           distinct from a <a title="library package" class="termref" href="#dt-library-package">library
                              package</a>) contains 
                           components whose visibility is <code>abstract</code>.</p>
               </dd>
               <dt><a href="#err-XTSE3085"><span class="error">ERR XTSE3085</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a>, 
                           when the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>declared-modes</code> attribute of 
                           an <a href="#element-package"><code>xsl:package</code></a> element is <code>yes</code>, if the 
                           package contains an explicit reference to an undeclared mode, or if 
                           it implicitly uses the unnamed mode and the unnamed mode is undeclared.</p>
               </dd>
               <dt><a href="#err-XTSE3087"><span class="error">ERR XTSE3087</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if more than
                        one <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration appears within a
                           <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, or if several modules within a
                        single <a title="package" class="termref" href="#dt-package">package</a> contain inconsistent
                           <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declarations</p>
               </dd>
               <dt><a href="#err-XTSE3088"><span class="error">ERR XTSE3088</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is
                        present  [on the <a href="#element-context-item"><code>xsl:context-item</code></a>
                           element]  when <code>use="absent"</code> is specified.</p>
               </dd>
               <dt><a href="#err-XTSE3089"><span class="error">ERR XTSE3089</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the <code>as</code> attribute is
                        present  [on the <a href="#element-global-context-item"><code>xsl:global-context-item</code></a>
                           element]  when <code>use="absent"</code> is specified.</p>
               </dd>
               <dt><a href="#err-XTSE3105"><span class="error">ERR XTSE3105</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a template
                        rule applicable to a mode that is defined with <code>typed="strict"</code>
                        uses a match pattern that contains a <code>RelativePathExprP</code> whose
                        first <code>StepExprP</code> is an <code>AxisStepP</code> whose
                           <code>ForwardStepP</code> uses an axis whose principal node kind is
                           <code>Element</code> and whose <code>NodeTest</code> is an
                           <code>EQName</code> that does not correspond to the name of any global
                        element declaration in the <a title="in-scope schema component" class="termref" href="#dt-in-scope-schema-component">in-scope schema components</a>.</p>
               </dd>
               <dt><a href="#err-XTSE3120"><span class="error">ERR XTSE3120</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-break"><code>xsl:break</code></a> or <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element
                     appears other than in a <a title="tail position" class="termref" href="#dt-tail-position">tail position</a>
                     within the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a> forming the body of an <a href="#element-iterate"><code>xsl:iterate</code></a>
                     instruction.</p>
               </dd>
               <dt><a href="#err-XTSE3125"><span class="error">ERR XTSE3125</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of <a href="#element-break"><code>xsl:break</code></a> or
                        <a href="#element-on-completion"><code>xsl:on-completion</code></a> is present and the instruction has
                     children.</p>
               </dd>
               <dt><a href="#err-XTSE3130"><span class="error">ERR XTSE3130</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>name</code> attribute of an <a href="#element-with-param"><code>xsl:with-param</code></a> child of
                     an <a href="#element-next-iteration"><code>xsl:next-iteration</code></a> element does not match the
                        <code>name</code> attribute of an <a href="#element-param"><code>xsl:param</code></a> child of the
                        innermost containing
                        <a href="#element-iterate"><code>xsl:iterate</code></a> instruction.</p>
               </dd>
               <dt><a href="#err-XTSE3140"><span class="error">ERR XTSE3140</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-try"><code>xsl:try</code></a> element is
                     present and the element has children other than <a href="#element-catch"><code>xsl:catch</code></a> and
                        <a href="#element-fallback"><code>xsl:fallback</code></a> elements.</p>
               </dd>
               <dt><a href="#err-XTSE3150"><span class="error">ERR XTSE3150</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute of the <a href="#element-catch"><code>xsl:catch</code></a> element is
                     present unless the element has empty content.</p>
               </dd>
               <dt><a href="#err-XTSE3185"><span class="error">ERR XTSE3185</span></a></dt>
               <dd>
                  <p>For the elements <a href="#element-sequence"><code>xsl:sequence</code></a>, <a href="#element-on-empty"><code>xsl:on-empty</code></a>,
                     <a href="#element-on-non-empty"><code>xsl:on-non-empty</code></a>, <a href="#element-when"><code>xsl:when</code></a>,
                     <a href="#element-otherwise"><code>xsl:otherwise</code></a>, <a href="#element-matching-substring"><code>xsl:matching-substring</code></a>,
                     <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>, <a href="#element-map"><code>xsl:map</code></a>,
                     <a href="#element-map-entry"><code>xsl:map-entry</code></a>, <a href="#element-array"><code>xsl:array</code></a>, <a href="#element-array-member"><code>xsl:array-member</code></a>,
                     and <a href="#element-result-document"><code>xsl:result-document</code></a>,
                     it is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                        <code>select</code> attribute is present
                     and the instruction has children other than <a href="#element-fallback"><code>xsl:fallback</code></a>.</p>
               </dd>
               <dt><a href="#err-XTSE3190"><span class="error">ERR XTSE3190</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if two sibling
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements have the same name.</p>
               </dd>
               <dt><a href="#err-XTSE3195"><span class="error">ERR XTSE3195</span></a></dt>
               <dd>
                  <p>If the <code>for-each-item</code> attribute is present then the
                        <code>for-each-source</code>, <code>use-accumulators</code>, and <code>streamable</code> attributes
                     must all be absent. If <span>either or both of the
                        <code>use-accumulators</code> or <code>streamable</code> attributes is present </span>
                     then the <code>for-each-source</code> attribute must be present. If the
                        <code>for-each-source</code> attribute is present then the
                     <code>for-each-item</code> attribute must be absent. 
                     </p>
               </dd>
               <dt><a href="#err-XTSE3200"><span class="error">ERR XTSE3200</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> element with a <code>select</code> attribute
                     has non-empty content.</p>
               </dd>
               <dt><a href="#err-XTSE3300"><span class="error">ERR XTSE3300</span></a></dt>
               <dd>
                  <p>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> if the list of
                        accumulator names  [in the <code>use-accumulators</code>
                           attribute]  contains an invalid token, contains the same
                        token more than once, or contains the token <code>#all</code> along with any
                        other value; or if any token (other than
                              <code>#all</code>) is not the name of a <a href="https://qt4cg.org/specifications/xslt-streaming-40/#dt-declared-streamable">declared-streamable</a><sup><small>SG</small></sup> accumulator visible in the containing
                           package.</p>
               </dd>
               <dt><a href="#err-XTSE3350"><span class="error">ERR XTSE3350</span></a></dt>
               <dd>
                  <p>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> for a 
                        <a title="package" class="termref" href="#dt-package">package</a> to contain two or more 
                        
                        accumulators with the same <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                           precedence</a>, unless there is another accumulator with the same
                           <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a>, and a higher
                        import precedence.</p>
               </dd>
               <dt><a href="#err-XTSE3355"><span class="error">ERR XTSE3355</span></a></dt>
               <dd>
                  <p>It is a <a href="https://qt4cg.org/specifications/xslt-40/#dt-static-error">static error</a><sup><small>XT</small></sup> for a 
                        an <a href="#element-accumulator-rule"><code>xsl:accumulator-rule</code></a> element to specify
                     <code>capture="yes"</code> unless it also specifies <code>phase="end"</code>.</p>
               </dd>
               <dt><a href="#err-XTSE3440"><span class="error">ERR XTSE3440</span></a></dt>
               <dd>
                  <p>In the case of a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> (that is, an
                           <a href="#element-template"><code>xsl:template</code></a> element having a <code>match</code>
                        attribute) appearing as a child of <a href="#element-override"><code>xsl:override</code></a>, it is a
                           <a title="static error" class="termref" href="#dt-static-error">static error</a> if the list of
                        modes in the <code>mode</code> attribute contains <code>#all</code> or
                           <code>#unnamed</code>, or if it contains <code>#default</code> and the
                        <a title="default mode" class="termref" href="#dt-default-mode">default mode</a> is the <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>, or if the
                           <code>mode</code> attribute is omitted when the default mode is the
                           <a title="unnamed mode" class="termref" href="#dt-unnamed-mode">unnamed mode</a>.</p>
               </dd>
               <dt><a href="#err-XTSE3450"><span class="error">ERR XTSE3450</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                           variable declared with <code>static="yes"</code> is inconsistent with
                           another static variable of the same name that is declared earlier in
                           stylesheet tree order and that has lower <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
               </dd>
               <dt><a href="#err-XTSE3460"><span class="error">ERR XTSE3460</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an
                              <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> element appears in a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> declared within an
                              <a href="#element-override"><code>xsl:override</code></a> element. (To invoke the template rule
                           that is being overridden, <a href="#element-next-match"><code>xsl:next-match</code></a> should
                           therefore be used.)</p>
               </dd>
               <dt><a href="#err-XTSE3470"><span class="error">ERR XTSE3470</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p>
               </dd>
               <dt><a href="#err-XTSE3500"><span class="error">ERR XTSE3500</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the
                     <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> or
                  <a href="#func-current-merge-key"><code>current-merge-key</code></a> function 
                  is used within a <a title="pattern" class="termref" href="#dt-pattern">pattern</a>.</p>
               </dd>
               <dt><a href="#err-XTSE3520"><span class="error">ERR XTSE3520</span></a></dt>
               <dd>
                  <p>It is a static error if a parameter to <a href="#element-iterate"><code>xsl:iterate</code></a> is
                                 <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a>.</p>
               </dd>
               <dt><a href="#err-XTSE4005"><span class="error">ERR XTSE4005</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration with one or more <a href="#element-template"><code>xsl:template</code></a> children has no <code>name</code>
                     attribute.</p>
               </dd>
               <dt><a href="#err-XTSE4010"><span class="error">ERR XTSE4010</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration has a child <a href="#element-template"><code>xsl:template</code></a> element with a <code>name</code> attribute,
                     with a <code>mode</code> attribute, or with no <code>match</code> attribute.</p>
               </dd>
               <dt><a href="#err-XTSE4015"><span class="error">ERR XTSE4015</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements has a <code>default-mode</code>
                     attribute whose value differs from its <code>name</code> attribute, or if any of those child <a href="#element-template"><code>xsl:template</code></a> 
                     elements has a <code>default-mode</code> attribute that differs from the <code>name</code> attribute
                     of the <a href="#element-mode"><code>xsl:mode</code></a> declaration.</p>
               </dd>
               <dt><a href="#err-XTSE4020"><span class="error">ERR XTSE4020</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                     <a title="package" class="termref" href="#dt-package">package</a> contains both (a) an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) 
                     an <a href="#element-template"><code>xsl:template</code></a> declaration that is not
                     one of those children but that references that <a href="#element-mode"><code>xsl:mode</code></a> declaration in its
                     <code>mode</code> attribute.</p>
               </dd>
               <dt><a href="#err-XTSE4025"><span class="error">ERR XTSE4025</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a
                     <a title="package" class="termref" href="#dt-package">package</a> contains (a) an <a href="#element-mode"><code>xsl:mode</code></a>
                     declaration having one or more child <a href="#element-template"><code>xsl:template</code></a> elements, and (b) 
                     a second <a href="#element-mode"><code>xsl:mode</code></a> declaration having the same name and the same
                     <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>.</p>
               </dd>
               <dt><a href="#err-XTSE4030"><span class="error">ERR XTSE4030</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a package contains two 
                     <a href="#element-item-type"><code>xsl:item-type</code></a> or <a href="#element-record-type"><code>xsl:record-type</code></a>
                     declarations having the same name and the same <a title="import precedence" class="termref" href="#dt-import-precedence">import
                        precedence</a>, unless there is another definition with the same
                     name and higher import precedence. It is also a static error if the name
                  of the item type uses a <a title="reserved namespace" class="termref" href="#dt-reserved-namespace">reserved namespace</a>, or if it has the same
                  name as a type in the <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#dt-is-types">in-scope schema types</a><sup><small>XP</small></sup> of
                  the static context.</p>
               </dd>
               <dt><a href="#err-XTSE4035"><span class="error">ERR XTSE4035</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> for an item type named
                     <var>N</var> to contain in its <code>as</code> attribute a reference to <var>N</var>,
                     or to an item type that references <var>N</var> directly or indirectly.</p>
               </dd>
               <dt><a href="#err-XTSE4040"><span class="error">ERR XTSE4040</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if a <a title="template rule" class="termref" href="#dt-template-rule">template rule</a>
                        <var>R</var> has an <code>as</code> attribute <var>S</var>, 
                        and the template rule is <a title="applicable" class="termref" href="#dt-applicable">applicable</a>
                        to a <a title="mode" class="termref" href="#dt-mode">mode</a> <var>M</var> that is declared with an <code>as</code> attribute <var>T</var>,
                        and the sequence type <var>S</var> is not a subtype of the sequence type <var>T</var> as defined
                     by the relationship <code>subtype(S, T)</code> in <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#id-seqtype-subtype">3.3.1 Subtypes of Sequence Types</a>.</p>
               </dd>
               <dt><a href="#err-XTSE4045"><span class="error">ERR XTSE4045</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value
                  of any <code>[xsl:]schema-role</code> in a stylesheet package does
                  not match the value of the <code>role</code> attribute on some
                  <a href="#element-import-schema"><code>xsl:import-schema</code></a> element in the same package.</p>
               </dd>
               <dt><a href="#err-XTSE4050"><span class="error">ERR XTSE4050</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if the names of the fields in an <a href="#element-record-type"><code>xsl:record-type</code></a>
                     declaration are not distinct.</p>
               </dd>
               <dt><a href="#err-XTSE4051"><span class="error">ERR XTSE4051</span></a></dt>
               <dd>
                  <p>It is a <a title="static error" class="termref" href="#dt-static-error">static error</a> 
                     if an <a href="#element-field"><code>xsl:field</code></a> element has a <code>default</code>
                     attribute unless it specifies <code>required="no"</code>.</p>
               </dd>
            </dl>
            <p><b>Type errors</b></p>
            <dl>
               <dt><a href="#err-XTDE0450"><span class="error">ERR XTDE0450</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result
                              sequence contains a function item. </p>
               </dd>
               <dt><a href="#err-XTTE0505"><span class="error">ERR XTTE0505</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                     evaluating the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence
                        constructor</a> cannot be coerced to the required type.</p>
               </dd>
               <dt><a href="#err-XTTE0510"><span class="error">ERR XTTE0510</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an
                        <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction with no <code>select</code>
                     attribute is evaluated when the <a title="context item" class="termref" href="#dt-context-item">context
                        item</a> is not a node. </p>
               </dd>
               <dt><a href="#err-XTTE0570"><span class="error">ERR XTTE0570</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a variable cannot be
                     converted to the required type.</p>
               </dd>
               <dt><a href="#err-XTTE0590"><span class="error">ERR XTTE0590</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the conversion
                        of the <a title="supplied value" class="termref" href="#dt-supplied-value">supplied value</a> of a
                        parameter, or of the context item, does not match the <a title="required type" class="termref" href="#dt-required-type">required type</a>,
                        after applying any permitted conversions.</p>
               </dd>
               <dt><a href="#err-XTTE0780"><span class="error">ERR XTTE0780</span></a></dt>
               <dd>
                  <p>If the <code>as</code> attribute  [of
                              <a href="#element-function"><code>xsl:function</code></a>
                        ]  is specified, then the result evaluated by the <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> (see
                           <a href="#sequence-constructors"><i>5.7 Sequence Constructors</i></a>) is converted to the required
                        type, using the <a title="coercion rules" class="termref" href="#dt-coercion-rules">coercion rules</a>. It is a <a title="type error" class="termref" href="#dt-type-error">type
                           error</a> if this conversion fails.</p>
               </dd>
               <dt><a href="#err-XTTE0945"><span class="error">ERR XTTE0945</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the
                           <a href="#element-copy"><code>xsl:copy</code></a> instruction with no <code>select</code>
                        attribute when the context item is absent. </p>
               </dd>
               <dt><a href="#err-XTTE0950"><span class="error">ERR XTTE0950</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to use the
                           <a href="#element-copy"><code>xsl:copy</code></a> or <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction to
                        copy a node that has namespace-sensitive content if the
                           <code>copy-namespaces</code> attribute has the value <code>no</code> and
                        its explicit or implicit <code>validation</code> attribute has the value
                           <code>preserve</code>. It is also a type error if either of these
                        instructions (with <code>validation="preserve"</code>) is used to copy an
                        attribute having namespace-sensitive content, unless the parent element is
                        also copied. A node has namespace-sensitive content if its typed value
                        contains an item of type <code>xs:QName</code> or <code>xs:NOTATION</code>
                        or a type derived therefrom. The reason this is an error is because the
                        validity of the content depends on the namespace context being
                        preserved.</p>
               </dd>
               <dt><a href="#err-XTTE0990"><span class="error">ERR XTTE0990</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                        <a href="#element-number"><code>xsl:number</code></a> instruction is evaluated, with no
                        <code>value</code> or <code>select</code> attribute, when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is not a node. </p>
               </dd>
               <dt><a href="#err-XTTE1000"><span class="error">ERR XTTE1000</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                     evaluating the <code>select</code> attribute of the <a href="#element-number"><code>xsl:number</code></a>
                     instruction is anything other than a single node.</p>
               </dd>
               <dt><a href="#err-XTTE1100"><span class="error">ERR XTTE1100</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                     evaluating the <code>group-adjacent</code> expression is the empty sequence or a
                     sequence containing more than one item, unless
                           <code>composite="yes"</code> is specified.</p>
               </dd>
               <dt><a href="#err-XTTE1510"><span class="error">ERR XTTE1510</span></a></dt>
               <dd>
                  <p>If the <code>validation</code> attribute of an
                                 <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                                 <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or
                                 <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the
                                 <code>xsl:validation</code> attribute of a literal result element, has
                              the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>strict</code>, and schema validity assessment
                              concludes that the validity of the element or attribute is invalid or
                              unknown, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As
                              with other type errors, the error <span class="verb">may</span> be raised
                              statically if it can be detected statically. </p>
               </dd>
               <dt><a href="#err-XTTE1512"><span class="error">ERR XTTE1512</span></a></dt>
               <dd>
                  <p>If the <code>validation</code> attribute of an
                                 <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                                 <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or
                                 <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the
                                 <code>xsl:validation</code> attribute of a literal result element, has
                              the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>strict</code>, and there is no matching
                              top-level declaration in the schema, then a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type errors, the error
                                 <span class="verb">may</span> be raised statically if it can be detected
                              statically. </p>
               </dd>
               <dt><a href="#err-XTTE1515"><span class="error">ERR XTTE1515</span></a></dt>
               <dd>
                  <p>If the <code>validation</code> attribute of an
                                 <a href="#element-element"><code>xsl:element</code></a>, <a href="#element-attribute"><code>xsl:attribute</code></a>,
                                 <a href="#element-copy"><code>xsl:copy</code></a>, <a href="#element-copy-of"><code>xsl:copy-of</code></a>, or
                                 <a href="#element-result-document"><code>xsl:result-document</code></a> instruction, or the
                                 <code>xsl:validation</code> attribute of a literal result element, has
                              the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> <code>lax</code>, and schema validity assessment
                              concludes that the element or attribute is invalid, a <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs. As with other type
                              errors, the error <span class="verb">may</span> be raised statically if it can
                              be detected statically. </p>
               </dd>
               <dt><a href="#err-XTTE1535"><span class="error">ERR XTTE1535</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the value of
                           the <code>type</code> attribute of an <a href="#element-copy"><code>xsl:copy</code></a> or
                              <a href="#element-copy-of"><code>xsl:copy-of</code></a> instruction refers to a complex type
                           definition and one or more of the items being copied is an attribute
                           node.</p>
               </dd>
               <dt><a href="#err-XTTE1540"><span class="error">ERR XTTE1540</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an
                              <code>[xsl:]type</code> attribute is defined for a constructed element
                           or attribute, and the outcome of schema validity assessment against that
                           type is that the <code>validity</code> property of that element or
                           attribute information item is other than <code>valid</code>.</p>
               </dd>
               <dt><a href="#err-XTTE1545"><span class="error">ERR XTTE1545</span></a></dt>
               <dd>
                  <p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs if a
                              <code>type</code> or <code>validation</code> attribute is defined
                           (explicitly or implicitly) for an instruction that constructs a new
                           attribute node, if the effect of this is to cause the attribute value to
                           be validated against a type that is derived from, or constructed by list
                           or union from, the primitive types <code>xs:QName</code> or
                              <code>xs:NOTATION</code>.</p>
               </dd>
               <dt><a href="#err-XTTE1550"><span class="error">ERR XTTE1550</span></a></dt>
               <dd>
                  <p>A <a title="type error" class="termref" href="#dt-type-error">type error</a> occurs
                                  [when a document node is validated]  unless
                              the children of the document node comprise exactly one element node,
                              no text nodes, and zero or more comment and processing instruction
                              nodes, in any order.</p>
               </dd>
               <dt><a href="#err-XTTE1555"><span class="error">ERR XTTE1555</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if, when
                        validating a document node, document-level constraints (such as ID/IDREF
                        constraints) are not satisfied. 
                        </p>
               </dd>
               <dt><a href="#err-XTTE2230"><span class="error">ERR XTTE2230</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if some item selected
                     by a particular merge key in one input sequence is not comparable using the
                     XPath <code>le</code> operator with the corresponding item selected by the corresponding
                     sort key in another input sequence.</p>
               </dd>
               <dt><a href="#err-XTTE3090"><span class="error">ERR XTTE3090</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                           <a href="#element-context-item"><code>xsl:context-item</code></a> child of <a href="#element-template"><code>xsl:template</code></a>
                        specifies that a context item is required and none is supplied by the
                        caller, that is, if the context item is absent at the point where
                           <a href="#element-call-template"><code>xsl:call-template</code></a> is evaluated.</p>
               </dd>
               <dt><a href="#err-XTTE3100"><span class="error">ERR XTTE3100</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if an
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a> instruction in a particular
                           <code>mode</code> selects an item that does not satisfy the constraints
                        imposed by the <code>@typed</code> attribute.</p>
               </dd>
               <dt><a href="#err-XTTE3165"><span class="error">ERR XTTE3165</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                     result of evaluating the expression in the <code>with-params</code>
                     attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is
                     anything other than a single map of type
                     <code>map(xs:QName, item()*)</code>.</p>
               </dd>
               <dt><a href="#err-XTTE3170"><span class="error">ERR XTTE3170</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the
                                    result of evaluating the <code>namespace-context</code>
                                    attribute of the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is
                                    anything other than a single node.</p>
               </dd>
               <dt><a href="#err-XTTE3180"><span class="error">ERR XTTE3180</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> if the result of
                        evaluating the <code>select</code> expression  [of the
                              <a href="#element-copy"><code>xsl:copy</code></a> element]  is a sequence of more
                        than one item.</p>
               </dd>
               <dt><a href="#err-XTTE3375"><span class="error">ERR XTTE3375</span></a></dt>
               <dd>
                  <p>A type error occurs if the result of the input sequence
                         [of an <a href="#element-map"><code>xsl:map</code></a> instruction]  is
                     not an instance of the required type <code>map(*)*</code>.</p>
               </dd>
            </dl>
            <p><b>Dynamic errors</b></p>
            <dl>
               <dt><a href="#err-XTDE0030"><span class="error">ERR XTDE0030</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of an attribute
                           written using curly brackets, in a position where an <a title="attribute value template" class="termref" href="#dt-attribute-value-template">attribute value template</a>
                           is permitted, is a value that is not one of the permitted values for that
                           attribute. If the processor is able to detect the error statically (for
                           example, when any XPath expressions within the curly brackets can be
                           evaluated statically), then the processor may optionally raise this as a
                           static error.</p>
               </dd>
               <dt><a href="#err-XTDE0040"><span class="error">ERR XTDE0040</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the invocation of
                        the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a template
                        name that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> of a named template defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose
                           visibility is <code>public</code> or <code>final</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0041"><span class="error">ERR XTDE0041</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> specifies a function name and
                        arity that does not match the <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded
                           QName</a> and arity of a named <a title="stylesheet function" class="termref" href="#dt-stylesheet-function">stylesheet function</a> defined in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>, whose visibility is
                           <code>public</code> or <code>final</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0044"><span class="error">ERR XTDE0044</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                              invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                              specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> when no <a title="initial match selection" class="termref" href="#dt-initial-match-selection">initial match selection</a> is
                                 supplied (either explicitly, or defaulted to the <a title="global context item" class="termref" href="#dt-global-context-item">global context item</a>).</p>
               </dd>
               <dt><a href="#err-XTDE0045"><span class="error">ERR XTDE0045</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                              invocation of the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                              specifies an <a title="initial mode" class="termref" href="#dt-initial-mode">initial mode</a> and the
                              specified mode is not eligible as an initial mode (as defined above).</p>
               </dd>
               <dt><a href="#err-XTDE0050"><span class="error">ERR XTDE0050</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a
                        stylesheet declares a visible <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a>
                        that is <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly</a> mandatory,
                        and no value for this parameter is supplied when the stylesheet is primed. A
                        stylesheet parameter is visible if it is not masked by another global
                        variable or parameter with the same name and higher <a title="import precedence" class="termref" href="#dt-import-precedence">import precedence</a>. If the parameter is a <a title="static parameter" class="termref" href="#dt-static-parameter">static parameter</a> then the value <span class="verb">must</span> be
                           supplied prior to the static analysis phase.</p>
               </dd>
               <dt><a href="#err-XTDE0160"><span class="error">ERR XTDE0160</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if an element has
                     an <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of
                     <var>V</var> (with <var>V</var> &lt; <span>4.0</span>) when the implementation does not
                     support backwards compatible behavior for XSLT version <var>V</var>.</p>
               </dd>
               <dt><a href="#err-XTDE0290"><span class="error">ERR XTDE0290</span></a></dt>
               <dd>
                  <p>Where the result of evaluating an XPath expression (or an attribute
                              value template) is required to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>, or if it is permitted to be a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> and the actual value
                              takes the form of a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                                 QName</a>, then unless otherwise specified it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value
                              has a prefix and the <a title="defining element" class="termref" href="#dt-defining-element">defining
                                 element</a> has no namespace node whose name matches that
                              prefix. This error <span class="verb">may</span> be raised as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if the value of the
                              expression can be determined statically.</p>
               </dd>
               <dt><a href="#err-XTDE0410"><span class="error">ERR XTDE0410</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence used to construct the content of an element node contains a
                              namespace node or attribute node that is preceded in the sequence by a
                              node that is neither a namespace node nor an attribute node.</p>
               </dd>
               <dt><a href="#err-XTDE0420"><span class="error">ERR XTDE0420</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence used to construct the content of a document node contains a
                              namespace node or attribute node.</p>
               </dd>
               <dt><a href="#err-XTDE0430"><span class="error">ERR XTDE0430</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence contains two or more namespace nodes having the same name but
                              different <a title="string value" class="termref" href="#dt-string-value">string values</a> (that
                              is, namespace nodes that map the same prefix to different namespace
                              URIs).</p>
               </dd>
               <dt><a href="#err-XTDE0440"><span class="error">ERR XTDE0440</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                              sequence contains a namespace node with no name and the element node
                              being constructed has a null namespace URI (that is, it is an error to
                              define a default namespace when the element is in no namespace). </p>
               </dd>
               <dt><a href="#err-XTDE0540"><span class="error">ERR XTDE0540</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the
                                 conflict resolution algorithm for template rules leaves more than
                                 one matching template rule  when the
                                    declaration of the relevant <a title="mode" class="termref" href="#dt-mode">mode</a> has an <code>on-multiple-match</code>
                                    attribute with the value <code>fail</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0555"><span class="error">ERR XTDE0555</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if
                           <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>, <a href="#element-apply-imports"><code>xsl:apply-imports</code></a>
                        or <a href="#element-next-match"><code>xsl:next-match</code></a> is used to process 
                        <span>an item</span> using a mode
                        whose declaration specifies <code>on-no-match="fail"</code> when there is no
                           <a title="template rule" class="termref" href="#dt-template-rule">template rule</a> in the <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a>
                        whose match pattern matches that <span>item</span>. </p>
               </dd>
               <dt><a href="#err-XTDE0560"><span class="error">ERR XTDE0560</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if
                        <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is
                     evaluated when the <a title="current template rule" class="termref" href="#dt-current-template-rule">current template
                        rule</a> is <a title="absent" class="termref" href="#dt-absent">absent</a>.</p>
               </dd>
               <dt><a href="#err-XTDE0565"><span class="error">ERR XTDE0565</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if a call
                        on the <a href="#func-apply-templates"><code>apply-templates</code></a> function selects a <a title="mode" class="termref" href="#dt-mode">mode</a>
                        that is not explicitly declared in the containing package, or accepted
                        from a used package, or whose visibility is <code>private</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0640"><span class="error">ERR XTDE0640</span></a></dt>
               <dd>
                  <p>In general, a <a title="circularity" class="termref" href="#dt-circularity">circularity</a> in a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">
                        dynamic error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE0700"><span class="error">ERR XTDE0700</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if a template
                              that has an <a title="explicitly mandatory" class="termref" href="#dt-explicitly-mandatory">explicitly mandatory</a> or <a title="implicitly mandatory" class="termref" href="#dt-implicitly-mandatory">implicitly mandatory</a> parameter is invoked without
                              supplying a value for that parameter.</p>
               </dd>
               <dt><a href="#err-XTDE0820"><span class="error">ERR XTDE0820</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                           <code>name</code> attribute  [of the
                              <a href="#element-element"><code>xsl:element</code></a> instruction]  is not a
                           <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a>. </p>
               </dd>
               <dt><a href="#err-XTDE0830"><span class="error">ERR XTDE0830</span></a></dt>
               <dd>
                  <p>In the case of an <a href="#element-element"><code>xsl:element</code></a> instruction with no
                           <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                           error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective
                           value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not
                        declared in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> for the
                           <a href="#element-element"><code>xsl:element</code></a> instruction.</p>
               </dd>
               <dt><a href="#err-XTDE0835"><span class="error">ERR XTDE0835</span></a></dt>
               <dd>
                  <p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                           <code>namespace</code> attribute  [of the
                              <a href="#element-element"><code>xsl:element</code></a> instruction]  is not in the
                        lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                           <code>http://www.w3.org/2000/xmlns/</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0850"><span class="error">ERR XTDE0850</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> 
                     of the <code>name</code>
                     attribute  [of an <a href="#element-attribute"><code>xsl:attribute</code></a>
                        instruction]  is not a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical
                        QName</a>.</p>
               </dd>
               <dt><a href="#err-XTDE0855"><span class="error">ERR XTDE0855</span></a></dt>
               <dd>
                  <p>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no
                        <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                        error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective
                        value</a> of the <code>name</code> attribute is the string
                        <code>xmlns</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0860"><span class="error">ERR XTDE0860</span></a></dt>
               <dd>
                  <p>In the case of an <a href="#element-attribute"><code>xsl:attribute</code></a> instruction with no
                        <code>namespace</code> attribute, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                        error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective
                        value</a> of the <code>name</code> attribute is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> whose prefix is not declared
                     in <span>the <a title="applicable static namespaces" class="termref" href="#dt-applicable-static-namespaces">applicable static namespaces</a></span> 
                     for the <a href="#element-attribute"><code>xsl:attribute</code></a>
                     instruction.</p>
               </dd>
               <dt><a href="#err-XTDE0865"><span class="error">ERR XTDE0865</span></a></dt>
               <dd>
                  <p> It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                        <code>namespace</code> attribute  [of the
                           <a href="#element-attribute"><code>xsl:attribute</code></a> instruction]  is not in the
                     lexical space of the <code>xs:anyURI</code> datatype or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0890"><span class="error">ERR XTDE0890</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code>
                     attribute  [of the <a href="#element-processing-instruction"><code>xsl:processing-instruction</code></a>
                        instruction]  is not both an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup> and a <a href="https://www.w3.org/TR/REC-xml/#NT-PITarget">PITarget</a><sup><small>XML</small></sup>.</p>
               </dd>
               <dt><a href="#err-XTDE0905"><span class="error">ERR XTDE0905</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the string value of
                     the new namespace node is not valid in the lexical space of the datatype
                        <code>xs:anyURI</code>, or if it is the string
                        <code>http://www.w3.org/2000/xmlns/</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0920"><span class="error">ERR XTDE0920</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>name</code>
                     attribute  [of the <a href="#element-namespace"><code>xsl:namespace</code></a>
                        instruction]  is neither a zero-length string nor an <a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">NCName</a><sup><small>Names</small></sup>, or if it is <code>xmlns</code>.
                  </p>
               </dd>
               <dt><a href="#err-XTDE0925"><span class="error">ERR XTDE0925</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the
                        <a href="#element-namespace"><code>xsl:namespace</code></a> instruction generates a namespace node whose
                     name is <code>xml</code> and whose string value is not
                        <code>http://www.w3.org/XML/1998/namespace</code>, or a namespace node whose
                     string value is <code>http://www.w3.org/XML/1998/namespace</code> and whose
                     name is not <code>xml</code>.</p>
               </dd>
               <dt><a href="#err-XTDE0930"><span class="error">ERR XTDE0930</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if evaluating the
                        <code>select</code> attribute or the contained <a title="sequence constructor" class="termref" href="#dt-sequence-constructor">sequence constructor</a> of an <a href="#element-namespace"><code>xsl:namespace</code></a>
                     instruction results in a zero-length string. </p>
               </dd>
               <dt><a href="#err-XTDE0980"><span class="error">ERR XTDE0980</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if any undiscarded item
                     in the atomized sequence supplied as the value of the <code>value</code>
                     attribute of <a href="#element-number"><code>xsl:number</code></a> cannot be converted to an integer, or
                     if the resulting integer is less than 0 (zero). </p>
               </dd>
               <dt><a href="#err-XTDE1030"><span class="error">ERR XTDE1030</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if, for any <a title="sort key component" class="termref" href="#dt-sort-key-component">sort key component</a>, the set of
                           <a title="sort key value" class="termref" href="#dt-sort-key-value">sort key values</a> evaluated for
                        all the items in the <a title="initial sequence" class="termref" href="#dt-initial-sequence">initial
                           sequence</a>, after any type conversion requested, contains a pair
                        of atomic items that are not comparable using the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-compare"><code>fn:compare</code></a>. If the processor is
                           able to detect the error statically, it <span class="verb">may</span> optionally
                           raise it as a <a title="static error" class="termref" href="#dt-static-error">static
                           error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE1035"><span class="error">ERR XTDE1035</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the
                           <code>collation</code> attribute of <a href="#element-sort"><code>xsl:sort</code></a> (after
                        resolving against the base URI) is not a URI that is recognized by the
                        implementation as referring to a collation.</p>
               </dd>
               <dt><a href="#err-XTDE1061"><span class="error">ERR XTDE1061</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-group"><code>current-group</code></a> function is used when the current group is
                     <a title="absent" class="termref" href="#dt-absent">absent</a>
                  , or when it is invoked in the course of evaluating a
                     pattern. The error <span class="verb">may</span> be reported statically if it
                  can be detected statically.</p>
               </dd>
               <dt><a href="#err-XTDE1071"><span class="error">ERR XTDE1071</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-grouping-key"><code>current-grouping-key</code></a> function is used when the current
                  grouping key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked in the course of evaluating a pattern.
                  The error <span class="verb">may</span> be reported statically if it can be detected
                  statically.</p>
               </dd>
               <dt><a href="#err-XTDE1110"><span class="error">ERR XTDE1110</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the collation URI
                     specified to <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> (after resolving against the
                     base URI) is a collation that is not recognized by the implementation. (For
                     notes, <span class="error">[see <a href="#err-XTDE1035">ERR XTDE1035</a>]</span>.)</p>
               </dd>
               <dt><a href="#err-XTDE1140"><span class="error">ERR XTDE1140</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a>
                     of the <code>regex</code>
                     attribute  [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>
                        instruction]  does not conform to the
                        <span class="verb">required</span> syntax for regular expressions, as specified in
                        <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the regular expression is known
                     statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then
                     the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p>
               </dd>
               <dt><a href="#err-XTDE1145"><span class="error">ERR XTDE1145</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the <code>flags</code>
                     attribute  [of the <a href="#element-analyze-string"><code>xsl:analyze-string</code></a>
                        instruction]  has a value other than the values defined in
                        <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>. If the value of the attribute is known
                     statically (for example, if the attribute does not contain any <a title="expression" class="termref" href="#dt-expression">expressions</a> enclosed in curly brackets) then
                     the processor <span class="verb">may</span> raise the error as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p>
               </dd>
               <dt><a href="#err-XTDE1160"><span class="error">ERR XTDE1160</span></a></dt>
               <dd>
                  <p>When a URI reference  [supplied to the <a href="#func-document"><code>document</code></a>
                     function]  contains a fragment identifier, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the media type is not one that is recognized by the
                  processor, or if the fragment identifier does not conform to the rules for
                  fragment identifiers for that media type, or if the fragment identifier selects
                  something other than a sequence of nodes (for example, if it selects a range of
                  characters within a text node). </p>
               </dd>
               <dt><a href="#err-XTDE1162"><span class="error">ERR XTDE1162</span></a></dt>
               <dd>
                  <p>When a URI reference  [supplied to the <a href="#func-document"><code>document</code></a>
                     function]  is a relative reference, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if no base URI is available to
                  resolve the relative reference. This can arise for example when the URI is
                  contained in a node that has no base URI (for example a parentless text node), or
                  when the second argument to the function is a node that has no base URI, or when
                  the base URI from the static context is undefined. </p>
               </dd>
               <dt><a href="#err-XTDE1260"><span class="error">ERR XTDE1260</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value
                     of <code>$key-name</code> is not a valid QName, or if there is no namespace
                  declaration in scope for the prefix of the QName, or if the name obtained by
                  expanding the QName is not the same as the expanded name of any
                     <a href="#element-key"><code>xsl:key</code></a> declaration in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the
                  processor is able to detect the error statically (for example, when the argument
                  is supplied as a string literal), then the processor <span class="verb">may</span>
                  optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static
                  error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE1262"><span class="error">ERR XTDE1262</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                        error</a> if the key identified in a call to the function <a href="#func-map-for-key"><code>map-for-key</code></a>
               is unsuitable because it uses a collation other than the Unicode Codepoint Collation, or because
               it is defined with <code>composite=yes</code>.</p>
               </dd>
               <dt><a href="#err-XTDE1270"><span class="error">ERR XTDE1270</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                        error</a> to call the <a href="#func-key"><code>key</code></a> function with
                  two arguments if there is no <a title="context node" class="termref" href="#dt-context-node">context
                  node</a>, or if the root of the tree containing the context node is not a
                  document node; or to call the function with three arguments if the root of the
                  tree containing the node supplied in the third argument is not a document
                  node.</p>
               </dd>
               <dt><a href="#err-XTDE1360"><span class="error">ERR XTDE1360</span></a></dt>
               <dd>
                  <p>If the <a href="#func-current"><code>current</code></a> function is evaluated within an expression
                  that is evaluated when the context item is absent, a <a title="dynamic error" class="termref" href="#dt-dynamic-error">
                     dynamic error</a> occurs.</p>
               </dd>
               <dt><a href="#err-XTDE1370"><span class="error">ERR XTDE1370</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.</p>
               </dd>
               <dt><a href="#err-XTDE1380"><span class="error">ERR XTDE1380</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if <code>$node</code>,
                  or the context item if the second argument is omitted,
                  is a node in a tree whose root is not a document node.</p>
               </dd>
               <dt><a href="#err-XTDE1390"><span class="error">ERR XTDE1390</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the value supplied as
                  the <code>$property-name</code> argument  [to the
                        <a href="#func-system-property"><code>system-property</code></a> function]  is not a valid
                  QName, or if there is no namespace declaration in scope for the prefix of the
                  QName. If the processor is able to detect the error statically (for example, when
                  the argument is supplied as a string literal), then the processor
                     <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>. </p>
               </dd>
               <dt><a href="#err-XTDE1400"><span class="error">ERR XTDE1400</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the 
                  <code>$name</code> argument
                      [passed to the <a href="#func-function-available"><code>function-available</code></a>
                     function]  <span>evaluates to a string that is not</span> a valid
                  <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value is a
                  <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <span class="verb">may</span> optionally raise this
                  as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE1420"><span class="error">ERR XTDE1420</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the arguments
                        supplied to a call on an extension function do not satisfy the rules defined
                        for that particular extension function, or if the extension function raises
                        an error, or if the result of the extension function cannot be converted to
                        an XPath value.</p>
               </dd>
               <dt><a href="#err-XTDE1425"><span class="error">ERR XTDE1425</span></a></dt>
               <dd>
                  <p>When the containing element is processed with
                              <a title="XSLT 1.0 behavior" class="termref" href="#dt-xslt-10-behavior">XSLT 1.0
                           behavior</a>, it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic
                           error</a> to evaluate an extension function call if no
                        implementation of the extension function is available.</p>
               </dd>
               <dt><a href="#err-XTDE1428"><span class="error">ERR XTDE1428</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument
                      [passed to the <a href="#func-type-available"><code>type-available</code></a>
                     function]  <span>evaluates to a string that is 
                        not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the 
                  value is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <span class="verb">may</span> optionally raise this
                  as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE1440"><span class="error">ERR XTDE1440</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the argument
                      [passed to the <a href="#func-element-available"><code>element-available</code></a>
                     function]  <span>evaluates to a string that is 
                        not</span> a valid <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if the value 
                  is a <a title="lexical QName" class="termref" href="#dt-lexical-qname">lexical QName</a> with a prefix for which no
                  namespace declaration is present in the static context. If the processor is able
                  to detect the error statically (for example, when the argument is supplied as a
                  string literal), then the processor <span class="verb">may</span> optionally raise this
                  as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE1450"><span class="error">ERR XTDE1450</span></a></dt>
               <dd>
                  <p>When a <a title="processor" class="termref" href="#dt-processor">processor</a> performs fallback for
                        an <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instruction</a>
                        that is not recognized, if the instruction element has one or more
                           <a href="#element-fallback"><code>xsl:fallback</code></a> children, then the content of each of the
                           <a href="#element-fallback"><code>xsl:fallback</code></a> children <span class="verb">must</span> be
                        evaluated; it is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if it has no
                           <a href="#element-fallback"><code>xsl:fallback</code></a> children.</p>
               </dd>
               <dt><a href="#err-XTDE1460"><span class="error">ERR XTDE1460</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="effective value" class="termref" href="#dt-effective-value">effective value</a> of the
                        <code>format</code> attribute  [of an
                           <a href="#element-result-document"><code>xsl:result-document</code></a> element]  is not a valid
                        <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if it does not match the
                        <a title="expanded QName" class="termref" href="#dt-expanded-qname">expanded QName</a> of an <a title="output definition" class="termref" href="#dt-output-definition">output definition</a> in the containing <a title="package" class="termref" href="#dt-package">package</a>. If the processor is able to detect
                     the error statically (for example, when the <code>format</code> attribute
                     contains no curly brackets), then the processor <span class="verb">may</span>
                     optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static
                        error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE1480"><span class="error">ERR XTDE1480</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> to evaluate the
                        <a href="#element-result-document"><code>xsl:result-document</code></a> instruction in <a title="temporary output state" class="termref" href="#dt-temporary-output-state">temporary output state</a>.</p>
               </dd>
               <dt><a href="#err-XTDE1490"><span class="error">ERR XTDE1490</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a transformation to
                     generate two or more <a title="final result tree" class="termref" href="#dt-final-result-tree">final result
                        trees</a> with the same URI.</p>
               </dd>
               <dt><a href="#err-XTDE1500"><span class="error">ERR XTDE1500</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> for a <a title="stylesheet" class="termref" href="#dt-stylesheet">stylesheet</a> to write to an external resource
                     and read from the same resource during a single transformation, if the same absolute URI is used to access the resource in
                        both cases. </p>
               </dd>
               <dt><a href="#err-XTDE1665"><span class="error">ERR XTDE1665</span></a></dt>
               <dd>
                  <p>A <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> <span class="verb">may</span> be raised if the
               input to the processor includes an item that requires availability
               of an optional feature that the processor does not provide.</p>
               </dd>
               <dt><a href="#err-XTDE2210"><span class="error">ERR XTDE2210</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic
                        error</a> if there are two <a href="#element-merge-key"><code>xsl:merge-key</code></a> elements
                     that occupy corresponding positions among the <a href="#element-merge-key"><code>xsl:merge-key</code></a>
                     children of two different <a href="#element-merge-source"><code>xsl:merge-source</code></a> elements and that
                     have differing <a title="effective value" class="termref" href="#dt-effective-value">effective values</a> for
                     any of the attributes <code>lang</code>, <code>order</code>,
                        <code>collation</code>, <code>case-order</code>, or <code>data-type</code>.
                     Values are considered to differ if  
                     they have different <a title="effective value" class="termref" href="#dt-effective-value">effective values</a>. 
                     In the case of the <code>collation</code> attribute, the values are
                     compared as absolute URIs after resolving against the base URI. The error
                        <span class="verb">may</span> be raised statically if it is detected
                     statically.</p>
               </dd>
               <dt><a href="#err-XTDE2220"><span class="error">ERR XTDE2220</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if any input
                     sequence to an <a href="#element-merge"><code>xsl:merge</code></a> instruction contains two items that
                     are not correctly sorted according to the merge key values defined on the
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the corresponding
                        <a href="#element-merge-source"><code>xsl:merge-source</code></a> element, when compared using the collation
                     rules defined by the attributes of the corresponding
                        <a href="#element-merge-key"><code>xsl:merge-key</code></a> children of the <a href="#element-merge"><code>xsl:merge</code></a>
                     instruction, unless the attribute <code>sort-before-merge</code> is present
                     with the value <code>yes</code>.</p>
               </dd>
               <dt><a href="#err-XTDE3052"><span class="error">ERR XTDE3052</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if
                                 an invocation of an abstract component is evaluated.
                              </p>
               </dd>
               <dt><a href="#err-XTDE3086"><span class="error">ERR XTDE3086</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an
                        <a href="#element-global-context-item"><code>xsl:global-context-item</code></a> declaration specifies
                     <code>use="required"</code>, and no global context item is supplied.</p>
               </dd>
               <dt><a href="#err-XTDE3160"><span class="error">ERR XTDE3160</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> if the <a title="target expression" class="termref" href="#dt-target-expression">target expression</a>
                      [of an <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction]  is
                     not a valid <a title="expression" class="termref" href="#dt-expression">expression</a> (that is, if a static error occurs when analyzing the string
                     according to the rules of the XPath specification).</p>
               </dd>
               <dt><a href="#err-XTDE3175"><span class="error">ERR XTDE3175</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an
                           <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction is evaluated when use of
                           <a href="#element-evaluate"><code>xsl:evaluate</code></a> has been statically or dynamically
                        disabled. </p>
               </dd>
               <dt><a href="#err-XTDE3340"><span class="error">ERR XTDE3340</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the value of the first
                     argument to the <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                        <a href="#func-accumulator-after"><code>accumulator-after</code></a> function is 
                  <span>a string that is</span> not a valid
                     <a title="EQName" class="termref" href="#dt-eqname">EQName</a>, or if there is no namespace declaration in scope
                  for the prefix of the QName, or if the name obtained by expanding the QName is not
                  the same as the expanded name of any <a href="#element-accumulator"><code>xsl:accumulator</code></a> declaration
                  appearing in the <a title="package" class="termref" href="#dt-package">package</a> in which the function
                  call appears. If the processor is able to detect the error statically (for
                  example, when the argument is supplied as a string literal), then the processor
                     <span class="verb">may</span> optionally raise this as a <a title="static error" class="termref" href="#dt-static-error">static error</a>.</p>
               </dd>
               <dt><a href="#err-XTDE3350"><span class="error">ERR XTDE3350</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the
                     <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when there is no <a title="context item" class="termref" href="#dt-context-item">context item</a>.</p>
               </dd>
               <dt><a href="#err-XTTE3360"><span class="error">ERR XTTE3360</span></a></dt>
               <dd>
                  <p>It is a <a title="type error" class="termref" href="#dt-type-error">type error</a> to call the
                     <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the <a title="context item" class="termref" href="#dt-context-item">context item</a> is 
                  not a node, or when it is an attribute or namespace node.</p>
               </dd>
               <dt><a href="#err-XTDE3362"><span class="error">ERR XTDE3362</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> to call the
                     <a href="#func-accumulator-before"><code>accumulator-before</code></a> or
                     <a href="#func-accumulator-after"><code>accumulator-after</code></a> function when the context
                  item is a node in a tree to which the selected accumulator is not
                  applicable (including the case where it is not applicable
                     because the document is streamed and the accumulator is not 
                  declared with <code>streamable="yes"</code>). Implementations
                  <span class="verb">may</span> raise this error but are <span class="verb">not required</span> to do so,
                  if they are capable of streaming documents without imposing this restriction.</p>
               </dd>
               <dt><a href="#err-XTDE3365"><span class="error">ERR XTDE3365</span></a></dt>
               <dd>
                  <p>In the absence of the <code>[xsl:]duplicates</code> attribute, 
                     a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> occurs if the set of
                     keys in the maps making up the input sequence
                       [of an <a href="#element-map"><code>xsl:map</code></a> or <a href="#element-record"><code>xsl:record</code></a> instruction] 
                     contains duplicates.</p>
               </dd>
               <dt><a href="#err-XTDE3400"><span class="error">ERR XTDE3400</span></a></dt>
               <dd>
                  <p>It is an error if there is a cyclic set of dependencies among accumulators such
                  that the (pre- or post-descent) value of an accumulator depends directly or indirectly on itself.
                  A processor <span class="verb">may</span> report this as a <a title="static error" class="termref" href="#dt-static-error">static error</a> if it
                  can be detected statically. Alternatively a processor <span class="verb">may</span> report this as a 
                  <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a>. As a further option, a processor may fail catastrophically when
                  this error occurs.</p>
               </dd>
               <dt><a href="#err-XTDE3480"><span class="error">ERR XTDE3480</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-merge-group"><code>current-merge-group</code></a> function is used when the current
                  merge group is <a title="absent" class="termref" href="#dt-absent">absent</a>. The error
                     <span class="verb">may</span> be reported statically if it can be detected
                  statically.</p>
               </dd>
               <dt><a href="#err-XTDE3490"><span class="error">ERR XTDE3490</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <code>$source</code> argument of the <a href="#func-current-merge-group"><code>current-merge-group</code></a>
                  function <span>(when supplied)</span>
                  does not match the <code>name</code> attribute of any
                     <a href="#element-merge-source"><code>xsl:merge-source</code></a> element for the current merge operation. The
                  error <span class="verb">may</span> be reported statically if it can be detected
                  statically.</p>
               </dd>
               <dt><a href="#err-XTDE3510"><span class="error">ERR XTDE3510</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if the
                     <a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a> or 
                  <a href="#func-current-merge-key"><code>current-merge-key</code></a> function is used when the current
                  merge key is <a title="absent" class="termref" href="#dt-absent">absent</a>, or when it is invoked
                  in the course of evaluating a pattern. The error <span class="verb">may</span> be
                  reported statically if it can be detected statically.</p>
               </dd>
               <dt><a href="#err-XTDE3530"><span class="error">ERR XTDE3530</span></a></dt>
               <dd>
                  <p>It is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-try"><code>xsl:try</code></a>
                        instruction is unable to recover the state of a final result tree because
                        recovery has been disabled by use of the attribute
                           <code>rollback-output="no"</code>.</p>
               </dd>
               <dt><a href="#err-XTDE4060"><span class="error">ERR XTDE4060</span></a></dt>
               <dd>
                  <p>It 
                           is a <a title="dynamic error" class="termref" href="#dt-dynamic-error">dynamic error</a> if an <a href="#element-array"><code>xsl:array</code></a>
                        instruction with a <code>for-each</code> attribute includes items constructed
                        using an <a href="#element-array-member"><code>xsl:array-member</code></a> instruction mixed (in the same array member)
                        with items not so constructed.</p>
               </dd>
               <dt><a href="#err-XTMM9000"><span class="error">ERR XTMM9000</span></a></dt>
               <dd>
                  <p>When a transformation is terminated by use of <code>&lt;xsl:message
                        terminate="yes"/&gt;</code>, the effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error">
                        dynamic error</a> occurs during the transformation. The default error code is <code>XTMM9000</code>; this may be
                        overridden using the <code>error-code</code> attribute of the
                           <a href="#element-message"><code>xsl:message</code></a> instruction.</p>
               </dd>
               <dt><a href="#err-XTMM9001"><span class="error">ERR XTMM9001</span></a></dt>
               <dd>
                  <p>When a transformation is terminated by use of <a href="#element-assert"><code>xsl:assert</code></a>, the
                     effect is the same as when a <a title="dynamic error" class="termref" href="#dt-dynamic-error"> dynamic error</a> occurs during the
                     transformation. The default error code is <code>XTMM9001</code>; this may be
                     overridden using the <code>error-code</code> attribute of the
                        <a href="#element-assert"><code>xsl:assert</code></a> instruction.</p>
               </dd>
            </dl>
         </div>
         <div class="div1">
            
            <h2><a id="pattern-syntax-summary"></a>E <a href="#pattern-syntax-summary" style="text-decoration: none">Pattern Syntax Summary</a> (Non-Normative)</h2>
            <p>This appendix gives the grammar for XSLT patterns. The top-level rule for
         patterns is <a href="#doc-xslt40-Pattern">Pattern</a>.</p>
            <p>This is an extension of the grammar for XPath expressions.
            The extended BNF notation is explained at <a href="#xpath-40">[XPath 4.0]</a> section <a href="../xquery-40/xpath-40.html#EBNFNotation">A.1.1 Notation</a>.</p>
            <p>Productions that are identical to their counterparts in XPath 4.0 are suffixed
         <code>XP</code> and link to the corresponding production in the XPath 4.0 specification.
         Productions whose names end with <code>P</code> are restrictions of the corresponding
         XPath production: for example, <code>ArgumentListP</code> is a restricted form of the
         XPath production <code>ArgumentList</code>.</p>
            <div class="div2">
               <table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AbbrevForwardStepP"></a><code>AbbrevForwardStepP</code></td>
                        <td>::=</td>
                        <td><code>("@"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeTest">NodeTest</a><sup><small>XP</small></sup>)  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AbbreviatedStep"></a><code>AbbreviatedStep</code></td>
                        <td>::=</td>
                        <td><code>".."  |  ("@"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeTest">NodeTest</a><sup><small>XP</small></sup>)  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AbsolutePathExpr"></a><code>AbsolutePathExpr</code></td>
                        <td>::=</td>
                        <td><code>("/"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RelativePathExpr">RelativePathExpr</a><sup><small>XP</small></sup>?)  |  ("//"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RelativePathExpr">RelativePathExpr</a><sup><small>XP</small></sup>)</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AdditiveExpr"></a><code>AdditiveExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MultiplicativeExpr">MultiplicativeExpr</a><sup><small>XP</small></sup>  (("+"  |  "-")  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MultiplicativeExpr">MultiplicativeExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AndExpr"></a><code>AndExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ComparisonExpr">ComparisonExpr</a><sup><small>XP</small></sup>  ("and"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ComparisonExpr">ComparisonExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AnyArrayType"></a><code>AnyArrayType</code></td>
                        <td>::=</td>
                        <td><code>"array"  "("  "*"  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AnyFunctionType"></a><code>AnyFunctionType</code></td>
                        <td>::=</td>
                        <td><code>("function"  |  "fn")  "("  "*"  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AnyItemTest"></a><code>AnyItemTest</code></td>
                        <td>::=</td>
                        <td><code>"item"  "("  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AnyMapType"></a><code>AnyMapType</code></td>
                        <td>::=</td>
                        <td><code>"map"  "("  "*"  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AnyNodeKindTest"></a><code>AnyNodeKindTest</code></td>
                        <td>::=</td>
                        <td><code>"node"  "("  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Argument"></a><code>Argument</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArgumentPlaceholder">ArgumentPlaceholder</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArgumentList"></a><code>ArgumentList</code></td>
                        <td>::=</td>
                        <td><code>"("  ((<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalArguments">PositionalArguments</a><sup><small>XP</small></sup>  (","  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-KeywordArguments">KeywordArguments</a><sup><small>XP</small></sup>)?)  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-KeywordArguments">KeywordArguments</a><sup><small>XP</small></sup>)?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArgumentListP"></a><code>ArgumentListP</code></td>
                        <td>::=</td>
                        <td><code>"("  (<a href="#prod-xslt40-ArgumentP">ArgumentP</a> ** ",")  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArgumentP"></a><code>ArgumentP</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Constant">Constant</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArgumentPlaceholder"></a><code>ArgumentPlaceholder</code></td>
                        <td>::=</td>
                        <td><code>"?"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArrayConstructor"></a><code>ArrayConstructor</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SquareArrayConstructor">SquareArrayConstructor</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-CurlyArrayConstructor">CurlyArrayConstructor</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArrayType"></a><code>ArrayType</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyArrayType">AnyArrayType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedArrayType">TypedArrayType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArrowExpr"></a><code>ArrowExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnaryExpr">UnaryExpr</a><sup><small>XP</small></sup>  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceArrowTarget">SequenceArrowTarget</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MappingArrowTarget">MappingArrowTarget</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ArrowTarget"></a><code>ArrowTarget</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RestrictedDynamicCall">RestrictedDynamicCall</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AttributeName"></a><code>AttributeName</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AttributeTest"></a><code>AttributeTest</code></td>
                        <td>::=</td>
                        <td><code>"attribute"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTestUnion">NameTestUnion</a><sup><small>XP</small></sup>  (","  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeName">TypeName</a><sup><small>XP</small></sup>)?)?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Axis"></a><code>Axis</code></td>
                        <td>::=</td>
                        <td><code>("ancestor"  |  "ancestor-or-self"  |  "attribute"  |  "child"  |  "descendant"  |
                              "descendant-or-self"  |  "following"  |  "following-or-self"  |  "following-sibling"
                              |  "following-sibling-or-self"  |  "namespace"  |  "parent"  |  "preceding"  |  "preceding-or-self"
                              |  "preceding-sibling"  |  "preceding-sibling-or-self"  |  "self")  "::"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AxisStep"></a><code>AxisStep</code></td>
                        <td>::=</td>
                        <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AbbreviatedStep">AbbreviatedStep</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FullStep">FullStep</a><sup><small>XP</small></sup>)  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AxisStepP"></a><code>AxisStepP</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-ForwardStepP">ForwardStepP</a>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-BracedAction"></a><code>BracedAction</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnclosedExpr">EnclosedExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-CastableExpr"></a><code>CastableExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-CastExpr">CastExpr</a><sup><small>XP</small></sup>  ("castable"  "as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-CastTarget">CastTarget</a><sup><small>XP</small></sup>  "?"?)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-CastExpr"></a><code>CastExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PipelineExpr">PipelineExpr</a><sup><small>XP</small></sup>  ("cast"  "as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-CastTarget">CastTarget</a><sup><small>XP</small></sup>  "?"?)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-CastTarget"></a><code>CastTarget</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeName">TypeName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ChoiceItemType"></a><code>ChoiceItemType</code></td>
                        <td>::=</td>
                        <td><code>"("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup> ++ "|")  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-CommentTest"></a><code>CommentTest</code></td>
                        <td>::=</td>
                        <td><code>"comment"  "("  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ComparisonExpr"></a><code>ComparisonExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-OtherwiseExpr">OtherwiseExpr</a><sup><small>XP</small></sup>  ((<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ValueComp">ValueComp</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-GeneralComp">GeneralComp</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeComp">NodeComp</a><sup><small>XP</small></sup>)  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-OtherwiseExpr">OtherwiseExpr</a><sup><small>XP</small></sup>)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Constant"></a><code>Constant</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup>  |  ("-"?  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NumericLiteral">NumericLiteral</a><sup><small>XP</small></sup>)  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QNameLiteral">QNameLiteral</a><sup><small>XP</small></sup>  |  ("true"  "("  ")")  |  ("false"  "("  ")")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ContextValueRef"></a><code>ContextValueRef</code></td>
                        <td>::=</td>
                        <td><code>"."</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-CurlyArrayConstructor"></a><code>CurlyArrayConstructor</code></td>
                        <td>::=</td>
                        <td><code>"array"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnclosedExpr">EnclosedExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-DocumentTest"></a><code>DocumentTest</code></td>
                        <td>::=</td>
                        <td><code>"document-node"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTestUnion">NameTestUnion</a><sup><small>XP</small></sup>)?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-DynamicFunctionCall"></a><code>DynamicFunctionCall</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PostfixExpr">PostfixExpr</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalArgumentList">PositionalArgumentList</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ElementName"></a><code>ElementName</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ElementTest"></a><code>ElementTest</code></td>
                        <td>::=</td>
                        <td><code>"element"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTestUnion">NameTestUnion</a><sup><small>XP</small></sup>  (","  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeName">TypeName</a><sup><small>XP</small></sup>  "?"?)?)?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-EnclosedExpr"></a><code>EnclosedExpr</code></td>
                        <td>::=</td>
                        <td><code>"{"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>?  "}"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-EnumerationType"></a><code>EnumerationType</code></td>
                        <td>::=</td>
                        <td><code>"enum"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup> ++ ",")  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-EQName"></a><code>EQName</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-QName">QName</a>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-URIQualifiedName">URIQualifiedName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Expr"></a><code>Expr</code></td>
                        <td>::=</td>
                        <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup> ++ ",")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ExprSingle"></a><code>ExprSingle</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForExpr">ForExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetExpr">LetExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QuantifiedExpr">QuantifiedExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-IfExpr">IfExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FieldDeclaration"></a><code>FieldDeclaration</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FieldName">FieldName</a><sup><small>XP</small></sup>  "?"?  ("as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FieldName"></a><code>FieldName</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FilterExpr"></a><code>FilterExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PostfixExpr">PostfixExpr</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FilterExprAM"></a><code>FilterExprAM</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PostfixExpr">PostfixExpr</a><sup><small>XP</small></sup>  "?["  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  "]"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForBinding"></a><code>ForBinding</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForItemBinding">ForItemBinding</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForMemberBinding">ForMemberBinding</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForEntryBinding">ForEntryBinding</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForClause"></a><code>ForClause</code></td>
                        <td>::=</td>
                        <td><code>"for"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForBinding">ForBinding</a><sup><small>XP</small></sup> ++ ",")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForEntryBinding"></a><code>ForEntryBinding</code></td>
                        <td>::=</td>
                        <td><code>((<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForEntryKeyBinding">ForEntryKeyBinding</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForEntryValueBinding">ForEntryValueBinding</a><sup><small>XP</small></sup>?)  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForEntryValueBinding">ForEntryValueBinding</a><sup><small>XP</small></sup>)  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalVar">PositionalVar</a><sup><small>XP</small></sup>?  "in"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForEntryKeyBinding"></a><code>ForEntryKeyBinding</code></td>
                        <td>::=</td>
                        <td><code>"key"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForEntryValueBinding"></a><code>ForEntryValueBinding</code></td>
                        <td>::=</td>
                        <td><code>"value"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForExpr"></a><code>ForExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForClause">ForClause</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForLetReturn">ForLetReturn</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForItemBinding"></a><code>ForItemBinding</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalVar">PositionalVar</a><sup><small>XP</small></sup>?  "in"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForLetReturn"></a><code>ForLetReturn</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForExpr">ForExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetExpr">LetExpr</a><sup><small>XP</small></sup>  |  ("return"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>)</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForMemberBinding"></a><code>ForMemberBinding</code></td>
                        <td>::=</td>
                        <td><code>"member"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalVar">PositionalVar</a><sup><small>XP</small></sup>?  "in"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForwardAxisP"></a><code>ForwardAxisP</code></td>
                        <td>::=</td>
                        <td><code>("child"  "::")<br>|  ("descendant"  "::")<br>|  ("attribute"  "::")<br>|  ("self"  "::")<br>|  ("descendant-or-self"  "::")<br>|  ("namespace"  "::")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ForwardStepP"></a><code>ForwardStepP</code></td>
                        <td>::=</td>
                        <td><code>(<a href="#prod-xslt40-ForwardAxisP">ForwardAxisP</a>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeTest">NodeTest</a><sup><small>XP</small></sup>)  |  <a href="#prod-xslt40-AbbrevForwardStepP">AbbrevForwardStepP</a></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FullStep"></a><code>FullStep</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Axis">Axis</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeTest">NodeTest</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FunctionBody"></a><code>FunctionBody</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnclosedExpr">EnclosedExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FunctionCall"></a><code>FunctionCall</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArgumentList">ArgumentList</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgs: reserved-function-names</a> */</td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-parens">gn: parens</a> */</td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FunctionCallP"></a><code>FunctionCallP</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-OuterFunctionName">OuterFunctionName</a>  <a href="#prod-xslt40-ArgumentListP">ArgumentListP</a></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FunctionItemExpr"></a><code>FunctionItemExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NamedFunctionRef">NamedFunctionRef</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-InlineFunctionExpr">InlineFunctionExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FunctionSignature"></a><code>FunctionSignature</code></td>
                        <td>::=</td>
                        <td><code>"("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ParamList">ParamList</a><sup><small>XP</small></sup>  ")"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeDeclaration">TypeDeclaration</a><sup><small>XP</small></sup>?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-FunctionType"></a><code>FunctionType</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyFunctionType">AnyFunctionType</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedFunctionType">TypedFunctionType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-GeneralComp"></a><code>GeneralComp</code></td>
                        <td>::=</td>
                        <td><code>"="  |  "!="  |  "&lt;"  |  "&lt;="  |  "&gt;"  |  "&gt;="</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-GNodePattern"></a><code>GNodePattern</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-UnionExprP">UnionExprP</a></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-GNodeType"></a><code>GNodeType</code></td>
                        <td>::=</td>
                        <td><code>"gnode"  "("  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-IfExpr"></a><code>IfExpr</code></td>
                        <td>::=</td>
                        <td><code>"if"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  ")"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnbracedActions">UnbracedActions</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-BracedAction">BracedAction</a><sup><small>XP</small></sup>)</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-InlineFunctionExpr"></a><code>InlineFunctionExpr</code></td>
                        <td>::=</td>
                        <td><code>("function"  |  "fn")  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionSignature">FunctionSignature</a><sup><small>XP</small></sup>?  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionBody">FunctionBody</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-InstanceofExpr"></a><code>InstanceofExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TreatExpr">TreatExpr</a><sup><small>XP</small></sup>  ("instance"  "of"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-IntersectExceptExpr"></a><code>IntersectExceptExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-InstanceofExpr">InstanceofExpr</a><sup><small>XP</small></sup>  (("intersect"  |  "except")  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-InstanceofExpr">InstanceofExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-IntersectExceptExprP"></a><code>IntersectExceptExprP</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-PathExprP">PathExprP</a>  (("intersect"  |  "except")  <a href="#prod-xslt40-PathExprP">PathExprP</a>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ItemType"></a><code>ItemType</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RegularItemType">RegularItemType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionType">FunctionType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeName">TypeName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ChoiceItemType">ChoiceItemType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-JNodeType"></a><code>JNodeType</code></td>
                        <td>::=</td>
                        <td><code>"jnode"  "("  (("*"  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-JRootSelector">JRootSelector</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Constant">Constant</a><sup><small>XP</small></sup>)  (","  ("*"  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>))?)?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-JRootSelector"></a><code>JRootSelector</code></td>
                        <td>::=</td>
                        <td><code>"("  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-KeySpecifier"></a><code>KeySpecifier</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Literal">Literal</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ContextValueRef">ContextValueRef</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ParenthesizedExpr">ParenthesizedExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LookupWildcard">LookupWildcard</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-KeywordArgument"></a><code>KeywordArgument</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  ":="  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Argument">Argument</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-KeywordArguments"></a><code>KeywordArguments</code></td>
                        <td>::=</td>
                        <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-KeywordArgument">KeywordArgument</a><sup><small>XP</small></sup> ++ ",")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LetArrayBinding"></a><code>LetArrayBinding</code></td>
                        <td>::=</td>
                        <td><code>"$"  "["  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup> ++ ",")  "]"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeDeclaration">TypeDeclaration</a><sup><small>XP</small></sup>?  ":="  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LetBinding"></a><code>LetBinding</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetValueBinding">LetValueBinding</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetSequenceBinding">LetSequenceBinding</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetArrayBinding">LetArrayBinding</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetMapBinding">LetMapBinding</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LetClause"></a><code>LetClause</code></td>
                        <td>::=</td>
                        <td><code>"let"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetBinding">LetBinding</a><sup><small>XP</small></sup> ++ ",")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LetExpr"></a><code>LetExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LetClause">LetClause</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ForLetReturn">ForLetReturn</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LetMapBinding"></a><code>LetMapBinding</code></td>
                        <td>::=</td>
                        <td><code>"$"  "{"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup> ++ ",")  "}"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeDeclaration">TypeDeclaration</a><sup><small>XP</small></sup>?  ":="  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LetSequenceBinding"></a><code>LetSequenceBinding</code></td>
                        <td>::=</td>
                        <td><code>"$"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup> ++ ",")  ")"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeDeclaration">TypeDeclaration</a><sup><small>XP</small></sup>?  ":="  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LetValueBinding"></a><code>LetValueBinding</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup>  ":="  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Literal"></a><code>Literal</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NumericLiteral">NumericLiteral</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QNameLiteral">QNameLiteral</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Lookup"></a><code>Lookup</code></td>
                        <td>::=</td>
                        <td><code>"?"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-KeySpecifier">KeySpecifier</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LookupExpr"></a><code>LookupExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PostfixExpr">PostfixExpr</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Lookup">Lookup</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-LookupWildcard"></a><code>LookupWildcard</code></td>
                        <td>::=</td>
                        <td><code>"*"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-MapConstructor"></a><code>MapConstructor</code></td>
                        <td>::=</td>
                        <td><code>"map"?  "{"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MapConstructorEntry">MapConstructorEntry</a><sup><small>XP</small></sup> ** ",")  "}"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-MapConstructorEntry"></a><code>MapConstructorEntry</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>  (":"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-MappingArrowTarget"></a><code>MappingArrowTarget</code></td>
                        <td>::=</td>
                        <td><code>"=!&gt;"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrowTarget">ArrowTarget</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-MapType"></a><code>MapType</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyMapType">AnyMapType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedMapType">TypedMapType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-MethodCall"></a><code>MethodCall</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PostfixExpr">PostfixExpr</a><sup><small>XP</small></sup>  "=?&gt;"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalArgumentList">PositionalArgumentList</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-MultiplicativeExpr"></a><code>MultiplicativeExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnionExpr">UnionExpr</a><sup><small>XP</small></sup>  (("*"  |  "×"  |  "div"  |  "÷"  |  "idiv"  |  "mod")  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnionExpr">UnionExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NamedFunctionRef"></a><code>NamedFunctionRef</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  "#"  <a href="#prod-xslt40-IntegerLiteral">IntegerLiteral</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-reserved-function-names">xgs: reserved-function-names</a> */</td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NamespaceNodeTest"></a><code>NamespaceNodeTest</code></td>
                        <td>::=</td>
                        <td><code>"namespace-node"  "("  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NameTest"></a><code>NameTest</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Wildcard">Wildcard</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NameTestUnion"></a><code>NameTestUnion</code></td>
                        <td>::=</td>
                        <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NameTest">NameTest</a><sup><small>XP</small></sup> ++ "|")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NodeComp"></a><code>NodeComp</code></td>
                        <td>::=</td>
                        <td><code>"is"  |  "is-not"  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodePrecedes">NodePrecedes</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeFollows">NodeFollows</a><sup><small>XP</small></sup>  |  "precedes-or-is"  |  "follows-or-is"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NodeFollows"></a><code>NodeFollows</code></td>
                        <td>::=</td>
                        <td><code>"&gt;&gt;"  |  "follows"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NodeKindTest"></a><code>NodeKindTest</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-DocumentTest">DocumentTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementTest">ElementTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AttributeTest">AttributeTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaElementTest">SchemaElementTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SchemaAttributeTest">SchemaAttributeTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PITest">PITest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-CommentTest">CommentTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TextTest">TextTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NamespaceNodeTest">NamespaceNodeTest</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyNodeKindTest">AnyNodeKindTest</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NodePrecedes"></a><code>NodePrecedes</code></td>
                        <td>::=</td>
                        <td><code>"&lt;&lt;"  |  "precedes"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NodeTest"></a><code>NodeTest</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnionNodeTest">UnionNodeTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NumericLiteral"></a><code>NumericLiteral</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-IntegerLiteral">IntegerLiteral</a>  |  <a href="#prod-xslt40-HexIntegerLiteral">HexIntegerLiteral</a>  |  <a href="#prod-xslt40-BinaryIntegerLiteral">BinaryIntegerLiteral</a>  |  <a href="#prod-xslt40-DecimalLiteral">DecimalLiteral</a>  |  <a href="#prod-xslt40-DoubleLiteral">DoubleLiteral</a></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-OccurrenceIndicator"></a><code>OccurrenceIndicator</code></td>
                        <td>::=</td>
                        <td><code>"?"  |  "*"  |  "+"</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-occurrence-indicators">xgs: occurrence-indicators</a> */</td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-OrExpr"></a><code>OrExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AndExpr">AndExpr</a><sup><small>XP</small></sup>  ("or"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AndExpr">AndExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-OtherwiseExpr"></a><code>OtherwiseExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringConcatExpr">StringConcatExpr</a><sup><small>XP</small></sup>  ("otherwise"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringConcatExpr">StringConcatExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-OuterFunctionName"></a><code>OuterFunctionName</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ParamList"></a><code>ParamList</code></td>
                        <td>::=</td>
                        <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup> ** ",")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ParenthesizedExpr"></a><code>ParenthesizedExpr</code></td>
                        <td>::=</td>
                        <td><code>"("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ParenthesizedPattern"></a><code>ParenthesizedPattern</code></td>
                        <td>::=</td>
                        <td><code>"("  <a href="#prod-xslt40-Pattern">Pattern</a>  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PathExpr"></a><code>PathExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AbsolutePathExpr">AbsolutePathExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RelativePathExpr">RelativePathExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-leading-lone-slash">xgs: leading-lone-slash</a> */</td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PathExprP"></a><code>PathExprP</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-RootedPath">RootedPath</a><br>|  ("/"  <a href="#prod-xslt40-RelativePathExprP">RelativePathExprP</a>?)<br>|  ("//"  <a href="#prod-xslt40-RelativePathExprP">RelativePathExprP</a>)<br>|  <a href="#prod-xslt40-RelativePathExprP">RelativePathExprP</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-leading-lone-slash">xgs: leading-lone-slash</a> */</td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Pattern"></a><code>Pattern</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-PredicatePattern">PredicatePattern</a>  |  <a href="#prod-xslt40-TypePattern">TypePattern</a>  |  <a href="#prod-xslt40-GNodePattern">GNodePattern</a></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PipelineExpr"></a><code>PipelineExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrowExpr">ArrowExpr</a><sup><small>XP</small></sup>  ("-&gt;"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrowExpr">ArrowExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PITest"></a><code>PITest</code></td>
                        <td>::=</td>
                        <td><code>"processing-instruction"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NCName">NCName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringLiteral">StringLiteral</a><sup><small>XP</small></sup>)?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PositionalArgumentList"></a><code>PositionalArgumentList</code></td>
                        <td>::=</td>
                        <td><code>"("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalArguments">PositionalArguments</a><sup><small>XP</small></sup>?  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PositionalArguments"></a><code>PositionalArguments</code></td>
                        <td>::=</td>
                        <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Argument">Argument</a><sup><small>XP</small></sup> ++ ",")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PositionalVar"></a><code>PositionalVar</code></td>
                        <td>::=</td>
                        <td><code>"at"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarName">VarName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PostfixExpr"></a><code>PostfixExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PrimaryExpr">PrimaryExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FilterExpr">FilterExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-DynamicFunctionCall">DynamicFunctionCall</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-LookupExpr">LookupExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MethodCall">MethodCall</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FilterExprAM">FilterExprAM</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PostfixExprP"></a><code>PostfixExprP</code></td>
                        <td>::=</td>
                        <td><code>(<a href="#prod-xslt40-FunctionCallP">FunctionCallP</a>  |  <a href="#prod-xslt40-ParenthesizedPattern">ParenthesizedPattern</a>)  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Predicate"></a><code>Predicate</code></td>
                        <td>::=</td>
                        <td><code>"["  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Expr">Expr</a><sup><small>XP</small></sup>  "]"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PredicatePattern"></a><code>PredicatePattern</code></td>
                        <td>::=</td>
                        <td><code>"."  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-PrimaryExpr"></a><code>PrimaryExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Literal">Literal</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ParenthesizedExpr">ParenthesizedExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ContextValueRef">ContextValueRef</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionCall">FunctionCall</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionItemExpr">FunctionItemExpr</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MapConstructor">MapConstructor</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrayConstructor">ArrayConstructor</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringTemplate">StringTemplate</a><sup><small>XP</small></sup><br>|  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-UnaryLookup">UnaryLookup</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-QNameLiteral"></a><code>QNameLiteral</code></td>
                        <td>::=</td>
                        <td><code>"#"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-QuantifiedExpr"></a><code>QuantifiedExpr</code></td>
                        <td>::=</td>
                        <td><code>("some"  |  "every")  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-QuantifierBinding">QuantifierBinding</a><sup><small>XP</small></sup> ++ ",")  "satisfies"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-QuantifierBinding"></a><code>QuantifierBinding</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarNameAndType">VarNameAndType</a><sup><small>XP</small></sup>  "in"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-RangeExpr"></a><code>RangeExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AdditiveExpr">AdditiveExpr</a><sup><small>XP</small></sup>  ("to"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AdditiveExpr">AdditiveExpr</a><sup><small>XP</small></sup>)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-RecordType"></a><code>RecordType</code></td>
                        <td>::=</td>
                        <td><code>"record"  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FieldDeclaration">FieldDeclaration</a><sup><small>XP</small></sup> ** ",")  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-RegularItemType"></a><code>RegularItemType</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AnyItemTest">AnyItemTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeKindTest">NodeKindTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-GNodeType">GNodeType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-JNodeType">JNodeType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MapType">MapType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrayType">ArrayType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RecordType">RecordType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnumerationType">EnumerationType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-RelativePathExpr"></a><code>RelativePathExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StepExpr">StepExpr</a><sup><small>XP</small></sup>  (("/"  |  "//")  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StepExpr">StepExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-RelativePathExprP"></a><code>RelativePathExprP</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-StepExprP">StepExprP</a>  (("/"  |  "//")  <a href="#prod-xslt40-StepExprP">StepExprP</a>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-RestrictedDynamicCall"></a><code>RestrictedDynamicCall</code></td>
                        <td>::=</td>
                        <td><code>(<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ParenthesizedExpr">ParenthesizedExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-FunctionItemExpr">FunctionItemExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-MapConstructor">MapConstructor</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrayConstructor">ArrayConstructor</a><sup><small>XP</small></sup>)  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PositionalArgumentList">PositionalArgumentList</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-RootedPath"></a><code>RootedPath</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-VarRef">VarRef</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*  (("/"  |  "//")  <a href="#prod-xslt40-RelativePathExprP">RelativePathExprP</a>)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-SchemaAttributeTest"></a><code>SchemaAttributeTest</code></td>
                        <td>::=</td>
                        <td><code>"schema-attribute"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AttributeName">AttributeName</a><sup><small>XP</small></sup>  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-SchemaElementTest"></a><code>SchemaElementTest</code></td>
                        <td>::=</td>
                        <td><code>"schema-element"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ElementName">ElementName</a><sup><small>XP</small></sup>  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Selector"></a><code>Selector</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Wildcard">Wildcard</a><sup><small>XP</small></sup>  |  ("get"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>  ")")</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-SequenceArrowTarget"></a><code>SequenceArrowTarget</code></td>
                        <td>::=</td>
                        <td><code>"=&gt;"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ArrowTarget">ArrowTarget</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-SequenceType"></a><code>SequenceType</code></td>
                        <td>::=</td>
                        <td><code>("empty-sequence"  "("  ")")<br>|  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-OccurrenceIndicator">OccurrenceIndicator</a><sup><small>XP</small></sup>?)</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-SimpleMapExpr"></a><code>SimpleMapExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PathExpr">PathExpr</a><sup><small>XP</small></sup>  ("!"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PathExpr">PathExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-SimpleNodeTest"></a><code>SimpleNodeTest</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeTest">TypeTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Selector">Selector</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-SquareArrayConstructor"></a><code>SquareArrayConstructor</code></td>
                        <td>::=</td>
                        <td><code>"["  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup> ** ",")  "]"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-StepExpr"></a><code>StepExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-PostfixExpr">PostfixExpr</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-AxisStep">AxisStep</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-StepExprP"></a><code>StepExprP</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-PostfixExprP">PostfixExprP</a>  |  <a href="#prod-xslt40-AxisStepP">AxisStepP</a></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-StringConcatExpr"></a><code>StringConcatExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RangeExpr">RangeExpr</a><sup><small>XP</small></sup>  ("||"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-RangeExpr">RangeExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-StringTemplate"></a><code>StringTemplate</code></td>
                        <td>::=</td>
                        <td><code>"`"  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringTemplateFixedPart">StringTemplateFixedPart</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-StringTemplateVariablePart">StringTemplateVariablePart</a><sup><small>XP</small></sup>)*  "`"</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-StringTemplateFixedPart"></a><code>StringTemplateFixedPart</code></td>
                        <td>::=</td>
                        <td><code>((<a href="#prod-xslt40-Char">Char</a> - ('{' | '}' | '`'))  |  "{{"  |  "}}"  |  "``")+</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-StringTemplateVariablePart"></a><code>StringTemplateVariablePart</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EnclosedExpr">EnclosedExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TextTest"></a><code>TextTest</code></td>
                        <td>::=</td>
                        <td><code>"text"  "("  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TreatExpr"></a><code>TreatExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-CastableExpr">CastableExpr</a><sup><small>XP</small></sup>  ("treat"  "as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>)?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypedArrayType"></a><code>TypedArrayType</code></td>
                        <td>::=</td>
                        <td><code>"array"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypeDeclaration"></a><code>TypeDeclaration</code></td>
                        <td>::=</td>
                        <td><code>"as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypedFunctionParam"></a><code>TypedFunctionParam</code></td>
                        <td>::=</td>
                        <td><code>("$"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  "as")?  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypedFunctionType"></a><code>TypedFunctionType</code></td>
                        <td>::=</td>
                        <td><code>("function"  |  "fn")  "("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypedFunctionParam">TypedFunctionParam</a><sup><small>XP</small></sup> ** ",")  ")"  "as"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypedMapType"></a><code>TypedMapType</code></td>
                        <td>::=</td>
                        <td><code>"map"  "("  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>  ","  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SequenceType">SequenceType</a><sup><small>XP</small></sup>  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypeName"></a><code>TypeName</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypePattern"></a><code>TypePattern</code></td>
                        <td>::=</td>
                        <td><code>"~"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ItemType">ItemType</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Predicate">Predicate</a><sup><small>XP</small></sup>*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-TypeTest"></a><code>TypeTest</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-GNodeType">GNodeType</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-NodeKindTest">NodeKindTest</a><sup><small>XP</small></sup>  |  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-JNodeType">JNodeType</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-UnaryExpr"></a><code>UnaryExpr</code></td>
                        <td>::=</td>
                        <td><code>("-"  |  "+")*  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ValueExpr">ValueExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-UnaryLookup"></a><code>UnaryLookup</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-Lookup">Lookup</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-UnbracedActions"></a><code>UnbracedActions</code></td>
                        <td>::=</td>
                        <td><code>"then"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup>  "else"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-ExprSingle">ExprSingle</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-UnionExpr"></a><code>UnionExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-IntersectExceptExpr">IntersectExceptExpr</a><sup><small>XP</small></sup>  (("union"  |  "|")  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-IntersectExceptExpr">IntersectExceptExpr</a><sup><small>XP</small></sup>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-UnionExprP"></a><code>UnionExprP</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-IntersectExceptExprP">IntersectExceptExprP</a>  (("union"  |  "|")  <a href="#prod-xslt40-IntersectExceptExprP">IntersectExceptExprP</a>)*</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-UnionNodeTest"></a><code>UnionNodeTest</code></td>
                        <td>::=</td>
                        <td><code>"("  (<a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SimpleNodeTest">SimpleNodeTest</a><sup><small>XP</small></sup> ++ "|")  ")"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ValueComp"></a><code>ValueComp</code></td>
                        <td>::=</td>
                        <td><code>"eq"  |  "ne"  |  "lt"  |  "le"  |  "gt"  |  "ge"</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-ValueExpr"></a><code>ValueExpr</code></td>
                        <td>::=</td>
                        <td><code><a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-SimpleMapExpr">SimpleMapExpr</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-VarName"></a><code>VarName</code></td>
                        <td>::=</td>
                        <td><code>"$"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-VarNameAndType"></a><code>VarNameAndType</code></td>
                        <td>::=</td>
                        <td><code>"$"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup>  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-TypeDeclaration">TypeDeclaration</a><sup><small>XP</small></sup>?</code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-VarRef"></a><code>VarRef</code></td>
                        <td>::=</td>
                        <td><code>"$"  <a href="https://qt4cg.org/specifications/xquery-40/xpath-40.html#prod-xpath40-EQName">EQName</a><sup><small>XP</small></sup></code></td>
                     </tr>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Wildcard"></a><code>Wildcard</code></td>
                        <td>::=</td>
                        <td><code>"*"<br>|  (<a href="#prod-xslt40-NCName">NCName</a>  ":"  "*")<br>|  ("*"  ":"  <a href="#prod-xslt40-NCName">NCName</a>)<br>|  (<a href="#prod-xslt40-BracedURILiteral">BracedURILiteral</a>  "*")</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
               </table>
            </div>
            <div class="div2">
               
               <h3><a id="terminal-symbols"></a>E.2 <a href="#terminal-symbols" style="text-decoration: none">Terminal Symbols</a></h3>
               <a id="d5e57112"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-IntegerLiteral"></a><code>IntegerLiteral</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-Digits">Digits</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-HexIntegerLiteral"></a><code>HexIntegerLiteral</code></td>
                        <td>::=</td>
                        <td><code>"0x"  <a href="#prod-xslt40-HexDigits">HexDigits</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-BinaryIntegerLiteral"></a><code>BinaryIntegerLiteral</code></td>
                        <td>::=</td>
                        <td><code>"0b"  <a href="#prod-xslt40-BinaryDigits">BinaryDigits</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-DecimalLiteral"></a><code>DecimalLiteral</code></td>
                        <td>::=</td>
                        <td><code>("."  <a href="#prod-xslt40-Digits">Digits</a>)  |  (<a href="#prod-xslt40-Digits">Digits</a>  "."  <a href="#prod-xslt40-Digits">Digits</a>?)</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-DoubleLiteral"></a><code>DoubleLiteral</code></td>
                        <td>::=</td>
                        <td><code>(("."  <a href="#prod-xslt40-Digits">Digits</a>)  |  (<a href="#prod-xslt40-Digits">Digits</a>  ("."  <a href="#prod-xslt40-Digits">Digits</a>?)?))  [eE]  [+-]?  <a href="#prod-xslt40-Digits">Digits</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-StringLiteral"></a><code>StringLiteral</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-AposStringLiteral">AposStringLiteral</a>  |  <a href="#prod-xslt40-QuotStringLiteral">QuotStringLiteral</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-AposStringLiteral"></a><code>AposStringLiteral</code></td>
                        <td>::=</td>
                        <td><code>"'"  (<a href="#prod-xslt40-EscapeApos">EscapeApos</a>  |  [^'])*  "'"</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-QuotStringLiteral"></a><code>QuotStringLiteral</code></td>
                        <td>::=</td>
                        <td><code>'"'  (<a href="#prod-xslt40-EscapeQuot">EscapeQuot</a>  |  [^"])*  '"'</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-URIQualifiedName"></a><code>URIQualifiedName</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-BracedURILiteral">BracedURILiteral</a>  (<a href="#prod-xslt40-NCName">NCName</a>  ":")?  <a href="#prod-xslt40-NCName">NCName</a></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-BracedURILiteral"></a><code>BracedURILiteral</code></td>
                        <td>::=</td>
                        <td><code>"Q"  "{"  [^{}]*  "}"</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-EscapeQuot"></a><code>EscapeQuot</code></td>
                        <td>::=</td>
                        <td><code>'""'</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-EscapeApos"></a><code>EscapeApos</code></td>
                        <td>::=</td>
                        <td><code>"''"</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Comment"></a><code>Comment</code></td>
                        <td>::=</td>
                        <td><code>"(:"  (<a href="#prod-xslt40-CommentContents">CommentContents</a>  |  <a href="#prod-xslt40-Comment">Comment</a>)*  ":)"</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-comments">gn: comments</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-QName"></a><code>QName</code></td>
                        <td>::=</td>
                        <td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-QName">[http://www.w3.org/TR/REC-xml-names/#NT-QName]</a><sup><small>Names</small></sup></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-NCName"></a><code>NCName</code></td>
                        <td>::=</td>
                        <td><code><a href="https://www.w3.org/TR/REC-xml-names/#NT-NCName">[http://www.w3.org/TR/REC-xml-names/#NT-NCName]</a><sup><small>Names</small></sup></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Char"></a><code>Char</code></td>
                        <td>::=</td>
                        <td><code><a href="https://www.w3.org/TR/REC-xml/#NT-NT-Char">[http://www.w3.org/TR/REC-xml#NT-Char]</a><sup><small>XML</small></sup></code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#parse-note-xml-version">xgs: xml-version</a> */</td>
                     </tr>
                  </tbody>
               </table>
               <p>The following symbols represent portions of terminal symbols; they are not
              themselves terminal symbols referenced in the grammar.</p>
               <a id="d5e57279"></a><table class="scrap">
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-Digits"></a><code>Digits</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-DecDigit">DecDigit</a>  ((<a href="#prod-xslt40-DecDigit">DecDigit</a>  |  "_")*  <a href="#prod-xslt40-DecDigit">DecDigit</a>)?</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-DecDigit"></a><code>DecDigit</code></td>
                        <td>::=</td>
                        <td><code>[0-9]</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-HexDigits"></a><code>HexDigits</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-HexDigit">HexDigit</a>  ((<a href="#prod-xslt40-HexDigit">HexDigit</a>  |  "_")*  <a href="#prod-xslt40-HexDigit">HexDigit</a>)?</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-HexDigit"></a><code>HexDigit</code></td>
                        <td>::=</td>
                        <td><code>[0-9a-fA-F]</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-BinaryDigits"></a><code>BinaryDigits</code></td>
                        <td>::=</td>
                        <td><code><a href="#prod-xslt40-BinaryDigit">BinaryDigit</a>  ((<a href="#prod-xslt40-BinaryDigit">BinaryDigit</a>  |  "_")*  <a href="#prod-xslt40-BinaryDigit">BinaryDigit</a>)?</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-BinaryDigit"></a><code>BinaryDigit</code></td>
                        <td>::=</td>
                        <td><code>[01]</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
                  <tbody>
                     <tr style="vertical-align:baseline;">
                        <td><a id="prod-xslt40-CommentContents"></a><code>CommentContents</code></td>
                        <td>::=</td>
                        <td><code>(<a href="#prod-xslt40-Char">Char</a>+ - (Char* ('(:' | ':)') Char*))</code></td>
                     </tr>
                     <tr>
                        <td></td>
                        <td></td>
                        <td style="text-align: right;" class="prodComment">/* <a href="#ws-explicit">ws: explicit</a> */</td>
                     </tr>
                  </tbody>
               </table>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="implementation-defined-features"></a>F <a href="#implementation-defined-features" style="text-decoration: none">Checklist of Implementation-Defined Features</a> (Non-Normative)</h2>
            <p>This appendix provides a summary of XSLT language features whose effect is explicitly
               <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a>. The conformance rules (see <a href="#conformance"><i>27 Conformance</i></a>) require vendors to provide documentation that explains how these
            choices have been exercised.</p>
            <p>The implementation-defined features are grouped into categories for convenience.</p>
            <div class="div2">
               
               <h3><a id="imp-def-api"></a>F.1 <a href="#imp-def-api" style="text-decoration: none">Application Programming Interfaces</a></h3>
               <p>This category covers interfaces for initiating a transformation, setting its
               parameters, initializing the static and dynamic context, and collecting the results.
               In general terms, it is implementation defined how input is passed to the processor
               and how it returns its output. This includes the interpretation of URIs used to refer
               to stylesheet packages and modules, source documents and collections, collations, and
               result documents.</p>
               <p>More specifically:</p>
               <ol>
                  <li>
                     <p>If the initialization of any
                           <a title="global variable" class="termref" href="#dt-global-variable">global variables</a> or <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">parameter</a> depends on the context
                        item, a dynamic error can occur if the context item is absent. It is
                           implementation-defined whether this error occurs
                        during priming of the stylesheet or subsequently when the variable is
                        referenced; and it is implementation-defined whether the
                        error occurs at all if the variable or parameter is never referenced.  (See <a href="#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>)</p>
                  </li>
                  <li>
                     <p>The way in which an XSLT processor is invoked,
                  and the way in which values are supplied for the source document, starting node,
                     <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameters</a>, and
                     <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a>, are
                  implementation-defined. (See <a href="#priming-stylesheet"><i>2.3.2 Priming a Stylesheet</i></a>)</p>
                  </li>
                  <li>
                     <p>The way in which a <a title="base output URI" class="termref" href="#dt-base-output-uri">base output URI</a> is established is implementation-defined (See <a href="#result-serialization"><i>2.3.6.2 Serializing the Result</i></a>)</p>
                  </li>
                  <li>
                     <p>In the absence of an
                     <code>[xsl:]default-collation</code> attribute, the default collation
                     <span class="verb">may</span> be set by the calling application in an implementation-defined way. (See <a href="#default-collation-attribute"><i>3.6.2 The default-collation Attribute</i></a>)</p>
                  </li>
                  <li>
                     <p> It is implementation-defined what forms of
                  URI reference are acceptable in the <code>href</code> attribute of the
                     <a href="#element-include"><code>xsl:include</code></a> and <a href="#element-import"><code>xsl:import</code></a> elements, for
                  example, the URI schemes that may be used, the forms of fragment identifier that
                  may be used, and the media types that are supported. The way in which the URI
                  reference is used to locate a representation of a <a title="stylesheet module" class="termref" href="#dt-stylesheet-module">stylesheet module</a>, and the way in which
                  the stylesheet module is constructed from that representation, are also
                  implementation-defined. (See <a href="#locating-modules"><i>3.10.1 Locating Stylesheet Modules</i></a>)</p>
                  </li>
                  <li>
                     <p>Implementations may provide user options that
                  relax the requirement for the <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>doc</code></a> and
                     <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-collection"><code>collection</code></a> functions (and therefore, by implication, the
                     <a href="#func-document"><code>document</code></a> function) to return stable results. The manner in
                  which such user options are provided, if at all, is implementation-defined.  (See <a href="#xpath-dynamic-context"><i>5.3.3 Initializing the Dynamic Context</i></a>)</p>
                  </li>
                  <li>
                     <p>The mechanism by which the caller supplies a value
               for a <a title="stylesheet parameter" class="termref" href="#dt-stylesheet-parameter">stylesheet parameter</a> is implementation-defined. (See <a href="#global-variables"><i>9.5 Global Variables and Parameters</i></a>)</p>
                  </li>
                  <li>
                     <p>The detail of any external mechanism
               allowing a processor to enable or disable checking of assertions is implementation-defined. (See <a href="#assertions"><i>23.2 Assertions</i></a>)</p>
                  </li>
                  <li>
                     <p>The way in which the results of the transformation
            are delivered to an application is implementation-defined. (See <a href="#result-trees"><i>25 Transformation Results</i></a>)</p>
                  </li>
                  <li>
                     <p> It is implementation-defined how the URI appearing in the <code>href</code>
               attribute of <a href="#element-result-document"><code>xsl:result-document</code></a> affects the way in which the result
               tree is delivered to the application. There <span class="verb">may</span> be restrictions on
               the form of this URI.  (See <a href="#creating-result-trees"><i>25.1 Creating Secondary Results</i></a>)</p>
                  </li>
                  <li>
                     <p>If serialization is supported, then the
            location to which a <a title="final result tree" class="termref" href="#dt-final-result-tree">final result tree</a> is
            serialized is implementation-defined, subject to the constraint that relative URI
               references used to reference one tree from another
            remain valid. (See <a href="#id-default-serialization-parameters"><i>26.2 Serialization parameters</i></a>)</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="imp-def-ext"></a>F.2 <a href="#imp-def-ext" style="text-decoration: none">Vendor and User Extensions</a></h3>
               <p>This category covers extensions and extensibility: mechanisms for providing vendor or
               user extensions to the language without sacrificing interoperability.</p>
               <p>In general terms, it is implementation-defined:</p>
               <ul>
                  <li>
                     <p>whether and under what circumstances the implementation recognizes any
                     extension functions, extension instructions, extension attributes, user-defined
                     data elements, additional types, additional serialization methods or
                     serialization parameters, or additional collations, and if so, what effect they
                     have. </p>
                  </li>
                  <li>
                     <p>whether, how, and under what circumstances the implementation allows users to
                     define extension functions, extension instructions, extension attributes,
                     user-defined data elements, additional types, additional serialization methods
                     or serialization parameters, or additional collations. If it does allow users
                     to do so, it must follow the rules given elsewhere in this specification. </p>
                  </li>
                  <li>
                     <p>what information is available to such extensions (for example, whether they
                     have access to the static and dynamic context.) </p>
                  </li>
                  <li>
                     <p>where such extensions are allowed, the extent to which the processor enforces
                     their correct behavior (for example, checking that strings returned by
                     extension functions contain only valid XML characters) </p>
                  </li>
               </ul>
               <p>More specifically:</p>
               <ol>
                  <li>
                     <p>The mechanisms for creating new <a title="extension instruction" class="termref" href="#dt-extension-instruction">extension instructions</a> and <a title="extension function" class="termref" href="#dt-extension-function">extension functions</a> are implementation-defined. It is not <span class="verb">required</span> that
               implementations provide any such mechanism. (See <a href="#extensibility"><i>2.9 Extensibility</i></a>)</p>
                  </li>
                  <li>
                     <p>The set of namespaces that are specially
                  recognized by the implementation (for example, for user-defined data elements, and
                     <a title="extension attribute" class="termref" href="#dt-extension-attribute">extension attributes</a>) is
                     implementation-defined. (See <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)</p>
                  </li>
                  <li>
                     <p>The effect of user-defined data elements
                  whose name is in a namespace recognized by the implementation is implementation-defined. (See <a href="#user-defined-top-level"><i>3.6.4 User-defined Data Elements</i></a>)</p>
                  </li>
                  <li>
                     <p>An implementation may define mechanisms, above
               and beyond <a href="#element-import-schema"><code>xsl:import-schema</code></a>, that allow <a title="schema component" class="termref" href="#dt-schema-component">schema components</a> such as type definitions to
               be made available within a stylesheet. (See <a href="#built-in-types"><i>3.12 Built-in Types</i></a>)</p>
                  </li>
                  <li>
                     <p>The set of extension functions
                        available in the static context for the target expression of
                           <a href="#element-evaluate"><code>xsl:evaluate</code></a> is implementation-defined. (See <a href="#evaluate-static-context"><i>10.5.1 Static context for the target expression</i></a>)</p>
                  </li>
                  <li>
                     <p>If the <code>data-type</code> attribute of
                  the <a href="#element-sort"><code>xsl:sort</code></a> element has a value other than <code>text</code> or
                     <code>number</code>, the effect is implementation-defined. (See <a href="#comparing-sort-keys"><i>13.1.2 Comparing Sort Key Values</i></a>)</p>
                  </li>
                  <li>
                     <p>The effect of an extension function
                  returning a string containing characters that are not permitted in XML is
                  implementation-defined. (See <a href="#calling-extension-functions"><i>24.2.2 Calling Extension Functions</i></a>)</p>
                  </li>
                  <li>
                     <p>The way in which external objects are
                  represented in the type system is implementation-defined. (See <a href="#external-objects"><i>24.2.3 External Objects</i></a>)</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="imp-def-feature"></a>F.3 <a href="#imp-def-feature" style="text-decoration: none">Localization</a></h3>
               <p>This specification, and the specifications that it refers to, include facilities for
               adapting the output of a transformation to meet local expectations: examples include
               the formatting of numbers and dates, and the choice of collations for sorted output.
               The general principles are:</p>
               <ul>
                  <li>
                     <p>The specification does not mandate any particular localizations that processors
                     must offer: for example, a conformant processor might choose to provide output
                     in Japanese only.</p>
                  </li>
                  <li>
                     <p>The specification provides fallback mechanisms so that if a particular
                     localization is requested and is not available, processing does not fail.</p>
                  </li>
               </ul>
               <p>More specifically:</p>
               <ol>
                  <li>
                     <p>The combinations of languages and numbering
               sequences recognized by the <a href="#element-number"><code>xsl:number</code></a> instruction, beyond those
               defined as mandatory in this specification, are implementation-defined. There <span class="verb">may</span> be
               implementation-defined upper bounds on the numbers that can be formatted using any
               particular numbering sequence. There <span class="verb">may</span> be constraints on the
               values of the <code>ordinal</code> attribute recognized for any given
               language. (See <a href="#convert"><i>12.4 Number to String Conversion Attributes</i></a>)</p>
                  </li>
                  <li>
                     <p>The facilities for defining collations and
                  allocating URIs to identify them are largely
                  implementation-defined. (See <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>)</p>
                  </li>
                  <li>
                     <p>The algorithm used by
                     <a href="#element-sort"><code>xsl:sort</code></a> to locate a collation, given the values of the
                     <code>lang</code> and <code>case-order</code> attributes, is
                  implementation-defined. (See <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>)</p>
                  </li>
                  <li>
                     <p>If none of the
                     <code>collation</code>, <code>lang</code>, or <code>case-order</code>
                  attributes is present (on <a href="#element-sort"><code>xsl:sort</code></a>), the collation is chosen in
                  an implementation-defined way. (See <a href="#collating-sequences"><i>13.1.3 Sorting Using Collations</i></a>)</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="imp-def-optional-feature"></a>F.4 <a href="#imp-def-optional-feature" style="text-decoration: none">Optional Features</a></h3>
               <p>As well as the optional conformance features identified in <a href="#conformance"><i>27 Conformance</i></a>, some specific features of the specification are defined to be optional.</p>
               <ol>
                  <li>
                     <p>It is implementation-defined
               whether an XSLT 4.0 processor supports backwards
               compatible behavior for any XSLT version earlier than XSLT 4.0. (See <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>)</p>
                  </li>
                  <li>
                     <p>If an <code>xml:id</code> attribute that has
                  not been subjected to attribute value normalization is copied from a source tree
                  to a result tree, it is implementation-defined whether attribute value
                  normalization will be applied during the copy process. (See <a href="#shallow-copy"><i>11.9.1 Shallow Copy</i></a>)</p>
                  </li>
                  <li>
                     <p>It is implementation-defined whether, and under
               what circumstances, disabling output escaping is supported. (See <a href="#disable-output-escaping"><i>26.5 Disabling Output Escaping</i></a>)</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="imp-def-dependencies"></a>F.5 <a href="#imp-def-dependencies" style="text-decoration: none">Dependencies</a></h3>
               <p>When this specification refers normatively to other specifications, it generally
               gives implementations freedom to decide (within constraints) which version of the
               referenced specification should be used. Specifically:</p>
               <ol>
                  <li>
                     <p>It is implementation-defined which versions and
               editions of XML and XML Namespaces (1.0 and/or 1.1) are supported. (See <a href="#xml-versions"><i>4.1 XML Versions</i></a>)</p>
                  </li>
                  <li>
                     <p>It is implementation-defined which versions of
            XML, HTML, and XHTML are supported in the <code>version</code> attribute of the
               <a href="#element-output"><code>xsl:output</code></a> declaration. (See <a href="#id-default-serialization-parameters"><i>26.2 Serialization parameters</i></a>)</p>
                  </li>
                  <li>
                     <p>It is implementation-defined whether (and if so how) an XSLT 3.0 processor is
               able to work with versions of <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> later than
               3.1. (See <a href="#serialization-feature"><i>27.3 Serialization Feature</i></a>)</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="imp-def-defaults-and-limits"></a>F.6 <a href="#imp-def-defaults-and-limits" style="text-decoration: none">Defaults and Limits</a></h3>
               <p>To accommodate variations in the way that the XSLT language is deployed, and the
               constraints of different processing environments, defaults for some options are
               implementation-defined. In addition, limits on the sizes of ranges of values
               permitted are in general implementation-defined:</p>
               <ol>
                  <li>
                     <p>Limits on the value space of primitive
               datatypes, where not fixed by <a href="#xmlschema-2">[XML Schema Part 2]</a>, are
               implementation-defined. (See <a href="#limits"><i>4.4 Limits</i></a>)</p>
                  </li>
                  <li>
                     <p>The default value of the
                     <code>encoding</code> attribute of the <a href="#element-output"><code>xsl:output</code></a> element is
                  implementation-defined. Where the encoding is UTF-8, the default for the
                     <code>byte-order-mark</code> attribute is
                  implementation-defined. (See <a href="#id-default-serialization-parameters"><i>26.2 Serialization parameters</i></a>)</p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="imp-def-errors"></a>F.7 <a href="#imp-def-errors" style="text-decoration: none">Detection and Reporting of Errors</a></h3>
               <p>Some aspects of error handling are implementation-defined:</p>
               <ol>
                  <li>
                     <p>It is implementation-defined whether type errors are raised
               statically. (See <a href="#errors"><i>2.12 Error Handling</i></a>)</p>
                  </li>
                  <li>
                     <p>If the 
                     <a title="effective version" class="termref" href="#dt-effective-version">effective version</a> of any element in the
                     stylesheet is not 1.0 or 2.0 but is less than <span>4.0</span>, the
                        <span class="verb">recommended</span> action is to raise a static error; however,
                     processors <span class="verb">may</span> recognize such values and process the element
                     in an implementation-defined way. (See <a href="#backwards"><i>3.8 Backwards Compatible Processing</i></a>)</p>
                  </li>
                  <li>
                     <p>The default values for the
                     <code>warning-on-no-match</code> and <code>warning-on-multiple-match</code>
                  attributes of <a href="#element-mode"><code>xsl:mode</code></a> are implementation-defined. (See <a href="#declaring-modes"><i>6.7.1 Declaring Modes</i></a>)</p>
                  </li>
                  <li>
                     <p>The form of any warnings output when
                  there is no matching template rule, or when there are multiple matching template
                  rules, is implementation-defined. (See <a href="#declaring-modes"><i>6.7.1 Declaring Modes</i></a>)</p>
                  </li>
                  <li>
                     <p>The destination and formatting of messages
               written using the <a href="#element-message"><code>xsl:message</code></a> instruction are implementation-defined. (See <a href="#message"><i>23.1 Messages</i></a>)</p>
                  </li>
               </ol>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="summary-list-of-functions"></a>G <a href="#summary-list-of-functions" style="text-decoration: none">Summary of Available Functions</a> (Non-Normative)</h2>
            <div class="div2">
               
               <h3><a id="function-categories"></a>G.1 <a href="#function-categories" style="text-decoration: none">Function Classification</a></h3>
               <p>The functions available for use within an XSLT stylesheet can be classified based firstly,
            on where the function is defined, and secondly, on where it can be used. Specifically, the set
            of functions available is slightly different for :</p>
               <ul>
                  <li>
                     <p>Regular XPath expressions within the stylesheet, for example those appearing in
                  <code>select</code> or <code>test</code> attributes, or between braces in a <a title="text value template" class="termref" href="#dt-text-value-template">text value template</a> (<var>R</var>)</p>
                  </li>
                  <li>
                     <p><a title="static expression" class="termref" href="#dt-static-expression">Static expressions</a> (<var>S</var>)</p>
                  </li>
                  <li>
                     <p>XPath expressions evaluated dynamically using <a href="#element-evaluate"><code>xsl:evaluate</code></a> (<var>D</var>)</p>
                  </li>
               </ul>
               <p>The categories are listed in the following table:</p>
               <table class="data">
                  <caption>Categories of Function, and their Availability</caption>
                  <thead>
                     <tr>
                        <th style="text-align:left; vertical-align:top">Category</th>
                        <th style="text-align:left; vertical-align:top">Defined where?</th>
                        <th style="text-align:left; vertical-align:top">Available where?</th>
                        <th style="text-align:left; vertical-align:top">Notes</th>
                     </tr>
                  </thead>
                  <tbody>
                     <tr>
                        <td style="text-align:left; vertical-align:top">User-defined functions</td>
                        <td style="text-align:left; vertical-align:top">Defined using <a href="#element-function"><code>xsl:function</code></a> declarations in the stylesheet</td>
                        <td style="text-align:left; vertical-align:top"><var>R</var>, <var>D</var></td>
                        <td style="text-align:left; vertical-align:top">Functions are private by default; private functions can be referenced only
                           within the package where they are declared (and not in <a href="#element-evaluate"><code>xsl:evaluate</code></a>
                           expressions).</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Constructor functions for built-in types</td>
                        <td style="text-align:left; vertical-align:top"><a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#constructor-functions">22 Constructor functions</a></td>
                        <td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var>, <var>D</var></td>
                        <td style="text-align:left; vertical-align:top">These functions are all in the namespace conventionally associated with the
                           prefix <code>xs</code>. The semantics of a constructor function are identical
                           to the semantics of a <code>cast</code> expression.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Constructor functions for user-defined types</td>
                        <td style="text-align:left; vertical-align:top"><a href="#xpath-functions-40">[Functions and Operators 4.0]</a> section <a href="../xpath-functions-40/#constructor-functions">22 Constructor functions</a></td>
                        <td style="text-align:left; vertical-align:top"><var>R</var>, <var>D</var> (if <code>schema-aware="yes"</code>)</td>
                        <td style="text-align:left; vertical-align:top">This category includes a function for every named user-defined simple
                           type in an imported schema; the function allows the conversion of strings
                           and certain other values to instances of the user-defined type.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Functions defined in XPath 4.0</td>
                        <td style="text-align:left; vertical-align:top"><a href="#xpath-functions-40">[Functions and Operators 4.0]</a></td>
                        <td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var>, <var>D</var></td>
                        <td style="text-align:left; vertical-align:top">Includes functions in the namespaces conventionally
                           referred to be the prefixes <code>fn</code> and <code>math</code>.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Functions defined in XSLT 4.0</td>
                        <td style="text-align:left; vertical-align:top">This specification</td>
                        <td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var> (see note), <var>D</var></td>
                        <td style="text-align:left; vertical-align:top">See <a href="#XSLT-defined-functions"><i>G.2 List of XSLT-defined functions</i></a>. There is an overlap with
                           the set of functions defined in XPath 4.0. The functions available in static expressions
                           are:
                           <a href="#func-element-available"><code>element-available</code></a>, <a href="#func-function-available"><code>function-available</code></a>,
                           <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-available-system-properties"><code>available-system-properties</code></a>,
                           and <a href="#func-system-property"><code>system-property</code></a>.</td>
                     </tr>
                     <tr>
                        <td style="text-align:left; vertical-align:top">Extension functions</td>
                        <td style="text-align:left; vertical-align:top">Implementation-defined: see <a href="#extension-functions"><i>24.2 Extension Functions</i></a>.</td>
                        <td style="text-align:left; vertical-align:top"><var>R</var>, <var>S</var>, <var>D</var></td>
                        <td style="text-align:left; vertical-align:top">Availability is <a title="implementation-defined" class="termref" href="#dt-implementation-defined">implementation-defined</a></td>
                     </tr>
                  </tbody>
               </table>
            </div>
            <div class="div2">
               
               <h3><a id="XSLT-defined-functions"></a>G.2 <a href="#XSLT-defined-functions" style="text-decoration: none">List of XSLT-defined functions</a></h3>
               <p>This appendix acts as an index of functions defined in this specification, to augment
            the set of functions defined in <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>.</p>
               <dl>
                  <dt class="label"><a href="#func-accumulator-after"><code>accumulator-after</code></a></dt>
                  <dd>See <a href="#func-accumulator-after"><i>19.7 fn:accumulator-after</i></a></dd>
                  <dt class="label"><a href="#func-accumulator-before"><code>accumulator-before</code></a></dt>
                  <dd>See <a href="#func-accumulator-before"><i>19.6 fn:accumulator-before</i></a></dd>
                  <dt class="label"><a href="#func-apply-templates"><code>apply-templates</code></a></dt>
                  <dd>See <a href="#func-apply-templates"><i>6.7.3.1 fn:apply-templates</i></a></dd>
                  <dt class="label"><a href="#func-available-system-properties"><code>available-system-properties</code></a></dt>
                  <dd>See <a href="#func-available-system-properties"><i>20.5.5 fn:available-system-properties</i></a></dd>
                  <dt class="label"><a href="#func-character-map"><code>character-map</code></a></dt>
                  <dd>See <a href="#func-character-map"><i>26.4.1 fn:character-map</i></a></dd>
                  <dt class="label"><a href="#func-copy-of"><code>copy-of</code></a></dt>
                  <dd>See <a href="#func-copy-of"><i>20.3 fn:copy-of</i></a></dd>
                  <dt class="label"><a href="#func-current"><code>current</code></a></dt>
                  <dd>See <a href="#func-current"><i>20.5.1 fn:current</i></a></dd>
                  <dt class="label"><a href="#func-current-group"><code>current-group</code></a></dt>
                  <dd>See <a href="#func-current-group"><i>14.2.1 fn:current-group</i></a></dd>
                  <dt class="label"><a href="#func-current-grouping-key"><code>current-grouping-key</code></a></dt>
                  <dd>See <a href="#func-current-grouping-key"><i>14.2.2 fn:current-grouping-key</i></a></dd>
                  <dt class="label"><a href="#func-current-merge-group"><code>current-merge-group</code></a></dt>
                  <dd>See <a href="#func-current-merge-group"><i>15.5.1 fn:current-merge-group</i></a></dd>
                  <dt class="label"><a href="#func-current-merge-key"><code>current-merge-key</code></a></dt>
                  <dd>See <a href="#func-current-merge-key"><i>15.5.3 fn:current-merge-key</i></a></dd>
                  <dt class="label"><a href="#func-current-merge-key-array"><code>current-merge-key-array</code></a></dt>
                  <dd>See <a href="#func-current-merge-key-array"><i>15.5.2 fn:current-merge-key-array</i></a></dd>
                  <dt class="label"><a href="#func-current-output-uri"><code>current-output-uri</code></a></dt>
                  <dd>See <a href="#func-current-output-uri"><i>25.3.1 fn:current-output-uri</i></a></dd>
                  <dt class="label"><a href="#func-document"><code>document</code></a></dt>
                  <dd>See <a href="#func-document"><i>20.1 fn:document</i></a></dd>
                  <dt class="label"><a href="#func-element-available"><code>element-available</code></a></dt>
                  <dd>See <a href="#func-element-available"><i>24.3.2 fn:element-available</i></a></dd>
                  <dt class="label"><a href="#func-function-available"><code>function-available</code></a></dt>
                  <dd>See <a href="#func-function-available"><i>24.2.1 fn:function-available</i></a></dd>
                  <dt class="label"><a href="#func-key"><code>key</code></a></dt>
                  <dd>See <a href="#func-key"><i>20.2.2 fn:key</i></a></dd>
                  <dt class="label"><a href="#func-map-for-key"><code>map-for-key</code></a></dt>
                  <dd>See <a href="#func-map-for-key"><i>20.2.3 fn:map-for-key</i></a></dd>
                  <dt class="label"><a href="#func-regex-group"><code>regex-group</code></a></dt>
                  <dd>See <a href="#func-regex-group"><i>17.2.2 fn:regex-group</i></a></dd>
                  <dt class="label"><a href="#func-regex-groups"><code>regex-groups</code></a></dt>
                  <dd>See <a href="#func-regex-groups"><i>17.2.1 fn:regex-groups</i></a></dd>
                  <dt class="label"><a href="#func-snapshot"><code>snapshot</code></a></dt>
                  <dd>See <a href="#func-snapshot"><i>20.4 fn:snapshot</i></a></dd>
                  <dt class="label"><a href="#func-stream-available"><code>stream-available</code></a></dt>
                  <dd>See <a href="#func-stream-available"><i>18.2 fn:stream-available</i></a></dd>
                  <dt class="label"><a href="#func-system-property"><code>system-property</code></a></dt>
                  <dd>See <a href="#func-system-property"><i>20.5.4 fn:system-property</i></a></dd>
                  <dt class="label"><a href="#func-type-available"><code>type-available</code></a></dt>
                  <dd>See <a href="#func-type-available"><i>24.2.4 fn:type-available</i></a></dd>
                  <dt class="label"><a href="#func-unparsed-entity-public-id"><code>unparsed-entity-public-id</code></a></dt>
                  <dd>See <a href="#func-unparsed-entity-public-id"><i>20.5.3 fn:unparsed-entity-public-id</i></a></dd>
                  <dt class="label"><a href="#func-unparsed-entity-uri"><code>unparsed-entity-uri</code></a></dt>
                  <dd>See <a href="#func-unparsed-entity-uri"><i>20.5.2 fn:unparsed-entity-uri</i></a></dd>
               </dl>
               <!--{xmlspec} XSLT Processor: Saxonica--><!--{xsl-query} XSLT Processor: Saxonica--></div>
         </div>
         <div class="div1">
            
            <h2><a id="schema-for-xslt"></a>H <a href="#schema-for-xslt" style="text-decoration: none">Schemas for XSLT 4.0 Stylesheets</a> (Non-Normative)</h2>
            <p>For convenience, schemas are provided for validation of XSLT 4.0 stylesheets
         using the XSD 1.1 and Relax NG schema languages. These are non-normative. Neither will detect
         every static error that might arise in an XSLT 4.0 stylesheet (for example, there is no attempt
         to check the syntax of XPath expressions); in addition, these schemas may reject some stylesheets
         that are valid, for example because they rely on <code>xsl:use-when</code> to eliminate sections of code
         that would otherwise be invalid.</p>
            <div class="div2">
               
               <h3><a id="xsd11-schema-for-xslt"></a>H.1 <a href="#xsd11-schema-for-xslt" style="text-decoration: none">XSD 1.1 Schema for XSLT Stylesheets</a></h3>
               <p>The following XSD 1.1 schema describes the structure of an XSLT stylesheet module. 
            There are some limitations:</p>
               <ul>
                  <li>
                     <p>It
            does not define all the constraints that apply to a stylesheet (for example, it does not
            attempt to define a datatype that precisely represents attributes containing XPath
               <a title="expression" class="termref" href="#dt-expression">expressions</a>).</p>
                  </li>
                  <li>
                     <p>Stylesheets that use <a title="forwards compatible behavior" class="termref" href="#dt-forwards-compatible-behavior">forwards compatible behavior</a> 
                  (an <code>[xsl:]version</code> attribute greater than
                  4.0), or that have sections excluded using <code>[xsl:]use-when</code>
                  attributes, are not required to conform to the schema.</p>
                  </li>
                  <li>
                     <p>The specification allows <a href="#element-note"><code>xsl:note</code></a> elements to appear anywhere,
               but this schema is more restrictive.</p>
                  </li>
               </ul>
               <p>A copy of this schema is available at <span><a href="schema-for-xslt40.xsd">schema-for-xslt40.xsd</a></span>
         </p>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The schema as written uses a lax wildcard to permit literal result elements to appear
               in a sequence constructor. This assumes that the schema used for validation will not
               contain any global element declaration that matches the element name of a literal
               result element. The content model for an element such as <code>invoice</code>
               appearing within a stylesheet is not the same as the content model for the same
               element appearing within a source document (it is likely to contain XSLT instructions
               rather than other elements from the target vocabulary): therefore, including such
               declarations in the schema used for validating a stylesheet is inappropriate.</p>
                  <p>The reason that lax validation rather than skip validation is used is so that XSLT
               instructions appearing as children of the literal result element will themselves be
               validated, using the appropriate global element declaration.</p>
               </div>
               <div class="note">
                  <p class="prefix"><b>Note:</b></p>
                  <p>The schema uses XSD 1.1 assertions to represent some of the non-grammatical
               constraints appearing in the specification, for example the rule that some elements
               can have either a <code>select</code> attribute or a contained sequence constructor,
               but not both. At this stage, no attempt has been made to represent every such
               constraint, even where it is not difficult to express the rule. There will always be
               some constraints that cannot be expressed at all, for example those that require
               access to multiple stylesheet modules, those that require access to the in-scope
               schema components, and those that involve parsing a non-regular grammar, such as the
               grammar for patterns.</p>
                  <p>Apart from assertions, the only other significant use of XSD 1.1 features is that the
               elements <a href="#element-param"><code>xsl:param</code></a> and <a href="#element-variable"><code>xsl:variable</code></a> are in two
               substitution groups: one containing all instructions, and one containing all
               declarations. If the schema needs to be converted to an XSD 1.0 schema, removing all
               assertions is straightforward; the other change needed is to remove
                  <a href="#element-param"><code>xsl:param</code></a> and <a href="#element-variable"><code>xsl:variable</code></a> from the substitution
               group for declarations, and instead permit them explicitly as children of
                  <a href="#element-transform"><code>xsl:transform</code></a>.</p>
               </div>
               <pre class="font-size: small">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;xs:schema xmlns:xs="http://www.w3.org/2001/XMLSchema"
           xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
           xmlns:vc="http://www.w3.org/2007/XMLSchema-versioning"
           targetNamespace="http://www.w3.org/1999/XSL/Transform"
           elementFormDefault="qualified"
           vc:minVersion="1.1"&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         This is an XSD 1.1 schema for XSLT 4.0 stylesheets. It defines all the
         elements that appear in the XSLT namespace; it also provides hooks that
         allow the inclusion of user-defined literal result elements, extension
         instructions, and top-level data elements.
      &lt;/p&gt;
      &lt;p&gt;
         This schema is available for use under the conditions of the W3C Software
         License published at
         http://www.w3.org/Consortium/Legal/copyright-software-19980720
      &lt;/p&gt;
      &lt;p&gt;
         The schema is organized as follows:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;
           PART A: definitions of complex types and model groups used as the basis
           for element definitions
        &lt;/li&gt;
        &lt;li&gt;
           PART B: definitions of individual XSLT elements
        &lt;/li&gt;
        &lt;li&gt;
           PART C: definitions for literal result elements
        &lt;/li&gt;
        &lt;li&gt;
           PART D: definitions of simple types used in attribute definitions
        &lt;/li&gt;
      &lt;/ul&gt;
      &lt;p&gt;
         The schema has a number of limitations:
      &lt;/p&gt;
      &lt;ul&gt;
        &lt;li&gt;
           The XSLT specification allows additional elements and attributes to be
           present where forwards compatibility is invoked. This schema does not.
        &lt;/li&gt;
        &lt;li&gt;
           The XSLT specification allows arbitrary content in a part of the
           stylesheet that is excluded by virtue of a use-when attribute. This
           schema does not.
        &lt;/li&gt;
        &lt;li&gt;
           The handling of literal result elements in this schema is imperfect;
           although various options are allowed, none matches the specification
           exactly. For example, the content of a literal result element uses lax
           validation, which permits child elements in the XSLT namespace that have
           no declaration in this schema.
        &lt;/li&gt;
        &lt;li&gt;
           The schema makes no attempt to check XPath expressions for syntactic or
           semantic correctness, nor to check that component references are
           resolved (for example that a template named in &lt;code&gt;xsl:call-template&lt;/code&gt; has a
           declaration). Doing this in general requires cross-document validation,
           which is beyond the scope of XSD.
        &lt;/li&gt;
        &lt;li&gt;
           The XSLT specification allows &lt;code&gt;xsl:note&lt;/code&gt; elements to appear
           anywhere, with arbitrary content. This schema does not: for example, it does
           not allow &lt;code&gt;xsl:note&lt;/code&gt; as a child of an element such as &lt;code&gt;xsl:text&lt;/code&gt;
           or &lt;code&gt;xsl:strip-space&lt;/code&gt;.
        &lt;/li&gt;
        &lt;li&gt;
           The schema imports the schema for XSD 1.0 schema documents. In
           stylesheets that contain an inline XSD 1.1 schema, this import should be
           replaced with one for the schema for XSD 1.1 schema documents.
        &lt;/li&gt;
      &lt;/ul&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;!--
The declaration of xml:space and xml:lang may need to be commented out because
of problems processing the schema using various tools
--&gt;

  &lt;xs:import namespace="http://www.w3.org/XML/1998/namespace"/&gt;
  &lt;!--schemaLocation="http://www.w3.org/2001/xml.xsd"--&gt;

  &lt;!-- 
    An XSLT stylesheet may contain an in-line schema within an xsl:import-schema element,
    so the Schema for schemas needs to be imported. We use the XSD 1.1 version.
--&gt;

  &lt;xs:import namespace="http://www.w3.org/2001/XMLSchema"
             schemaLocation="http://www.w3.org/TR/xmlschema11-1/XMLSchema.xsd"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART A: definitions of complex types and model groups used as the basis
         for element definitions
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:defaultOpenContent&gt;
    &lt;!-- Allow xsl:note anywhere --&gt;
    &lt;xs:any processContents="strict" 
            namespace="##targetNamespace"
            notQName="xsl:accept 
                      xsl:accumulator 
                      xsl:accumulator-rule 
                      xsl:analyze-string 
                      xsl:apply-imports 
                      xsl:apply-templates 
                      xsl:array 
                      xsl:assert 
                      xsl:attribute 
                      xsl:attribute-set 
                      xsl:break 
                      xsl:call-template 
                      xsl:catch 
                      xsl:character-map 
                      xsl:choose 
                      xsl:comment 
                      xsl:context-item 
                      xsl:copy 
                      xsl:copy-of 
                      xsl:document 
                      xsl:decimal-format 
                      xsl:element 
                      xsl:evaluate 
                      xsl:expose 
                      xsl:fallback
                      xsl:field 
                      xsl:for-each 
                      xsl:for-each-group 
                      xsl:fork 
                      xsl:function 
                      xsl:global-context-item 
                      xsl:if 
                      xsl:import 
                      xsl:import-schema 
                      xsl:include 
                      xsl:iterate 
                      xsl:key 
                      xsl:map 
                      xsl:map-entry 
                      xsl:matching-substring 
                      xsl:merge 
                      xsl:merge-action 
                      xsl:merge-key 
                      xsl:merge-source 
                      xsl:message 
                      xsl:mode 
                      xsl:namespace 
                      xsl:namespace-alias 
                      xsl:next-iteration 
                      xsl:next-match 
                      xsl:non-matching-substring 
                      xsl:number 
                      xsl:on-completion 
                      xsl:on-empty 
                      xsl:on-non-empty 
                      xsl:otherwise 
                      xsl:output 
                      xsl:output-character 
                      xsl:override 
                      xsl:package
                      xsl:package-location
                      xsl:param 
                      xsl:perform-sort 
                      xsl:preserve-space 
                      xsl:processing-instruction
                      xsl:record 
                      xsl:record-type 
                      xsl:result-document
                      xsl:select
                      xsl:sequence 
                      xsl:sort 
                      xsl:source-document 
                      xsl:strip-space 
                      xsl:stylesheet 
                      xsl:switch 
                      xsl:template 
                      xsl:text 
                      xsl:transform 
                      xsl:try 
                      xsl:use-package 
                      xsl:value-of 
                      xsl:variable 
                      xsl:when 
                      xsl:where-populated 
                      xsl:with-param
            "/&gt;
  &lt;/xs:defaultOpenContent&gt;
  
  &lt;xs:complexType name="generic-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements except 
           &lt;code&gt;xsl:record&lt;/code&gt;; it contains the definitions of the standard attributes 
           that may appear on any element.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:attribute name="default-collation" type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation"
                  type="xsl:validation-strip-or-preserve"
                  default="strip"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="expand-text" type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="schema-role" type="xs:NCName"/&gt;
    &lt;xs:attribute name="use-when" type="xsl:expression"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" type="xs:anyURI"/&gt;
    &lt;xs:attribute name="_default-collation" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-mode" type="xs:string"/&gt;
    &lt;xs:attribute name="_default-validation" type="xs:string"/&gt;
    &lt;xs:attribute name="_exclude-result-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_expand-text" type="xs:string"/&gt;
    &lt;xs:attribute name="_extension-element-prefixes" type="xs:string"/&gt;
    &lt;xs:attribute name="_schema-role" type="xs:string"/&gt;
    &lt;xs:attribute name="_use-when" type="xs:string"/&gt;
    &lt;xs:attribute name="_xpath-default-namespace" type="xs:string"/&gt;
    &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="element-only-generic-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:generic-element-type"/&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="versioned-element-type" mixed="true"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This complex type provides a generic supertype for all XSLT elements with
                the exception of &lt;code&gt;xsl:output&lt;/code&gt; and &lt;code&gt;xsl:record&lt;/code&gt;; it contains the
                definitions of the &lt;code&gt;version&lt;/code&gt; attribute that may appear on any element.
                &lt;/p&gt;
        &lt;p&gt;The &lt;code&gt;xsl:output&lt;/code&gt; element does not use this definition because, although it
             has a &lt;code&gt;version&lt;/code&gt; attribute, the syntax and semantics of this attribute are
             unrelated to the standard &lt;code&gt;version&lt;/code&gt; attribute allowed on other elements.&lt;/p&gt;
        &lt;p&gt;Similarly &lt;code&gt;xsl:record&lt;/code&gt; does not use this definition because it expects
        standard attributes (including [xsl:]version) to be in the XSLT namespace.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:extension base="xsl:generic-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="element-only-versioned-element-type" mixed="false"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:versioned-element-type"&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:complexType name="sequence-constructor"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements
           that allow a sequence constructor as their content.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:versioned-element-type"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group"
                  minOccurs="0"
                  maxOccurs="unbounded"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-and-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type allows a sequence constructor and a select attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:extension base="xsl:sequence-constructor"&gt;
        &lt;xs:attribute name="select" type="xsl:expression"/&gt;
        &lt;xs:attribute name="_select" type="xs:string"/&gt;
      &lt;/xs:extension&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;
  
  &lt;xs:complexType name="sequence-constructor-or-select"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type allows a sequence constructor or a select attribute,
           but not both.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexContent mixed="true"&gt;
      &lt;xs:restriction base="xsl:sequence-constructor-and-select"&gt;
        &lt;xs:group ref="xsl:sequence-constructor-group"
                  minOccurs="0"
                  maxOccurs="unbounded"/&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;xs:assert test="not(exists(@select | @_select) and 
          (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:group name="sequence-constructor-group"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This complex type provides a generic supertype for all XSLT elements
           that allow a sequence constructor as their content.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:instruction"/&gt;
      &lt;xs:element ref="xsl:record"/&gt;
      &lt;xs:group ref="xsl:result-elements"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;

  &lt;xs:element name="declaration" type="xsl:generic-element-type" abstract="true"/&gt;

  &lt;xs:element name="instruction" type="xsl:versioned-element-type" abstract="true"/&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART B: definitions of individual XSLT elements Elements are listed in
         alphabetical order.
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  
  &lt;xs:element name="accept"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any variations that the containing package wishes to make to the visibility of
            components made available from a library package. For example, it may indicate that
            some of the public components in the library package are not to be made available
            to the containing package.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:component-tests"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@component | @_component)"/&gt;
          &lt;xs:assert test="exists(@names | @_names)"/&gt;
          &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="accumulator" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:accumulator-rule" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="initial-value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_initial-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="accumulator-rule"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:sequence/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="phase"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="start"/&gt;
                &lt;xs:enumeration value="end"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="capture" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_phase" type="xs:string"/&gt;
          &lt;xs:attribute name="_capture" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="analyze-string" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:non-matching-substring" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="regex" type="xsl:avt"/&gt;
          &lt;xs:attribute name="flags" type="xsl:avt" default=""/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_regex" type="xs:string"/&gt;
          &lt;xs:attribute name="_flags" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="exists(@regex | @_regex)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-imports" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="apply-templates" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:sort"/&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="select" type="xsl:expression" default="child::node()"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="mode" type="xsl:mode"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="array" 
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="for-each" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_for-each" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="array-member"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="assert" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="attribute-set" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:attribute"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="break"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="call-template" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="catch"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="errors" type="xsl:nametests" use="optional"/&gt;
          &lt;xs:attribute name="_errors" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="character-map" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:output-character" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="choose" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="comment"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="context-item"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="absent"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="copy-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="copy-accumulators" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="decimal-format" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="decimal-separator" type="xsl:char-optionally-expanded" default="."/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:char-optionally-expanded" default=","/&gt;
          &lt;xs:attribute name="infinity" type="xs:string" default="Infinity"/&gt;
          &lt;xs:attribute name="minus-sign" type="xs:string" default="-"/&gt;
          &lt;xs:attribute name="exponent-separator" type="xsl:char-optionally-expanded" default="e"/&gt;
          &lt;xs:attribute name="NaN" type="xs:string" default="NaN"/&gt;
          &lt;xs:attribute name="percent" type="xsl:char-optionally-expanded" default="%"/&gt;
          &lt;xs:attribute name="per-mille" type="xsl:char-optionally-expanded" default="â&#x80;°"/&gt;
          &lt;xs:attribute name="zero-digit" type="xsl:zero-digit" default="0"/&gt;
          &lt;xs:attribute name="digit" type="xsl:char" default="#"/&gt;
          &lt;xs:attribute name="pattern-separator" type="xsl:char" default=";"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_decimal-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_infinity" type="xs:string"/&gt;
          &lt;xs:attribute name="_minus-sign" type="xs:string"/&gt;
          &lt;xs:attribute name="_exponent-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_NaN" type="xs:string"/&gt;
          &lt;xs:attribute name="_percent" type="xs:string"/&gt;
          &lt;xs:attribute name="_per-mille" type="xs:string"/&gt;
          &lt;xs:attribute name="_zero-digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_digit" type="xs:string"/&gt;
          &lt;xs:attribute name="_pattern-separator" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="element" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType mixed="true"&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="namespace" type="xsl:avt"/&gt;
          &lt;xs:attribute name="inherit-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="use-attribute-sets" type="xsl:EQNames" default=""/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_inherit-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-attribute-sets" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="evaluate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="xpath" type="xsl:expression"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="base-uri" type="xsl:avt"/&gt;
          &lt;xs:attribute name="context-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="namespace-context" type="xsl:expression"/&gt;
          &lt;xs:attribute name="schema-aware" type="xsl:avt"/&gt;
          &lt;xs:attribute name="trusted" type="xsl:avt"/&gt;
          &lt;xs:attribute name="with-params" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_xpath" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_base-uri" type="xs:string"/&gt;
          &lt;xs:attribute name="_context-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_namespace-context" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-aware" type="xs:string"/&gt;
          &lt;xs:attribute name="_trusted" type="xs:string"/&gt;
          &lt;xs:attribute name="_with-params" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@xpath | @_xpath)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="expose"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            the visibility of components that are made available (or not) by this package
            to other using packages.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="component" type="xsl:component-kind-type"/&gt;
          &lt;xs:attribute name="names" type="xsl:component-tests"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_component" type="xs:string"/&gt;
          &lt;xs:attribute name="_names" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@component | @_component)"/&gt;
          &lt;xs:assert test="exists(@names | @_names)"/&gt;
          &lt;xs:assert test="exists(@visibility | @_visibility)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fallback"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor"/&gt;
  
  &lt;xs:element name="field"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="name" type="xs:NCName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="default" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_required" type="xs:string"/&gt;
          &lt;xs:attribute name="_default" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="for-each-group" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-by" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-adjacent" type="xsl:expression"/&gt;
          &lt;xs:attribute name="group-starting-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="group-ending-with" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="split-when" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-by" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-adjacent" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-starting-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_group-ending-with" type="xs:string"/&gt;
          &lt;xs:attribute name="_split-when" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="count(((@group-by|@_group-by)[1], 
                                  (@group-adjacent|@_group-adjacent)[1], 
                                  (@group-starting-with|@_group-starting-with)[1], 
                                  (@group-ending-with|@_group-ending-with)[1],
                                  (@split-when|@_split-when)[1])) = 1"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   These four attributes are mutually exclusive: it is a static
                   error if none of these four attributes is present or if more
                   than one of them is present.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (exists(@collation|@_collation) or exists(@composite|@_composite)) 
                           then (exists(@group-by|@_group-by) or exists(@group-adjacent|@_group-adjacent)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is an error to specify the collation attribute or the
                   composite attribute if neither the group-by attribute nor
                   group-adjacent attribute is specified.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="fork" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:choice&gt;
              &lt;xs:sequence minOccurs="0" maxOccurs="unbounded"&gt;
                &lt;xs:element ref="xsl:sequence"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
              &lt;xs:sequence&gt;
                &lt;xs:element ref="xsl:for-each-group"/&gt;
                &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
              &lt;/xs:sequence&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="function" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="override" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="streamability" type="xsl:streamability-type"/&gt;
          &lt;xs:attribute name="override-extension-function" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="new-each-time" type="xsl:yes-or-no-or-maybe"/&gt;
          &lt;xs:attribute name="cache" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_override" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamability" type="xs:string"/&gt;
          &lt;xs:attribute name="_override-extension-function" type="xs:string"/&gt;
          &lt;xs:attribute name="_new-each-time" type="xs:string"/&gt;
          &lt;xs:attribute name="_cache" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a function must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="global-context-item" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="as" type="xsl:item-type"/&gt;
          &lt;xs:attribute name="use"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xs:token"&gt;
                &lt;xs:enumeration value="required"/&gt;
                &lt;xs:enumeration value="optional"/&gt;
                &lt;xs:enumeration value="absent"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  

  &lt;xs:element name="if" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="then" type="xsl:expression"/&gt;
          &lt;xs:attribute name="else" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:attribute name="_then" type="xs:string"/&gt;
          &lt;xs:attribute name="_else" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
          &lt;xs:assert test="not(exists(@then | @_then) and 
            (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="import-schema" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xs:schema" minOccurs="0" maxOccurs="1"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="namespace" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="role" type="xs:NCName"/&gt;
          &lt;xs:attribute name="schema-location" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_namespace" type="xs:string"/&gt;
          &lt;xs:attribute name="_role" type="xs:string"/&gt;
          &lt;xs:attribute name="_schema-location" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@schema-location | @_schema-location) and exists(xs:schema))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0215: It is a static error if an &lt;code&gt;xsl:import-schema&lt;/code&gt; element
                   that contains an xs:schema element has a &lt;code&gt;schema-location&lt;/code&gt;
                   attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="include" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="iterate" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:on-completion" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="key" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="use" type="xsl:expression"/&gt;
          &lt;xs:attribute name="composite" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="collation" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_use" type="xs:string"/&gt;
          &lt;xs:attribute name="_composite" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="exists(@match | @_match)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="duplicates" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_duplicates" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="map-entry" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-and-select"&gt;
          &lt;xs:attribute name="key" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_key" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@key | @_key)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="matching-substring" type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="merge" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-source" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:merge-action" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-action" type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="merge-key" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="merge-source"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:merge-key" minOccurs="1" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xs:NCName"/&gt;
          &lt;xs:attribute name="for-each-item" type="xsl:expression"/&gt;
          &lt;xs:attribute name="for-each-source" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="sort-before-merge" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-item" type="xs:string"/&gt;
          &lt;xs:attribute name="_for-each-source" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_sort-before-merge" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="message" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="terminate" type="xsl:avt" default="no"/&gt;
          &lt;xs:attribute name="error-code" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_terminate" type="xs:string"/&gt;
          &lt;xs:attribute name="_error-code" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="mode" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt; 
            &lt;xs:element ref="xsl:fallback"/&gt; 
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="copy-namespaces" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="on-no-match" type="xsl:on-no-match-type" default="text-only-copy"/&gt;
          &lt;xs:attribute name="on-multiple-match"
                        type="xsl:on-multiple-match-type"
                        default="use-last"/&gt;
          &lt;xs:attribute name="warning-on-no-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="warning-on-multiple-match" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="typed" type="xsl:typed-type"/&gt;
          &lt;xs:attribute name="visibility"&gt;
            &lt;xs:simpleType&gt;
              &lt;xs:restriction base="xsl:visibility-type"&gt;
                &lt;xs:enumeration value="public"/&gt;
                &lt;xs:enumeration value="private"/&gt;
                &lt;xs:enumeration value="final"/&gt;
              &lt;/xs:restriction&gt;
            &lt;/xs:simpleType&gt;
          &lt;/xs:attribute&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_copy-namespaces" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-no-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_warning-on-multiple-match" type="xs:string"/&gt;
          &lt;xs:attribute name="_typed" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="namespace" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="namespace-alias" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="stylesheet-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="result-prefix" type="xsl:prefix-or-default"/&gt;
          &lt;xs:attribute name="_stylesheet-prefix" type="xs:string"/&gt;
          &lt;xs:attribute name="_result-prefix" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@stylesheet-prefix | @_stylesheet-prefix)"/&gt;
          &lt;xs:assert test="exists(@result-prefix | @_result-prefix)"/&gt;
          &lt;xs:assert test="every $prefix in (@stylesheet-prefix, @result-prefix)/normalize-space(.)[. ne '#default']
                           satisfies $prefix = in-scope-prefixes(.)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-iteration" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:with-param" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;


  &lt;xs:element name="next-match" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:with-param"/&gt;
            &lt;xs:element ref="xsl:fallback"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="non-matching-substring" type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="note" type="xs:anyType"/&gt;

  &lt;xs:element name="number" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:attribute name="value" type="xsl:expression"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="level" type="xsl:level" default="single"/&gt;
          &lt;xs:attribute name="count" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="from" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="format" type="xsl:avt" default="1"/&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="letter-value" type="xsl:avt"/&gt;
          &lt;xs:attribute name="ordinal" type="xsl:avt"/&gt;
          &lt;xs:attribute name="start-at" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="grouping-size" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_value" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_level" type="xs:string"/&gt;
          &lt;xs:attribute name="_count" type="xs:string"/&gt;
          &lt;xs:attribute name="_from" type="xs:string"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_letter-value" type="xs:string"/&gt;
          &lt;xs:attribute name="_ordinal" type="xs:string"/&gt;
          &lt;xs:attribute name="_start-at" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_grouping-size" type="xs:string"/&gt;
          &lt;xs:assert test="if (exists(@value | @_value)) 
                           then empty((@select | @_select, @count | @_count, @from | @_from)) 
                            and (exists(@_level) or normalize-space(@level)='single') 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if the value attribute of &lt;code&gt;xsl:number&lt;/code&gt; is
                   present unless the &lt;code&gt;select&lt;/code&gt;, &lt;code&gt;level&lt;/code&gt;, &lt;code&gt;count&lt;/code&gt;, 
                   and &lt;code&gt;from&lt;/code&gt; attributes are all absent.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="on-completion" type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="on-empty"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;
  
  &lt;xs:element name="on-non-empty"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="otherwise" 
              type="xsl:sequence-constructor-or-select"/&gt;

  &lt;xs:element name="output" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent &gt;
        &lt;xs:extension base="xsl:element-only-generic-element-type"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="method" type="xsl:method"/&gt;
          &lt;xs:attribute name="allow-duplicate-names" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="build-tree" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="canonical" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="escape-solidus" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="html-version" type="xs:decimal"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="indent" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="json-lines" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="json-node-output-method" type="xsl:method"/&gt;
          &lt;xs:attribute name="media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="normalization-form" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="parameter-document" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:yes-or-no-or-omit"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="version" type="xs:NMTOKEN"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_allow-duplicate-names" type="xs:string"/&gt;
          &lt;xs:attribute name="_build-tree" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_canonical" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-solidus" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-lines" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-node-output-method" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_version" type="xs:string"/&gt;
          &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="output-character"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="character" type="xsl:char"/&gt;
          &lt;xs:attribute name="string" type="xs:string"/&gt;
          &lt;xs:attribute name="_character" type="xs:string"/&gt;
          &lt;xs:attribute name="_string" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@character | @_character)"/&gt;
          &lt;xs:assert test="exists(@string | @_string)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="override"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:use-package&lt;/code&gt; and defines 
            any overriding definitions of components that the containing package wishes to make 
            to the components made available from a library package.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:template"/&gt;
            &lt;xs:element ref="xsl:function"/&gt;
            &lt;xs:element ref="xsl:variable"/&gt;
            &lt;xs:element ref="xsl:param"/&gt;
            &lt;xs:element ref="xsl:attribute-set"/&gt;
          &lt;/xs:choice&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
    
  &lt;xs:element name="package"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:expose"/&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="declared-modes" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="input-type-annotations" type="xsl:input-type-annotations-type"/&gt;
          &lt;xs:attribute name="fixed-namespaces" type="xsl:fixed-namespaces-type"/&gt;
          &lt;xs:attribute name="_declared-modes" type="xs:string"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
          &lt;xs:attribute name="_fixed-namespaces" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="package-location"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="href" type="xs:anyURI" use="required"/&gt;
          &lt;xs:attribute name="path-in-archive" type="xs:string"/&gt;
          &lt;xs:attribute name="archive-type" type="xs:string"/&gt;
          &lt;xs:attribute name="is-priority" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="format" type="xs:string"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_path-in-archive" type="xs:string"/&gt;
          &lt;xs:attribute name="_archive-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_is-priority" type="xs:string"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="param" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;Declaration of the &lt;code&gt;xsl:param&lt;/code&gt; element, used both defining function
            parameters, template parameters, parameters to &lt;code&gt;xsl:iterate&lt;/code&gt;,
            and global stylesheet parameters.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="required" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_required" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then empty((*,text())) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the attribute &lt;code&gt;static="yes"&lt;/code&gt; is specified, the &lt;code&gt;xsl:param&lt;/code&gt;
                   element must have empty content.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  

  &lt;xs:element name="perform-sort" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:sort" minOccurs="1" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:assert test="every $e in subsequence(xsl:sort, 2) 
                           satisfies empty($e/(@stable | @_stable))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   It is a static error if an &lt;code&gt;xsl:sort&lt;/code&gt; element other than the first
                   in a sequence of sibling &lt;code&gt;xsl:sort&lt;/code&gt; elements has a &lt;code&gt;stable&lt;/code&gt;
                   attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="preserve-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="processing-instruction" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="record"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;  
          &lt;xs:attribute name="as" form="qualified" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="duplicates" form="qualified" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" form="qualified" type="xs:string"/&gt;
          &lt;xs:attribute name="_duplicates" form="qualified" type="xs:string"/&gt;
          &lt;xs:attributeGroup ref="xsl:literal-result-element-attributes"/&gt;
          &lt;xs:anyAttribute namespace="##local" processContents="lax"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="record-type" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:field" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="extensible" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-type"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_extensible" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="result-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="format" type="xsl:avt"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="allow-duplicate-names" type="xsl:avt"/&gt;
          &lt;xs:attribute name="build-tree" type="xsl:avt"/&gt;
          &lt;xs:attribute name="byte-order-mark" type="xsl:avt"/&gt;
          &lt;xs:attribute name="canonical" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata-section-elements" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-public" type="xsl:avt"/&gt;
          &lt;xs:attribute name="doctype-system" type="xsl:avt"/&gt;
          &lt;xs:attribute name="encoding" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-solidus" type="xsl:avt"/&gt;
          &lt;xs:attribute name="escape-uri-attributes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="html-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="include-content-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="indent" type="xsl:avt"/&gt;
          &lt;xs:attribute name="item-separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="json-lines" type="xsl:avt"/&gt;
          &lt;xs:attribute name="json-node-output-method" type="xsl:avt"/&gt;
          &lt;xs:attribute name="media-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="normalization-form" type="xsl:avt"/&gt;
          &lt;xs:attribute name="omit-xml-declaration" type="xsl:avt"/&gt;
          &lt;xs:attribute name="parameter-document" type="xsl:avt"/&gt;
          &lt;xs:attribute name="standalone" type="xsl:avt"/&gt;
          &lt;xs:attribute name="suppress-indentation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="undeclare-prefixes" type="xsl:avt"/&gt;
          &lt;xs:attribute name="use-character-maps" type="xsl:EQNames"/&gt;
          &lt;xs:attribute name="output-version" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_format" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:attribute name="_method" type="xs:string"/&gt;
          &lt;xs:attribute name="_allow-duplicate-names" type="xs:string"/&gt;
          &lt;xs:attribute name="_build-tree" type="xs:string"/&gt;
          &lt;xs:attribute name="_byte-order-mark" type="xs:string"/&gt;
          &lt;xs:attribute name="_canonical" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata-section-elements" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-public" type="xs:string"/&gt;
          &lt;xs:attribute name="_doctype-system" type="xs:string"/&gt;
          &lt;xs:attribute name="_encoding" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-solidus" type="xs:string"/&gt;
          &lt;xs:attribute name="_escape-uri-attributes" type="xs:string"/&gt;
          &lt;xs:attribute name="_html-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_include-content-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_indent" type="xs:string"/&gt;
          &lt;xs:attribute name="_item-separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-lines" type="xs:string"/&gt;
          &lt;xs:attribute name="_json-node-output-method" type="xs:string"/&gt;
          &lt;xs:attribute name="_media-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_normalization-form" type="xs:string"/&gt;
          &lt;xs:attribute name="_omit-xml-declaration" type="xs:string"/&gt;
          &lt;xs:attribute name="_parameter-document" type="xs:string"/&gt;
          &lt;xs:attribute name="_standalone" type="xs:string"/&gt;
          &lt;xs:attribute name="_suppress-indentation" type="xs:string"/&gt;
          &lt;xs:attribute name="_undeclare-prefixes" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-character-maps" type="xs:string"/&gt;
          &lt;xs:attribute name="_output-version" type="xs:string"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="select"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;  
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:assert test="empty(xsl:fallback/preceding-sibling::text()[normalize-space()])"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;An xsl:fallback child must not be preceded by a non-whitespace text node.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="sequence"
              substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="sort"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="lang" type="xsl:avt"/&gt;
          &lt;xs:attribute name="data-type" type="xsl:avt"/&gt;
          &lt;xs:attribute name="order" type="xsl:avt" default="ascending"/&gt;
          &lt;xs:attribute name="case-order" type="xsl:avt"/&gt;
          &lt;xs:attribute name="collation" type="xsl:avt"/&gt;
          &lt;xs:attribute name="stable" type="xsl:avt"/&gt;
          &lt;xs:attribute name="_lang" type="xs:string"/&gt;
          &lt;xs:attribute name="_data-type" type="xs:string"/&gt;
          &lt;xs:attribute name="_order" type="xs:string"/&gt;
          &lt;xs:attribute name="_case-order" type="xs:string"/&gt;
          &lt;xs:attribute name="_collation" type="xs:string"/&gt;
          &lt;xs:attribute name="_stable" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="source-document" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="href" type="xsl:avt"/&gt;
          &lt;xs:attribute name="streamable" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="use-accumulators" type="xsl:accumulator-names"/&gt;
          &lt;xs:attribute name="type" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="validation" type="xsl:validation-type"/&gt;
          &lt;xs:attribute name="_href" type="xs:string"/&gt;
          &lt;xs:attribute name="_streamable" type="xs:string"/&gt;
          &lt;xs:attribute name="_use-accumulators" type="xs:string"/&gt;
          &lt;xs:attribute name="_type" type="xs:string"/&gt;
          &lt;xs:attribute name="_validation" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@href | @_href)"/&gt;
          &lt;xs:assert test="not(exists(@type | @_type) and exists(@validation | @_validation))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;The &lt;code&gt;type&lt;/code&gt; and &lt;code&gt;validation&lt;/code&gt; attributes are mutually exclusive
                  (if one is present, the other must be absent).&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="strip-space" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:attribute name="elements" type="xsl:nametests"/&gt;
          &lt;xs:attribute name="_elements" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@elements | @_elements)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="stylesheet" substitutionGroup="xsl:transform"/&gt;

  &lt;xs:element name="switch" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:when" maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:otherwise" minOccurs="0"/&gt;
            &lt;xs:element ref="xsl:fallback" minOccurs="0" maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xsl:avt"/&gt;
          &lt;xs:assert test="exists(@select | @_select)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="template" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:element ref="xsl:context-item" minOccurs="0" maxOccurs="1"/&gt;
            &lt;xs:element ref="xsl:param" minOccurs="0" maxOccurs="unbounded"/&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="match" type="xsl:pattern"/&gt;
          &lt;xs:attribute name="priority" type="xs:decimal"/&gt;
          &lt;xs:attribute name="mode" type="xsl:modes"/&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type" default="item()*"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="_match" type="xs:string"/&gt;
          &lt;xs:attribute name="_priority" type="xs:string"/&gt;
          &lt;xs:attribute name="_mode" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@match | @_match) or exists(@name | @_name)"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element must have either a &lt;code&gt;match&lt;/code&gt; attribute or a
                   &lt;code&gt;name&lt;/code&gt; attribute, or both.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (empty(@match | @_match)) 
                           then (empty(@mode | @_mode) and empty(@priority | @_priority)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element that has no &lt;code&gt;match&lt;/code&gt; attribute must have no
                   &lt;code&gt;mode&lt;/code&gt; attribute and no &lt;code&gt;priority&lt;/code&gt; attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(exists(@visibility | @_visibility) and empty(@name | @_name))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   An &lt;code&gt;xsl:template&lt;/code&gt; element that has no &lt;code&gt;name&lt;/code&gt; attribute must have no
                   &lt;code&gt;visibility&lt;/code&gt; attribute
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@visibility) = 'abstract') 
                           then empty(* except (xsl:context-item, xsl:param)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   If the &lt;code&gt;visibility&lt;/code&gt; attribute is present with the value &lt;code&gt;abstract&lt;/code&gt;
                   then (a) the sequence constructor defining the template body
                   must be empty: that is, the only permitted children are
                   &lt;code&gt;xsl:context-item&lt;/code&gt; and &lt;code&gt;xsl:param&lt;/code&gt;
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="not(normalize-space(@visibility) = 'abstract' and exists(@match))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   If the &lt;code&gt;visibility&lt;/code&gt; attribute is present with the value &lt;code&gt;abstract&lt;/code&gt;
                   then there must be no &lt;code&gt;match&lt;/code&gt; attribute.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $e in xsl:param satisfies empty($e/(@visibility | @_visibility))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;A parameter for a template must have no &lt;code&gt;visibility&lt;/code&gt; attribute.&lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="text" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata" type="xs:string"/&gt;
          &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:complexType name="transform-element-base-type"&gt;
    &lt;xs:complexContent&gt;
      &lt;xs:restriction base="xsl:element-only-versioned-element-type"&gt;
        &lt;xs:attribute name="version" type="xs:decimal" use="optional"/&gt;
        &lt;xs:attribute name="_version" type="xs:string"&gt;
          &lt;xs:annotation&gt;
            &lt;xs:documentation&gt;
              &lt;p&gt;
                 The version attribute indicates the version of XSLT that the
                 stylesheet module requires. The attribute is required, unless the
                 &lt;code&gt;xsl:stylesheet&lt;/code&gt; element is a child of an &lt;code&gt;xsl:package&lt;/code&gt; element, in
                 which case it is optional: the default is then taken from the
                 parent &lt;code&gt;xsl:package&lt;/code&gt; element.
              &lt;/p&gt;
            &lt;/xs:documentation&gt;
          &lt;/xs:annotation&gt;
        &lt;/xs:attribute&gt;
        &lt;xs:anyAttribute namespace="##other" processContents="lax"/&gt;
      &lt;/xs:restriction&gt;
    &lt;/xs:complexContent&gt;
  &lt;/xs:complexType&gt;

  &lt;xs:element name="transform"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent&gt;
        &lt;xs:extension base="xsl:transform-element-base-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:declaration"/&gt;
              &lt;xs:any namespace="##other" processContents="lax"/&gt;
              &lt;!-- weaker than XSLT 1.0 --&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="id" type="xs:ID"/&gt;
          &lt;xs:attribute name="input-type-annotations"
                        type="xsl:input-type-annotations-type"
                        default="unspecified"/&gt;
          &lt;xs:attribute name="fixed-namespaces"
                        type="xsl:fixed-namespaces-type"/&gt;
          &lt;xs:attribute name="_id" type="xs:string"/&gt;
          &lt;xs:attribute name="_input-type-annotations" type="xs:string"/&gt;
          &lt;xs:attribute name="_fixed-namespaces" type="xs:string"/&gt;
          &lt;!--* The 'static' attribute may be used on 'param' and 'variable'
              * only when they are top-level elements. *--&gt;
          &lt;xs:assert test="every $v in (.//xsl:param, .//xsl:variable)[exists(@static | @_static)] 
                           satisfies $v[parent::xsl:stylesheet or parent::xsl:transform or parent::xsl:override]"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   The static attribute must not be present on an &lt;code&gt;xsl:variable&lt;/code&gt; or
                   &lt;code&gt;xsl:param&lt;/code&gt; element unless it is a top-level element.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="every $prefix in (@exclude-result-prefixes[not(. = '#all')], 
                                             @extension-element-prefixes) 
                           satisfies ((if ($prefix = '#default') then '' else $prefix) = in-scope-prefixes(.))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0808: It is a static error if a namespace prefix is used
                   within the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute and there is
                   no namespace binding in scope for that prefix.
                &lt;/p&gt;
                &lt;p&gt;
                   XTSE0809: It is a static error if the value #default is used
                   within the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute and the
                   parent element of the &lt;code&gt;[xsl:]exclude-result-prefixes&lt;/code&gt; attribute
                   has no default namespace.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="try" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:versioned-element-type"&gt;
          &lt;xs:sequence&gt;
            &lt;xs:group ref="xsl:sequence-constructor-group"
                      minOccurs="0"
                      maxOccurs="unbounded"/&gt;
            &lt;xs:element ref="xsl:catch" minOccurs="1" maxOccurs="1"/&gt;
            &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
              &lt;xs:element ref="xsl:catch"/&gt;
              &lt;xs:element ref="xsl:fallback"/&gt;
            &lt;/xs:choice&gt;
          &lt;/xs:sequence&gt;
          &lt;xs:attribute name="rollback-output" type="xsl:yes-or-no" default="yes"/&gt;
          &lt;xs:attribute name="select" type="xsl:expression" use="optional"/&gt;
          &lt;xs:attribute name="_rollback-output" type="xs:string"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="use-package" substitutionGroup="xsl:declaration"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;This element appears as a child of &lt;code&gt;xsl:package&lt;/code&gt; and defines a dependency
            of the containing package on another package, identified by URI in the &lt;code&gt;name&lt;/code&gt;
            attribute. The &lt;code&gt;package-version&lt;/code&gt; attribute indicates which version of the
            library package is required, or may indicate a range of versions.&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="false"&gt;
        &lt;xs:extension base="xsl:element-only-versioned-element-type"&gt;
          &lt;xs:choice minOccurs="0" maxOccurs="unbounded"&gt;
            &lt;xs:element ref="xsl:package-location"/&gt;
            &lt;xs:element ref="xsl:accept"/&gt;
            &lt;xs:element ref="xsl:override"/&gt;
          &lt;/xs:choice&gt;
          &lt;xs:attribute name="name" type="xs:anyURI"/&gt;
          &lt;xs:attribute name="package-version" type="xs:string"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_package-version" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="value-of" substitutionGroup="xsl:instruction"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="separator" type="xsl:avt"/&gt;
          &lt;xs:attribute name="cdata" type="xsl:avt"/&gt;
          &lt;xs:attribute name="disable-output-escaping" type="xsl:yes-or-no" default="no"/&gt;
          &lt;xs:attribute name="_separator" type="xs:string"/&gt;
          &lt;xs:attribute name="_cdata" type="xs:string"/&gt;
          &lt;xs:attribute name="_disable-output-escaping" type="xs:string"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="variable" substitutionGroup="xsl:declaration xsl:instruction"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;Declaration of the &lt;code&gt;xsl:variable&lt;/code&gt; element, used both for local
            and global variable bindings.&lt;/p&gt;
        &lt;p&gt;
           This definition takes advantage of the ability in XSD 1.1 for an element
           to belong to more than one substitution group. A global variable is a
           declaration, while a local variable can appear as an instruction in a
           sequence constructor.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="visibility" type="xsl:visibility-not-hidden-type"/&gt;
          &lt;xs:attribute name="static" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_visibility" type="xs:string"/&gt;
          &lt;xs:attribute name="_static" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then (exists(@_visibility) or normalize-space(@visibility) 
                                       = ('', 'private', 'final')) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the static attribute is present with the value yes, the
                   visibility attribute must not have a value other than private or
                   final.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
          &lt;xs:assert test="if (normalize-space(@static) = ('yes', 'true', '1')) 
                           then (empty((*, text())) and exists(@select | @_select)) 
                           else true()"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   When the attribute &lt;code&gt;static="yes"&lt;/code&gt; is specified, the &lt;code&gt;xsl:variable&lt;/code&gt;
                   element must have empty content, and the &lt;code&gt;select&lt;/code&gt; attribute must
                   be present to define the value of the variable.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assert&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;xs:element name="when"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor"&gt;
          &lt;xs:attribute name="select" type="xsl:expression"/&gt;
          &lt;xs:attribute name="test" type="xsl:expression"/&gt;
          &lt;xs:attribute name="_select" type="xs:string"/&gt;
          &lt;xs:attribute name="_test" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@test | @_test)"/&gt;
          &lt;xs:assert test="not(exists(@select | @_select) and 
            (exists(* except xsl:fallback) or exists(text()[normalize-space()])))"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;
  
  &lt;xs:element name="where-populated"
              substitutionGroup="xsl:instruction"
              type="xsl:sequence-constructor"/&gt;

  &lt;xs:element name="with-param"&gt;
    &lt;xs:complexType&gt;
      &lt;xs:complexContent mixed="true"&gt;
        &lt;xs:extension base="xsl:sequence-constructor-or-select"&gt;
          &lt;xs:attribute name="name" type="xsl:EQName"/&gt;
          &lt;xs:attribute name="as" type="xsl:sequence-type"/&gt;
          &lt;xs:attribute name="tunnel" type="xsl:yes-or-no"/&gt;
          &lt;xs:attribute name="_name" type="xs:string"/&gt;
          &lt;xs:attribute name="_as" type="xs:string"/&gt;
          &lt;xs:attribute name="_tunnel" type="xs:string"/&gt;
          &lt;xs:assert test="exists(@name | @_name)"/&gt;
        &lt;/xs:extension&gt;
      &lt;/xs:complexContent&gt;
    &lt;/xs:complexType&gt;
  &lt;/xs:element&gt;

  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt; PART C: definition of literal result elements There are three ways to define
      the literal result elements permissible in a stylesheet. (a) do nothing. This allows any
      element to be used as a literal result element, provided it is not in the XSLT namespace (b)
      declare all permitted literal result elements as members of the &lt;code&gt;xsl:literal-result-element&lt;/code&gt;
      substitution group (c) redefine the model group xsl:result-elements to accommodate all
      permitted literal result elements. Literal result elements are allowed to take certain
      attributes in the XSLT namespace. These are defined in the attribute group
      &lt;code&gt;literal-result-element-attributes&lt;/code&gt;, which can be included in the definition of any literal
      result element. &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:element name="literal-result-element" abstract="true" type="xs:anyType"/&gt;

  &lt;xs:attributeGroup name="literal-result-element-attributes"&gt;
    &lt;xs:attribute name="default-collation" 
                  form="qualified" 
                  type="xsl:uri-list"/&gt;
    &lt;xs:attribute name="default-mode" 
                  form="qualified"  
                  type="xsl:default-mode-type"/&gt;
    &lt;xs:attribute name="default-validation" 
                  form="qualified" 
                  type="xsl:validation-strip-or-preserve"
                  default="strip"/&gt;
    &lt;xs:attribute name="expand-text" 
                  form="qualified"  
                  type="xsl:yes-or-no"/&gt;
    &lt;xs:attribute name="extension-element-prefixes" 
                  form="qualified" 
                  type="xsl:prefix-list"/&gt;
    &lt;xs:attribute name="exclude-result-prefixes" 
                  form="qualified" 
                  type="xsl:prefix-list-or-all"/&gt;
    &lt;xs:attribute name="inherit-namespaces"
                  form="qualified"
                  type="xsl:yes-or-no"
                  default="yes"/&gt;
    &lt;xs:attribute name="schema-role"
                  form="qualified"
                  type="xs:NCName"
                  default="yes"/&gt;
    &lt;xs:attribute name="use-attribute-sets"
                  form="qualified"
                  type="xsl:EQNames"
                  default=""/&gt;
    &lt;xs:attribute name="use-when" 
                  form="qualified" 
                  type="xsl:expression"/&gt;
    &lt;xs:attribute name="version" 
                  form="qualified" 
                  type="xs:decimal"/&gt;
    &lt;xs:attribute name="type" 
                  form="qualified" 
                  type="xsl:EQName"/&gt;
    &lt;xs:attribute name="validation" 
                  form="qualified" 
                  type="xsl:validation-type"/&gt;
    &lt;xs:attribute name="xpath-default-namespace" 
                  form="qualified" 
                  type="xs:anyURI"/&gt;
  &lt;/xs:attributeGroup&gt;

  &lt;xs:group name="result-elements"&gt;
    &lt;xs:choice&gt;
      &lt;xs:element ref="xsl:literal-result-element"/&gt;
      &lt;xs:any namespace="##other" processContents="lax"/&gt;
      &lt;xs:any namespace="##local" processContents="lax"/&gt;
    &lt;/xs:choice&gt;
  &lt;/xs:group&gt;


  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;
  &lt;xs:annotation&gt;
    &lt;xs:documentation&gt;
      &lt;p&gt;
         PART D: definitions of simple types used in stylesheet attributes
      &lt;/p&gt;
    &lt;/xs:documentation&gt;
  &lt;/xs:annotation&gt;
  &lt;!-- ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ --&gt;

  &lt;xs:simpleType name="accumulator-names"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;use-accumulators&lt;/code&gt; attribute of &lt;code&gt;xsl:source-document&lt;/code&gt;, 
           &lt;code&gt;xsl:merge-source&lt;/code&gt;, or &lt;code&gt;xsl:global-context-item&lt;/code&gt;: 
           either a list, each member being a QName; or the value &lt;code&gt;#all&lt;/code&gt;
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:list itemType="xsl:EQName"/&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt; 
  
  &lt;xs:simpleType name="avt"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           This type is used for all attributes that allow an attribute value
           template. The general rules for the syntax of attribute value templates,
           and the specific rules for each such attribute, are described in the
           XSLT 4.0 Recommendation.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="char"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A string containing exactly one character.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:length value="1"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

           
  &lt;xs:simpleType name="char-optionally-expanded"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A string containing either a single character, or a single character
           followed by a colon followed by an arbitrary string
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:string"&gt;
      &lt;xs:pattern value=".(:.*)?"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt; 

           
  &lt;xs:simpleType name="component-kind-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes a kind of component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="template"/&gt;
      &lt;xs:enumeration value="function"/&gt;
      &lt;xs:enumeration value="variable"/&gt;
      &lt;xs:enumeration value="attribute-set"/&gt;
      &lt;xs:enumeration value="mode"/&gt;
      &lt;xs:enumeration value="*"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="default-mode-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;default-mode&lt;/code&gt; attribute of &lt;code&gt;xsl:stylesheet&lt;/code&gt;, 
           &lt;code&gt;xsl:transform&lt;/code&gt;, &lt;code&gt;xsl:package&lt;/code&gt;
           (or any other xsl:* element): either a QName or #unnamed.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="component-test"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A NameTest or a named function reference. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:nametest xsl:named-function-reference"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="component-tests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests or named function references&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:component-test"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="expression"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An XPath 4.0 expression.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
          A sequence of tokens, each of which may be one of #default, an NCName, a prefix=namespace binding, or a URI
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:union memberTypes="xsl:fixed-namespaces-type-standard xs:NCName xsl:fixed-namespaces-type-prefix-binding xs:anyURI"/&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:list&gt;
 
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type-standard"&gt;
    &lt;xs:restriction base="xs:token"&gt;
       &lt;xs:enumeration value="#standard"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="fixed-namespaces-type-prefix-binding"&gt;
    &lt;xs:restriction base="xs:string"&gt;
       &lt;xs:pattern value="([\i-[:]][\c-[:]]*:)=.+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="item-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An XPath 4.0 ItemType
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="input-type-annotations-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes how type annotations in source documents are handled.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="level"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;level&lt;/code&gt; attribute of &lt;code&gt;xsl:number&lt;/code&gt;: 
           one of &lt;code&gt;single&lt;/code&gt;, &lt;code&gt;multiple&lt;/code&gt;, or &lt;code&gt;any&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="single"/&gt;
      &lt;xs:enumeration value="multiple"/&gt;
      &lt;xs:enumeration value="any"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="mode"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;mode&lt;/code&gt; attribute of &lt;code&gt;xsl:apply-templates&lt;/code&gt;: 
           either a QName, or &lt;code&gt;#current&lt;/code&gt;,
           or &lt;code&gt;#unnamed&lt;/code&gt;, or &lt;code&gt;#default&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
          &lt;xs:enumeration value="#unnamed"/&gt;
          &lt;xs:enumeration value="#current"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="modes"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;mode&lt;/code&gt; attribute of &lt;code&gt;xsl:template&lt;/code&gt;: either a list, each member being
           either a QName or &lt;code&gt;#default&lt;/code&gt; or &lt;code&gt;#unnamed&lt;/code&gt;; or the value &lt;code&gt;#all&lt;/code&gt;
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction&gt;
          &lt;xs:simpleType&gt;
            &lt;xs:list&gt;
              &lt;xs:simpleType&gt;
                &lt;xs:union memberTypes="xsl:EQName"&gt;
                  &lt;xs:simpleType&gt;
                    &lt;xs:restriction base="xs:token"&gt;
                      &lt;xs:enumeration value="#default"/&gt;
                      &lt;xs:enumeration value="#unnamed"/&gt;
                    &lt;/xs:restriction&gt;
                  &lt;/xs:simpleType&gt;
                &lt;/xs:union&gt;
              &lt;/xs:simpleType&gt;
            &lt;/xs:list&gt;
          &lt;/xs:simpleType&gt;
          &lt;xs:assertion test="count($value) = count(distinct-values($value))"&gt;
            &lt;xs:annotation&gt;
              &lt;xs:documentation&gt;
                &lt;p&gt;
                   XTSE0550: It is a static error if the same token is included
                   more than once in the list.
                &lt;/p&gt;
              &lt;/xs:documentation&gt;
            &lt;/xs:annotation&gt;
          &lt;/xs:assertion&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

   &lt;xs:simpleType name="named-function-reference"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; In simple terms, this is an EQName followed by "#arity" where "arity" is a non-negative integer. However,
          XSD doesn't allow us to reuse the definition of EQName in this way, so it has to be defined from scratch. The simplest
          way to do this is with an assertion. However, the assertion cannot exploit types such as &lt;code&gt;xsl:EQName&lt;/code&gt; defined in this
        schema&lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value="((Q\{.*\})|([\i-[:]][\c-[:]]*:))?[\i-[:]][\c-[:]]*#[0-9]+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="nametest"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests, as defined in the XPath 31 Recommendation. Each NameTest is either
          an EQName, or "*", or "prefix:*", or "*:localname", or the wildcard Q{uri}*. &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="[\i-[:]][\c-[:]]*:\*"/&gt;
          &lt;xs:pattern value="\*:[\i-[:]][\c-[:]]*"/&gt;
          &lt;xs:pattern value="Q\{[^}]*\}\*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="nametests"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt; A list of NameTests, as defined in the XPath 4.0 Recommendation. Each NameTest is either
          a QName, or "*", or "prefix:*", or "*:localname" &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:nametest"/&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-multiple-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the action to be taken when there are several template rules
           to match an item in a given mode.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="use-last"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="on-no-match-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the action to be taken when there is no template rule to match
           an item in a given mode.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="deep-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy"/&gt;
      &lt;xs:enumeration value="shallow-copy-all"/&gt;
      &lt;xs:enumeration value="deep-skip"/&gt;
      &lt;xs:enumeration value="shallow-skip"/&gt;
      &lt;xs:enumeration value="text-only-copy"/&gt;
      &lt;xs:enumeration value="fail"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list-or-all"&gt;
    &lt;xs:union memberTypes="xsl:prefix-list"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#all"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-list"&gt;
    &lt;xs:list itemType="xsl:prefix-or-default"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="method"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The &lt;code&gt;method&lt;/code&gt; attribute of &lt;code&gt;xsl:output&lt;/code&gt;: Either one of the recognized names
           "xml", "xhtml", "html", "text", "json", or "adaptive",
            or an EQName that must include a prefix or namespace URI.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="xml"/&gt;
          &lt;xs:enumeration value="xhtml"/&gt;
          &lt;xs:enumeration value="html"/&gt;
          &lt;xs:enumeration value="text"/&gt;
          &lt;xs:enumeration value="json"/&gt;
          &lt;xs:enumeration value="adaptive"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="pattern"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A match pattern as defined in the XSLT 4.0 Recommendation. The syntax
           for patterns is a restricted form of the syntax for XPath 4.0
           expressions. 
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:expression"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="prefix-or-default"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Either a namespace prefix, or &lt;code&gt;#default&lt;/code&gt;. Used in the &lt;code&gt;xsl:namespace-alias&lt;/code&gt;
           element.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="#default"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQNames"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A list of QNames. Used in the &lt;code&gt;[xsl:]use-attribute-sets&lt;/code&gt; attribute of
           various elements, and in the &lt;code&gt;cdata-section-elements&lt;/code&gt; attribute of
           &lt;code&gt;xsl:output&lt;/code&gt;.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:list itemType="xsl:EQName"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="EQName"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           An extended QName. This schema does not use the built-in type &lt;code&gt;xs:QName&lt;/code&gt;,
           but rather defines its own QName type. This may be either a local name,
           or a prefixed QName, or a name written using the extended QName notation
           &lt;code&gt;Q{uri}[prefix:]local&lt;/code&gt;
        &lt;/p&gt;
        &lt;p&gt;In XSLT 4.0, where a QName is used in the &lt;code&gt;name&lt;/code&gt; attribute
        of (say) &lt;code&gt;xsl:template&lt;/code&gt; or &lt;code&gt;xsl:call-template&lt;/code&gt;, the prefix
        does not have to be bound in an XML namespace declaration; rather it can be bound
        in a &lt;code&gt;fixed-namespaces&lt;/code&gt; attribute on the &lt;code&gt;xsl:stylesheet&lt;/code&gt;
        element. Therefore, the built-in &lt;code&gt;xs:QName&lt;/code&gt; type cannot be used.
        This schema does not attempt to verify that namespace prefixes have been
        properly declared.&lt;/p&gt;
        
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xs:NCName"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="[\i-[:]][\c-[:]]*:[\i-[:]][\c-[:]]*"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:pattern value="Q\{[^{}]*\}[\i-[:]][\c-[:]]*(:[\i-[:]][\c-[:]]*)?"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="EQName-in-namespace"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A subtype of EQNames that excludes no-namespace names
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:EQName"&gt;
      &lt;xs:pattern value="Q\{.+\}.+|\i\c*:.+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="sequence-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           The description of a datatype, conforming to the SequenceType production
           defined in the XPath 4.0 Recommendation
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:pattern value=".+"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="streamability-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the category to which a function belongs, with regards to its
           streaming behavior.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:union memberTypes="xsl:EQName-in-namespace"&gt;
      &lt;xs:simpleType&gt;
        &lt;xs:restriction base="xs:token"&gt;
          &lt;xs:enumeration value="unclassified"/&gt;
          &lt;xs:enumeration value="absorbing"/&gt;
          &lt;xs:enumeration value="inspection"/&gt;
          &lt;xs:enumeration value="filter"/&gt;
          &lt;xs:enumeration value="shallow-descent"/&gt;
          &lt;xs:enumeration value="deep-descent"/&gt;
          &lt;xs:enumeration value="ascent"/&gt;
        &lt;/xs:restriction&gt;
      &lt;/xs:simpleType&gt;
    &lt;/xs:union&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="tokens"&gt;
    &lt;xs:list itemType="xs:token"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="typed-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes whether a mode is designed to match typed or untyped nodes.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="unspecified"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="uri-list"&gt;
    &lt;xs:list itemType="xs:anyURI"/&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-strip-or-preserve"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes different ways of type-annotating an element or attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:validation-type"&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="validation-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes different ways of type-annotating an element or attribute.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="strict"/&gt;
      &lt;xs:enumeration value="lax"/&gt;
      &lt;xs:enumeration value="preserve"/&gt;
      &lt;xs:enumeration value="strip"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the visibility of a component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
      &lt;xs:enumeration value="hidden"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="visibility-not-hidden-type"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           Describes the visibility of a component within a package.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:visibility-type"&gt;
      &lt;xs:enumeration value="public"/&gt;
      &lt;xs:enumeration value="private"/&gt;
      &lt;xs:enumeration value="final"/&gt;
      &lt;xs:enumeration value="abstract"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no": the values "true" or "false", or "1" or
           "0" are accepted as synonyms.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="yes-or-no-or-maybe"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no" or "omit". The values "true" or "false",
           or "1" or "0" are accepted as synonyms of "yes" and "no" respectively.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="maybe"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

  &lt;xs:simpleType name="yes-or-no-or-omit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           One of the values "yes" or "no" or "omit". The values "true" or "false",
           or "1" or "0" are accepted as synonyms of "yes" and "no" respectively.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xs:token"&gt;
      &lt;xs:enumeration value="yes"/&gt;
      &lt;xs:enumeration value="no"/&gt;
      &lt;xs:enumeration value="true"/&gt;
      &lt;xs:enumeration value="false"/&gt;
      &lt;xs:enumeration value="1"/&gt;
      &lt;xs:enumeration value="0"/&gt;
      &lt;xs:enumeration value="omit"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;
  
  &lt;xs:simpleType name="zero-digit"&gt;
    &lt;xs:annotation&gt;
      &lt;xs:documentation&gt;
        &lt;p&gt;
           A digit that has the numerical value zero.
        &lt;/p&gt;
      &lt;/xs:documentation&gt;
    &lt;/xs:annotation&gt;
    &lt;xs:restriction base="xsl:char"&gt;
      &lt;xs:pattern value="\p{Nd}"/&gt;
      &lt;xs:assertion test="matches(string-join(codepoints-to-string(
           for $i in 0 to 9 return string-to-codepoints($value) + $i), ''), '\p{Nd}{10}')"/&gt;
    &lt;/xs:restriction&gt;
  &lt;/xs:simpleType&gt;

&lt;/xs:schema&gt;
</pre>
            </div>
            <div class="div2">
               
               <h3><a id="relax-ng-schema-for-xslt"></a>H.2 <a href="#relax-ng-schema-for-xslt" style="text-decoration: none">Relax-NG Schema for XSLT Stylesheets</a></h3>
               <p>The following Relax-NG schema may be used to validate XSLT 4.0 stylesheet modules. Similar
            caveats apply as for the XSD 1.1 version.</p>
               <p>A copy of this schema is available at <a href="schema-for-xslt30.rnc">schema-for-xslt30.rnc</a>
            </p>
               <p>TODO: Needs updating for 4.0.</p>
               <pre class="font-size: small"># XSLT 4.0 Relax NG Schema
# 
# Copyright (c) 2010-2016, Mohamed ZERGAOUI (Innovimax)
# Portions © 2024, XQuery and XSLT Extensions Community Group
# 
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# Redistributions of source code must retain the above copyright notice, this
# list of conditions and the following disclaimer. Redistributions in binary
# form must reproduce the above copyright notice, this list of conditions and
# the following disclaimer in the documentation and/or other materials provided
# with the distribution. Neither the name of the Mohamed ZERGAOUI or Innovimax
# nor the names of its contributors may be used to endorse or promote products
# derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
# AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
# DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
# FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
# DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
# 
namespace local = ""
default namespace xsl = "http://www.w3.org/1999/XSL/Transform"
namespace xs = "http://www.w3.org/2001/XMLSchema"

start =
  stylesheet.element
  | transform.element
  | package.element  
  | literal-result-element-as-stylesheet
  
sequence-constructor.model = (instruction.category | record.element | literal-result-element | text)*

literal-result-element-as-stylesheet =
  element * - xsl:* {
    attribute xsl:version { decimal.datatype },
    literal-result-element-no-version.atts,
    sequence-constructor.model
  }

literal-result-element =
  element * - xsl:* {
     literal-result-element.atts,
     sequence-constructor.model
  }

literal-result-element.atts =
  literal-result-element-no-version.atts,
  attribute xsl:version { text }?

# These attributes may also appear on a literal result element, but in this case, to distinguish them from user-defined attributes, 
# the names of the attributes are in the XSLT namespace. They are thus typically written as 
# xsl:default-collation,
# xsl:default-mode,
# xsl:default-validation,
# xsl:exclude-result-prefixes,
# xsl:expand-text,
# xsl:extension-element-prefixes,
# xsl:use-when,
# xsl:version,
# or xsl:xpath-default-namespace.
literal-result-element-no-version.atts =
   attribute * - xsl:* { avt.datatype }*
 &amp; attribute xsl:default-collation { uris.datatype }?
 &amp; attribute xsl:default-mode { eqname.datatype | '#unnamed' }?
 &amp; attribute xsl:default-validation  { "preserve" | "strip" }?
 &amp; attribute xsl:exclude-result-prefixes { exclude.prefixes.datatype }? # or prefixes.datatype ?
 &amp; attribute xsl:expand-text { boolean.datatype }?
 &amp; attribute xsl:extension-element-prefixes { extension.prefixes.datatype }? # or prefixes.datatype ?
 &amp; attribute xsl:inherit-namespaces { boolean.datatype }?
 &amp; attribute xsl:on-empty { expression.datatype }?
 &amp; attribute xsl:use-attribute-sets { eqnames.datatype }?
 &amp; attribute xsl:use-when { expression.datatype }?
 &amp; attribute xsl:xpath-default-namespace { xsd:anyURI }?
 &amp; attribute xsl:schema-role { ncname.datatype }?
 &amp; (attribute xsl:type { eqname.datatype }
    | attribute xsl:validation { "strict" | "lax" | "preserve" | "strip" })?


top-level-extension =
  element * - (xsl:* | local:*) {
     anyElement
  }

anyElement =
   grammar {
      start = any
      any =
        (attribute * { text }
         | text
         | element * { any })*
    }
    
extension.atts = attribute * - (xsl:* | local:*) { text }*

declarations.model = (declaration.category | top-level-extension)*

# [Definition: There are a number of standard attributes that may appear on any XSLT element: specifically 
# default-collation, 
# default-mode, 
# default-validation, 
# exclude-result-prefixes, 
# expand-text, 
# extension-element-prefixes, 
# use-when, 
# version, 
# and xpath-default-namespace.]

global.atts = 
   attribute default-collation { uris.datatype }?,
   attribute _default-collation { avt.datatype }?,
   attribute default-mode { eqname.datatype | '#unnamed' }?,
   attribute _default-mode { avt.datatype }?,
   attribute default-validation  { "preserve" | "strip" }?,
   attribute _default-validation { avt.datatype }?,   
   attribute exclude-result-prefixes { exclude.prefixes.datatype }?,
   attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute expand-text { boolean.datatype }?,
   attribute _expand-text { avt.datatype }?,
   attribute extension-element-prefixes { extension.prefixes.datatype }?,
   attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute use-when { expression.datatype }?,
   attribute _use-when { avt.datatype }?,
   attribute version { decimal.datatype }?,
   attribute _version { avt.datatype }?,
   attribute xpath-default-namespace { uri.datatype }?,
   attribute _xpath-default-namespace { avt.datatype }?
   

global.atts.except.version = 
   attribute default-collation { uris.datatype }?,
   attribute _default-collation { avt.datatype }?,
   attribute exclude-result-prefixes { exclude.prefixes.datatype }?,
   attribute _exclude-result-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute expand-text { boolean.datatype }?,
   attribute _expand-text { avt.datatype }?,
   attribute extension-element-prefixes { extension.prefixes.datatype }?,
   attribute _extension-element-prefixes { avt.datatype }?, # or prefixes.datatype ?
   attribute use-when { expression.datatype }?,
   attribute _use-when { avt.datatype }?,
   attribute xpath-default-namespace { uri.datatype }?,
   attribute _xpath-default-namespace { avt.datatype }?
   
# In XSLT 4.0, prefixes can be defined with the fixed-namespaces attribute
# on the xsl:stylesheet, so we can't rely on XML declarations for QNames.
qname.strict = xsd:token { pattern = "[\i-[:]][\c-[:]]*:[\i-[:]][\c-[:]]*" }
qname.datatype = xsd:NCName | qname.strict

# Extract from XPath 3.0
#[94]   EQName           ::= QName | URIQualifiedName
#[104]  QName            ::= [http://www.w3.org/TR/REC-xml-names/#NT-QName]Names
#[105]  NCName           ::= [http://www.w3.org/TR/REC-xml-names/#NT-NCName]Names
#[99]   URIQualifiedName ::= BracedURILiteral NCName
#[100]  BracedURILiteral ::= "Q" "{" [^{}]* "}"

uri.qualified.name = xsd:token { pattern = "Q\{[^\{\}]*\}[\i-[:]][\c-[:]]*" } 
eqname.datatype = qname.datatype | uri.qualified.name
qnames.datatype = list { qname.datatype* }
eqnames.datatype = list { eqname.datatype* }
ncname.datatype = xsd:NCName
prefix.datatype = xsd:NCName
boolean.datatype = "yes" | "no" | "true" | "false" | "0" | "1" 
expression.datatype = text
char.datatype = xsd:string { length = "1" }
string.datatype = text
id.datatype = xsd:NCName
tokens.datatype = list { token* }
prefixes.datatype = list { token* }
extension.prefixes.datatype = list { xsd:NCName* }
exclude.prefixes.datatype = list { "#all" | (xsd:NCName | "#default")* }
token.datatype = token
language.datatype = xsd:language
nmtoken.datatype = xsd:NMTOKEN
decimal.datatype = xsd:decimal
integer.datatype = xsd:integer
uri.datatype = xsd:anyURI
uris.datatype = list { xsd:anyURI* }
pattern.datatype = text
qname-but-not-ncname.datatype = xsd:QName { pattern = ".*:.*" }
xs_schema.element = element xs:schema { anyElement* }
item-type.datatype = text
sequence-type.datatype = text

# #standard or NCName or prefix=URI or URI
fixed-namespaces.datatype = xsd:string

select-or-sequence-constructor.model =
  ((attribute select { expression.datatype }
    | attribute _select { avt.datatype })+
   | sequence-constructor.model)

declaration.category =
   use-package.element
 | include.element
 | import.element
 | import-schema.element
 | strip-space.element
 | preserve-space.element
 | decimal-format.element
 | template.element
 | mode.element
 | global-context-item.element
 | variable.element
 | param.element
 | attribute-set.element
 | function.element
 | namespace-alias.element
 | accumulator.element
 | key.element
 | output.element
 | character-map.element

instruction.category =
   apply-templates.element
 | apply-imports.element
 | next-match.element
 | for-each.element
 | iterate.element
 | next-iteration.element
 | break.element
 | if.element
 | choose.element
 | switch.element
 | try.element
 | variable.element
 | call-template.element
 | evaluate.element
 | element.element
 | attribute.element
 | text.element
 | value-of.element
 | document.element
 | processing-instruction.element
 | namespace.element
 | comment.element
 | copy.element
 | copy-of.element
 | sequence.element
 | where-populated.element
 | on-empty.element
 | on-non-empty.element
 | number.element
 | perform-sort.element
 | for-each-group.element
 | merge.element
 | fork.element
 | analyze-string.element
 | source-document.element
 | map.element
 | map-entry.element
 | array.element
 | array-member.element
 | message.element
 | assert.element
 | fallback.element
 | result-document.element
 | select.element
package.element =
   element package {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute name { uri.datatype }?,
      attribute _name { avt.datatype }?,
      attribute package-version { string.datatype }?,
      attribute _package-version { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute declared-modes { boolean.datatype }?,
      attribute _declared-modes { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      ((expose.element | declarations.model)*)
   }
use-package.element =
   element use-package {
      extension.atts,
      global.atts,
      attribute name { uri.datatype }?,
      attribute _name { avt.datatype }?,
      attribute package-version { string.datatype }?,
      attribute _package-version { avt.datatype }?,
      (package-location.element | accept.element | override.element)*
   }
expose.element =
   element expose {
      extension.atts,
      global.atts,
      attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" }?,
      attribute _component { avt.datatype }?,
      attribute names { tokens.datatype }?,
      attribute _names { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      empty
   }
package-location.element =
   element package-location {
      extension.atts,
      global.atts,    
      (attribute path-in-archive { string.datatype } |
      attribute _path-in-archive { avt.datatype })+,
      (attribute archive-type { string.datatype } |
      attribute _archive-type { avt.datatype })+,
      (attribute is-priority { boolean.datatype } |
      attribute _is-priority { avt.datatype })+,
      (attribute format { string.datatype } |
      attribute _format { avt.datatype })+,
      empty
   }   
accept.element =
   element accept {
      extension.atts,
      global.atts,
      (attribute component { "template" | "function" | "attribute-set" | "variable" | "mode" | "*" } |
      attribute _component { avt.datatype })+,
      (attribute names { tokens.datatype } |
      attribute _names { avt.datatype })+,
      (attribute visibility { "public" | "private" | "final" | "abstract" | "hidden" } |
      attribute _visibility { avt.datatype })+,
      empty
   }
override.element =
   element override {
      extension.atts,
      global.atts,
      (template.element | function.element | variable.element | param.element | attribute-set.element)*
   }
stylesheet.element =
   element stylesheet {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      (declarations.model)
   }
transform.element =
   element transform {
      extension.atts,
      attribute id { id.datatype }?,
      attribute _id { avt.datatype }?,
      attribute version { decimal.datatype }?,
      attribute _version { avt.datatype }?,
      attribute default-mode { eqname.datatype | "#unnamed" }?,
      attribute _default-mode { avt.datatype }?,
      attribute default-validation { "preserve" | "strip" }?,
      attribute _default-validation { avt.datatype }?,
      attribute input-type-annotations { "preserve" | "strip" | "unspecified" }?,
      attribute _input-type-annotations { avt.datatype }?,
      attribute default-collation { uris.datatype }?,
      attribute _default-collation { avt.datatype }?,
      attribute extension-element-prefixes { prefixes.datatype }?,
      attribute _extension-element-prefixes { avt.datatype }?,
      attribute exclude-result-prefixes { prefixes.datatype }?,
      attribute _exclude-result-prefixes { avt.datatype }?,
      attribute expand-text { boolean.datatype }?,
      attribute _expand-text { avt.datatype }?,
      attribute use-when { expression.datatype }?,
      attribute _use-when { avt.datatype }?,
      attribute xpath-default-namespace { uri.datatype }?,
      attribute _xpath-default-namespace { avt.datatype }?,
      attribute fixed-namespaces { fixed-namespaces.datatype }?,
      attribute _fixed-namespaces { fixed-namespaces.datatype }?,
      (declarations.model)
   }
include.element =
   element include {
      extension.atts,
      global.atts,
      attribute href { uri.datatype }?,
      attribute _href { avt.datatype }?,
      empty
   }
import.element =
   element import {
      extension.atts,
      global.atts,
      (attribute href { uri.datatype }
      | attribute _href { avt.datatype })+,
      empty
   }
import-schema.element =
   element import-schema {
      extension.atts,
      global.atts,
      attribute namespace { uri.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute schema-location { uri.datatype }?,
      attribute _schema-location { avt.datatype }?,
      xs_schema.element?
   }
strip-space.element =
   element strip-space {
      extension.atts,
      global.atts,
      (attribute elements { tokens.datatype }
      | attribute _elements { avt.datatype })+,
      empty
   }
preserve-space.element =
   element preserve-space {
      extension.atts,
      global.atts,
      (attribute elements { tokens.datatype }
      | attribute _elements { avt.datatype })+,
      empty
   }
decimal-format.element =
   element decimal-format {
      extension.atts,
      global.atts,
      attribute name { eqname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute decimal-separator { char.datatype }?,
      attribute _decimal-separator { avt.datatype }?,
      attribute grouping-separator { char.datatype }?,
      attribute _grouping-separator { avt.datatype }?,
      attribute infinity { string.datatype }?,
      attribute _infinity { avt.datatype }?,
      attribute minus-sign { char.datatype }?,
      attribute _minus-sign { avt.datatype }?,
      attribute exponent-separator { char.datatype }?,
      attribute _exponent-separator { avt.datatype }?,
      attribute NaN { string.datatype }?,
      attribute _NaN { avt.datatype }?,
      attribute percent { char.datatype }?,
      attribute _percent { avt.datatype }?,
      attribute per-mille { char.datatype }?,
      attribute _per-mille { avt.datatype }?,
      attribute zero-digit { char.datatype }?,
      attribute _zero-digit { avt.datatype }?,
      attribute digit { char.datatype }?,
      attribute _digit { avt.datatype }?,
      attribute pattern-separator { char.datatype }?,
      attribute _pattern-separator { avt.datatype }?,
      empty
   }
template.element =
   element template {
      extension.atts,
      global.atts,
      (attribute match { pattern.datatype }
      | attribute _match { avt.datatype }
      | attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute priority { decimal.datatype }?,
      attribute _priority { avt.datatype }?,
      attribute mode { list { '#all' | ('#default' | '#unnamed' | eqname.datatype)* } }?,
      attribute _mode { avt.datatype }?,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      (context-item.element?, param.element*, sequence-constructor.model)
   }
apply-templates.element =
   element apply-templates {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute mode { (eqname.datatype | '#unnamed' | '#default' | '#current') }?,
      attribute _mode { avt.datatype }?,
      attribute separator { avt.datatype }?,
      attribute _separator { avt.datatype }?,
      (sort.element | with-param.element)*
   }
mode.element =
   element mode {
      extension.atts,
      global.atts,
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute copy-namespaces { boolean.datatype }?
      | attribute _copy-namespaces { boolean.datatype }?),
      (attribute name { eqname.datatype }?
      | attribute _name { avt.datatype }?),
      (attribute streamable { boolean.datatype }?
      | attribute _streamable { avt.datatype }?),
      (attribute on-no-match { "deep-copy" | "shallow-copy" | "shallow-copy-all" | "deep-skip" | "shallow-skip" | "text-only-copy" | "fail" }?
      | attribute _on-no-match { avt.datatype }?),
      (attribute on-multiple-match { "use-last" | "fail" }?
      | attribute _on-multiple-match { avt.datatype }?),
      (attribute warning-on-no-match { boolean.datatype }?
      | attribute _warning-on-no-match { avt.datatype }?),
      (attribute warning-on-multiple-match { boolean.datatype }?
      | attribute _warning-on-multiple-match { avt.datatype }?),
      (attribute typed { boolean.datatype | "strict" | "lax" | "unspecified" }?
      | attribute _typed { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" }?
      | attribute _visibility { avt.datatype }?),
      (attribute use-accumulators { tokens.datatype }?
      | attribute _use-accumulators { avt.datatype }?),
      empty
   }
context-item.element =
   element context-item {
      extension.atts,
      global.atts,
      attribute as { item-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute use { "required" | "optional" | "absent" }?,
      attribute _use { avt.datatype }?,
      empty
   }
global-context-item.element =
   element global-context-item {
      extension.atts,
      global.atts,
      attribute as { item-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute use { "required" | "optional" | "absent" }?,
      attribute _use { avt.datatype }?,
      empty
   }
apply-imports.element =
   element apply-imports {
      extension.atts,
      global.atts,
      with-param.element*
   }
next-match.element =
   element next-match {
      extension.atts,
      global.atts,
      (with-param.element | fallback.element)*
   }
for-each.element =
   element for-each {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (sort.element*, sequence-constructor.model)
   }
iterate.element =
   element iterate {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (param.element*, on-completion.element?, sequence-constructor.model)
   }
next-iteration.element =
   element next-iteration {
      extension.atts,
      global.atts,
      (with-param.element*)
   }
break.element =
   element break {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })?,
      sequence-constructor.model
   }
on-completion.element =
   element on-completion {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      sequence-constructor.model
   }
if.element =
   element if {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      sequence-constructor.model
   }
choose.element =
   element choose {
      extension.atts,
      global.atts,
      (when.element+, otherwise.element?)
   }
when.element =
   element when {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      select-or-sequence-constructor.model
   }
otherwise.element =
   element otherwise {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }

switch.element =
  element switch {
    extension.atts,
    global.atts,
    (attribute select { expression.datatype }
    | attribute _select { avt.datatype })+,
    (when.element+, otherwise.element?, fallback.element*)
  }

try.element =
   element try {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute rollback-output { boolean.datatype }?,
      attribute _rollback-output { avt.datatype }?,
      (sequence-constructor.model, catch.element, (catch.element | fallback.element)*)
   }
catch.element =
   element catch {
      extension.atts,
      global.atts,
      attribute errors { tokens.datatype }?,
      attribute _errors { avt.datatype }?,
      select-or-sequence-constructor.model
   }
variable.element =
   element variable {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute static { boolean.datatype }?,
      attribute _static { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      select-or-sequence-constructor.model
   }
param.element =
   element param {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute required { boolean.datatype }?,
      attribute _required { avt.datatype }?,
      attribute tunnel { boolean.datatype }?,
      attribute _tunnel { avt.datatype }?,
      attribute static { boolean.datatype }?,
      attribute _static { avt.datatype }?,
      select-or-sequence-constructor.model
   }
with-param.element =
   element with-param {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute tunnel { boolean.datatype }?,
      attribute _tunnel { avt.datatype }?,
      select-or-sequence-constructor.model
   }
call-template.element =
   element call-template {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      with-param.element*
   }
attribute-set.element =
   element attribute-set {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      attribute visibility { "public" | "private" | "final" | "abstract" }?,
      attribute _visibility { avt.datatype }?,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      attribute.element*
   }
function.element =
   element function {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" | "abstract" }?
      | attribute _visibility { avt.datatype }?),
      (attribute streamability { "unclassified" | "absorbing" | "inspection" | "filter" | "shallow-descent" | "deep-descent" | "ascent" | eqname.datatype }?
      | attribute _streamability { avt.datatype }?),
      (attribute override-extension-function { boolean.datatype }?
      | attribute _override-extension-function { avt.datatype }?),
      (attribute override { boolean.datatype }?
      | attribute _override { avt.datatype }?),
      (attribute new-each-time { "yes" | "true" | "1" | "no" | "false" | "0" | "maybe" }?
      | attribute _new-each-time { avt.datatype }?),
      (attribute cache { boolean.datatype }?
      | attribute _cache { avt.datatype }?),
      (param.element*, sequence-constructor.model)
   }
evaluate.element =
   element evaluate {
      extension.atts,
      global.atts,
      (attribute xpath { expression.datatype }
      | attribute _xpath { avt.datatype })+,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute base-uri { uri.datatype | avt.datatype }?,
      attribute _base-uri { avt.datatype }?,
      attribute with-params { expression.datatype }?,
      attribute _with-params { avt.datatype }?,
      attribute context-item { expression.datatype }?,
      attribute _context-item { avt.datatype }?,
      attribute namespace-context { expression.datatype }?,
      attribute _namespace-context { avt.datatype }?,
      attribute schema-aware { boolean.datatype | avt.datatype }?,
      attribute _schema-aware { avt.datatype }?,
      (with-param.element | fallback.element)*
   }
namespace-alias.element =
   element namespace-alias {
      extension.atts,
      global.atts,
      (attribute stylesheet-prefix { prefix.datatype | "#default" }
      | attribute _stylesheet-prefix { avt.datatype })+,
      (attribute result-prefix { prefix.datatype | "#default" }
      | attribute _result-prefix { avt.datatype })+,
      empty
   }
element.element =
   element element {
      extension.atts,
      global.atts,
      (attribute name { qname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      attribute namespace { uri.datatype | avt.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute inherit-namespaces { boolean.datatype }?,
      attribute _inherit-namespaces { avt.datatype }?,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
attribute.element =
   element attribute {
      extension.atts,
      global.atts,
      (attribute name { qname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      attribute namespace { uri.datatype | avt.datatype }?,
      attribute _namespace { avt.datatype }?,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      select-or-sequence-constructor.model
   }
text.element =
   element text {
      extension.atts,
      global.atts,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      attribute cdata { boolean.datatype | avt.datatype }?,
      attribute _cdata { avt.datatype }?,
      attribute disable-output-escaping { boolean.datatype }?,
      attribute _disable-output-escaping { avt.datatype }?,
      text
   }
value-of.element =
   element value-of {
      extension.atts,
      global.atts,
      attribute separator { string.datatype | avt.datatype }?,
      attribute _separator { avt.datatype }?,
      attribute cdata { boolean.datatype | avt.datatype }?,
      attribute _cdata { avt.datatype }?,
      attribute disable-output-escaping { boolean.datatype }?,
      attribute _disable-output-escaping { avt.datatype }?,
      select-or-sequence-constructor.model
   }
document.element =
   element document {
      extension.atts,
      global.atts,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
processing-instruction.element =
   element processing-instruction {
      extension.atts,
      global.atts,
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      select-or-sequence-constructor.model
   }
record.element = 
   element record {
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute duplicates { expression.datatype }?
      | attribute _duplicates { avt.datatype }?),
      sequence-constructor.model
  }
record-type.element = 
   element record-type {
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      (attribute extensible { boolean.datatype }?
      | attribute _extensible { avt.datatype }?),
      (attribute visibility { "public" | "private" | "final" | "abstract" | "hidden" }?
      | attribute _visibility { avt.datatype }?),
      field.element*
  }
field.element = 
   element field {
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype }),
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (attribute required { boolean.datatype }?
      | attribute _required { avt.datatype }?),
      (attribute \default { expression.datatype }?
      |attribute _default { expression.datatype }?),
      empty
  }

select.element = 
   element select {
      (attribute as { sequence-type.datatype }?
      | attribute _as { avt.datatype }?),
      (fallback.element | text)*
  }
namespace.element =
   element namespace {
      extension.atts,
      global.atts,
      (attribute name { ncname.datatype | avt.datatype }
      | attribute _name { avt.datatype })+,
      select-or-sequence-constructor.model
   }
comment.element =
   element comment {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
copy.element =
   element copy {
      extension.atts,
      global.atts,
      attribute copy-namespaces { boolean.datatype }?,
      attribute _copy-namespaces { avt.datatype }?,
      attribute inherit-namespaces { boolean.datatype }?,
      attribute _inherit-namespaces { avt.datatype }?,
      attribute use-attribute-sets { eqnames.datatype }?,
      attribute _use-attribute-sets { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      sequence-constructor.model
   }
copy-of.element =
   element copy-of {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      attribute copy-accumulators { boolean.datatype }?,
      attribute _copy-accumulators { avt.datatype }?,
      attribute copy-namespaces { boolean.datatype }?,
      attribute _copy-namespaces { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      empty
   }
sequence.element =
   element sequence {
      extension.atts,
      global.atts,
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      select-or-sequence-constructor.model
   }
where-populated.element =
   element where-populated {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
on-empty.element =
   element on-empty {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
on-non-empty.element =
   element on-non-empty {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
number.element =
   element number {
      extension.atts,
      global.atts,
      attribute value { expression.datatype }?,
      attribute _value { avt.datatype }?,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute level { "single" | "multiple" | "any" }?,
      attribute _level { avt.datatype }?,
      attribute count { pattern.datatype }?,
      attribute _count { avt.datatype }?,
      attribute from { pattern.datatype }?,
      attribute _from { avt.datatype }?,
      attribute format { string.datatype | avt.datatype }?,
      attribute _format { avt.datatype }?,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute letter-value { "alphabetic" | "traditional" | avt.datatype }?,
      attribute _letter-value { avt.datatype }?,
      attribute ordinal { string.datatype | avt.datatype }?,
      attribute _ordinal { avt.datatype }?,
      attribute start-at { integer.datatype | avt.datatype }?,
      attribute _start-at { avt.datatype }?,
      attribute grouping-separator { char.datatype | avt.datatype }?,
      attribute _grouping-separator { avt.datatype }?,
      attribute grouping-size { integer.datatype | avt.datatype }?,
      attribute _grouping-size { avt.datatype }?,
      empty
   }
sort.element =
   element sort {
      extension.atts,
      global.atts,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute order { "ascending" | "descending" | avt.datatype }?,
      attribute _order { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      attribute stable { boolean.datatype | avt.datatype }?,
      attribute _stable { avt.datatype }?,
      attribute case-order { "upper-first" | "lower-first" | avt.datatype }?,
      attribute _case-order { avt.datatype }?,
      attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?,
      attribute _data-type { avt.datatype }?,
      select-or-sequence-constructor.model
   }
perform-sort.element =
   element perform-sort {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      (sort.element+, sequence-constructor.model)
   }
for-each-group.element =
   element for-each-group {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      ((attribute group-by { expression.datatype }?,
      attribute _group-by { avt.datatype }?) |
      (attribute group-adjacent { expression.datatype }?,
      attribute _group-adjacent { avt.datatype }?) |
      (attribute group-starting-with { pattern.datatype }?,
      attribute _group-starting-with { avt.datatype }?) |
      (attribute group-ending-with { pattern.datatype }?,
      attribute _group-ending-with { avt.datatype }?)),
      attribute composite { boolean.datatype }?,
      attribute _composite { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      (sort.element*, sequence-constructor.model)
   }
merge.element =
   element merge {
      extension.atts,
      global.atts,
      (merge-source.element+, merge-action.element, fallback.element*)
   }
merge-source.element =
   element merge-source {
      extension.atts,
      global.atts,
      attribute name { ncname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute for-each-item { expression.datatype }?,
      attribute _for-each-item { avt.datatype }?,
      attribute for-each-stream { expression.datatype }?,
      attribute _for-each-stream { avt.datatype }?,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      attribute use-accumulators { tokens.datatype }?,
      attribute _use-accumulators { avt.datatype }?,
      attribute sort-before-merge { boolean.datatype }?,
      attribute _sort-before-merge { avt.datatype }?,
      attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }?,
      attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?,
      attribute for-each-source { expression.datatype }?,
      attribute _for-each-source { avt.datatype }?,
      merge-key.element+
   }
merge-key.element =
   element merge-key {
      extension.atts,
      global.atts,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute lang { language.datatype | avt.datatype }?,
      attribute _lang { avt.datatype }?,
      attribute order { "ascending" | "descending" | avt.datatype }?,
      attribute _order { avt.datatype }?,
      attribute collation { uri.datatype | avt.datatype }?,
      attribute _collation { avt.datatype }?,
      attribute case-order { "upper-first" | "lower-first" | avt.datatype }?,
      attribute _case-order { avt.datatype }?,
      attribute data-type { "text" | "number" | eqname.datatype | avt.datatype }?,
      attribute _data-type { avt.datatype }?,
      sequence-constructor.model
   }
merge-action.element =
   element merge-action {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
fork.element =
   element fork {
      extension.atts,
      global.atts,
      (fallback.element*, ((sequence.element, fallback.element*)* | (for-each-group.element, fallback.element*)))
   }
analyze-string.element =
   element analyze-string {
      extension.atts,
      global.atts,
      (attribute select { expression.datatype }
      | attribute _select { avt.datatype })+,
      (attribute regex { string.datatype | avt.datatype }
      | attribute _regex { avt.datatype })+,
      attribute flags { string.datatype | avt.datatype }?,
      attribute _flags { avt.datatype }?,
      (matching-substring.element?, non-matching-substring.element?, fallback.element*)
   }
matching-substring.element =
   element matching-substring {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
non-matching-substring.element =
   element non-matching-substring {
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }
source-document.element =
   element source-document {
      extension.atts,
      global.atts,
      (attribute href { uri.datatype | avt.datatype }
      | attribute _href { avt.datatype })+,
      attribute use-accumulators { tokens.datatype }?,
      attribute _use-accumulators { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      sequence-constructor.model
   }
accumulator.element =
   element accumulator {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype }),
      (attribute initial-value { expression.datatype }
      | attribute _initial-value { avt.datatype }),
      attribute as { sequence-type.datatype }?,
      attribute _as { avt.datatype }?,
      attribute streamable { boolean.datatype }?,
      attribute _streamable { avt.datatype }?,
      accumulator-rule.element+
   }
accumulator-rule.element =
   element accumulator-rule {
      extension.atts,
      global.atts,
      (attribute match { pattern.datatype } |
      attribute _match { avt.datatype })+,
      attribute phase { "start" | "end" }?,
      attribute _phase { avt.datatype }?,
      select-or-sequence-constructor.model
   }
key.element =
   element key {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      (attribute match { pattern.datatype }
      | attribute _match { avt.datatype })+,
      attribute use { expression.datatype }?,
      attribute _use { avt.datatype }?,
      attribute composite { boolean.datatype }?,
      attribute _composite { avt.datatype }?,
      attribute collation { uri.datatype }?,
      attribute _collation { avt.datatype }?,
      sequence-constructor.model
   }
map.element =
   element map {
      (attribute duplicates { expression.datatype }?
      | attribute _duplicates { avt.datatype }?),
      extension.atts,
      global.atts,
      select-or-sequence-constructor.model
   }

map-entry.element =
   element map-entry {
      extension.atts,
      global.atts,
      (attribute key { expression.datatype }
      | attribute _key { avt.datatype }),
      select-or-sequence-constructor.model
   }

array.element =
  element array {
    (attribute for-each { expression.datatype }
     | attribute _for-each { expression.datatype }),
    extension.atts,
    global.atts,
    select-or-sequence-constructor.model
  }

array-member.element =
  element array-member {
    extension.atts,
    global.atts,
    select-or-sequence-constructor.model
  }

message.element =
   element message {
      extension.atts,
      global.atts,
      attribute terminate { boolean.datatype | avt.datatype }?,
      attribute _terminate { avt.datatype }?,
      attribute error-code { eqname.datatype | avt.datatype }?,
      attribute _error-code { avt.datatype }?,
      select-or-sequence-constructor.model
   }
assert.element =
   element assert {
      extension.atts,
      global.atts,
      (attribute test { expression.datatype }
      | attribute _test { avt.datatype })+,
      attribute select { expression.datatype }?,
      attribute _select { avt.datatype }?,
      attribute error-code { eqname.datatype | avt.datatype }?,
      attribute _error-code { avt.datatype }?,
      sequence-constructor.model
   }
fallback.element =
   element fallback {
      extension.atts,
      global.atts,
      sequence-constructor.model
   }
result-document.element =
   element result-document {
      extension.atts,
      global.atts,
      attribute format { eqname.datatype | avt.datatype }?,
      attribute _format { avt.datatype }?,
      attribute href { uri.datatype | avt.datatype }?,
      attribute _href { avt.datatype }?,
      ((attribute type { eqname.datatype }?,
      attribute _type { avt.datatype }?) |
      (attribute validation { "strict" | "lax" | "preserve" | "strip" }?,
      attribute _validation { avt.datatype }? )), # type and validation are mutually exclusive      
      attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype | avt.datatype }?,
      attribute _method { avt.datatype }?,
      attribute allow-duplicate-names { boolean.datatype | avt.datatype }?,
      attribute _allow-duplicate-names { avt.datatype }?,
      attribute build-tree { boolean.datatype | avt.datatype }?,
      attribute _build-tree { avt.datatype }?,
      attribute byte-order-mark { boolean.datatype | avt.datatype }?,
      attribute _byte-order-mark { avt.datatype }?,
      attribute canonical { boolean.datatype | avt.datatype }?,
      attribute _canonical { avt.datatype }?,
      attribute cdata-section-elements { eqnames.datatype | avt.datatype }?,
      attribute _cdata-section-elements { avt.datatype }?,
      attribute doctype-public { string.datatype | avt.datatype }?,
      attribute _doctype-public { avt.datatype }?,
      attribute doctype-system { string.datatype | avt.datatype }?,
      attribute _doctype-system { avt.datatype }?,
      attribute encoding { string.datatype | avt.datatype }?,
      attribute _encoding { avt.datatype }?,
      attribute escape-uri-attributes { boolean.datatype | avt.datatype }?,
      attribute _escape-uri-attributes { avt.datatype }?,
      attribute html-version { decimal.datatype | avt.datatype }?,
      attribute _html-version { avt.datatype }?,
      attribute include-content-type { boolean.datatype | avt.datatype }?,
      attribute _include-content-type { avt.datatype }?,
      attribute indent { boolean.datatype | avt.datatype }?,
      attribute _indent { avt.datatype }?,
      attribute item-separator { string.datatype | avt.datatype }?,
      attribute _item-separator { avt.datatype }?,
      attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype | avt.datatype }?,
      attribute _json-node-output-method { avt.datatype }?,
      attribute media-type { string.datatype | avt.datatype }?,
      attribute _media-type { avt.datatype }?,
      attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype | avt.datatype }?,
      attribute _normalization-form { avt.datatype }?,
      attribute omit-xml-declaration { boolean.datatype | avt.datatype }?,
      attribute _omit-xml-declaration { avt.datatype }?,
      attribute parameter-document { uri.datatype | avt.datatype }?,
      attribute _parameter-document { avt.datatype }?,
      attribute standalone { boolean.datatype | "omit" | avt.datatype }?,
      attribute _standalone { avt.datatype }?,
      attribute suppress-indentation { eqnames.datatype | avt.datatype }?,
      attribute _suppress-indentation { avt.datatype }?,
      attribute undeclare-prefixes { boolean.datatype | avt.datatype }?,
      attribute _undeclare-prefixes { avt.datatype }?,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      attribute output-version { nmtoken.datatype | avt.datatype }?,
      attribute _output-version { avt.datatype }?,
      sequence-constructor.model
   }
output.element =
   element output {
      extension.atts,
      global.atts.except.version,
      attribute name { eqname.datatype }?,
      attribute _name { avt.datatype }?,
      attribute method { "xml" | "html" | "xhtml" | "text" | "json" | "adaptive" | eqname.datatype }?,
      attribute _method { avt.datatype }?,
      attribute allow-duplicate-names { boolean.datatype }?,
      attribute _allow-duplicate-names { avt.datatype }?,
      attribute build-tree { boolean.datatype }?,
      attribute _build-tree { avt.datatype }?,
      attribute byte-order-mark { boolean.datatype }?,
      attribute _byte-order-mark { avt.datatype }?,
      attribute canonical { boolean.datatype }?,
      attribute _canonical { avt.datatype }?,
      attribute cdata-section-elements { eqnames.datatype }?,
      attribute _cdata-section-elements { avt.datatype }?,
      attribute doctype-public { string.datatype }?,
      attribute _doctype-public { avt.datatype }?,
      attribute doctype-system { string.datatype }?,
      attribute _doctype-system { avt.datatype }?,
      attribute encoding { string.datatype }?,
      attribute _encoding { avt.datatype }?,
      attribute escape-uri-attributes { boolean.datatype }?,
      attribute _escape-uri-attributes { avt.datatype }?,
      attribute html-version { decimal.datatype }?,
      attribute _html-version { avt.datatype }?,
      attribute include-content-type { boolean.datatype }?,
      attribute _include-content-type { avt.datatype }?,
      attribute indent { boolean.datatype }?,
      attribute _indent { avt.datatype }?,
      attribute item-separator { string.datatype }?,
      attribute _item-separator { avt.datatype }?,
      attribute json-node-output-method { "xml" | "html" | "xhtml" | "text" | eqname.datatype }?,
      attribute _json-node-output-method { avt.datatype }?,
      attribute media-type { string.datatype }?,
      attribute _media-type { avt.datatype }?,
      attribute normalization-form { "NFC" | "NFD" | "NFKC" | "NFKD" | "fully-normalized" | "none" | nmtoken.datatype }?,
      attribute _normalization-form { avt.datatype }?,
      attribute omit-xml-declaration { boolean.datatype }?,
      attribute _omit-xml-declaration { avt.datatype }?,
      attribute parameter-document { uri.datatype }?,
      attribute _parameter-document { avt.datatype }?,
      attribute standalone { boolean.datatype | "omit" }?,
      attribute _standalone { avt.datatype }?,
      attribute suppress-indentation { eqnames.datatype }?,
      attribute _suppress-indentation { avt.datatype }?,
      attribute undeclare-prefixes { boolean.datatype }?,
      attribute _undeclare-prefixes { avt.datatype }?,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      attribute version { nmtoken.datatype }?,
      attribute _version { avt.datatype }?,
      empty
   }
character-map.element =
   element character-map {
      extension.atts,
      global.atts,
      (attribute name { eqname.datatype }
      | attribute _name { avt.datatype })+,
      attribute use-character-maps { eqnames.datatype }?,
      attribute _use-character-maps { avt.datatype }?,
      (output-character.element*)
   }
output-character.element =
   element output-character {
      extension.atts,
      global.atts,
      (attribute character { char.datatype }
      | attribute _character { avt.datatype })+,
      (attribute string { string.datatype }
      | attribute _string { avt.datatype })+,
      empty
   }
avt.datatype =
  xsd:string
# {
#    pattern =
#      """([^\{\}]|\{\{|\}\}|\{([^"'\{\}]|"[^"]*"|'[^']*')+\})*""" # this regexp will not work in all the case.
#      }
</pre>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="changes-since-3.0"></a>I <a href="#changes-since-3.0" style="text-decoration: none">Changes since XSLT 3.0</a> (Non-Normative)</h2>
            <div class="div2">
               
               <h3><a id="xslt-changes-since-3.0"></a>I.1 <a href="#xslt-changes-since-3.0" style="text-decoration: none">Changes in this specification</a></h3>
               <ol>
                  <li>
                     <p>If a section of this specification has been updated since version 3.0,
                   an overview of the changes is provided, along with links to
                   navigate to the next or previous change.</p>
                     <p>See <a href="#whats-new-in-xslt4"><b>1.2 What’s New in XSLT 4.0?</b></a></p>
                  </li>
                  <li>
                     <p>Sections with significant changes are marked with a ✭ symbol in the
                   table of contents.</p>
                     <p>See <a href="#whats-new-in-xslt4"><b>1.2 What’s New in XSLT 4.0?</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/751 1386">751 1386&nbsp;</a></p>
                     <p>
                     The result type of a mode can be declared using an <code>as</code> attribute. The result type
                  of all template rules in this mode must be consistent with this, as must the values returned
                  by any built-in template rules for the mode.
                  </p>
                     <p>See <a href="#mode-result-type"><b>6.7.5 Declaring the Result Type of a Mode</b></a></p>
                  </li>
                  <li>
                     <p>
                  The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  instructions acquire an attribute <code>separator</code> that can be
                  used to insert content between adjacent items. [This change was in the
                  editor's draft adopted as a baseline when the WG commenced work.]
               </p>
                     <p>See <a href="#for-each"><b>7.1 The xsl:for-each instruction</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2015 2296">2015 2296&nbsp;</a></p>
                     <p>
                  A variable-binding with no <code>as</code> or <code>select</code> attribute no longer
                  attempts to create an implicit document node if the sequence constructor contains
                  certain instructions (such as <a href="#element-map"><code>xsl:map</code></a>, <a href="#element-array"><code>xsl:array</code></a>, 
                  <a href="#element-record"><code>xsl:record</code></a>, and <a href="#element-select"><code>xsl:select</code></a>).
               </p>
                     <p>See <a href="#variable-values"><b>9.3 Values of Variables and Parameters</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2200 2236">2200 2236&nbsp;</a></p>
                     <p>
                     Stylesheet functions may now be in no namespace, and may be invoked without
                     use of a namespace prefix, provided they are private to a package.
                  </p>
                     <p>See <a href="#xsl-function-name"><b>10.3.1 Function Name and Arity</b></a></p>
                  </li>
                  <li>
                     <p>
               Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>,
               <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>,
               <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>,
               <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>,
               now have the option of supplying an <code>xs:QName</code> value instead.
               [This change was in the editor's draft accepted by the WG as its baseline when
               it started work.]
            </p>
                     <p>See <a href="#add-func"><b>20 Additional Functions</b></a></p>
                  </li>
                  <li>
                     <p>
               Functions that accept a lexical QName as an argument, such as <a href="#func-key"><code>key</code></a>,
               <a href="#func-function-available"><code>function-available</code></a>, <a href="#func-element-available"><code>element-available</code></a>,
               <a href="#func-type-available"><code>type-available</code></a>, <a href="#func-system-property"><code>system-property</code></a>,
               <a href="#func-accumulator-before"><code>accumulator-before</code></a>, and <a href="#func-accumulator-after"><code>accumulator-after</code></a>,
               now have the option of supplying an <code>xs:QName</code> value instead.
               [This change was in the editor's draft accepted by the WG as its baseline when
               it started work.]
            </p>
                     <p>See <a href="#extension"><b>24 Extensibility and Fallback</b></a></p>
                  </li>
                  <li>
                     <p>New in 4.0</p>
                     <p>See <a href="#func-character-map"><b>26.4.1 fn:character-map</b></a></p>
                  </li>
                  <li>
                     <p>
                  The <a href="#element-for-each"><code>xsl:for-each</code></a> and <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                  instructions acquire an attribute <code>separator</code> that can be
                  used to insert content between adjacent items. [This change was in the
                  editor's draft adopted as a baseline when the WG commenced work.]
               </p>
                     <p>See <a href="#applying-templates"><b>6.4 Applying Template Rules</b></a></p>
                  </li>
                  <li>
                     <p>
                     It is possible to invoke a named template using an extension instruction, specifically,
                     an element whose name matches the name of the named template.
                  </p>
                     <p>See <a href="#invoking-templates-with-extension-instructions"><b>10.1.3 Invoking Named Templates using Extension Instructions</b></a></p>
                     <p>See <a href="#extension-instruction"><b>24.3 Extension Instructions</b></a></p>
                  </li>
                  <li>
                     <p>
                     A new attribute <code>xsl:map/@duplicates</code> is available,
                  allowing control over how duplicate keys are handled by the <a href="#element-map"><code>xsl:map</code></a>
                  instruction.
                  </p>
                     <p>See <a href="#duplicate-keys"><b>21.1.2 Handling of duplicate keys</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1497 1546">1497 1546&nbsp;</a></p>
                     <p>
                  A new serialization parameter <code>json-lines</code> is available to enable
                  output as one JSON value per line.
               </p>
                     <p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p>
                     <p>See <a href="#id-xsl-output-declaration"><b>26.1 The xsl:output declaration</b></a></p>
                  </li>
                  <li>
                     <p>An options parameter has been added.</p>
                     <p>See <a href="#func-document"><b>20.1 fn:document</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/159">159&nbsp;</a></p>
                     <p>Parameters on functions
                     declared using <a href="#element-function"><code>xsl:function</code></a> can now be defined as optional,
                     with a default value supplied.</p>
                     <p>See <a href="#default-values-of-parameters"><b>9.2.2 Default Values of Parameters</b></a></p>
                     <p>See <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/237">237&nbsp;</a></p>
                     <p>
                  The <a href="#element-if"><code>xsl:if</code></a> instruction now allows <code>then</code> and <code>else</code>
                  attributes.
               </p>
                     <p>See <a href="#xsl-if"><b>8.1 Conditional Processing with xsl:if</b></a></p>
                     <p>
                  In <a href="#element-choose"><code>xsl:choose</code></a>, the <a href="#element-when"><code>xsl:when</code></a> and
                  <code>xsl:otherwise</code> elements can take a <code>select</code> attribute
                  in place of a sequence constructor. 
               </p>
                     <p>See <a href="#xsl-choose"><b>8.2 Conditional Processing with xsl:choose</b></a></p>
                     <p>
                  A new <a href="#element-switch"><code>xsl:switch</code></a> instruction is introduced.
               </p>
                     <p>See <a href="#xsl-switch"><b>8.3 Conditional Processing with xsl:switch</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/326">326&nbsp;</a></p>
                     <p>
               The higher-order-function feature no longer exists; higher-order functions
               are now a core part of XSLT, no longer an optional extra.
            </p>
                     <p>See <a href="#conformance"><b>27 Conformance</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/353">353&nbsp;</a></p>
                     <p>
                  A new attribute, <code>main-module</code>, is added to the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
                  element. The attribute is provided for the benefit of development tools such as syntax-directed
                  editors to provide information about all the components (variables, functions, etc) visible
                  within a stylesheet module.
               </p>
                     <p>See <a href="#stylesheet-element"><b>3.6 Stylesheet Element</b></a></p>
                     <p>
                     A new element <a href="#element-note"><code>xsl:note</code></a> is available for documentation and similar purposes:
                     it can appear anywhere in the stylesheet and is ignored by the XSLT processor.
                  </p>
                     <p>See <a href="#xsl-note-elements"><b>3.11.2 The xsl:note element</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/401">401&nbsp;</a></p>
                     <p>
                        Patterns (especially those used in template rules) can now be defined
                        by reference to item types, so any item type can be used as a match
                        pattern. For example <code>match="~record(longitude, latitude)"</code>
                        matches any map that includes the key values <code>"longitude"</code>
                        and <code>"latitude"</code>.
                     </p>
                     <p>See <a href="#type-patterns"><b>6.3.2.2 Type Patterns</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/406">406&nbsp;</a></p>
                     <p>
                  The new instruction <a href="#element-array"><code>xsl:array</code></a> is introduced
                  to allow construction of arrays.
               </p>
                     <p>See <a href="#array-construction"><b>22.1 Array Construction</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/470">470&nbsp;</a></p>
                     <p>
                     The <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>, <a href="#element-transform"><code>xsl:transform</code></a>, or <a href="#element-package"><code>xsl:package</code></a>
                     element may have a <code>fixed-namespaces</code> attribute making it easier to have the same
                     namespace declarations in force throughout a stylesheet.
                  </p>
                     <p>See <a href="#fixed-namespaces"><b>3.6.1 The fixed-namespaces Attribute</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/489">489&nbsp;</a></p>
                     <p>
                  The <a href="#element-matching-substring"><code>xsl:matching-substring</code></a> and <a href="#element-non-matching-substring"><code>xsl:non-matching-substring</code></a>
                  elements within <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> may now take a <code>select</code> attribute
                  in place of a contained sequence constructor.
               </p>
                     <p>See <a href="#analyze-string"><b>17.1 The xsl:analyze-string Instruction</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/534">534&nbsp;</a></p>
                     <p>
                  A new serialization parameter <code>escape-solidus</code> is provided to control
                  whether the character <code>/</code> is escaped as <code>\/</code> by the
                  JSON serialization method.
               </p>
                     <p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p>
                     <p>See <a href="#id-xsl-output-declaration"><b>26.1 The xsl:output declaration</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/542">542&nbsp;</a></p>
                     <p>
                     A mode (called an enclosing mode) can be defined in which all the relevant 
                     template rules are children of the <code>xsl:mode</code> element.
                     This is intended to allow a stylesheet design in which it is easier to
                     determine which rules might apply to a given <a href="#element-apply-templates"><code>xsl:apply-templates</code></a>
                     call.
                  </p>
                     <p>See <a href="#enclosing-modes"><b>6.7.6 Enclosing Modes</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/599">599&nbsp;</a></p>
                     <p>
                  Simplified stylesheets no longer require an <code>xsl:version</code> attribute
                  (which means they might not need a declaration of the XSLT namespace). Unless otherwise
                  specified, a 4.0 simplified stylesheet defaults <code>expand-text</code> to <code>true</code>.
               </p>
                     <p>See <a href="#simplified-stylesheet"><b>3.7 Simplified Stylesheet Modules</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/635">635&nbsp;</a></p>
                     <p>
                  The rules concerning the compatibility of schemas imported by different packages have 
                  been clarified. It is now explicitly stated that instructions that trigger validation 
                  must use the imported schema of the package in which validation is invoked. 
                  This differs from the current practice of some XSLT 3.0 processors, which may 
                  use (for example) a schema formed from the union of the imported schemas in all 
                  packages.
               </p>
                     <p>See <a href="#import-schema"><b>3.13 Importing Schema Components</b></a></p>
                     <p>See <a href="#validation"><b>25.4 Validation</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/717">717&nbsp;</a></p>
                     <p>
                     Capturing accumulators have been added; when streaming with a capturing accumulator,
                     the <a href="#func-accumulator-after"><code>accumulator-after</code></a> has full access to a snapshot of the matched
                     element node.
                  </p>
                     <p>See <a href="#capturing-accumulators"><b>19.9 Capturing Accumulators</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/718">718&nbsp;</a></p>
                     <p>
                  To allow recursive-descent transformation on a tree of maps and arrays, a new
                  set of built-in templates rules <code>shallow-copy-all</code> is introduced.
               </p>
                     <p>See <a href="#built-in-rule"><b>6.8 Built-in Template Rules</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/740">740&nbsp;</a></p>
                     <p>
               A new attribute <code>xsl:for-each-group/@split-when</code> is available to
               give applications more complete control over how a sequence is partitioned
            </p>
                     <p>See <a href="#grouping"><b>14 Grouping</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/751">751&nbsp;</a></p>
                     <p>
                     The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute
                     <code>as="sequence-type"</code> which declares the return type of 
                     all template rules in that mode.
                  </p>
                     <p>See <a href="#declaring-modes"><b>6.7.1 Declaring Modes</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1181">1181&nbsp;</a></p>
                     <p>
                     The <code>[xsl:]xpath-default-namespace</code> attribute can be set to the value
                     <code>##any</code>, which causes unprefixed element names to match in any namespace
                     or none.
                  </p>
                     <p>See <a href="#unprefixed-qnames"><b>5.1.2 Unprefixed Lexical QNames in Expressions and Patterns</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1250">1250&nbsp;</a></p>
                     <p>
                  The strings used in the formatted number to represent 
                     a decimal separator, grouping separator, exponent
                  separator, percent sign, per mille sign, or minus sign,
                  are no longer constrained to be single characters.
               </p>
                     <p>See <a href="#defining-decimal-format"><b>5.5 Defining a Decimal Format</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1254">1254&nbsp;</a></p>
                     <p>
                  The rules concerning the interpretation of <code>xsi:schemaLocation</code>
                  and <code>xsi:noNamespaceSchemaLocation</code> attributes have been tightened up.
               </p>
                     <p>See <a href="#validation"><b>25.4 Validation</b></a></p>
                     <p>See <a href="#validation"><b>25.4 Validation</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1306">1306&nbsp;</a></p>
                     <p>
                  An <code>as</code> attribute is available on the <a href="#element-sequence"><code>xsl:sequence</code></a> instruction.
               </p>
                     <p>See <a href="#constructing-sequences"><b>10.4.1 The xsl:sequence Instruction</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1361">1361&nbsp;</a></p>
                     <p>
                  The term <b>atomic value</b> has been replaced by <b>atomic item</b>.
               </p>
                     <p>See <a href="#terminology"><b>2.1 Terminology</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1378">1378&nbsp;</a></p>
                     <p>
                        A function call at the outermost level can now be named using any valid <code>EQName</code>
                        (for example <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a>) provided it binds to one of the permitted functions
                        <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-doc"><code>fn:doc</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-id"><code>fn:id</code></a>, <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-element-with-id"><code>fn:element-with-id</code></a>, 
                        <a href="#func-key"><code>fn:key</code></a>, or <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-root"><code>fn:root</code></a>. 
                        If two functions are called, for example <code>doc('a.xml')/id('abc')</code>,
                        it is no longer necessary to put the second call in parentheses.
                     </p>
                     <p>See <a href="#node-patterns"><b>6.3.2.3 GNode Patterns</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1442">1442&nbsp;</a></p>
                     <p>
                  Default priorities are added for new forms of <code>ElementTest</code> and <code>AttributeTest</code>,
                  for example <code>element(p:*)</code> and <code>element(a|b)</code>.
               </p>
                     <p>See <a href="#default-priority"><b>6.3.3 Default Priority for Patterns</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1454">1454&nbsp;</a></p>
                     <p>
                     Duplicate <a href="#element-include"><code>xsl:include</code></a> declarations within a stylesheet level are
                     now ignored, preventing spurious errors caused by the presence of duplicate named components.
                  </p>
                     <p>See <a href="#include"><b>3.10.2 Stylesheet Inclusion</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1505">1505&nbsp;</a></p>
                     <p>
                  New variables <code>err:stack-trace</code>, <code>err:additional</code>, 
                  and <code>err:map</code> are available within an <a href="#element-catch"><code>xsl:catch</code></a> clause.
               </p>
                     <p>See <a href="#try-catch"><b>8.4 Try/Catch</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1530">1530&nbsp;</a></p>
                     <p>
                  The contents of a character map declared using <a href="#element-character-map"><code>xsl:character-map</code></a> are now
                  available dynamically via a new <a href="#func-character-map"><code>character-map</code></a> function.
               </p>
                     <p>See <a href="#character-map-function"><b>26.4 The character-map function</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1544">1544&nbsp;</a></p>
                     <p>
                  It is no longer an intrinsic error for a global variable to refer to itself; this
                  is now permitted, for example in cases where the value of the global variable is
                  a recursive inline function. Cases where self-reference would not make sense are
                  covered by the existing rules on circularities: see <a href="#circularity"><i>9.11 Circular Definitions</i></a>.
               </p>
                     <p>See <a href="#global-variables"><b>9.5 Global Variables and Parameters</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1549">1549&nbsp;</a></p>
                     <p>
                  The input to the serializer can be defined using the <code>select</code> attribute
                  of <a href="#element-result-document"><code>xsl:result-document</code></a> as an alternative to using a sequence constructor.
               </p>
                     <p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1560">1560&nbsp;</a></p>
                     <p>
                  The default value for the <code>indent</code> parameter is now defined to be
                  <code>no</code> for all output methods other than <code>html</code> and <code>xhtml</code>.
               </p>
                     <p>See <a href="#id-default-serialization-parameters"><b>26.2 Serialization parameters</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1617">1617&nbsp;</a></p>
                     <p>
                     Named item types can be declared using the new <a href="#element-item-type"><code>xsl:item-type</code></a>
                     element. This is designed to avoid repeating lengthy type definitions (for example
                     function types) every time they are used.
                  </p>
                     <p>See <a href="#named-item-types"><b>5.4.1 Named Item Types</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1622">1622&nbsp;</a></p>
                     <p>The rules for equality comparison have changed to bring keys into line with maps.</p>
                     <p>See <a href="#func-key"><b>20.2.2 fn:key</b></a></p>
                     <p>New in 4.0.</p>
                     <p>See <a href="#func-map-for-key"><b>20.2.3 fn:map-for-key</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1674">1674&nbsp;</a></p>
                     <p>
                     Composite sort keys are allowed in <a href="#element-sort"><code>xsl:sort</code></a>.
                  </p>
                     <p>See <a href="#comparing-sort-keys"><b>13.1.2 Comparing Sort Key Values</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1689">1689&nbsp;</a></p>
                     <p>
               Composite merge keys are now allowed.
            </p>
                     <p>See <a href="#merging"><b>15 Merging</b></a></p>
                     <p>New in 4.0</p>
                     <p>See <a href="#func-current-merge-key-array"><b>15.5.2 fn:current-merge-key-array</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1694">1694&nbsp;</a></p>
                     <p>
                  The <a href="#element-map"><code>xsl:map</code></a> instruction allows a <code>select</code> attribute
                  as an alternative to the contained sequence constructor.
               </p>
                     <p>See <a href="#map-instructions"><b>21.1 Map Instructions</b></a></p>
                     <p>
                  The <a href="#element-map-entry"><code>xsl:map-entry</code></a> instruction, in common with other instructions,
                  now raises error XTSE3185 (rather than XTSE3280) if both a <code>select</code>
                  attribute and a sequence constructor are present.
               </p>
                     <p>See <a href="#map-instructions"><b>21.1 Map Instructions</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1703">1703&nbsp;</a></p>
                     <p>
                  Ordered maps are introduced.
               </p>
                     <p>See <a href="#map-instructions"><b>21.1 Map Instructions</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1708">1708&nbsp;</a></p>
                     <p>
                     Named record types are introduced.
                  </p>
                     <p>See <a href="#named-record-types"><b>5.4.2 Named Record Types</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1772">1772&nbsp;</a></p>
                     <p>
                  The default priority for a template rule using a union pattern has changed.
                  This change may cause incompatible behavior.
               </p>
                     <p>See <a href="#default-priority"><b>6.3.3 Default Priority for Patterns</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1819">1819&nbsp;</a></p>
                     <p>
                  Different parts of a stylesheet may now use different imported schemas.
               </p>
                     <p>See <a href="#stylesheets-and-schemas"><b>2.10 Stylesheets and XML Schemas</b></a></p>
                     <p>
                  The standard attribute <code>[xsl:]schema-role</code> is introduced, to allow 
                  different parts of a stylesheet to use different schemas.
               </p>
                     <p>See <a href="#standard-attributes"><b>3.3 Standard Attributes</b></a></p>
                     <p>
                  Different parts of a stylesheet may now use different imported schemas.
               </p>
                     <p>See <a href="#import-schema"><b>3.13 Importing Schema Components</b></a></p>
                     <p>
                     A stylesheet can import multiple schemas with different schema role names.
                  </p>
                     <p>See <a href="#multiple-schemas"><b>3.13.1 Multiple Schemas</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1856">1856&nbsp;</a></p>
                     <p>
                  The rules for <a href="#element-analyze-string"><code>xsl:analyze-string</code></a> have been adjusted to allow for new capabilities in regular expressions, such as
                  zero-width assertions.
               </p>
                     <p>See <a href="#analyze-string"><b>17.1 The xsl:analyze-string Instruction</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1858">1858&nbsp;</a></p>
                     <p> The <a href="#element-record"><code>xsl:record</code></a> instruction is introduced
                     to make construction of record maps simpler. </p>
                     <p>See <a href="#record-instructions"><b>21.1.1 Record Instruction</b></a></p>
                     <p>
                       Attribute <code>xsl:record/@xsl:duplicates</code> is added to control duplicate keys handling in the <a href="#element-record"><code>xsl:record</code></a>
                       instruction.
                   </p>
                     <p>See <a href="#duplicate-keys"><b>21.1.2 Handling of duplicate keys</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1875">1875&nbsp;</a></p>
                     <p>
                  The <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> and <a href="#element-next-match"><code>xsl:next-match</code></a> instructions automatically
                  pass supplied parameters to the overridden template rule.
               </p>
                     <p>See <a href="#apply-imports"><b>6.9 Overriding Template Rules</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1888">1888&nbsp;</a></p>
                     <p>A new XSLT element, <code>xsl:package-location</code> is provide
                      to indicate to the processor where the required package is to be found.</p>
                     <p>See <a href="#package-locations"><b>3.4.3 Locating Packages</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/1929">1929&nbsp;</a></p>
                     <p>
                     The <a href="#element-mode"><code>xsl:mode</code></a> declaration acquires an attribute
                     <code>copy-namespaces</code> which determines whether or not the built-in
                     template rule copies unused namespace bindings.
                  </p>
                     <p>See <a href="#declaring-modes"><b>6.7.1 Declaring Modes</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2006">2006&nbsp;</a></p>
                     <p>A new function <code>fn:apply-templates</code> is introduced.</p>
                     <p>See <a href="#apply-templates-function"><b>6.7.3 The apply-templates Function</b></a></p>
                     <p>New in 4.0</p>
                     <p>See <a href="#func-apply-templates"><b>6.7.3.1 fn:apply-templates</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2008">2008&nbsp;</a></p>
                     <p>
                  The <a href="#element-select"><code>xsl:select</code></a> instruction is new in 4.0.
               </p>
                     <p>See <a href="#select-instruction"><b>10.4.2 The xsl:select Instruction</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2030">2030&nbsp;</a></p>
                     <p>
                  In order to reduce duplication between the XSLT and XQuery specifications, description
                  of the validation process has been moved to the <em>Functions and Operators</em>
                  specification.
               </p>
                     <p>See <a href="#validation"><b>25.4 Validation</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2123">2123&nbsp;</a></p>
                     <p>
               A new attribute <code>xsl:for-each-group/@merge-when</code> is available to
               give applications control to create groups based on clustering, overlap, and networks.
            </p>
                     <p>See <a href="#grouping"><b>14 Grouping</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2200">2200&nbsp;</a></p>
                     <p>User-defined functions can now have names that are in
               no namespace. An unprefixed name appearing in a function call is resolved
               to a no-namespace function with matching local name in preference to
               a function in the standard <code>fn</code> namespace.</p>
                     <p>See <a href="#stylesheet-functions"><b>10.3 Stylesheet Functions</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2213">2213&nbsp;</a></p>
                     <p>
                  A new attribute <code>trusted=yes|no</code> is added to <a href="#element-evaluate"><code>xsl:evaluate</code></a>
                  to indicate whether the XPath expression to be evaluated is trusted to access
                  external resources. The default value is <code>no</code>, which may cause backwards
                  incompatibility. Dynamic evaluation using <a href="#element-evaluate"><code>xsl:evaluate</code></a> is no longer
                  an optional feature of the XSLT language.
               </p>
                     <p>See <a href="#dynamic-xpath"><b>10.5 Dynamic XPath Evaluation</b></a></p>
                     <p>
               The dynamic evaluation feature no longer exists; processor are now required
               to support the <a href="#element-evaluate"><code>xsl:evaluate</code></a> instruction.
            </p>
                     <p>See <a href="#conformance"><b>27 Conformance</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2218">2218&nbsp;</a></p>
                     <p>
                     Numeric values of type <code>xs:decimal</code> are compared
                     as decimals, without first converting to <code>xs:double</code>.
                  </p>
                     <p>See <a href="#comparing-sort-keys"><b>13.1.2 Comparing Sort Key Values</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2246">2246&nbsp;</a></p>
                     <p>New in 4.0</p>
                     <p>See <a href="#func-regex-groups"><b>17.2.1 fn:regex-groups</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2251">2251&nbsp;</a></p>
                     <p>
                  The <a href="#element-text"><code>xsl:text</code></a> instruction can now have a <code>select</code> attribute,
                  and it can take a sequence constructor as its content. The only remaining distinction
                  between the <a href="#element-text"><code>xsl:text</code></a> and <a href="#element-value-of"><code>xsl:value-of</code></a> instructions
                  is that whitespace text node children of <a href="#element-text"><code>xsl:text</code></a> are treated
                  as significant, rather than being stripped during stylesheet preprocessing.
               </p>
                     <p>See <a href="#creating-text-nodes"><b>11.4 Creating Text Nodes</b></a></p>
                     <p>The rules for <a href="#element-text"><code>xsl:text</code></a>
                  and <a href="#element-value-of"><code>xsl:value-of</code></a> are integrated, allowing <a href="#element-text"><code>xsl:text</code></a>
                  to be used to construct all text nodes, whether the content is fixed or variable.</p>
                     <p>See <a href="#xsl-text"><b>11.4.2 The xsl:text and xsl:value-of instructions</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2259">2259&nbsp;</a></p>
                     <p>
                  A new serialization parameter <code>canonical</code> is available to give control
                  over serialization of XML, XHTML, and JSON.
               </p>
                     <p>See <a href="#creating-result-trees"><b>25.1 Creating Secondary Results</b></a></p>
                     <p>See <a href="#id-xsl-output-declaration"><b>26.1 The xsl:output declaration</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2274">2274&nbsp;</a></p>
                     <p>
                     <p>XSLT-specific components of the dynamic context can now be retained in the captured
                     context of a function item, in the same way as XPath-defined components of the dynamic context.</p>
                  </p>
                     <p>See <a href="#additional-dynamic-context"><b>5.3.4 Additional Dynamic Context Components used by XSLT</b></a></p>
                     <p>In XSLT 4.0, the function item <code>current-group#0</code> retains the value of the current
         group within its captured context.</p>
                     <p>See <a href="#func-current-group"><b>14.2.1 fn:current-group</b></a></p>
                     <p>In XSLT 4.0, the function item <code>current-grouping-key#0</code> retains the value of the current
         grouping key within its captured context.</p>
                     <p>See <a href="#func-current-grouping-key"><b>14.2.2 fn:current-grouping-key</b></a></p>
                     <p>In XSLT 4.0, the function item <code>current-merge-group</code> retains the value of the current
         merge-key within its captured context.</p>
                     <p>See <a href="#func-current-merge-group"><b>15.5.1 fn:current-merge-group</b></a></p>
                     <p>In XSLT 4.0, the function item <code>current-merge-key#0</code> retains the value of the current
         group within its captured context.</p>
                     <p>See <a href="#func-current-merge-key"><b>15.5.3 fn:current-merge-key</b></a></p>
                     <p>In XSLT 4.0, the function item <code>regex-group#1</code> retains the value of the current
         captured substrings within its captured context.</p>
                     <p>See <a href="#func-regex-group"><b>17.2.2 fn:regex-group</b></a></p>
                     <p>In XSLT 4.0, the function item <code>current#0</code> retains the value of the current
         item within its captured context.</p>
                     <p>See <a href="#func-current"><b>20.5.1 fn:current</b></a></p>
                     <p>In XSLT 4.0, the function item <code>current-output-uri#0</code> retains the value of the current
         output URI within its captured context.</p>
                     <p>See <a href="#func-current-output-uri"><b>25.3.1 fn:current-output-uri</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2283">2283&nbsp;</a></p>
                     <p>The conformance requirements for extension
                  attributes have been relaxed: the requirement to maintain strict conformance
               to the specification in the presence of extension attributes is now a <span class="verb">should</span>
               rather than a <span class="verb">must</span>, and extension attributes are allowed to modify
               the form of serialized output without limitation.</p>
                     <p>See <a href="#extension-attributes"><b>24.1 Extension Attributes</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2301">2301&nbsp;</a></p>
                     <p>The attribute <code>cdata</code> is added to <a href="#element-text"><code>xsl:text</code></a>
                  and <a href="#element-value-of"><code>xsl:value-of</code></a> to request serialization of a text node as a CDATA
                  section.</p>
                     <p>See <a href="#xsl-text"><b>11.4.2 The xsl:text and xsl:value-of instructions</b></a></p>
                     <p>See <a href="#generating-cdata"><b>11.4.3 Generating CDATA Sections</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2323">2323&nbsp;</a></p>
                     <p>
                  The outermost element of a simplified stylesheet need no longer be a literal result element,
                  it can now be any instruction (including <a href="#element-result-document"><code>xsl:result-document</code></a>). This allows a
                  simplified stylesheet to produce JSON output as well as XML or HTML.
               </p>
                     <p>See <a href="#simplified-stylesheet"><b>3.7 Simplified Stylesheet Modules</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2413">2413&nbsp;</a></p>
                     <p>
                        Extensible map types are dropped; instead, the coercion rules cause undefined
                        map entries to be discarded.
                     </p>
                     <p>See <a href="#type-patterns"><b>6.3.2.2 Type Patterns</b></a></p>
                  </li>
                  <li>
                     <p>PR <a href="https://github.com/qt4cg/qtspecs/pull/2736">2736&nbsp;</a></p>
                     <p>
                     <p>The <code>xsl:mode/@typed</code> attribute has been clarified and expanded
                  to provide better control over the handling of items other than XNodes.</p></p>
                     <p>See <a href="#xsl-mode-typed"><b>6.7.4 Declaring the Type of Values Processed by a Mode</b></a></p>
                  </li>
               </ol>
            </div>
            <div class="div2">
               
               <h3><a id="xpath-changes-since-3.1"></a>I.2 <a href="#xpath-changes-since-3.1" style="text-decoration: none">Changes in Other Related Specifications</a></h3>
               <p>A number of changes affecting XSLT 4.0 have been made in other related
               specifications. Some of the more significant changes are as follows:</p>
               <ol class="enumar">
                  <li>
                     <p>A number of new kinds of ItemType are introduced, for example choice item types,
                  record types, and enumeration types.</p>
                  </li>
                  <li>
                     <p>The coercion rules (previously “function conversion rules”) allow atomic items
                  of primitive types to be supplied where a restricted type is required: for example
                  if the required type is <code>xs:positiveInteger</code>, it is now acceptable to supply the
                  value <code>42</code>.</p>
                  </li>
                  <li>
                     <p>XPath 4.0 introduces abbreviated syntax for  inline functions
                  (for example <code>fn($x, $y) { $x + $y }</code>).</p>
                  </li>
               </ol>
            </div>
         </div>
         <div class="div1">
            
            <h2><a id="incompatibilities"></a>J <a href="#incompatibilities" style="text-decoration: none">Incompatibilities with XSLT 3.0</a> (Non-Normative)</h2>
            <p>This section lists all known incompatibilities with XSLT 3.0, that is, situations
               where a stylesheet that is error-free
            according to the XSLT 3.0 specification and where all elements have an effective version
            of <code>3.0</code> or less, will produce different results depending on whether it is
            run under an XSLT 3.0 processor or an XSLT 4.0 processor.</p>
            <ol class="enumar">
               <li>
                  <p>The rules for comparing values in <a href="#element-for-each-group"><code>xsl:for-each-group</code></a> now reference
               the rules for <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-distinct-values"><code>distinct-values</code></a>, which have themselves changed
               <span>to be compatible with <a href="https://qt4cg.org/specifications/xpath-functions-40/Overview.html#func-atomic-equal"><code>fn:atomic-equal</code></a></span>. This change eliminates the intransitivity
               in the previous specification, which meant that in edge cases involving rounding of numeric values
               of different types, two items in different groups could compare equal. Any change in behavior
               is confined to this edge case.</p>
               </li>
               <li>
                  <p>The rules for matching nodes against patterns using the <code>intersect</code>
               and <code>except</code> operators have changed to deliver a more intuitive result.</p>
               </li>
               <li>
                  <p>The rules for comparing values in <a title="key" class="termref" href="#dt-key">keys</a> have changed,
               to align with the rules for maps. The changes affect edge cases involving rounding of numeric values
               of different types, and the comparison of date/time values with and without timezones.</p>
               </li>
               <li>
                  <p>In previous versions, a template rule whose match pattern was a union pattern
               and that had no explicity priority was treated as equivalent to a set of template
               rules, one for each alternative in the union, each potentially with different default
               priority. This rule has not been carried forward into XSLT 4.0: instead, the priority
               of the rule is taken as being the highest priority of any of the alternatives.</p>
               </li>
               <li>
                  <p>In XSLT 4.0, an <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>
               instruction automatically passes on the values of any non-tunnel parameters that were
               present in its own invocation. This means that the template rule invoked by 
               <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a>, if it declares
               a default value for such a parameter, will take the implicitly-supplied value in 
               preference to the default value.</p>
                  <p>This change in the specification applies only if the <a title="effective version" class="termref" href="#dt-effective-version">effective version</a>
               of the <a href="#element-apply-imports"><code>xsl:apply-imports</code></a> or <a href="#element-next-match"><code>xsl:next-match</code></a> is 4.0 or greater.
               This means that 3.0 behavior can be retained by adding the attribute <code>version="3.0"</code>
               to the instruction, or to some ancestor element (for example, the <a href="#element-stylesheet"><code>xsl:stylesheet</code></a>
               or <code>xsl:transform</code> element).</p>
               </li>
               <li>
                  <p>A <a title="" class="termref" href="#"></a> module in XSLT 4.0 defines a template rule
               whose implicit match pattern is <code>match="."</code> (matching any item), whereas in XSLT 3.0
               the implicit match pattern was <code>match="/"</code> (matching document nodes only). This change
               is made to allow such stylesheets to be used to process JSON input, but it also has
               the effect of changing the behavior of the stylesheet if it is applied to other items, such as
               element or text nodes.</p>
               </li>
            </ol>
            <p>This specification also corrects a number of errors and omissions in XSLT 3.0, in a way that
         might create incompatibilities for some processors, depending on how they interpreted the XSLT 3.0
         specification:</p>
            <ol class="enumar">
               <li>
                  <p>XSLT 3.0 (and earlier releases) did not fully define the evaluation context for the
            default values of template parameters. For example, if the default value of a parameter of a 
            template rule invoked <a href="#element-next-match"><code>xsl:next-match</code></a>, it was not specified whether the
            current template rule should be the calling template or the called template. This omission has
            been corrected.</p>
               </li>
               <li>
                  <p>Where different packages import different schemas, the specification is now more
                  prescriptive about which schema is used for validation. The rules may differ from
                  the conventions adopted by implementations of XSLT 3.0.</p>
               </li>
               <li>
                  <p>XSLT 3.0 failed to specify a default value for the serialization parameter <code>indent</code>
               where the serialization method is <code>json</code> or <code>adaptive</code>. XSLT 4.0 specifies
               a default value of <code>no</code>.</p>
               </li>
            </ol>
            <p>See also <a href="#xpath-40">[XPath 4.0]</a>, <a href="#xpath-functions-40">[Functions and Operators 4.0]</a>, and
            <a href="#xslt-xquery-serialization-40">[Serialization 4.0]</a> for incompatibilities in other related
            specifications that may affect XSLT stylesheets.</p>
         </div>
      </div>
      <p role="navigation" id="back-to-top"><a href="#title"><abbr title="Back to top">↑</abbr></a></p><script src="https://www.w3.org/scripts/TR/2016/fixup.js"></script><script src="js/toc.js"></script></body>
</html><!--{xmlspec} XSLT Processor: Saxonica--><!--{xsl-query} XSLT Processor: Saxonica-->